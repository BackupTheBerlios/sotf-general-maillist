<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Sotf-general] r558 - in node/branches/video_test: code code/classes code/configs code/getid3-1.7.5 code/getid3-1.7.5/demos code/getid3-1.7.5/getid3 code/getid3-1.7.5/helperapps code/share code/templates www www/static
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/sotf-general/2006-May/index.html" >
   <LINK REL="made" HREF="mailto:sotf-general%40lists.berlios.de?Subject=Re%3A%20%5BSotf-general%5D%20r558%20-%20in%20node/branches/video_test%3A%20code%20code/classes%20code/configs%20code/getid3-1.7.5%20code/getid3-1.7.5/demos%20code/getid3-1.7.5/getid3%20code/getid3-1.7.5/helperapps%20code/share%20code/templates%20www%20www/static&In-Reply-To=%3C200605041435.k44EZfr3015583%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000180.html">
   <LINK REL="Next"  HREF="000182.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Sotf-general] r558 - in node/branches/video_test: code code/classes code/configs code/getid3-1.7.5 code/getid3-1.7.5/demos code/getid3-1.7.5/getid3 code/getid3-1.7.5/helperapps code/share code/templates www www/static</H1>
    <B>buddhafly at berlios.de</B> 
    <A HREF="mailto:sotf-general%40lists.berlios.de?Subject=Re%3A%20%5BSotf-general%5D%20r558%20-%20in%20node/branches/video_test%3A%20code%20code/classes%20code/configs%20code/getid3-1.7.5%20code/getid3-1.7.5/demos%20code/getid3-1.7.5/getid3%20code/getid3-1.7.5/helperapps%20code/share%20code/templates%20www%20www/static&In-Reply-To=%3C200605041435.k44EZfr3015583%40sheep.berlios.de%3E"
       TITLE="[Sotf-general] r558 - in node/branches/video_test: code code/classes code/configs code/getid3-1.7.5 code/getid3-1.7.5/demos code/getid3-1.7.5/getid3 code/getid3-1.7.5/helperapps code/share code/templates www www/static">buddhafly at berlios.de
       </A><BR>
    <I>Thu May  4 16:35:41 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000180.html">[Sotf-general] r557 - node/branches
</A></li>
        <LI>Next message: <A HREF="000182.html">[Sotf-general] r558 - in node/branches/video_test: code      code/classes code/configs code/getid3-1.7.5 code/getid3-1.7.5/demos      code/getid3-1.7.5/getid3 code/getid3-1.7.5/helperapps code/share      code/templates www www/static
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#181">[ date ]</a>
              <a href="thread.html#181">[ thread ]</a>
              <a href="subject.html#181">[ subject ]</a>
              <a href="author.html#181">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: buddhafly
Date: 2006-05-04 16:34:58 +0200 (Thu, 04 May 2006)
New Revision: 558

Added:
   node/branches/video_test/code/classes/sotf_ContentCheck.class.php
   node/branches/video_test/code/classes/sotf_VideoCheck.class.php
   node/branches/video_test/code/classes/sotf_VideoFile.class.php
   node/branches/video_test/code/getid3-1.7.5/
   node/branches/video_test/code/getid3-1.7.5/changelog.txt
   node/branches/video_test/code/getid3-1.7.5/demos/
   node/branches/video_test/code/getid3-1.7.5/demos/demo.audioinfo.class.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.basic.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.browse.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.cache.dbm.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.cache.mysql.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.joinmp3.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.mimeonly.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.mysql.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.simple.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.simple.write.php
   node/branches/video_test/code/getid3-1.7.5/demos/demo.write.php
   node/branches/video_test/code/getid3-1.7.5/demos/index.php
   node/branches/video_test/code/getid3-1.7.5/dependencies.txt
   node/branches/video_test/code/getid3-1.7.5/getid3/
   node/branches/video_test/code/getid3-1.7.5/getid3/extension.cache.dbm.php
   node/branches/video_test/code/getid3-1.7.5/getid3/extension.cache.mysql.php
   node/branches/video_test/code/getid3-1.7.5/getid3/getid3.lib.php
   node/branches/video_test/code/getid3-1.7.5/getid3/getid3.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.gzip.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.rar.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.szip.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.tar.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.zip.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.asf.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.bink.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.flv.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.matroska.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.mpeg.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.nsv.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.quicktime.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.real.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.riff.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.swf.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.aac.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.ac3.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.au.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.avr.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.bonk.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.flac.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.la.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.lpac.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.midi.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mod.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.monkey.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mp3.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mpc.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.ogg.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.optimfrog.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.rkau.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.shorten.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.tta.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.voc.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.vqf.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.wavpack.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.bmp.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.gif.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.jpg.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.pcd.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.png.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.tiff.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.misc.exe.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.misc.iso.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.apetag.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.id3v1.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.id3v2.php
   node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.lyrics3.php
   node/branches/video_test/code/getid3-1.7.5/getid3/write.apetag.php
   node/branches/video_test/code/getid3-1.7.5/getid3/write.id3v1.php
   node/branches/video_test/code/getid3-1.7.5/getid3/write.id3v2.php
   node/branches/video_test/code/getid3-1.7.5/getid3/write.lyrics3.php
   node/branches/video_test/code/getid3-1.7.5/getid3/write.metaflac.php
   node/branches/video_test/code/getid3-1.7.5/getid3/write.php
   node/branches/video_test/code/getid3-1.7.5/getid3/write.real.php
   node/branches/video_test/code/getid3-1.7.5/getid3/write.vorbiscomment.php
   node/branches/video_test/code/getid3-1.7.5/helperapps/
   node/branches/video_test/code/getid3-1.7.5/helperapps/readme.txt
   node/branches/video_test/code/getid3-1.7.5/license.txt
   node/branches/video_test/code/getid3-1.7.5/readme.txt
   node/branches/video_test/code/getid3-1.7.5/structure.txt
   node/branches/video_test/code/templates/advsearch.orig.htm
   node/branches/video_test/www/flvplayer.swf
   node/branches/video_test/www/static/rss.gif
   node/branches/video_test/www/transcode.php
   node/branches/video_test/www/videoplayer.swf
Modified:
   node/branches/video_test/code/classes/sotf_AdvSearch.class.php
   node/branches/video_test/code/classes/sotf_AudioCheck.class.php
   node/branches/video_test/code/classes/sotf_AudioFile.class.php
   node/branches/video_test/code/classes/sotf_File.class.php
   node/branches/video_test/code/classes/sotf_FileList.class.php
   node/branches/video_test/code/classes/sotf_PlayList.class.php
   node/branches/video_test/code/classes/sotf_Programme.class.php
   node/branches/video_test/code/configs/eng.conf
   node/branches/video_test/code/configs/fra.conf
   node/branches/video_test/code/configs/ger.conf
   node/branches/video_test/code/configs/hun.conf
   node/branches/video_test/code/share/db.sql
   node/branches/video_test/code/share/update.sql
   node/branches/video_test/code/templates/advsearch.htm
   node/branches/video_test/code/templates/advsearchresults.htm
   node/branches/video_test/code/templates/editFiles.htm
   node/branches/video_test/code/templates/get.htm
   node/branches/video_test/code/templates/index.htm
   node/branches/video_test/code/templates/search.htm
   node/branches/video_test/code/templates/showSeries.htm
   node/branches/video_test/code/templates/showStation.htm
   node/branches/video_test/www/admin.php
   node/branches/video_test/www/advsearch.php
   node/branches/video_test/www/advsearchresults.php
   node/branches/video_test/www/convert.php
   node/branches/video_test/www/editFiles.php
   node/branches/video_test/www/editMeta.php
   node/branches/video_test/www/editor.php
   node/branches/video_test/www/get.php
   node/branches/video_test/www/getFile.php
   node/branches/video_test/www/init.inc.php
   node/branches/video_test/www/podcast.php
   node/branches/video_test/www/search.php
   node/branches/video_test/www/static/main.css
Log:
sotf video extension, current status
this version has already been merged with the newest trunk revision, but not yet cleaned (-&gt; getid3-1.7.5)


Modified: node/branches/video_test/code/classes/sotf_AdvSearch.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_AdvSearch.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_AdvSearch.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -1,801 +1,553 @@
 &lt;?php
 
 /*
-
  * This class represents a query for the advanced search
-
  *
-
  * @author Mate Pataki MTA SZTAKI DSD
-
  *
-
  */
 
 class sotf_AdvSearch
-
 {
 
-	var $SQLquery, $sort1, $sort2, $allid;
+  var $SQLquery, $sort1, $sort2, $allid;
 
-
-
   /** Used by deserialize only */
+  //var $SQLFields = array('station','production_date','language','person','title','seriestitle','topic','length','rating','genre_id','keywords','abstract','seriesdescription','entry_date','expiry_date','modify_date','broadcast_date','spatial_coverage','temporal_coverage','contenttype');
+  
+  var $SQLFields = array( // SQLFields arranged logically for addAll() - Martin Schmidt
+  'title',
+  'abstract',
+  'keywords',
+  
+  'station',
+  'seriestitle',
+  'seriesdescription',
+  
+  'language',
+  'genre_id',
+  'topic',
+  
+  'contenttype', 
+  'length',
+  'rating',
+ 
+  'person',
+  
+  'production_date',
+  'broadcast_date',
+  'entry_date',
+  'modify_date',
+  'expiry_date'
+  //'spatial_coverage',
+  //'temporal_coverage',
+  );
 
-  var $SQLFields = array('station','production_date','language','person','title','seriestitle','topic','length','rating','genre_id','keywords','abstract','seriesdescription','entry_date','expiry_date','modify_date','broadcast_date','spatial_coverage','temporal_coverage');
 
-	
-
 	function sotf_AdvSearch($array = &quot;&quot;)			//constuctor with a starting query
-
 	{
-
 		if ($array != &quot;&quot;) $this-&gt;SQLquery = $array;
-
 	}
 
 
-
 	function GetQuery()					//gives back the current query
-
 	{
-
 		return $this-&gt;SQLquery;
-
 	}
 
 
-
 	function GetSort1()					//gives back the current sort order 1
-
 	{
-
 		$pos = strpos($this-&gt;sort1, &quot; DESC&quot;);
-
 		if (!$pos) return $this-&gt;sort1;
-
 		return substr($this-&gt;sort1, 0, $pos);
-
 	}
 
 
-
 	function GetSort2()					//gives back the current sort order 2
-
 	{
-
 		$pos = strpos($this-&gt;sort2, &quot; DESC&quot;);
-
 		if (!$pos) return $this-&gt;sort2;
-
 		return substr($this-&gt;sort2, 0, $pos);
-
 	}
 
 
-
 	function getDir1()					//gives back if the current sort order direction 1 is DESC or not
-
 	{
-
 		$pos = strpos($this-&gt;sort1, &quot; DESC&quot;);
-
 		if (!$pos) return false;
-
 		return &quot;DESC&quot;;
-
 	}
 
 
-
 	function getDir2()					//gives back if the current sort order direction 2 is DESC or not
-
 	{
-
 		$pos = strpos($this-&gt;sort2, &quot; DESC&quot;);
-
 		if (!$pos) return false;
-
 		return &quot;DESC&quot;;
-
 	}
 
 
-
 	function DeleteQuery()					//start a new query
-
 	{
-
 		$this-&gt;SQLquery = NULL;
-
 		return $this-&gt;SQLquery;
-
 	}
 
 
-
 	function Serialize()					//make a string from array
-
 	{
-
 		$serial= $this-&gt;sort1.&quot;|B&quot;.$this-&gt;sort2;
-
 		$max = count($this-&gt;SQLquery);
-
 		for($i=0; $i &lt; $max; $i++)
-
 		{			//Need | char as a sepecial char so replace it
-
 			$serial = $serial.&quot;|A&quot;.strtr($this-&gt;SQLquery[$i][0], &quot;|&quot;, &quot;I&quot;).&quot;|B&quot;.strtr($this-&gt;SQLquery[$i][1], &quot;|&quot;, &quot;I&quot;).&quot;|B&quot;.strtr($this-&gt;SQLquery[$i][2], &quot;|&quot;, &quot;I&quot;).&quot;|B&quot;.strtr($this-&gt;SQLquery[$i][3], &quot;|&quot;, &quot;I&quot;).&quot;|B&quot;.strtr($this-&gt;SQLquery[$i][4], &quot;|&quot;, &quot;I&quot;);
-
 		}
-
 		return $serial;
-
 	}
 
-
-
 	function Deserialize($serial)					//make an array from string
-
 	{
-
 		$this-&gt;SQLquery = array();
-
 		$terms = explode(&quot;|A&quot;, $serial);
-
 		$max = count($terms);
-
 		$term = explode(&quot;|B&quot;, $terms[0]);		//sort order is the first array
-
 		$pos1 = strpos($term[0], &quot; DESC&quot;);			//SORT 1
-
 		$pos2 = strpos($term[1], &quot; DESC&quot;);			//SORT 2
-
 		if ($pos1) $term[0] = substr($term[0], 0, $pos1);		//remove DESC
-
 		if ($pos2) $term[1] = substr($term[1], 0, $pos2);		//remove DESC
-
 		if (array_key_exists($term[0], $this-&gt;getOrderFields()) AND array_key_exists($term[1], $this-&gt;getOrderFields())) $this-&gt;SetSortOrder($term[0], $term[1]);	//SetSortOrder
-
 		else $this-&gt;SetSortOrder();		//set default
-
 		$this-&gt;setDir($pos1, $pos2);		//set direction after field is set
 
-
-
 		if ($max &lt; 1) return $this-&gt;SQLquery;		//at least sort order nedded
-
 		if (count($term) != 2) return $this-&gt;SQLquery;	//two sort orders needed
 
-
-
 		for($i=1; $i &lt; $max; $i++)
-
 		{			//TODO: | char as a sepecial char so replace it
-
 			$term = explode(&quot;|B&quot;, $terms[$i]);
-
 			if (count($term == 5) AND in_array($term[1], $this-&gt;SQLFields))			//to be sure :-)
-
 				$this-&gt;SQLquery[]=$term;
-
 		}
-
 		return $this-&gt;SQLquery;
-
 	}
 
 
-
 	function getEQSign($sign, $value)
-
 	{
-
 		switch ($sign) {			//= &lt; &gt; != ...
-
 		    case &quot;bigger&quot;:
-
 			return &quot; &gt;= &quot;.$value;
-
+			
 		    case &quot;smaller&quot;:
-
 			return &quot; &lt;= &quot;.$value;
-
+			
 		    case &quot;is&quot;:
-
 			return &quot; = &quot;.$value;
-
+			
 		    case &quot;is_equal&quot;:
-
 			return &quot; ~* '^&quot;.substr($value, 1, -1).&quot;$'&quot;;
-
+			
 		    case &quot;is_not_equal&quot;:
-
 			return &quot; != &quot;.$value;
 
 		    case &quot;is_not&quot;:
-
 			return &quot; != &quot;.$value;
 
 		    case &quot;contains&quot;:
-
 			return &quot; ~* '.*&quot;.substr($value, 1, -1).&quot;.*'&quot;;
 
 		    case &quot;begins_with&quot;:
-
 			return &quot; ~* '^&quot;.substr($value, 1, -1).&quot;'&quot;;
 
 		    case &quot;does_not_contain&quot;:
-
 			return &quot; !~* '.*&quot;.substr($value, 1, -1).&quot;.*'&quot;;
-
 		}
-
 		return false;
-
 	}
 
 
-
 	function GetSQLCommand()			//gives back the SQL command for the search
-
 	{
-
 		global $lang;
-
 		$topic = false;		//stores whether there was a search for topic;
-
 		$max = count($this-&gt;SQLquery);					//all rows of the advsearch
-
+		
 		for($i = 0; $i &lt; $max; $i++)
-
 			if ($this-&gt;SQLquery[$i][1] == &quot;topic&quot;)	{$topic = true;	break;}
 
-
-
 		$query=&quot;SELECT distinct programmes.* FROM (&quot;;
-
 		$query.=&quot; SELECT sotf_programmes.*, sotf_stations.name as station, sotf_series.name as seriestitle, sotf_series.description as seriesdescription, sotf_prog_rating.rating_value as rating&quot;;
-
 		if ($topic) $query.=&quot;, sotf_topics.topic_name as topic_name&quot;;
-
 		$query.=&quot; FROM sotf_programmes&quot;;
-
 		$query.=&quot; LEFT JOIN sotf_stations ON sotf_programmes.station_id = sotf_stations.id&quot;;
-
 		$query.=&quot; LEFT JOIN sotf_series ON sotf_programmes.series_id = sotf_series.id&quot;;
-
 		$query.=&quot; LEFT JOIN sotf_prog_rating ON sotf_programmes.id = sotf_prog_rating.id&quot;;
-
 		
-
 		if ($topic)		// added the topics as left join for performance reasons
-
 		{
-
 			$query .= &quot; LEFT JOIN sotf_prog_topics ON sotf_programmes.id = sotf_prog_topics.prog_id&quot;;
-
 			$query .= &quot; LEFT JOIN sotf_topics ON sotf_prog_topics.topic_id = sotf_topics.topic_id&quot;;
-
 		}
 
 
-
-
-
 		$query.=&quot;) as programmes WHERE published = 't'&quot;;
-
 		
 
 		for($i = 0; $i &lt; $max ;$i++)		//go through all terms
-
 		{
-
 			//AND or OR words
-
-			if ($i != 0) $query .= &quot; &quot;.$this-&gt;SQLquery[$i][0];
-
+			//if ($i != 0) $query .= &quot; &quot;.$this-&gt;SQLquery[$i][0];
+			
+			// MODIFIED BY Martin Schmidt
+			//if ($i != 0) {
+				if($this-&gt;SQLquery[$i][0]==&quot;IGNORE&quot;) continue; 
+				elseif ($i != 0) $query .= &quot; &quot;.$this-&gt;SQLquery[$i][0];
+			//}
+			///////////////////////////////
+			
 			else $query .= &quot; AND&quot;;
 
-			
-
 			//set begining of round bracket
-
 			if ( (($this-&gt;SQLquery[$i][0] == &quot;AND&quot;) || ($i == 0)) &amp;&amp; ($this-&gt;SQLquery[$i+1][0] == &quot;OR&quot;) ) $query = $query.&quot; (&quot;;
 
-
-
 			//field name eq sign and value
 
 			if ($this-&gt;SQLquery[$i][4] == &quot;date&quot;)
-
 			{
-
 				$query .= &quot; &quot;.$this-&gt;SQLquery[$i][1];
-
 				$date = getdate($this-&gt;SQLquery[$i][3]);
-
 				$query .= $this-&gt;getEQSign($this-&gt;SQLquery[$i][2], &quot;'&quot;.$date[&quot;year&quot;].&quot;-&quot;.$date[&quot;mon&quot;].&quot;-&quot;.$date[&quot;mday&quot;].&quot;'&quot;);
-
 			}
 
 			elseif ($this-&gt;SQLquery[$i][1] == &quot;topic&quot;)
-
 			{
-
 				$query .= &quot; (&quot;.
-
 					&quot; programmes.topic_name&quot;;
-
 //					&quot; sotf_topics.topic_name&quot;;
-
 				$query .= $this-&gt;getEQSign($this-&gt;SQLquery[$i][2], &quot;'&quot;.$this-&gt;SQLquery[$i][3].&quot;'&quot;);
-
 				$query .= &quot;)&quot;;
-
 			}
+			
+			//ADDED BY Martin Schmidt
+			elseif ($this-&gt;SQLquery[$i][1] == &quot;contenttype&quot;)
+			{
+				$query .= &quot; (&quot;.
+					&quot; programmes.type&quot;;
+					//echo $this-&gt;SQLquery[$i][2].&quot; |&quot;.$this-&gt;SQLquery[$i][3];
+				$query .= $this-&gt;getEQSign($this-&gt;SQLquery[$i][2], &quot;'&quot;.$this-&gt;SQLquery[$i][3].&quot;'&quot;);
+				$query .= &quot;)&quot;;
+			}
+			/////////////////////////////////////////////////
 
 			elseif ($this-&gt;SQLquery[$i][1] == &quot;title&quot;)
-
 			{
-
 				if (strpos($this-&gt;SQLquery[$i][2], &quot;not&quot;) == false) $andor = &quot;OR&quot;;
-
 				else $andor = &quot;AND&quot;;	//if does not contain or not equal then NONE should contain it
 
 				$query .= &quot; (coalesce(title,'')&quot;;
-
 				$query .= $this-&gt;getEQSign($this-&gt;SQLquery[$i][2], &quot;'&quot;.$this-&gt;SQLquery[$i][3].&quot;'&quot;);
-
 				$query .= &quot; $andor coalesce(alternative_title,'')&quot;;
-
 				$query .= $this-&gt;getEQSign($this-&gt;SQLquery[$i][2], &quot;'&quot;.$this-&gt;SQLquery[$i][3].&quot;'&quot;);
-
 				$query .= &quot; $andor coalesce(episode_title,'')&quot;;
-
 				$query .= $this-&gt;getEQSign($this-&gt;SQLquery[$i][2], &quot;'&quot;.$this-&gt;SQLquery[$i][3].&quot;'&quot;).&quot;)&quot;;
-
 			}
 
 			elseif ($this-&gt;SQLquery[$i][1] == &quot;person&quot;)
-
 			{
-
 				if ($this-&gt;SQLquery[$i][2] == &quot;does_not_contain&quot;)
-
 				{
-
 					$qi2 = &quot;contains&quot;;
-
 					$not = &quot;not&quot;;
-
 				}
 
 				elseif  ($this-&gt;SQLquery[$i][2] == &quot;is_not_equal&quot;)
-
 				{
-
 					$qi2 = &quot;is_equal&quot;;
-
 					$not = &quot;not&quot;;
-
 				}
 
 				else
-
 				{
-
 					$qi2 = $this-&gt;SQLquery[$i][2];
-
 					$not = &quot;&quot;;
-
 				}
 
 
-
 				$query .= &quot; id $not in (SELECT sotf_object_roles.object_id as id FROM sotf_object_roles WHERE sotf_object_roles.contact_id = sotf_contacts.id AND&quot;;
-
 				$query .= &quot; ( coalesce(sotf_contacts.name,'')&quot;;
-
 				$query .= $this-&gt;getEQSign($qi2, &quot;'&quot;.$this-&gt;SQLquery[$i][3].&quot;'&quot;);
-
 				$query .= &quot; OR coalesce(sotf_contacts.alias,'')&quot;;
-
 				$query .= $this-&gt;getEQSign($qi2, &quot;'&quot;.$this-&gt;SQLquery[$i][3].&quot;'&quot;);
-
 				$query .= &quot; OR coalesce(sotf_contacts.acronym,'')&quot;;
-
 				$query .= $this-&gt;getEQSign($qi2, &quot;'&quot;.$this-&gt;SQLquery[$i][3].&quot;'&quot;).&quot;))&quot;;
-
 			}
 
 			elseif (($this-&gt;SQLquery[$i][4] == &quot;number&quot;) or ($this-&gt;SQLquery[$i][4] == &quot;genre&quot;))
-
 			{
-
 				$query .= &quot; &quot;.$this-&gt;SQLquery[$i][1].&quot; &quot;;
-
 				$query .= $this-&gt;getEQSign($this-&gt;SQLquery[$i][2], $this-&gt;SQLquery[$i][3]);
-
+				//echo $this-&gt;SQLquery[$i][2].&quot; |&quot;.$this-&gt;SQLquery[$i][3];
 			}
 
 			else
-
 			{
-
 				$query .= &quot; &quot;.$this-&gt;SQLquery[$i][1].&quot; &quot;;
-
 				$query .= $this-&gt;getEQSign($this-&gt;SQLquery[$i][2], &quot;'&quot;.$this-&gt;SQLquery[$i][3].&quot;'&quot;);
-
 			}
 
 
-
 			//set end of round bracket
-
 			if (($this-&gt;SQLquery[$i][0] == &quot;OR&quot;) &amp;&amp; ($this-&gt;SQLquery[$i+1][0] != &quot;OR&quot;)) $query = $query.&quot; )&quot;;
-
 		}
 
 		$query = $query.&quot; ORDER BY &quot;.$this-&gt;sort1.&quot;, &quot;.$this-&gt;sort2;			//ISBN, TITLE 
 
 		//print($query);
-
 		//die();
-
+		
 		return $query;
-
 	}
 
 
 
-
-
 	function getPersons($program_id)			//gives back the persons that have to do with the program
-
 	{
-
 		global $db, $lang;
 
 		$query=&quot;SELECT sotf_contacts.name, sotf_contacts.alias, sotf_contacts.acronym, sotf_role_names.name as role FROM sotf_contacts, sotf_role_names WHERE sotf_contacts.id = sotf_object_roles.contact_id AND sotf_object_roles.object_id = '$program_id' AND sotf_object_roles.role_id = sotf_role_names.role_id AND sotf_role_names.language='$lang'&quot;;
 
 		return $db-&gt;getAll($query);
-
 	}
 
 
-
-
-
 	function getTopics($program_id)			//gives back the topics for the program
-
 	{
-
 		global $db, $lang;
 
 		$query=&quot;SELECT sotf_topics.topic_name as name FROM sotf_topics WHERE sotf_topics.language = '$lang' AND sotf_prog_topics.topic_id = sotf_topics.topic_id AND sotf_prog_topics.prog_id = '$program_id'&quot;;
 
 		return $db-&gt;getAll($query);
-
 	}
-
-
-
-
-
+	
+	
 	function AddRow($SQLlink, $SQLfield, $where = -1)			//add a row to the query
-
 	{
 
 		if ($SQLlink == &quot;AND&quot;) $new[0] = &quot;AND&quot;;
-
 		else $new[0] = &quot;OR&quot;;
 
 		$new[1] = $SQLfield;		//name of the field
-
 		$new[2] = &quot;&quot;;			//=, !=, &lt;, &gt;
-
 		$new[3] = &quot;&quot;;			//text or date
 
 
-
 		switch ($SQLfield) {		//set type of the field
 
 		    case &quot;station&quot;:
-
 			$new[4] = &quot;station&quot;;
-
 		        break;
 
 		    case &quot;production_date&quot;:
-
 			$new[4] = &quot;date&quot;;
-
 		        break;
 
 		    case &quot;language&quot;:
-
 			$new[4] = &quot;lang&quot;;
-
 		        break;
 
 		    case &quot;series&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;track&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;topic&quot;:
-
 			$new[4] = &quot;topic&quot;;
-
 		        break;
 
 		    case &quot;entry_date&quot;:
-
 			$new[4] = &quot;date&quot;;
-
 		        break;
 
 		    case &quot;expiry_date&quot;:
-
 			$new[4] = &quot;date&quot;;
-
 		        break;
 
 		    case &quot;modify_date&quot;:
-
 			$new[4] = &quot;date&quot;;
-
 		        break;
 
 		    case &quot;broadcast_date&quot;:
-
 			$new[4] = &quot;date&quot;;
-
 		        break;
 
 		    case &quot;owner&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;person&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;title&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;seriestitle&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;seriesdescription&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;keywords&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;genre_id&quot;:
-
 			$new[4] = &quot;genre&quot;;
-
 		        break;
 
 		    case &quot;abstract&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;length&quot;:
-
 			$new[4] = &quot;length&quot;;
-
 		        break;
 
 		    case &quot;contact_email&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;contact_phone&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;spatial_coverage&quot;:
-
 			$new[4] = &quot;string&quot;;
-
 		        break;
 
 		    case &quot;temporal_coverage&quot;:
-
 			$new[4] = &quot;date&quot;;
-
 		        break;
 
 		    case &quot;rating&quot;:
-
 			$new[4] = &quot;rating&quot;;
-
 		        break;
+				
+			case &quot;contenttype&quot;: //ADDED BY Martin Schmidt
+			$new[4] = &quot;contenttype&quot;;
+		        break;
 
 		}
 
 
-
 		if ($where == -1)
-
 		{
-
 			$this-&gt;SQLquery[] = $new;
-
 		}
 
 		else
-
 		{
-
 			$max = count($this-&gt;SQLquery);
-
 			$output1 = array_slice($this-&gt;SQLquery, 0, $where+1);   
-
 			if ($where &lt; $max) $output2 = array_slice($this-&gt;SQLquery, $where+1);
-
 			//var_dump($output);
-
 			$output1[]=$new;
-
 			$this-&gt;SQLquery = array_merge($output1, $output2);
-
 		}
-
 		return $this-&gt;SQLquery;
-
 	}
+	
+	
+	function addAll(){ //ADDED BY Martin Schmidt
+		for($i=0;$i&lt;count($this-&gt;SQLFields);$i++){
+			$this-&gt;AddRow(&quot;OR&quot;, $this-&gt;SQLFields[$i]);
+		}
+		return $this-&gt;SQLquery;
+	}
 
 	
 
 	function DelRow($where)		//set the sort order
-
 	{
-
 		$max = count($this-&gt;SQLquery);
-
 		if ($where &gt; 0) $output1 = array_slice($this-&gt;SQLquery, 0, $where);
-
 		if ($where &lt; $max) $output2 = array_slice($this-&gt;SQLquery, $where+1);
-
-		$this-&gt;SQLquery = array_merge($output1, $output2);
-
+		
+		//$this-&gt;SQLquery = array_merge($output1, $output2); 
+		
+		//php5 hack - martin schmidt
+		if(is_array($output1)) $this-&gt;SQLquery = array_merge($output1, $output2); 
+		else $this-&gt;SQLquery = $output2;
+		
 		return $this-&gt;SQLquery;
-
 	}
 
 
-
 	function SetSortOrder($sort1 = &quot;entry_date DESC&quot;, $sort2 = &quot;station&quot;)		//set the sort order
-
 	{
-
 		$pos = strpos($this-&gt;sort1, &quot; DESC&quot;);			//SORT 1
-
 		if ($pos) $this-&gt;sort1 = $sort1.&quot; DESC&quot;;
-
 		else  $this-&gt;sort1 = $sort1;
 
-
-
 		$pos = strpos($this-&gt;sort2, &quot; DESC&quot;);			//SORT 2
-
 		if ($pos) $this-&gt;sort2 = $sort2.&quot; DESC&quot;;
-
 		else  $this-&gt;sort2 = $sort2;
-
 	}
-
 	
 
 	function setDir($dir1 = false, $dir2 = false)					//gives back if the current sort order direction 1 is DESC or not
-
 	{
-
 		$pos = strpos($this-&gt;sort1, &quot; DESC&quot;);			//SORT 1
-
 		if (!$pos AND $dir1) $this-&gt;sort1 .= &quot; DESC&quot;;		//add DESC
-
 		elseif ($pos AND !$dir1) $this-&gt;sort1 = substr($this-&gt;sort1, 0, $pos);		//remove DESC
 
 
-
 		$pos = strpos($this-&gt;sort2, &quot; DESC&quot;);			//SORT 2
-
 		if (!$pos AND $dir2) $this-&gt;sort2 .= &quot; DESC&quot;;		//add DESC
-
 		elseif ($pos AND !$dir2) $this-&gt;sort2 = substr($this-&gt;sort2, 0, $pos);		//remove DESC
-
 	}
 
 
-
 	function GetHumanReadable()			//translates fieldnames for all rows of the query
-
 	{
-
 		global $page;
-
 		$SQLfields = &quot;&quot;;
-
 		$max = count($this-&gt;SQLquery);
 
 		for($i=0; $i &lt; $max; $i++)
-
 			{
-
 			$SQLfield[0] = $page-&gt;getlocalized($this-&gt;SQLquery[$i][0]);
-
 			$SQLfield[1] = $page-&gt;getlocalized($this-&gt;SQLquery[$i][1]);
-
 			$SQLfield[2] = $page-&gt;getlocalized($this-&gt;SQLquery[$i][2]);
 
 			if ($this-&gt;SQLquery[$i][4] == &quot;date&quot;) $SQLfield[3] = date(&quot;Y-m-d&quot;, $this-&gt;SQLquery[$i][3]);
-
 				elseif ($this-&gt;SQLquery[$i][4] == &quot;lang&quot;) $SQLfield[3] = $page-&gt;getlocalized($this-&gt;SQLquery[$i][3]);
-
 				else $SQLfield[3] = $this-&gt;SQLquery[$i][3];
 
 			$SQLfield[4] = $this-&gt;SQLquery[$i][4];
-
 			$SQLfields[] = $SQLfield;
-
 			}
 
 		return $SQLfields;
-
 	}
 
 
 
 	function GetSQLqueryfields()			//translates fieldnames for all rows of the query
-
 	{
-
 		global $page;
-
 		$max = count($this-&gt;SQLquery);
-
 		for($i=0; $i &lt; $max; $i++)
-
 			$SQLfield[] = $page-&gt;getlocalized($this-&gt;SQLquery[$i][1]);
 
 		return $SQLfield;
-
 	}
 
 
@@ -823,369 +575,270 @@
 
 
 	function GetSQLfields()		//translates fieldnames for dropdown box
-
 	{
-
 		global $page;
-
+		
 		$SQLfiels['station'] = $page-&gt;getlocalized(&quot;station&quot;);
-
 		$SQLfiels['production_date'] = $page-&gt;getlocalized(&quot;production_date&quot;);
-
 		$SQLfiels['language'] = $page-&gt;getlocalized(&quot;language&quot;);
-
 		$SQLfiels['person'] = $page-&gt;getlocalized(&quot;person&quot;);
-
 		$SQLfiels['title'] = $page-&gt;getlocalized(&quot;title&quot;);
-
 		$SQLfiels['seriestitle'] = $page-&gt;getlocalized(&quot;seriestitle&quot;);
-
 		$SQLfiels['topic'] = $page-&gt;getlocalized(&quot;topic&quot;);
-
 		$SQLfiels['length'] = $page-&gt;getlocalized(&quot;length&quot;);
-
 		$SQLfiels['rating'] = $page-&gt;getlocalized(&quot;rating&quot;);
-
 		//$SQLfiels['track'] = $page-&gt;getlocalized(&quot;track&quot;);
-
 		$SQLfiels['genre_id'] = $page-&gt;getlocalized(&quot;genre_id&quot;);
-
 		$SQLfiels['keywords'] = $page-&gt;getlocalized(&quot;keywords&quot;);
-
 		$SQLfiels['abstract'] = $page-&gt;getlocalized(&quot;abstract&quot;);
-
 		$SQLfiels['seriesdescription'] = $page-&gt;getlocalized(&quot;seriesdescription&quot;);
-
 		$SQLfiels['entry_date'] = $page-&gt;getlocalized(&quot;entry_date&quot;);
-
 		$SQLfiels['expiry_date'] = $page-&gt;getlocalized(&quot;expiry_date&quot;);
-
 		$SQLfiels['modify_date'] = $page-&gt;getlocalized(&quot;modify_date&quot;);
-
 		$SQLfiels['broadcast_date'] = $page-&gt;getlocalized(&quot;broadcast_date&quot;);
-
 		$SQLfiels['spatial_coverage'] = $page-&gt;getlocalized(&quot;spatial_coverage&quot;);
-
 		$SQLfiels['temporal_coverage'] = $page-&gt;getlocalized(&quot;temporal_coverage&quot;);
-
 		
+		//$SQLfiels['contenttype'] = $page-&gt;getlocalized(&quot;contenttype&quot;); 
+		$SQLfiels['contenttype'] = &quot;Content Type&quot;; //added by Martin Schmidt
 
 		asort($SQLfiels);
-
 		return $SQLfiels;
-
 	}
 
 
-
 	function getOrderFields()		//translates fieldnames for dropdown box
-
 	{
-
 	  global $page;
 
 		$SQLfiels = $this-&gt;GetSQLfields();
-
 		foreach($SQLfiels as $key =&gt; $value) if ($key != &quot;person&quot; AND $key != &quot;topic&quot;) $OrderFields[$key] = $value;
-
+		
 		$OrderFields['episode_sequence'] = $page-&gt;getlocalized(&quot;episode_sequence&quot;);
 
 		asort($OrderFields);
-
 		return $OrderFields;
-
 	}
 
 
 
 	function GetLanguages()		//returns all the languages
-
 	{
-
 		global $page, $config;
-
+		
 		$max = count($config['languages']);
-
 		for($i=0; $i&lt;$max;$i++) $Languages[$config['languages'][$i]] = $page-&gt;getlocalized($config['languages'][$i]);
 
 		return $Languages;
-
 	}
 
 
 
 	function GetStations()		//returns all the stations
-
 	{
-
 		$stationsarray = sotf_Station::listStationNames();
-
 		$max = count($stationsarray);
-
 		for($i=0; $i&lt;$max;$i++) $Stations[$stationsarray[$i][name]] = $stationsarray[$i][name];
 
 		return $Stations;
-
 	}
 
 
 
 	function GetGenres()		//returns all the genres
-
 	{
-
 		global $vocabularies;
 
 		$genresarray = $vocabularies-&gt;getGenres();
-
 		$max = count($genresarray);
-
 		for($i=0; $i&lt;$max;$i++) $Genres[$genresarray[$i][id]] = $genresarray[$i][name];
 
 		return $Genres;
-
 	}
-
-
-
-	function getRatings()		//returns all the genres
-
+	
+	function getRatings()		//returns all the ratings
 	{
-
 		$rating = new sotf_Rating();
-
 		for($i=$rating-&gt;minValue; $i&lt;=$rating-&gt;maxValue; $i+=0.5) $ratings[&quot;$i&quot;] = &quot;$i&quot;;
 
 		return $ratings;
+	}
+	
+	
+	function GetContentTypes()		//returns all the contenttypes - ADDED BY Martin Schmidt
+	{
+		/*global $db;
 
+		$query=&quot;SELECT DISTINCT type FROM sotf_programmes&quot;;
+
+		return $db-&gt;getCol($query);*/
+		
+		$contenttypes=array('sound'=&gt;'Audio', 'video'=&gt;'Video');
+		return $contenttypes;
+		
 	}
 
 
 
 	function GetEQdate()		//returns EQ options for dates
-
 	{
 
 		global $page;
 
 		$EQdate[bigger] = $page-&gt;getlocalized(&quot;after&quot;);
-
 		$EQdate[smaller] = $page-&gt;getlocalized(&quot;before&quot;);
-
 		$EQdate[is] = $page-&gt;getlocalized(&quot;is&quot;);
-
 		$EQdate[is_not] = $page-&gt;getlocalized(&quot;is_not&quot;);
 
 		return $EQdate;
-
 	}
 
 
 
 	function GetEQstring()		//returns EQ options for strings
-
 	{
-
 		global $page;
-
+		
 		$EQstring[contains] = $page-&gt;getlocalized(&quot;contains&quot;);
-
 		$EQstring[begins_with] = $page-&gt;getlocalized(&quot;begins_with&quot;);
-
 		$EQstring[is_equal] = $page-&gt;getlocalized(&quot;is&quot;);
-
 		$EQstring[does_not_contain] = $page-&gt;getlocalized(&quot;does_not_contain&quot;);
-
 		$EQstring[is_not_equal] = $page-&gt;getlocalized(&quot;is_not_equal&quot;);
 
 		return $EQstring;
-
 	}
 
 
-
 	function GetEQtopic()		//returns EQ options for topics
-
 	{
-
 		global $page;
 
 		$EQstring[contains] = $page-&gt;getlocalized(&quot;contains&quot;);
-
 		$EQstring[begins_with] = $page-&gt;getlocalized(&quot;begins_with&quot;);
-
 		$EQstring[is_equal] = $page-&gt;getlocalized(&quot;is&quot;);
-
+		
 		//$EQstring[does_not_contain] = $page-&gt;getlocalized(&quot;does_not_contain&quot;);
-
 		//$EQstring[is_not_equal] = $page-&gt;getlocalized(&quot;is_not_equal&quot;);
 
 		return $EQstring;
-
 	}
 
 
-
-
-
 	function GetEQlang()		//returns EQ options for languages and station
-
 	{
-
 		global $page;
 
 		$EQlang[is] = $page-&gt;getlocalized(&quot;is&quot;);
-
 		$EQlang[contains] = $page-&gt;getlocalized(&quot;contains&quot;);
-
 		$EQlang[does_not_contain] = $page-&gt;getlocalized(&quot;does_not_contain&quot;);
-
 		$EQlang[is_not] = $page-&gt;getlocalized(&quot;is_not&quot;);
 
 		return $EQlang;
-
 	}
 
 
-
 	function GetEQlength()		//returns EQ options for length
-
 	{
-
 		global $page;
 
 		$EQlength[bigger] = $page-&gt;getlocalized(&quot;longer&quot;);
-
 		$EQlength[smaller] = $page-&gt;getlocalized(&quot;shorter&quot;);
-
 		$EQlength[is] = $page-&gt;getlocalized(&quot;is&quot;);
-
 		$EQlength[is_not] = $page-&gt;getlocalized(&quot;is_not&quot;);
 
 		return $EQlength;
-
 	}
 
 
-
 	function GetEQnumber()		//returns EQ options for numbers
-
 	{
-
 		global $page;
 
 		$EQnumber[bigger] = $page-&gt;getlocalized(&quot;bigger&quot;);
-
 		$EQnumber[smaller] = $page-&gt;getlocalized(&quot;smaller&quot;);
-
 		$EQnumber[is] = $page-&gt;getlocalized(&quot;is&quot;);
-
 		$EQnumber[is_not] = $page-&gt;getlocalized(&quot;is_not&quot;);
 
 		return $EQnumber;
-
 	}
+	
+	function GetEQcontenttype()		//returns EQ options for contenttype - ADDED BY Martin Schmidt
+	{
+		global $page;
 
+		$EQcontenttype[is] = $page-&gt;getlocalized(&quot;is&quot;);
+		$EQcontenttype[is_not] = $page-&gt;getlocalized(&quot;is_not&quot;);
 
+		return $EQcontenttype;
+	}
 
-	function simpleSearch($words, $language = false, $stationId = '')		//searches the words in the most popular fields
 
+	function simpleSearch($words, $language = false, $stationId = '', $audio=false, $video=false)		//searches the words in the most popular fields
 	{
-
 		global $db;
 
 		$this-&gt;allid = array();
-
 		$words = sotf_Utils::magicQuotes(strip_tags($words));		//remove special chars
-
 		$word = split(&quot; &quot;, $words);			//split into separate words
-
 		$max = count($word);				//count words
 
 		for ($i=0; $i&lt;$max; $i++)			//go through all words
-
 		{
-
 			$word[$i] = trim($word[$i]);			//trim word
-
+			
 			if ($word[$i] == &quot;&quot;) continue;			//in empty get next
 
 			//find word at the most common places
-
 			$serial = str_replace(&quot;XXX&quot;, $word[$i], &quot;production_date|Bstation|AAND|Bperson|Bcontains|BXXX|Bstring|AOR|Btitle|Bcontains|BXXX|Bstring|AOR|Bkeywords|Bcontains|BXXX|Bstring|AOR|Babstract|Bcontains|BXXX|Bstring|AOR|Bspatial_coverage|Bcontains|BXXX|Bstring&quot;);
 
 			if ($language) $serial .= &quot;|AAND|Blanguage|Bis|B&quot;.$language.&quot;|Blang&quot;;		//if language given add to search options
+      		if ($stationId) $serial .= &quot;|AAND|Bstation|Bis|B&quot;.$stationId.&quot;|Bstation&quot;;
+			
+			//ADDED BY Martin Schmidt
+			if($audio &amp;&amp; $video) $serial .= &quot;|AAND|Bcontenttype|Bis|Bsound|Bcontenttype|AOR|Bcontenttype|Bis|Bvideo|Bcontenttype&quot;;
+			elseif ($audio) $serial .= &quot;|AAND|Bcontenttype|Bis|Bsound|Bcontenttype&quot;;
+			elseif ($video) $serial .= &quot;|AAND|Bcontenttype|Bis|Bvideo|Bcontenttype&quot;;
 
-      if ($stationId) $serial .= &quot;|AAND|Bstation|Bis|B&quot;.$stationId.&quot;|Bstation&quot;;
-
 			$this-&gt;Deserialize($serial);		//deserialize query
-
 			$query = $this-&gt;GetSQLCommand();	//get desrialized query
-
 			$query = &quot;SELECT id FROM (&quot;.$query.&quot;) as a&quot;;
-
 			$result = $db-&gt;getAll($query);
-
 			$maxk = count($result);				//count words
 
 			for ($k=0; $k&lt;$maxk; $k++)			//go through all results
-
 			{
-
 				if (array_key_exists($result[$k][&quot;id&quot;], $this-&gt;allid)) $this-&gt;allid[$result[$k][&quot;id&quot;]] += 1;
-
 				else $this-&gt;allid[$result[$k][&quot;id&quot;]] = 1;
-
 			}
-
 		}
 
 		return count($this-&gt;allid);
-
 	}
 
 
-
 	function getSimpleSearchResults($from, $to)		//gives back the search results from the simpleSearch
-
 	{
-
 		global $db;
 
 		arsort($this-&gt;allid, SORT_NUMERIC);		//sorts the array, bigger numbers first
-
 		$result = array();
-
 		$i = -1;
 
 		foreach($this-&gt;allid as $id =&gt; $value)
-
 		{
-
 			$i++;
-
 			if ($i &lt; $from) continue;
-
 			if ($i &gt; $to) break;
-
 			$query = &quot;SELECT * FROM sotf_programmes WHERE id='$id'&quot;;
-
 			$result = array_merge($result, $db-&gt;getAll($query));
-
 		}
 
 //		print(&quot;&lt;pre&gt;&quot;);
-
 //		var_dump($result);
-
 //		print(&quot;&lt;/pre&gt;&quot;);
 
     return($result);
-
 	}
-
-
-
 }
 
 ?&gt;
\ No newline at end of file

Modified: node/branches/video_test/code/classes/sotf_AudioCheck.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_AudioCheck.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_AudioCheck.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -1,7 +1,6 @@
 &lt;?php
 
 
-
 /**
 
 * This is a class for checking the requested formats, and for converting them
@@ -18,9 +17,10 @@
 
 */
 
-class sotf_AudioCheck
+class sotf_AudioCheck extends sotf_ContentCheck
 
 {
+	
 
 	/**
 
@@ -72,8 +72,9 @@
 
 	var $list;
 
+    var $prefix = 'audio';
+	var $type = 'audioChecker';
 
-
   var $console = false;
 
 
@@ -98,10 +99,7 @@
 
 		global $config;
 
-		global $config;
 
-
-
 		$this-&gt;list = &amp; $list;
 
 		for($i=0;$i&lt;count($config['audioFormats']);$i++)			// walk thru the requested formats
@@ -274,44 +272,29 @@
 
 
 
-	/**
-
-	* Gets best quality audio file
-
+ 	/**
+	* Encode format to a filename.
 	*
-
-	* @return	mixed	If found return the index of the file, else returns boolean false
-
+	* @param	integer	$index	Format index of the jingle in the $config['audioFormats'] global variable
+	* @return	string	Encoded format. Example: 24kbps_1chn_22050Hz.mp3
+	* @use	$config['audioFormats']
 	*/
 
-	function getBest()
+	function getFormatFilename($index)
 
 	{
 
-		$bitrate = 0;								// set minimum bitrate
+		global $config;
 
-		$index = false;								// initialize file index
 
-		for($i=0;$i&lt;count($this-&gt;list-&gt;list);$i++)	// walk thru files
 
-			if ($this-&gt;list-&gt;list[$i]-&gt;type == 'audio')
+		return $config['audioFormats'][$index]['bitrate'] . 'kbps_' . $config['audioFormats'][$index]['channels'] . 'chn_' . $config['audioFormats'][$index]['samplerate'] . 'Hz.' . $config['audioFormats'][$index]['format'];
 
-				if ($this-&gt;list-&gt;list[$i]-&gt;average_bitrate &gt; $bitrate)
+	} // end func getFormatFilename
 
-				{
 
-					$bitrate = $this-&gt;list-&gt;list[$i]-&gt;average_bitrate;
 
-					$index = $i;
 
-				}
-
-		return $index;
-
-	}
-
-
-
 	/**
 
 	* Gets best quality MP3 file
@@ -349,37 +332,21 @@
 		return $index;
 
 	}
+	
+	
+	function checkFile($file) {
 
+      if(!is_readable($file)) {
+		
+        raiseError(&quot;conversion_failed&quot;);
 
+      }
 
-	/**
+    }
 
-	* Encode format to a filename.
 
-	*
 
-	* @param	integer	$index	Format index of the jingle in the $config['audioFormats'] global variable
 
-	* @return	string	Encoded format. Example: 24kbps_1chn_22050Hz.mp3
-
-	* @use	$config['audioFormats']
-
-	*/
-
-	function getFormatFilename($index)
-
-	{
-
-		global $config;
-
-
-
-		return $config['audioFormats'][$index]['bitrate'] . 'kbps_' . $config['audioFormats'][$index]['channels'] . 'chn_' . $config['audioFormats'][$index]['samplerate'] . 'Hz.' . $config['audioFormats'][$index]['format'];
-
-	} // end func getFormatFilename
-
-
-
   ////////////////////////////////////////////////////////
 
   //
@@ -394,26 +361,12 @@
 
 
 
-    function getTempWavName()
+   
 
-      {
 
-        global $config;
 
-        
+   /* function progressBar($cmd,$regexp) COMMENTED OUT BY BUDDHAFLY
 
-        $tempname = tempnam($config['tmpDir'],&quot;__&quot;);
-
-        unlink($tempname);
-
-        return $tempname. &quot;.wav&quot;;
-
-      }
-
-
-
-    function progressBar($cmd,$regexp)
-
       {
 
         global $config;
@@ -500,7 +453,7 @@
 
       exec($cmd);
 
-    }
+    }*/
 
 
 
@@ -676,7 +629,7 @@
 
     
 
-    function checkFile($file) {
+    /*function checkFile($file) {
 
       if(!is_readable($file)) {
 
@@ -692,7 +645,7 @@
 
       unlink($file) or logError(&quot;Could not delete file: $file&quot;);
 
-    }
+    }*/
 
 
 

Modified: node/branches/video_test/code/classes/sotf_AudioFile.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_AudioFile.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_AudioFile.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -1,157 +1,115 @@
 &lt;?php
 
-
-
 require_once($config['getid3dir'] . &quot;/getid3.php&quot;);
-
 require_once(&quot;sotf_File.class.php&quot;);
 
-
-
 /**
-
 * This is a class for handling audio files.
-
 *
-
 * @author	Tamas Kezdi SZTAKI DSD &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">tbyte at sztaki.hu</A>&gt;
-
 * @package	StreamOnTheFly
-
 * @version	0.1
-
 */
 
 class sotf_AudioFile extends sotf_File
-
 {
 
 	/**
-
 	* Format of the audio file.
-
 	* 
-
 	* Currently this member variable can be &quot;mp3&quot; or &quot;ogg&quot;.
-
 	* @attribute 	string	$format
-
 	*/
 
 	var $format;
 
-
-
 	/**
-
 	* Bitrate of the audio file.
-
 	* 
-
 	* If this value is numeric, it contains the constant bit rate in kbps, or it can be &quot;VBR&quot;.
-
 	* @attribute 	mixed	$bitrate
-
 	*/
 
 	var $bitrate;
 
-
-
 	/**
-
 	* Average bitrate of the audio file in kbps.
-
 	* 
-
 	* @attribute 	float	$average_bitrate
-
 	*/
 
 	var $average_bitrate;
 
-
-
 	/**
-
 	* Sample rate of the audio file in Hz.
-
 	* @attribute 	integer	$samplerate
-
 	*/
 
 	var $samplerate;
 
-
-
 	/**
-
 	* Number of channels.
-
 	*
-
 	* 1 means this is mono, 2 means this is stereo
-
 	* @attribute 	integer	$channels
-
 	*/
 
 	var $channels;
 
-
-
 	/**
-
 	* Duration of the audio file in seconds.
-
 	*
-
 	* @attribute 	float	$duration
-
 	*/
 
 	var $duration;
 
+    var $allInfo;
 
-
-  var $allInfo;
-
-
-
 	/**
-
 	* Sets up sotf_AudioFile object
-
 	*
-
 	* @constructor sotf_AudioFile
-
 	* @param	string	$path	Path of the file
 
 	*/
 
 	function sotf_AudioFile($path)
-
 	{
-
+		
 		$parent = get_parent_class($this);
 
 		parent::$parent($path);		// Call the constructor of the parent class. lk. super()
+		
+		// CHANGED BY BUDDHAFLY 06-02-14
+		$getID3 = new getID3();
+		$fileinfo = $getID3-&gt;analyze($this-&gt;path);
+		getid3_lib::CopyTagsToComments($fileinfo);
+		
+		//$fileinfo = GetAllFileInfo($this-&gt;path);
 
-		$fileinfo = GetAllFileInfo($this-&gt;path);
+    $this-&gt;allInfo = $fileinfo; //was $fileInfo
 
-    $this-&gt;allInfo = $fileInfo;
-
 		//if ($audioinfo[&quot;fileformat&quot;] == 'mp3' || $audioinfo[&quot;fileformat&quot;] == 'ogg') {
 
     //debug(&quot;finfo&quot;, $fileinfo);
+	//print_r($fileinfo);
 
+	// ADDED BY BUDDHAFLY 06-02-20
+	if (isset ($fileinfo['video']) &amp;&amp; $fileinfo['video']['dataformat']!=&quot;jpg&quot;) $this-&gt;type = &quot;video&quot;;
+	else if(isset($fileinfo['audio'])) $this-&gt;type = &quot;audio&quot;;
+
     if (isset($fileinfo['audio'])) {
 
       $audioinfo = $fileinfo['audio'];
 
+			// ADDED BY BUDDHAFLY 06-02-20
+			if (isset ($fileinfo['video'])) $this-&gt;type = &quot;video&quot;;
+			else 
+			// ADDED BY BUDDHAFLY 06-02-20
 			$this-&gt;type = &quot;audio&quot;;
 
+			//$this-&gt;format = $fileinfo[&quot;fileformat&quot;];
 			$this-&gt;format = $fileinfo[&quot;fileformat&quot;];
 
 			if ($audioinfo[&quot;bitrate_mode&quot;] == 'vbr')
@@ -179,17 +137,12 @@
 	/**
 
 	* Encode format to a filename.
-
 	*
-
 	* @return	string	Encoded format. Example: 24kbps_1chn_22050Hz.mp3
-
 	* @use	$config['audioFormats'], $config['bitrateTolerance']
-
 	*/
 
 	function getFormatFilename()
-
 	{
 
 		global $config;
@@ -229,7 +182,4 @@
   }
 
 
-
-
-
 } // end class sotf_AudioFile
\ No newline at end of file

Added: node/branches/video_test/code/classes/sotf_ContentCheck.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_ContentCheck.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_ContentCheck.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,275 @@
+&lt;?php
+
+
+/**
+
+* DESCRIPTION MISSING
+*
+* @author	Martin Schmidt &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">ptmschmidt at fh-stpoelten.ac.at</A>&gt;
+* @package	StreamOnTheFly
+* @version	0.1
+*/
+
+class sotf_ContentCheck
+
+{
+
+	var $reqs = array();
+
+	/**
+	* FileList object.
+	*
+	* @attribute 	object	$list
+	* @see	{@link FileList}
+	*/
+
+	var $list;
+
+
+    var $console = false;
+
+	/**
+	* Sets up the object
+	*
+	* @constructor sotf_ContentCheck
+	* @param	object	$list	FileList object contains list of files to be checked
+	* @use	$config['audioFormats'], $config['bitrateTolerance']
+	*/
+
+	function sotf_ContentCheck($list)
+	{
+		global $config;
+		$this-&gt;list = &amp; $list;
+
+			
+	} // end func sotf_AudioCheck
+
+
+	function selectType(){
+	
+		for($j=0;$j&lt;count($this-&gt;list-&gt;list);$j++)	// walk thru the the files we have
+			{
+						
+				if ($this-&gt;list-&gt;list[$j]-&gt;type == &quot;video&quot;){
+					$checker = &amp; new sotf_VideoCheck($this-&gt;list);
+					return $checker;
+				}
+
+				else if($this-&gt;list-&gt;list[$j]-&gt;type == &quot;audio&quot;){
+					$checker = &amp; new sotf_AudioCheck($this-&gt;list);
+					return $checker;
+				}
+			}
+	} // end func selectType
+
+	/**
+	* Gets the request index for a sotf_AudioFile
+	*
+	* @param	object	$audiofile	sotf_AudioFile object to be checked
+	* @return	mixed	If the audio file satisfies any requestment returns an integer which is an index of the $config['audioFormats'] global variable. If the file satisfy any requestment returns boolean false
+	* @use	$config['audioFormats'], $config['bitrateTolerance']
+	*/
+
+	function getRequestIndex($audiofile)
+	{
+		global $config;
+		for($i=0;$i&lt;count($config[$this-&gt;prefix.'Formats']);$i++)			// walk thru the requested formats
+		{
+
+			if ($audiofile-&gt;type != &quot;audio&quot;)
+				continue;								// This is not an audio, get another one
+
+			if ($config[$this-&gt;prefix.'Formats'][$i]['format'] != $audiofile-&gt;format)
+				continue;								// This is not the one we need, get another one
+
+			//if ($config['audioFormats'][$i]['bitrate'] != $audiofile-&gt;bitrate)
+
+			//	continue;								// This is not the one we need, get another one
+			if (abs($audiofile-&gt;average_bitrate - $config[$this-&gt;prefix.'Formats'][$i]['bitrate']) &gt; $config['bitrateTolerance'])
+				continue;							// This is not the one we need, get another one
+			if ($config[$this-&gt;prefix.'Formats'][$i]['channels'] != $audiofile-&gt;channels)
+				continue;								// This is not the one we need, get another one
+			if ($config[$this-&gt;prefix.'Formats'][$i]['samplerate'] != $audiofile-&gt;samplerate)
+				continue;								// This is not the one we need, get another one
+			return $j;									// All conditions matched, that's what we need, return the index
+
+		}
+
+		return false;
+
+	} // end func getRequestIndex
+
+
+
+	/**
+	* Gets best quality audio file
+	*
+	* @return	mixed	If found return the index of the file, else returns boolean false
+	*/
+
+	function getBest()
+	{
+		$bitrate = 0;								// set minimum bitrate
+		$index = false;								// initialize file index
+
+		for($i=0;$i&lt;count($this-&gt;list-&gt;list);$i++)	// walk thru files
+			if ($this-&gt;list-&gt;list[$i]-&gt;type == $this-&gt;prefix)
+				if ($this-&gt;list-&gt;list[$i]-&gt;average_bitrate &gt; $bitrate)
+				{
+					$bitrate = $this-&gt;list-&gt;list[$i]-&gt;average_bitrate;
+					$index = $i;
+				}
+		return $index;
+	}
+
+
+	
+
+
+  ////////////////////////////////////////////////////////
+  //
+  //  AUDIO CONVERSION
+  //
+  ///////////////////////////////////////////////////////
+
+
+
+
+    function progressBar($cmd,$regexp, $totalframes=0, $returndata=false, $errorRegexp=&quot;&quot;)
+
+      {
+
+        global $config;
+
+
+        $line = &quot;&quot;;
+
+        $out = 0;
+
+        $left = $config['progressBarLength'];
+		
+		$output=array();
+
+
+        debug('execute',$cmd);
+        $fp = popen($cmd . ' 2&gt;&amp;1', 'r');
+		//echo $cmd.&quot;&lt;br&gt;&nbsp;&lt;br&gt;&quot;;
+		$output['data']=&quot;$cmd\n&quot;;
+		$output['error']=&quot;&quot;;
+        while(!feof($fp))
+
+          {
+
+            $data = fread($fp,1);
+			$output ['data'].= $data;
+			//echo $data;
+            if ((ord($data) == 13) || (ord($data) == 10))
+
+              {
+				
+                if (preg_match($regexp,$line,$match))
+
+                  {
+				  	if ($totalframes){
+					
+						//echo &quot;&lt;br/&gt;t:$totalframes|&quot;;
+						 $curr = (integer) ((((integer) $match[1])/$totalframes*100) * $config['progressBarLength'] / 100);
+						 
+						//echo &quot;c:$curr&lt;br/&gt;&quot;;
+					}
+                    else $curr = (integer) (((integer) $match[1]) * $config['progressBarLength'] / 100);
+                    
+					if($curr&lt;=$config['progressBarLength']){
+						for ($i=$out;$i&lt;$curr;$i++)
+						  {
+							echo $config['progressBarChar'];
+							$out++;
+							$left--;
+						  }
+					}
+                  }
+				  
+				 /*if ($errorRegexp &amp;&amp; preg_match($errorRegexp,$line,$match)){
+				 	$output['error'].= ucfirst($match[1]).&quot;&lt;br&gt;&quot;;
+				 }*/
+                
+				$line = &quot;&quot;;
+              }
+
+            else
+              $line .= $data;
+            flush();
+          }
+
+        pclose($fp);
+
+        while($left)
+          {
+            echo $config['progressBarChar'];
+            $left--;
+            $out++;
+          }
+
+        flush();
+		if($returndata) return $output;
+
+      }
+
+
+
+    function exec($cmd) {
+
+      debug('execute',$cmd);
+
+      exec($cmd);
+
+    }
+
+
+
+
+    function rmFile($file) {
+
+      unlink($file) or logError(&quot;Could not delete file: $file&quot;);
+
+    }
+
+	 function getTempWavName()
+
+      {
+
+        global $config;
+
+        $tempname = tempnam($config['tmpDir'],&quot;__&quot;);
+
+        unlink($tempname);
+
+        return $tempname. &quot;.wav&quot;;
+
+      }
+
+
+    /** returns array of names of new audio files */
+
+    function convertAll($id) {
+
+      global $config;
+
+      for($i=0; $i&lt;count($config[$this-&gt;prefix.'Formats']); $i++) {
+		
+        $file = $this-&gt;convert($id, $i);
+        if($file)
+			
+          $files[] = $file;
+
+      }
+		
+      return $files;
+
+    }
+
+} // end class sotf_AudioCheck
+
+
+
+?&gt;
\ No newline at end of file

Modified: node/branches/video_test/code/classes/sotf_File.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_File.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_File.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -124,6 +124,14 @@
 	{
 		return ($this-&gt;type == &quot;audio&quot;);
 	} // end func getPath
+	
+	//ADDED BY BUDDHAFLY  06-02-20
+	
+	function isVideo()
+	{
+		return ($this-&gt;type == &quot;video&quot;);
+	}
+	
 } // end class sotf_File
 
 ?&gt;
\ No newline at end of file

Modified: node/branches/video_test/code/classes/sotf_FileList.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_FileList.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_FileList.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -3,6 +3,7 @@
 require_once($config['getid3dir'] . &quot;/getid3.php&quot;);
 require_once(&quot;sotf_File.class.php&quot;);
 require_once(&quot;sotf_AudioFile.class.php&quot;);
+require_once(&quot;sotf_VideoFile.class.php&quot;); //ADDED BY BUDDHAFLY 06-02-20
 
 // $Id$
 
@@ -60,13 +61,26 @@
 		{
 			if (!$this-&gt;pathExist($path))
 			{
-				$audioinfo = GetAllFileInfo($path);
-				if (isset($audioinfo[&quot;audio&quot;]))
+				//CHANGED BY BUDDHAFLY 06-02-14
+				//echo $path;
+				$getID3 = new getID3();
+				$fileinfo = $getID3-&gt;analyze($path);
+				getid3_lib::CopyTagsToComments($fileinfo);
+				
+				//print_r ($fileinfo);
+				
+				//$audioinfo = GetAllFileInfo($path);
+				if(isset($fileinfo[&quot;video&quot;])){
+					$this-&gt;list[] = &amp; new sotf_VideoFile($path);
+				}
+				else if (isset($fileinfo[&quot;audio&quot;])){
 					$this-&gt;list[] = &amp; new sotf_AudioFile($path);
-				else
+				}
+				else{
 					$this-&gt;list[] = &amp; new sotf_File($path);
-			}
-		}
+				}  // if-elseif-else
+			} //if
+		} //if
 		return false;
 	} // end func add
 
@@ -97,11 +111,34 @@
 	/**
 	* Removes all non-audio files from the list.
 	*/
+	
+	//new functions by buddhafly 
+	
+	function removeNonAudioVideo(){
+		$paths = array();
+		for ($i=0;$i&lt;count($this-&gt;list);$i++)
+			if (!$this-&gt;list[$i]-&gt;isAudio() &amp;&amp; !$this-&gt;list[$i]-&gt;isVideo())
+				$paths[] = $this-&gt;list[$i]-&gt;getPath();
+		for ($i=0;$i&lt;count($paths);$i++)
+			$this-&gt;remove($paths[$i]);
+	}
+	
+	function removeNonVideo(){
+		$paths = array();
+		for ($i=0;$i&lt;count($this-&gt;list);$i++)
+			if (!$this-&gt;list[$i]-&gt;isVideo()) 
+				$paths[] = $this-&gt;list[$i]-&gt;getPath();
+		for ($i=0;$i&lt;count($paths);$i++)
+			$this-&gt;remove($paths[$i]);
+	}
+	
+	/////////
+	
 	function removeNonAudio()
 	{
 		$paths = array();
 		for ($i=0;$i&lt;count($this-&gt;list);$i++)
-			if (!$this-&gt;list[$i]-&gt;isAudio())
+			if (!$this-&gt;list[$i]-&gt;isAudio()) 
 				$paths[] = $this-&gt;list[$i]-&gt;getPath();
 		for ($i=0;$i&lt;count($paths);$i++)
 			$this-&gt;remove($paths[$i]);
@@ -125,7 +162,7 @@
           if(!$prefix || preg_match(&quot;/^$prefix/&quot;, $filename))			
 		  
 		  	// START ----- added by buddhafly 05-08-30
-			if(!preg_match('/^\./', $filename)){
+			if(!preg_match('/^\./', $filename) &amp;&amp; $filename!='stills'){
 
 				 $extension = substr($filename, strrpos($filename, '.') +1);
 
@@ -155,6 +192,27 @@
 	* @param	string	$path	Path of the directory
 	* @return	boolean	If the list was successfully created return true, else false
 	*/
+	
+	// new function by buddhafly
+	
+	function getVideoFromDir($path, $prefix='')
+	{
+		$retval = $this-&gt;getDir($path, $prefix);
+		$this-&gt;removeNonVideo();
+
+		return $retval;
+	} 
+	
+	function getAudioVideoFromDir($path, $prefix='')
+	{
+		$retval = $this-&gt;getDir($path, $prefix);
+		$this-&gt;removeNonAudioVideo();
+
+		return $retval;
+	} 
+	
+	/////////////////////////////////
+	
 	function getAudioFromDir($path, $prefix='')
 	{
 		$retval = $this-&gt;getDir($path, $prefix);

Modified: node/branches/video_test/code/classes/sotf_PlayList.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_PlayList.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_PlayList.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -31,10 +31,16 @@
 		}
 	 } else {
 		// this is a local file
-
-		$mp3info = GetAllFileInfo($item['path']);
+		// CHANGED BY BUDDHAFLY 06-02-20
+		$getID3 = new getID3();
+		$mp3info = $getID3-&gt;analyze($item['path']);
+		getid3_lib::CopyTagsToComments($mp3info);
+		//$mp3info = GetAllFileInfo($item['path']);
 		//debug('mp3info', $mp3info);
-		$bitrate = (string) $mp3info['audio']['bitrate'];
+		// CHANGED BY BUDDHAFLY 06-02-20
+		
+		$bitrate = (string) $mp3info['bitrate'];
+		
 		if(!$bitrate)
 		  raiseError(&quot;Could not determine bitrate, maybe this audio is temporarily unavailable&quot;);
 		$item['bitrate'] = $bitrate;

Modified: node/branches/video_test/code/classes/sotf_Programme.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_Programme.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_Programme.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -15,7 +15,13 @@
 require_once($config['classdir'] . '/unpackXML.class.php');
 //require_once($config['classdir'] . '/packXML.class.php');
 require_once($config['classdir'] . '/sotf_Statistics.class.php');
-require_once($config['getid3dir'] . &quot;/getid3.putid3.php&quot;);
+
+//ADDED BY BUDDHAFLY - 06-02-14
+require_once($config['getid3dir'] . &quot;/getid3.php&quot;);
+
+
+//require_once($config['getid3dir'] . &quot;/getid3.putid3.php&quot;);
+
 require_once($config['classdir'] . '/sotf_Metadata.class.php');
 
 class sotf_Programme extends sotf_ComplexNodeObject {
@@ -38,6 +44,8 @@
   var $links;
   var $rights;
   var $refs;
+  
+  var $type;
 
   /**
 	* constructor
@@ -77,7 +85,7 @@
 		raiseError(&quot;Could not create unique dir for prog!&quot;);
   }
 
-  function create($stationOrSeriesId, $track='') {
+  function create($stationOrSeriesId, $track='', $is_video=false) {
 	 global $db, $repository;
 
 	 $db-&gt;begin();
@@ -103,6 +111,14 @@
 	 if(empty($track))
 		$track = 'prg';
 	 $this-&gt;getStation();
+	 
+	 if($is_video){
+	 $this-&gt;set('type', 'video');
+	 }	 
+	 else {
+	 $this-&gt;set('type', 'sound');
+	 }
+	 
 	 $this-&gt;set('entry_date', date('Y-m-d'));
 	 $this-&gt;set('modify_date', date('Y-m-d'));
 	 $this-&gt;set('track', sotf_Utils::makeValidName($track, 32));
@@ -190,12 +206,14 @@
 	 return $this-&gt;getDir();
   }
 
-  /** returns directory where audio files are stored for the programme */
+  /** returns directory where content files are stored for the programme */
   function getAudioDir() {
-	 return $this-&gt;getDir() . '/audio';
+	 return $this-&gt;getDir() . '/content'; // MOD BY BUDDHAFLY
   }
+  
 
-  /** returns directory where other files are stored for the programme */
+  
+   /** returns directory where other files are stored for the programme */
   function getOtherFilesDir() {
 	 return $this-&gt;getDir() . '/files';
   }
@@ -215,8 +233,8 @@
 	 if(!is_dir($dir)) {
 		mkdir($dir, 0770);
 	 }
-	 if(!is_dir($dir . '/audio')) {
-		mkdir($dir . '/audio', 0770);
+	 if(!is_dir($dir . '/content')) { //CHANGED BY BUDDHAFLY
+		mkdir($dir . '/content', 0770); //CHANGED BY BUDDHAFLY
 	 }
 	 if(!is_dir($dir . '/files')) {
 		mkdir($dir . '/files', 0770);
@@ -462,6 +480,29 @@
 	 return $objects;
   }
 
+  function isVideoPrg(){ //ADDED BY BUDDHAFLY
+  
+   if ($this-&gt;get('type')=='video') return true;
+   else return false;
+  
+  }
+  
+  function isAudioPrg(){ //ADDED BY BUDDHAFLY
+  
+  	if ($this-&gt;get('type')=='sound') return true;
+    else return false;
+  
+  }
+  
+  function getType(){ //ADDED BY BUDDHAFLY
+ 
+  	return $this-&gt;get('type');
+  
+  }
+  
+  
+
+
   function selectFileToListen() {
 
 	 // TODO: write this better
@@ -487,9 +528,17 @@
 	 if(!is_file($source))
 		raiseError(&quot;no such file: $source&quot;);
 	 $srcFile = new sotf_AudioFile($source);
+	 
+	 //ADDED BY BUDDHAFLY 06-02-20
+	 if($srcFile-&gt;isVideo()) $srcFile = new sotf_VideoFile($source);
+	// if($srcFile-&gt;isVideo()) $File = new sotf_VideoFile($filepath);
+	 //--------------------------
+	
 	 $target = $this-&gt;getAudioDir() .  '/' . $this-&gt;get('track') . '_' . $srcFile-&gt;getFormatFilename();
-	 if(!$srcFile-&gt;isAudio())
-		raiseError(&quot;this is not an audio file&quot;);
+
+	 if(!$srcFile-&gt;isAudio() &amp;&amp; !$srcFile-&gt;isVideo()){
+		raiseError(&quot;$source is neither an audio nor a video file&quot;); // was THIS
+	}
 	 //if(is_file($target)) {
 	 //	raiseError($page-&gt;getlocalized('format_already_present'));
 	 //}
@@ -502,7 +551,7 @@
 		$diff = abs($this-&gt;get('length') - $length);
 		if($diff &gt; 15) { 
 		  // allow for 15 sec of difference in program length
-		  $page-&gt;addStatusMsg(&quot;audio_length_no_match&quot;);
+		  if($this-&gt;isAudioPrg()) $page-&gt;addStatusMsg(&quot;audio_length_no_match&quot;); //MODIFIED BY Martin Schmidt
 		  //raiseError(&quot;audio_length_no_match&quot;);
 		  $this-&gt;set('length', $length);
 		  $this-&gt;update();
@@ -541,7 +590,7 @@
 
   function saveFileInfo($filepath, $mainContent = false) {
 	 global $db;
-
+	
 	 // convert boolean into pgsql format
 	 if($mainContent)
 		$mainContent = 'true';
@@ -549,8 +598,14 @@
 		$mainContent = 'false';
 	 // get audio properties of file
 	 $file = new sotf_AudioFile($filepath);
+	 
+	 //ADDED BY BUDDHAFLY 06-02-20
+	 if($file-&gt;isVideo()) $file = new sotf_VideoFile($filepath);
+	 //--------------------------
+	  
+	 
 	 // find if this is an existing file
-	 if($file-&gt;isAudio()) {
+	 if($file-&gt;isAudio() || $file-&gt;isVideo()) { //CHANGED BY BUDDHAFLY 06-02-20
 		$fileInfo = new sotf_NodeObject('sotf_media_files');
 	 } else {
 		$fileInfo = new sotf_NodeObject('sotf_other_files');
@@ -558,8 +613,11 @@
 	 $fileInfo-&gt;set(&quot;prog_id&quot;, $this-&gt;id);
 	 $fileInfo-&gt;set(&quot;filename&quot;, $file-&gt;name);
 	 $fileInfo-&gt;find();
+	 
 	 // save file info into database
-	 if($file-&gt;isAudio()) {
+	 
+	//ADDED BY BUDDHAFLY 06-02-20
+	if($file-&gt;isVideo()) {
 		$fileInfo-&gt;set('play_length', round($file-&gt;duration));
 		$fileInfo-&gt;set('type', $file-&gt;type);
 		if(is_numeric($file-&gt;bitrate)) {
@@ -573,7 +631,37 @@
 		}
 		$fileInfo-&gt;set('format', $file-&gt;getFormatFilename());
 		$fileInfo-&gt;set('main_content', $mainContent);
+		
+		
+		$fileInfo-&gt;set('codec', $file-&gt;codec);
+		$fileInfo-&gt;set('frame_rate', $file-&gt;frame_rate);
+		$fileInfo-&gt;set('resolution_x', $file-&gt;resolution_x);
+		$fileInfo-&gt;set('resolution_y', $file-&gt;resolution_y);
+		$fileInfo-&gt;set('pixel_aspect_ratio', $file-&gt;pixel_aspect_ratio);
+		
+		//manage access rights for video
+		$fileInfo-&gt;set('download_access', 't');
+		$fileInfo-&gt;set('stream_access', 'f');
+	
 	 }
+	 
+	 
+	 else if($file-&gt;isAudio()) {
+		$fileInfo-&gt;set('play_length', round($file-&gt;duration));
+		$fileInfo-&gt;set('type', $file-&gt;type);
+		if(is_numeric($file-&gt;bitrate)) {
+		  // constant bitrate
+		  $fileInfo-&gt;set('kbps', round($file-&gt;bitrate));
+		  $fileInfo-&gt;set('vbr', 'f');
+		} else {
+		  // variable bitrate
+		  $fileInfo-&gt;set('kbps', round($file-&gt;average_bitrate));
+		  $fileInfo-&gt;set('vbr', 't');
+		}
+		$fileInfo-&gt;set('format', $file-&gt;getFormatFilename());
+		$fileInfo-&gt;set('main_content', $mainContent);
+	 }
+	 
 	 $fstat = stat($filepath);
 	 $fileInfo-&gt;set('filesize', $fstat['size']);
 	 $fileInfo-&gt;set('last_modified', $db-&gt;getTimestampTz($fstat['mtime']));
@@ -593,8 +681,30 @@
   function saveID3($file) {
 	 global $config;
 	 $fileInfo = $file-&gt;allInfo;
+	 //----------------- CHANGED BY BUDDHAFLY 06-02-19
 	 $id3 = $fileInfo['id3v1'];
-	 //$id3['comment'] =  substr(substr($config['rootUrl'], 7), 0, 30);
+
+	require_once($config['getid3dir'] . &quot;/write.php&quot;);
+	 $tagwriter = new getid3_writetags;
+	 $tagwriter-&gt;filename   = $file;
+	 $TagData['comment'][] = &quot;id: &quot; . $this-&gt;id;
+	 debug(&quot;writing ID3V1&quot;, $id3);	
+
+	// write tags
+	if ($tagwriter-&gt;WriteTags()) {
+		//echo 'Successfully wrote tags&lt;br&gt;';
+		if (!empty($tagwriter-&gt;warnings)) {
+			logError('Wrtiting ID3V1 Tags: There were some warnings:&lt;br&gt;'.implode('&lt;br&gt;&lt;br&gt;', $tagwriter-&gt;warnings));
+		}
+	} else {
+		logError(&quot;Could not change ID3V1 tags in file &quot;. $file-&gt;path);
+	}
+	
+	//---------------------------------------------------	
+	
+	
+	/*
+	//$id3['comment'] =  substr(substr($config['rootUrl'], 7), 0, 30);
 	 $id3['comment'] = &quot;id: &quot; . $this-&gt;id;
 	 //$id3['album'] =  &quot;id: &quot; . $this-&gt;id;
 	 //if(!$id3['title'])
@@ -602,10 +712,11 @@
 	 //if(!$id3['artist'])
 	 //	$id3['artist'] = substr($this-&gt;getCreatorNames(), 0, 30);
 	 debug(&quot;writing ID3V1&quot;, $id3);
-	 //$succ = WriteID3v1($file-&gt;path, $id3['title'], $id3['artist'], $id3['album'], $id3['year'], $id3['comment'], $id3['genre'], NULL /*track*/);
-	 $succ = WriteID3v1($file-&gt;path, $id3['comment'], NULL /*track*/);
+	 //$succ = WriteID3v1($file-&gt;path, $id3['title'], $id3['artist'], $id3['album'], $id3['year'], $id3['comment'], $id3['genre'], NULL /*track*//*);
+	 $succ = WriteID3v1($file-&gt;path, $id3['comment'], NULL /*track*//*);
 	 if(!$succ)
 		logError(&quot;Could not change ID3V1 tags in file &quot;. $file-&gt;path);
+	*/
   }
 
   function deleteFile($fid) {
@@ -947,7 +1058,7 @@
 	 // convert missing formats!
 	 $audioFiles = &amp; new sotf_FileList();
 	 $audioFiles-&gt;getAudioFromDir($newPrg-&gt;getAudioDir());
-	 $checker = &amp; new sotf_AudioCheck($audioFiles);
+	 $checker = &amp; new sotf_ContentCheck($audioFiles); //MOD BY BUDDHAFLY
 	 $checker-&gt;console = $console; // if we don't want progress bars
 	 $targets = $checker-&gt;convertAll($newPrg-&gt;id);
 	 if(is_array($targets)) {

Added: node/branches/video_test/code/classes/sotf_VideoCheck.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_VideoCheck.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_VideoCheck.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,397 @@
+&lt;?php
+
+
+function print_r_html($arr, $style = &quot;display: none; margin-left: 10px;&quot;)
+{ 
+//print_r($arr);
+//return;
+
+static $i = 0; $i++;
+  echo &quot;\n&lt;div id=\&quot;array_tree_$i\&quot; class=\&quot;array_tree\&quot;&gt;\n&quot;;
+  foreach($arr as $key =&gt; $val)
+  { switch (gettype($val))
+   { case &quot;array&quot;:
+       echo &quot;&lt;a onclick=\&quot;document.getElementById('array_tree_element_$i').style.display = &quot;;
+       echo &quot;document.getElementById('array_tree_element_$i&quot;;
+       echo &quot;').style.display == 'block' ?&quot;;
+       echo &quot;'none' : 'block';\&quot;\n&quot;;
+       echo &quot;name=\&quot;array_tree_link_$i\&quot; href=\&quot;#array_tree_link_$i\&quot;&gt;&quot;.htmlspecialchars($key).&quot;&lt;/a&gt;&lt;br /&gt;\n&quot;;
+       echo &quot;&lt;div class=\&quot;array_tree_element_\&quot; id=\&quot;array_tree_element_$i\&quot; style=\&quot;$style\&quot;&gt;&quot;;
+       echo print_r_html($val);
+       echo &quot;&lt;/div&gt;&quot;;
+     break;
+     case &quot;integer&quot;:
+       echo &quot;&lt;b&gt;&quot;.htmlspecialchars($key).&quot;&lt;/b&gt; =&gt; &lt;i&gt;&quot;.htmlspecialchars($val).&quot;&lt;/i&gt;&lt;br /&gt;&quot;;
+     break;
+     case &quot;double&quot;:
+       echo &quot;&lt;b&gt;&quot;.htmlspecialchars($key).&quot;&lt;/b&gt; =&gt; &lt;i&gt;&quot;.htmlspecialchars($val).&quot;&lt;/i&gt;&lt;br /&gt;&quot;;
+     break;
+     case &quot;boolean&quot;:
+       echo &quot;&lt;b&gt;&quot;.htmlspecialchars($key).&quot;&lt;/b&gt; =&gt; &quot;;
+       if ($val)
+       { echo &quot;true&quot;; }
+       else
+       { echo &quot;false&quot;; }
+       echo  &quot;&lt;br /&gt;\n&quot;;
+     break;
+     case &quot;string&quot;:
+       echo &quot;&lt;b&gt;&quot;.htmlspecialchars($key).&quot;&lt;/b&gt; =&gt; &lt;code&gt;&quot;.htmlspecialchars($val).&quot;&lt;/code&gt;&lt;br /&gt;&quot;;
+     break;
+     default:
+       echo &quot;&lt;b&gt;&quot;.htmlspecialchars($key).&quot;&lt;/b&gt; =&gt; &quot;.gettype($val).&quot;&lt;br /&gt;&quot;;
+     break; }
+   echo &quot;\n&quot;; }
+  echo &quot;&lt;/div&gt;\n&quot;; }
+
+
+/**
+* This is a class for checking the requested VIDEO formats, and for converting them
+*
+* @author	Tamas Kezdi SZTAKI DSD &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">tbyte at sztaki.hu</A>&gt;
+* @package	StreamOnTheFly
+* @version	0.1
+*/
+
+class sotf_VideoCheck extends sotf_ContentCheck
+{
+
+	
+
+	/**
+	* Array of the arrays describes which requestments can be satisfied.
+	*
+	* The description of the requestment can be found at the same index where the requestment was
+	* found in the $config['videoFormats'] array. The first element of these arrays is a boolean indicates
+	* whether the conditions are matched. If it is true the second elements of these arrays show
+	* where is the matching file in the $list member variable. If the first element is false, the
+	* second element can be an index shows from which file can be generated the requested file,
+	* or it can be false if there was not so file. For example we need a 128 and a 24 kbps mp3
+	* but we have only the 128. The first element will be (true,0) so we have the file at index 0,
+	* the second element will be (false,0) so we haven't the 24 kbps file but it can be generated
+	* from the 128 kbps file that has the index 0. If we needed a 192 kbps mp3, we got (false,false),
+	* so we haven't so file, and we cannot generate it from 128, because 128 is less than 192.
+	* @attribute 	array	$reqs
+	* @see	{@link $config['videoFormats']}
+	*/
+
+	var $reqs = array();
+
+	/**
+	* FileList object.
+	*
+	* @attribute 	object	$list
+	* @see	{@link FileList}
+	*/
+
+	var $list;
+
+	var $prefix = 'video';
+	var $type = 'videoChecker';
+
+  var $console = false;
+
+	/**
+	* Sets up the object
+	*
+	* @constructor sotf_AudioCheck
+	* @param	object	$list	FileList object contains list of files to be checked
+	* @use	$config['videoFormats'], $config['bitrateTolerance']
+	*/
+	
+
+	function sotf_VideoCheck($list)
+	{
+		global $config;
+		
+		$display_arr=false;
+		
+		$this-&gt;list = &amp; $list;
+
+		for($i=0;$i&lt;count($config['videoFormats']);$i++)			// walk thru the requested formats
+
+		{
+			$found = false;								// indicates whether the current audio format has been found
+			for($j=0;$j&lt;count($this-&gt;list-&gt;list);$j++)	// walk thru the the files we have
+			{
+
+				// $this-&gt;list-&gt;list[$j] means the current AudioFile object
+				if ($this-&gt;list-&gt;list[$j]-&gt;type != &quot;video&quot;){
+					continue;							// This is not an video, get another one
+				}
+
+				if ($config['videoFormats'][$i]['format'] != $this-&gt;list-&gt;list[$j]-&gt;format){
+					if($display_arr) print &quot;$i$j wrong format: &quot;.$this-&gt;list-&gt;list[$j]-&gt;format.&quot;, should be &quot;.$config['videoFormats'][$i]['format'].&quot;&lt;br&gt;&quot;.print_r_html($this-&gt;list-&gt;list[$j]).&quot;&lt;br&gt;&nbsp;&lt;br&gt;&quot;;
+					continue;							// This is not the one we need, get another one
+				}
+
+				
+				/*if($this-&gt;list-&gt;list[$j]-&gt;format!=&quot;flv&quot;){
+					if (abs($this-&gt;list-&gt;list[$j]-&gt;average_bitrate - ($config['videoFormats'][$i]['video_bitrate']+$config['videoFormats'][$i]['audio_bitrate'])) &gt; $config['bitrateToleranceVideo']){
+						if($display_arr) print &quot;$i$j wrong bitrate: &quot;.$this-&gt;list-&gt;list[$j]-&gt;average_bitrate.&quot;, should be &quot;.($config['videoFormats'][$i]['video_bitrate']+$config['videoFormats'][$i]['audio_bitrate']).&quot;&lt;br&gt;&quot;.print_r_html($this-&gt;list-&gt;list[$j]).&quot;&lt;br&gt;&nbsp;&lt;br&gt;&quot;;
+						continue;							// This is not the one we need, get another one
+					}
+	
+					else
+	
+					{
+						$this-&gt;list-&gt;list[$j]-&gt;bitrate = $config['videoFormats'][$i]['video_bitrate']+$config['videoFormats'][$i]['audio_bitrate'];
+						$this-&gt;list-&gt;list[$j]-&gt;average_bitrate = $config['videoFormats'][$i]['video_bitrate']+$config['videoFormats'][$i]['audio_bitrate'];
+					}
+	
+					if ($config['videoFormats'][$i]['audio_channels'] != $this-&gt;list-&gt;list[$j]-&gt;channels){
+						if($display_arr) print &quot;$i$j wrong channels: &quot;.$this-&gt;list-&gt;list[$j]-&gt;channels.&quot;, should be &quot;.$config['videoFormats'][$i]['audio_channels'].&quot;&lt;br&gt;&quot;.print_r_html($this-&gt;list-&gt;list[$j]).&quot;&lt;br&gt;&nbsp;&lt;br&gt;&quot;;
+						continue;							// This is not the one we need, get another one
+					}
+				}*/
+
+				if ($config['videoFormats'][$i]['audio_samplerate'] != $this-&gt;list-&gt;list[$j]-&gt;samplerate){
+					if($display_arr) print &quot;$i$j wrong samplerate: &quot;.$this-&gt;list-&gt;list[$j]-&gt;samplerate.&quot;, should be &quot;.$config['videoFormats'][$i]['audio_samplerate'].&quot;&lt;br&gt;&quot;.print_r_html($this-&gt;list-&gt;list[$j]).&quot;&lt;br&gt;&nbsp;&lt;br&gt;&quot;;
+					continue;							// This is not the one we need, get another one
+				}
+
+				$found = $j;							// All conditions matched, that's what we need, store its position
+				break;									// don't need to search for another, leave the loop
+
+			}
+
+			if ($found !== false)
+			{
+				$this-&gt;reqs[] = array(true,$found);		// store the position of the matched file
+				continue;								// get the next requested format
+			}
+
+			$this-&gt;reqs[] = array(false,false);			// There was nothing we could have use
+		}
+	} // end func sotf_AudioCheck
+
+
+	/**
+	* Gets the request index for a sotf_AudioFile
+	*
+	* @param	object	$audiofile	sotf_AudioFile object to be checked
+	* @return	mixed	If the audio file satisfies any requestment returns an integer which is an index of the $config['videoFormats'] global variable. If the file satisfy any requestment returns boolean false
+	* @use	$config['videoFormats'], $config['bitrateTolerance']
+	*/
+
+	function getRequestIndex($videofile)
+	{
+		global $config;
+		for($i=0;$i&lt;count($config['videoFormats']);$i++)			// walk thru the requested formats
+
+		{
+			if ($videofile-&gt;type != &quot;video&quot;)
+				continue;								// This is not an audio, get another one
+
+			if ($config['videoFormats'][$i]['format'] != $videofile-&gt;format)
+				continue;								// This is not the one we need, get another one
+
+			//if($videofile-&gt;format!=&quot;flv&quot;){
+				if (abs($videofile-&gt;average_bitrate - $config['videoFormats'][$i]['video_bitrate']+$videofile-&gt;average_bitrate - $config['videoFormats'][$i]['audio_bitrate']) &gt; $config['bitrateToleranceVideo'])
+					continue;							// This is not the one we need, get another one
+	
+				if ($config['videoFormats'][$i]['audio_channels'] != $videofile-&gt;channels)
+					continue;								// This is not the one we need, get another one
+			//}
+			if ($config['videoFormats'][$i]['audio_samplerate'] != $videofile-&gt;samplerate)
+				continue;								// This is not the one we need, get another one
+
+			return $j;									// All conditions matched, that's what we need, return the index
+
+		}
+
+		return false;
+
+	} // end func getRequestIndex
+
+
+
+
+	/**
+	* Encode format to a filename.
+	*
+	* @param	integer	$index	Format index of the jingle in the $config['audioFormats'] global variable
+	* @return	string	Encoded format. Example: 24kbps_1chn_22050Hz.mp3
+	* @use	$config['audioFormats']
+	*/
+
+	function getFormatFilename($index)
+
+	{
+
+		global $config;
+
+		return ($config['videoFormats'][$index]['video_bitrate']+$config['videoFormats'][$index]['audio_bitrate']) . 'kbps_' . $config['videoFormats'][$index]['audio_channels'] . 'chn_' . $config['videoFormats'][$index]['audio_samplerate'] . 'Hz.' . $config['videoFormats'][$index]['format'];
+		
+		
+
+	} // end func getFormatFilename
+
+
+
+	
+	
+function fileOK($file) {
+
+	$getID3 = new getID3();
+	$fileinfo = $getID3-&gt;analyze($file);
+	getid3_lib::CopyTagsToComments($fileinfo);
+	
+	if(is_file($file.&quot;.txt&quot;)){
+	
+		$handle = fopen ($file.&quot;.txt&quot;, &quot;r&quot;);
+		$buffer=&quot;&quot;;
+		while (!feof($handle)) {
+		   $buffer .= fgets($handle, 4096);
+		}
+		fclose ($handle);
+		$finished = stristr($buffer,'muxing overhead');
+
+	}
+	else $finished = false;
+	
+	if(!is_readable($file) || filesize($file)==0 || (!isset($fileinfo['audio'])&amp;&amp;!isset($fileinfo['video'])) || !$finished) {
+		return false;
+	}
+	else{
+		
+		return true;
+	}
+}
+
+	function getTotalFrames($source, $index){
+		
+		global $config;
+		
+		$getID3 = new getID3();
+		$fileinfo = $getID3-&gt;analyze($source);
+		getid3_lib::CopyTagsToComments($fileinfo);
+		
+		$totalframes=round($fileinfo[&quot;playtime_seconds&quot;]*$config['videoFormats'][$index]['framerate']);
+		
+		return $totalframes;
+	}
+	
+	function getPercentageOrError($tempfile, $totalframes){
+	
+		if(is_file($tempfile.&quot;.txt&quot;)){
+			$handle = fopen ($tempfile.&quot;.txt&quot;, &quot;r&quot;);
+			$buffer=&quot;&quot;;
+			while (!feof($handle)) {
+			   $buffer .= fgets($handle, 4096);
+			}
+			fclose ($handle);
+			
+			$returnarray=array();			
+	
+			preg_match_all(&quot;/frame=(.{1,9})q=/&quot;, $buffer, $results);
+			$curframe=$results[1][count($results[1])-1];
+			$timediff= time()-filemtime($tempfile);
+
+			if (empty($results[1]) &amp;&amp; is_file($tempfile) &amp;&amp; preg_match_all(&quot;/\n\[.*@ 0x.*\n/&quot;, $buffer, $errors) &amp;&amp; $timediff&gt;3){
+				$returnarray['errors']=$errors[0];
+				logError('conversion failed: '.$tempfile);
+				logError('ffmpeg output: '. $buffer); 
+			}
+			$percentage=round($curframe/$totalframes*100);
+			$returnarray['percentage']=$percentage;
+			return $returnarray;
+		}
+	}
+
+
+
+  ////////////////////////////////////////////////////////
+  //
+  //  VIDEO CONVERSION
+  //
+  ///////////////////////////////////////////////////////
+
+
+  
+    function transcodeWithFfmpeg($cmd, $totalframes)
+      {
+
+		global $config, $page;
+
+        if($this-&gt;console) {
+          //echo &quot;&lt;p&gt;&quot;; // . $page-&gt;getlocalized('transcoding_video') . &quot;&lt;br /&gt;\n&quot;;
+          flush();
+          
+          $output = $this-&gt;progressBar($cmd,$config['ffmpegRegexp'], $totalframes, true, $config['ffmpegErrorRegexp']);
+          echo &quot;&lt;br/&gt;\n&quot;;
+          flush();
+		  return $output;
+        } else {
+          $this-&gt;exec($cmd);
+        }
+		
+
+      }
+
+  
+  
+    /** returns name of new audio file */
+
+    function convert($id, $index) {
+
+      global $config, $page;
+
+      debug('conversion started', $this-&gt;getFormatFilename($index));
+
+      if ($this-&gt;reqs[$index][0] === true) {
+        debug(&quot;We have this format already&quot;, $index);
+        return;
+      }
+
+      $sourceindex = $this-&gt;reqs[$index][1];
+
+
+      $audioFiles = &amp; $this-&gt;list;
+      $source = $audioFiles-&gt;list[$sourceindex]-&gt;getPath();
+	  
+      debug(&quot;source&quot;, $source);
+
+      $target = $config['tmpDir'] . '/' . $id . '_' . time() . '_' . $this-&gt;getFormatFilename($index);
+
+
+      $bitrate = $config['videoFormats'][$index][&quot;audio_bitrate&quot;];
+      $samplerate = $config['videoFormats'][$index][&quot;audio_samplerate&quot;];
+      if ($config['videoFormats'][$index][&quot;audio_channels&quot;] == 1)
+        $mode = &quot;mono&quot;;
+      else
+        $mode = &quot;joint&quot;;
+	
+		$this-&gt;getTotalFrames($source, $index);
+
+		
+		$cmd=&quot;nohup nice -n 15 &quot;.$config['ffmpeg'].' -i '.$source.' '.$config['videoFormats'][$index]['ffmpeg_params']./*' -minrate '. ($config['videoFormats'][$index]['video_bitrate']) .' -maxrate '. ($config['videoFormats'][$index]['video_bitrate']+$config['bitrateToleranceVideo']) .' -bufsize 4096 '.*/' '.$target.&quot; 1&gt;&quot;.$target.&quot;.txt 2&gt;&amp;1 &amp;&quot;;
+		
+		
+      if($this-&gt;console){
+        echo &quot;&lt;br&gt;&quot; . $page-&gt;getlocalized('conversion_started') . ' ' . $this-&gt;getFormatFilename($index) . &quot;&lt;br&gt;\n&quot;;
+		$output=$this-&gt;transcodeWithFfmpeg($cmd, $totalframes);
+	  }
+           $this-&gt;transcodeWithFfmpeg($cmd, $totalframes);
+		  
+       /*
+	   $videoFileOK = $this-&gt;fileOK($target);
+	   	if(!$videoFileOK) {
+			logError('conversion failed: '.$target);
+			if($output)logError('ffmpeg output: '. $output['data']); 
+			if($this-&gt;console){
+				echo &quot;&lt;span style='color:#c00'&gt;[ffmpeg error] Transcoding failed. The error has been logged.&lt;/span&gt;&quot;;
+				echo &quot;&lt;br&gt;&nbsp;&quot;;
+			}
+		}
+		else unlink($target.&quot;.txt&quot;);
+		*/
+		
+		
+      debug('conversion finished', $target);
+
+      return $target;
+    }
+
+} // end class sotf_AudioCheck
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/classes/sotf_VideoFile.class.php
===================================================================
--- node/branches/video_test/code/classes/sotf_VideoFile.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/classes/sotf_VideoFile.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,255 @@
+&lt;?php
+
+require_once($config['getid3dir'] . &quot;/getid3.php&quot;);
+require_once(&quot;sotf_File.class.php&quot;);
+
+/**
+* This is a class for handling audio files.
+* MODIFIED FOR HANDLING VIDEO FILES BY BUDDHAFLY
+* @author	Tamas Kezdi SZTAKI DSD &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">tbyte at sztaki.hu</A>&gt;
+* @package	StreamOnTheFly
+* @version	0.1
+*/
+
+class sotf_VideoFile extends sotf_File
+{
+
+	/**
+	* Format of the audio file.
+	* 
+	* Currently this member variable can be &quot;mp3&quot; or &quot;ogg&quot;.
+	* @attribute 	string	$format
+	*/
+
+	var $format;
+
+	/**
+	* Bitrate of the audio file.
+	* 
+	* If this value is numeric, it contains the constant bit rate in kbps, or it can be &quot;VBR&quot;.
+	* @attribute 	mixed	$bitrate
+	*/
+
+	var $bitrate;
+
+	/**
+	* Average bitrate of the audio file in kbps.
+	* 
+	* @attribute 	float	$average_bitrate
+	*/
+
+	var $average_bitrate;
+
+	/**
+	* Sample rate of the audio file in Hz.
+	* @attribute 	integer	$samplerate
+	*/
+
+	var $samplerate;
+
+	/**
+	* Number of channels.
+	*
+	* 1 means this is mono, 2 means this is stereo
+	* @attribute 	integer	$channels
+	*/
+
+	var $channels;
+
+	/**
+	* Duration of the audio file in seconds.
+	*
+	* @attribute 	float	$duration
+	*/
+
+	var $duration;
+	
+	var $codec;
+	
+	var $frame_rate;
+	
+	var $resolution_x;
+	
+	var $resolution_y;
+	
+	var $pixel_aspect_ratio;
+
+    var $allInfo;
+	
+	var $totalframes;
+
+	/**
+	* Sets up sotf_AudioFile object
+	*
+	* @constructor sotf_AudioFile
+	* @param	string	$path	Path of the file
+	*/
+
+	function sotf_VideoFile($path)
+	{
+		
+		$parent = get_parent_class($this);
+
+		parent::$parent($path);		// Call the constructor of the parent class. lk. super()
+		
+		// CHANGED BY BUDDHAFLY 06-02-14
+		$getID3 = new getID3();
+		$fileinfo = $getID3-&gt;analyze($path);
+		getid3_lib::CopyTagsToComments($fileinfo);
+		//print_r($fileinfo);
+		//$fileinfo = GetAllFileInfo($this-&gt;path);
+		 
+   		 $this-&gt;allInfo = $fileinfo; //was $fileInfo
+
+		//if ($audioinfo[&quot;fileformat&quot;] == 'mp3' || $audioinfo[&quot;fileformat&quot;] == 'ogg') {
+
+    //debug(&quot;finfo&quot;, $fileinfo);
+	
+
+    if (isset($fileinfo['video'])) {
+
+     	 $videoinfo = $fileinfo['video'];
+		 
+		 
+
+			$this-&gt;type = &quot;video&quot;;
+
+			//$this-&gt;format = $fileinfo[&quot;fileformat&quot;];
+
+			$this-&gt;format = $videoinfo[&quot;dataformat&quot;];
+			
+			if($this-&gt;format == &quot;quicktime&quot;) $this-&gt;format = &quot;mov&quot;;
+			
+			if($fileinfo['quicktime']['ftyp']['signature']==&quot;3gp4&quot;) $this-&gt;format = &quot;3gp&quot;;
+			else if($this-&gt;format == &quot;mpeg4&quot;) $this-&gt;format = &quot;mp4&quot;;
+			
+			if($this-&gt;format == &quot;asf&quot;) $this-&gt;format = &quot;wmv&quot;;
+			if($this-&gt;format == &quot;mpeg&quot;) $this-&gt;format = &quot;mpg&quot;;
+			
+			
+			if ($videoinfo[&quot;bitrate_mode&quot;] == 'vbr') $this-&gt;bitrate = &quot;VBR&quot;;
+
+      		$this-&gt;bitrate = round($fileinfo[&quot;bitrate&quot;]/1000);
+
+			$this-&gt;average_bitrate = round($fileinfo[&quot;bitrate&quot;]/1000);
+
+
+			
+			$this-&gt;duration = round($fileinfo[&quot;playtime_seconds&quot;]);
+
+			$this-&gt;mimetype = $this-&gt;determineMimeType($this-&gt;format);
+			
+			$this-&gt;codec = $videoinfo[&quot;codec&quot;];
+	
+			$this-&gt;frame_rate = round($videoinfo[&quot;frame_rate&quot;]);
+	
+			$this-&gt;resolution_x = $videoinfo[&quot;resolution_x&quot;];
+	
+			$this-&gt;resolution_y = $videoinfo[&quot;resolution_y&quot;];
+			
+			$this-&gt;lossless = $videoinfo[&quot;lossless&quot;];
+	
+			$this-&gt;pixel_aspect_ratio = $videoinfo[&quot;pixel_aspect_ratio&quot;];
+			
+			
+			if(isset($fileinfo['audio'])){
+			 $audioinfo = $fileinfo['audio'];
+			 $this-&gt;samplerate = $audioinfo[&quot;sample_rate&quot;];
+			$this-&gt;channels = $audioinfo[&quot;channels&quot;];
+			}
+			else {
+			$this-&gt;samplerate = 0;
+			$this-&gt;channels = 0;
+			
+			}
+
+		}
+
+	} // end func sotf_AudioFile
+
+	
+	
+	function createStills($file, $length, $id){
+	
+		global $config;
+		
+		//echo $file.&quot;&lt;br&gt;&quot;;
+		//echo $id.&quot;&lt;br&gt;&quot;;
+		//echo $dir.&quot;&lt;br&gt;&quot;;
+		
+		$temppath=$config['wwwdir'].&quot;/tmp&quot;;
+		
+		for($i=1;$i&lt;=5;$i++){
+			$position = round((($i+($i-1.5))/10)*$length);
+			$target = $temppath.&quot;/still_&quot;.$id.&quot;_&quot;.$i.&quot;.gif&quot;;
+			$cmd = &quot;nohup nice -n 15 &quot;.$config['ffmpeg'].&quot; -i $file -f image2 -img gif -ss $position -t 1 -r 1 -s sqcif -y $target 1&gt;$target.txt 2&gt;&amp;1 &amp;&quot;;
+			//echo $cmd.&quot;&lt;br&gt;&quot;;
+			exec($cmd);
+		}
+		
+		//die();
+	}
+
+
+	/**
+
+	* Encode format to a filename.
+	*
+	* @return	string	Encoded format. Example: 24kbps_1chn_22050Hz.mp3
+	* @use	$config['audioFormats'], $config['bitrateTolerance']
+	*/
+
+	function getFormatFilename()
+	{
+
+		global $config;
+
+
+
+		$bitrate = $this-&gt;bitrate;
+
+		for ($i=0;$i&lt;count($config['videoFormats']);$i++)
+
+			if (abs(($config['videoFormats'][$i]['audio_bitrate']+$config['videoFormats'][$i]['video_bitrate']) - $this-&gt;bitrate) &lt; $config['bitrateTolerance'])
+
+				$bitrate = $config['videoFormats'][$i]['audio_bitrate']+$config['videoFormats'][$i]['video_bitrate'];
+				
+		return round($bitrate) . 'kbps_' . $this-&gt;channels . 'chn_' . $this-&gt;samplerate . 'Hz.'. $this-&gt;format;
+		
+		//return round($bitrate) . 'kbps_' . $this-&gt;channels . 'chn_' . $this-&gt;samplerate . 'Hz_' . convert_special_chars($this-&gt;codec) . '.' . $this-&gt;format;
+
+	} // end func getFormatFilename
+
+
+
+  /** static method converts format encoded into filename back to array of format characteristics. */
+
+  function decodeFormatFilename($filename) {
+
+    preg_match('/(\d+)kbps_(\d)chn_(\d+)Hz.(.*)/', $filename, $matches);
+
+    return array('bitrate' =&gt; $matches[1],
+
+                 'channels' =&gt; $matches[2],
+
+                 'samplerate' =&gt; $matches[3],
+				 
+                 'format' =&gt; $matches[5]);
+
+  }
+  
+ /* function transcode(){
+  
+  $path = $this-&gt;path;
+  
+  	exec(&quot;ffmpeg -i $path -r 16 -i 100 -s qcif -ar 22050 -ab 48 -ac 1 $flvpath/mov.flv&quot;, $output_array);
+	print_r($output_array);
+	exec(&quot;ffmpeg -i $path -r 16 -i 100 -s qcif -ar 22050 -ab 48 -ac 1 $flvpath/mov.flv&quot;, $output_array);
+	print_r($output_array);
+  	exec(&quot;ffmpeg -i $path -r 16 -i 100 -s qcif -ar 22050 -ab 48 -ac 1 $flvpath/mov.flv&quot;, $output_array);
+	print_r($output_array);
+	
+  }*/
+
+
+} // end class sotf_AudioFile
\ No newline at end of file

Modified: node/branches/video_test/code/configs/eng.conf
===================================================================
--- node/branches/video_test/code/configs/eng.conf	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/configs/eng.conf	2006-05-04 14:34:58 UTC (rev 558)
@@ -130,7 +130,7 @@
 title=Title
 keywords=Keywords
 abstract=Abstract
-length=Lengts
+length=Length
 rating=Rating
 contact_email=Contact Email
 contact_phone=Contact Phone
@@ -143,6 +143,9 @@
 episode_title=Episode title
 episode_sequence = Episode sequence
 
+#ADDED BY Martin Schmidt
+contenttype = Content Type
+
 # audio conversion messages
 conversion_started = Converting into:
 encoding_mp3 = Encoding MP3 file...
@@ -639,6 +642,11 @@
 URL_missing=URL not found
 
 box3=3. Manage your queries
+
+#ADDED BY Martin Schmidt
+manage_queries=Manage your queries
+combine=Combine one or more criterias to perform an advanced search on programmes
+
 load=Load query
 default=Make my default
 deleteq=Delete query
@@ -893,7 +901,7 @@
 change = Change
 delete = Delete
 change_caption = Change caption
-add_content = Add other formats of audio content
+add_content = Add other formats of content
 add_files = Add files
 missing = missing
 convert = Convert from others
@@ -904,7 +912,7 @@
 
 no_files = No files
 no_user_files = No user files
-Prg_files = Programme audio
+Prg_files = Programme files
 Files = Associated files
 audio_file_list = Audio files:
 other_file_list = Other files:
@@ -1047,7 +1055,7 @@
 [createNeighbour]
 create_neighbour = Create new neighbour
 create_from_nodes = Use an existing node as neighbour
-create_new_node = Create a new neighbour node
+create_new_node = Create a new neighbour connection
 create = Create
 id = Node id
 name = Name

Modified: node/branches/video_test/code/configs/fra.conf
===================================================================
--- node/branches/video_test/code/configs/fra.conf	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/configs/fra.conf	2006-05-04 14:34:58 UTC (rev 558)
@@ -144,6 +144,9 @@
 episode_title= titre d'&#195;&#169;pisode
 episode_sequence = ordre d'&#195;&#169;pisode
 
+#ADDED BY Martin Schmidt
+contenttype = Type de contenu
+
 # audio conversion messages
 conversion_started = convertir en:
 encoding_mp3 = codage de dossier MP3
@@ -636,6 +639,11 @@
 URL_missing= URL non trouv&#195;&#169;
 
 box3=3. Manage your queries
+
+#ADDED BY Martin Schmidt
+manage_queries=Manage your queries
+combine=Choisissez un ou plusieurs champs pour faire votre question
+
 load= Chargez question
 default= Faites mon d&#195;&#169;faut
 deleteq= Effacez question
@@ -886,7 +894,7 @@
 change = changez
 delete = effacez
 change_caption = changez la l&#195;&#169;gende
-add_content = Ajoutez d'autres formats de contenu audio
+add_content = Ajoutez d'autres formats de contenu
 add_files = Ajoutez les dossiers
 missing = manquer
 convert = convertissez d'autres
@@ -897,7 +905,7 @@
 
 no_files = Aucuns dossiers
 no_user_files = Aucuns dossiers d'utilisateur
-Prg_files = audio programme
+Prg_files = Dossiers de la programme
 Files = Dossiers associ&#195;&#169;s
 audio_file_list = Dossiers audio:
 other_file_list = d'autres dossiers:

Modified: node/branches/video_test/code/configs/ger.conf
===================================================================
--- node/branches/video_test/code/configs/ger.conf	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/configs/ger.conf	2006-05-04 14:34:58 UTC (rev 558)
@@ -143,6 +143,9 @@
 episode_title = Episoden-Titel
 episode_sequence = Episode
 
+#ADDED BY Martin Schmidt
+contenttype = Art des Programmes
+
 # audio conversion messages
 conversion_started = Konvertieren in:
 encoding_mp3 = In MP3 Datei wandeln...
@@ -642,6 +645,11 @@
 URL_missing = URL nicht gefunden
 
 box3 = 3. Suche/n verwalten
+
+#ADDED BY Martin Schmidt
+manage_queries=Suche/n verwalten
+combine=W&#195;&#164;hlen Sie ein oder mehrere Feld(er), um eine erweiterte Suche durchzuf&#195;&#188;hren
+
 load = Suche laden
 default = Zu Standard machen
 deleteq = Suche l&#195;&#188;schen
@@ -895,7 +903,7 @@
 change = &#195;&#132;ndern
 delete = L&#195;&#182;schen
 change_caption = Benennung ver&#195;&#164;ndern
-add_content = Andere format hinzuf&#195;&#188;gen
+add_content = Andere Programm-Dateien hinzuf&#195;&#188;gen
 add_files = Datei(en) hinzuf&#195;&#188;gen
 missing = fehlt
 convert = Von anderen konvertieren
@@ -906,7 +914,7 @@
 
 no_files = Keine Dateien
 no_user_files = Keine Benutzer-Dateien
-Prg_files = Programm Audio
+Prg_files = Programm-Dateien
 Files = verbundene Dateien
 audio_file_list = Audio-Dateien:
 other_file_list = Andere Dateien:

Modified: node/branches/video_test/code/configs/hun.conf
===================================================================
--- node/branches/video_test/code/configs/hun.conf	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/configs/hun.conf	2006-05-04 14:34:58 UTC (rev 558)
@@ -143,6 +143,9 @@
 episode_title = Epiz&#195;&#179;dc&#195;&#173;m
 episode_sequence = Epiz&#195;&#179;d sorsz&#195;&#161;m
 
+#ADDED BY Martin Schmidt
+contenttype = Content Type
+
 # audio conversion messages
 conversion_started = Konvert&#195;&#161;l&#195;&#161;s:
 encoding_mp3 = Konvert&#195;&#161;l&#195;&#161;s MP3 form&#195;&#161;ba...
@@ -633,6 +636,11 @@
 URL_missing = Az URL hi&#195;&#161;nyzik!
 
 box3 = 3. Keres&#197;&#145;k&#195;&#169;rd&#195;&#169;sek kezel&#195;&#169;se
+
+#ADDED BY Martin Schmidt
+manage_queries= Keres&#197;&#145;k&#195;&#169;rd&#195;&#169;sek kezel&#195;&#169;se
+combine=Combine one or more criterias to perform an advanced search on programmes
+
 load = Bet&#195;&#182;lt&#195;&#169;s
 default = Legyen alap&#195;&#169;rtelmezett
 deleteq = T&#195;&#182;rl&#195;&#169;s
@@ -879,6 +887,7 @@
 format = Form&#195;&#161;tum
 mime_type = MIME t&#195;&#173;pus
 url = URL
+
 actions = Utas&#195;&#173;t&#195;&#161;sok
 public = Nyilv&#195;&#161;nos
 add_link = &#195;&#154;j ugr&#195;&#179;pont hozz&#195;&#161;ad&#195;&#161;sa
@@ -886,7 +895,10 @@
 change = M&#195;&#179;dos&#195;&#173;t&#195;&#161;s
 delete = T&#195;&#182;rl&#195;&#169;s
 change_caption = Le&#195;&#173;r&#195;&#161;s m&#195;&#179;dos&#195;&#173;t&#195;&#161;sa
+
+#to_translate#
 add_content = M&#197;&#177;sor hanganyag&#195;&#161;nak felt&#195;&#182;lt&#195;&#169;se m&#195;&#161;s form&#195;&#161;tumban
+
 add_files = &#195;&#154;j f&#195;&#161;jl t&#195;&#161;rs&#195;&#173;t&#195;&#161;sa
 missing = hi&#195;&#161;nyzik
 convert = Gener&#195;&#161;ld a t&#195;&#182;bbib&#197;&#145;l
@@ -897,10 +909,14 @@
 
 no_files = Nincsenek f&#195;&#161;jlok
 no_user_files = Nincsenek felt&#195;&#182;lt&#195;&#182;tt f&#195;&#161;jlok
+
+#to_translate#
 Prg_files = A m&#197;&#177;sor hanganyaga
+
 Files = Kapcsolt f&#195;&#161;jlok
 audio_file_list = Hangf&#195;&#161;jlok
 other_file_list = Egy&#195;&#169;b f&#195;&#161;jlok
+
 Add_to_audio = &lt;&lt;&lt; Add to audio files &lt;&lt;&lt; (*) ??
 Add_to_other = &lt;&lt;&lt; Add to other files &lt;&lt;&lt; (*) ??
 Add_as_icon = &lt;&lt;&lt; Set as icon &lt;&lt;&lt; (*) ??

Added: node/branches/video_test/code/getid3-1.7.5/changelog.txt
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/changelog.txt	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/changelog.txt	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,2436 @@
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// changelog.txt - part of getID3()                            //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+        &#187;  denotes a major feature addition/change
+        &#164;  denotes a change in the returned structure
+* Bugfix:  denotes a fixed bug
+
+Version History
+===============
+
+1.7.5: [2005-12-29] James Heinrich
+    &#187; Added FLV (FLash Video) support -- new file:
+      module.audio-video.flv.php
+      (thanks Seth Kaufman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">seth at whirl-i-gig.com</A>&gt; for code)
+    &#187; Real tags can now be written (previous Real tag writing
+      code was not supposed to be in public releases, as it
+      was not complete)
+    &#187; GETID3_HELPERAPPSDIR now autodetected under Windows
+    &#164; ASF lyrics now returned under [comments][lyrics]
+    * Bugfix: removed &quot;--lowpass xxxxx&quot; info from guessed
+      LAME presets when source frequency &lt;= 32kHz
+    * Bugfix: ID3v2 extended header errors
+    * Bugfix: missing ob_end_clean() in write.id3v2.php
+      (thanks rasher&#216;gmail*com)
+
+1.7.4: [2005-05-04] James Heinrich
+    &#164; Added ['quicktime']['hinting'] key (boolean)
+      (thanks jon&#216;webignition*net)
+    * Bugfix: major UTF-8 to UTF-16/ISO-8859-1 conversion
+      bug (empty string returned) when using iconv_fallback
+      (thanks chris&#216;fmgp*com)
+    * Bugfix: Missing 'lossless' key in RIFF-WAV
+      (thanks bobbfwed&#216;comcast*net)
+
+1.7.3: [2005-04-22] James Heinrich
+    &#187; Added TAR support -- new file: module.archive.tar.php
+      (thanks Mike Mozolin &lt;teddybear&#216;mail*ru&gt; for code!)
+    &#187; Added GZIP support -- new file: module.archive.gzip.php
+      (thanks Mike Mozolin &lt;teddybear&#216;mail*ru&gt; for code!)
+    * Bugfix: demo.browse.php now displays embedded images
+      internally instead of passing local filename as IMG
+      SRC (should allow demo.browse.php to correctly show
+      embedded images over a network)
+      (thanks patpowerman&#216;hotmail*com)
+    * Bugfix: minor UTF-8 display issues in demo.browse.php
+    * Bugfix: demo.browse.php now works even if the evil
+      setting magic_quotes_gpc is turned on
+      (thanks patpowerman&#216;hotmail*com)
+    * Bugfix: incorrect MIDI playtime for some files
+      (thanks joel&#216;oneporpoise*com)
+    * Bugfix: 'url_source' typo in module.tag.id3v2.php
+      (thanks richardlynch&#216;users*sourceforge*net)
+    * Bugfix: Quicktime 'mvhd' matrix values were wrong
+      (thanks web&#216;bobbymac*net)
+    &#164; ID3v2 now returns xx/yy for ['track'] (if
+      available), with xx in ['tracknum'] and yy in
+      ['totaltracks']. Previously ['tracknum'] was not
+      available and ['track'] had only xx.
+    Bugfixes and improvements to /demo/demo.mysql.php:
+      - remix/version parsed from tags and stored in
+        database, can be used when renaming files
+      - track number can be used for renaming files
+
+
+1.7.2: [2004-10-18] Allan Hansen
+    &#187; Added support for WavPack v4.0+
+      (thanks ah&#216;artemis*dk)
+    &#187; Removed code for parsing EXE files
+      (thanks ah&#216;artemis*dk)
+      Removed file: module.misc.exe.php
+    * Bugfix: Large ID3v2 tags inside ASF not parsed
+      properly under PHP5.
+    * Bugfix: Certain Wavpack3 files failed under PHP5 due
+      to new undocumented tmpfile() limit (same problem as
+      above).
+    * Bugfix: New iTunes crashes PHP - temp fix - no tags
+      on those files.
+    * Bugfix: ['nsv']['NSVs']['framerate_index'] might be
+      wrong  (thanks ah&#216;artemis*dk)
+    * Bugfix: transparent color was wrong from truecolor
+      PNG  (thanks ah&#216;artemis*dk)
+    * Bugfix: Changed MPC SV7 header size from 30 to 28,
+      this will change hash values for MPC files
+      (thanks ah&#216;artemis*dk)
+    * Bugfix: Changed MPC SV4-6 header size from 28 to 8,
+      this will change hash values for MPC files
+      (thanks ah&#216;artemis*dk)
+    &#164; Trim/unset wavpack encoder_options to match 2.0.0b2
+      output.
+    &#164; Commented-out unknown/unused values in NSV and ISO
+      modules  (thanks ah&#216;artemis*dk)
+
+
+1.7.1b1: [July-26-2004] James Heinrich
+    &#187; Added support for Apple Lossless Audio Codec
+    &#187; Added support for RealAudio Lossless
+    &#187; Added support for TTA v3
+    &#187; Added support for TIFF
+      New file: /getid3/module.graphic.tiff.php
+    &#187; Modified iconv_fallback to work with UTF-8, UTF-16, UTF-16LE,
+      UTF-16BE and ISO-8859-1 even if iconv() and/or XML support is
+      not available. This means that iconv() is no longer required
+      for most users of getID3()
+      (thanks Jeremia, khlee&#216;bitpass*com)
+    &#187; Added support for Monkey's Audio v3.98+ (thanks ah&#216;artemis*dk)
+    &#187; Included new demo showing most-basic getID3() usage
+      New file: /demos/demo.basic.php
+    * Bugfix: LAME3.94+ presets cached incorrectly if multiple files
+      are scanned in one batch and first file is LAME3.93 or earlier
+      (thanks enoyand&#216;yahoo*com)
+    * Bugfix: Added warning if compressed ID3v2 frame decompression
+      fails. (thanks Mike Billings)
+    * Bugfix: Assorted small fixes to ensure compatability with PHP5
+    * Bugfix: ID3v1 genre &quot;Blues&quot; could not be written
+      (thanks Jeremia)
+    * Bugfix: ['bitrate_mode'] typo in module.audio-video.real.php
+      (thanks asukakenji&#216;users*sourceforge*net)
+    * Bugfix: ['zip']['files'] is now populated with filenames even
+      if End Of Central Directory couldn't be parsed
+    * Bugfix: ['audio']['lossless'] was incorrect for FLAC
+      (thanks WaldoMonster)
+    * Bugfix: MD5 File was incorrect in directory browse mode for
+      /demo/getid3.browse.php
+    * Bugfix: PHP v5 compatability changes (float array keys, fread()
+      calls with zero data length)
+      (thanks getid3&#216;jsc*pp*ru)
+    * Bugfix: was dying if on compressed ID3v2 frames if
+      gzuncompress() function was unavailable
+    * Bugfix: ['vqf']['COMM'] was always empty
+    * Bugfix: MIDI playtime was missing for single-track MIDI files
+    * Bugfix: removed &#0; characters from ['comments_html']
+      (thanks p*quaedackers&#216;planet*nl)
+    * Bugfix: improved MIDI playtime accuracy
+      (thanks joel&#216;oneporpoise*com)
+    * Bugfix: BMP subtypes 4 and 5 were not being identified
+    * Bugfix: frame_rate in AVI was incorrectly truncated to integer
+    * Bugfix: FLAC cuesheet track index was incorrect
+      (thanks tetsuo*yokozuka&#216;operamail*com)
+    &#164; ['quicktime']['display_scale'] now contains the playback scale
+      multiplier for QuickTime movies - a movie set to playback at
+      double-size will have &quot;2&quot; here. Other values are &quot;1&quot; and &quot;0.5&quot;
+    &#164; Added LAME preset guessing for --preset medium with v3.90.3
+      (thanks phwip&#216;fish*co*uk)
+    &#164; Added $encoding_id3v1 to allow for ID3v1 encodings other than
+      the standard ISO-8859-1
+    &#164; Default AVI video bitrate_mode is now 'vbr'
+      (thanks eltoder&#216;pisem*net)
+    Force getID3() to abort if Shorten files have ID3 or APE tags
+      (thanks ah&#216;artemis*dk)
+    Editable textbox for parent directory in demo.browse.php
+      (thanks eltoder&#216;pisem*net)
+
+
+1.7.0-hotfix [2004-03-17] Allan Hansen
+    (hotfix version released by Allan Hansen)
+    * Bugfix: PHP 4.1.x compatiblity - fgets($fp) =&gt; fgets($fp, 1024)
+    * Bugfix: Added default charset to TextEncodingNameLookup() in
+      module.tag.id3v2.php
+    &#216; Removed option_no_iconv
+      iconv() support is only a requirement for WMA/WMW/ASF, and for
+      destination encodings other than ISO-8859-1 and UTF-8, iconv is
+      not needed otherwise. New 'iconv_req' in GetFileFormatArray()
+      only set for WMA/WMV/ASF. analyze() now refuses to analyse
+      WMA/ASF file if iconv is not present.
+    iconv_fallback() only dies on internal errors not missing iconv()
+
+
+1.7.0: [January-19-2004] James Heinrich
+    &#187; Added support for RIFF/CDXA files (MPEG video in RIFF container
+      format (thanks chris&#216;digitekdesign*com)
+    &#187; Added support for TTA v2  (thanks ah&#216;artemis*dk)
+    &#164; ID3v2 unsynchronisation scheme disabled by default because most
+      tag-reading programs cannot read unsynchronised tags. Can be
+      overridden by setting id3v2_use_unsynchronisation to true.
+      (thanks mike&#216;delusion*org)
+    &#164; extention.*.php renamed to extension.*.php
+      (thanks tp62&#216;cornell*edu)
+    &#164; /demo/demo.check.php renamed to /demo/demo.browse.php
+    &#164; Added id3v2_paddedlength configuration parameter to WriteTags()
+      and renamed tag_language to id3v2_tag_language
+    &#164; MPEG audio layers are now represented as 1, 2 or 3 instead of
+      'I', 'II', or 'III'
+    &#164; Added [audio][wformattag] and [video][fourcc] for WAV and AVI
+    &#164; Added [audio][streams] which contains one entry for each audio
+      stream present in the file (usually only one). The data is a
+      copy of what is usually found in [audio]. If there are multiple
+      audio streams then [audio] will contain a sum of the bitrates
+      of all audio streams, and the data format of the first stream
+      (if streams are of different data types)
+    &#164; Added BruteForce mode to mp3 scanning. Disabled by default as
+      it is extremely slow and only files that are broken enough to
+      not really play will gain any benefit from this.
+    &#164; Suppress '--resample xxxxx' appended to encoder options for mp3
+      with low-quality presets for default sampling frequencies
+    &#164; Enhanced LAME preset guessing for pre-3.93 with a better lookup
+      table, --resample/--lowpass guessing (thanks phwip&#216;fish*co*uk)
+    &#164; RIFF files with non-MP3 contents no longer have
+      [audio][encoder_options] set
+    &#164; Added [audio][encoder_options] to audio formats where possible
+      (including LiteWave, LPAC, OptimFROG, TTA)
+    &#164; Moved [quantization] and [max_prediction_order] from
+      [lpac][flags] to just [lpac]
+    &#164; WavPack flags are now parsed into [wavpack][flags]
+    * Bugfix: APEtags with ReplayGain information stored with comma-
+      seperated decimal values (ie &quot;0,95&quot; instead of &quot;0.95&quot;) were
+      giving wrong peak and gain values
+    * Bugfix: Filesize &gt; 2GB not always detected correctly
+    * Bugfix: Some ID3v2 frames had data key unset incorrectly
+      (thanks chris&#216;digitekdesign*com)
+    * Bugfix: Warnings on empty-strings-only comments
+    * Bugfix: ID3v2 tag writing may have had incorrect padding length
+      if padded length less than current ID3v2 tag length and
+      merge_existing_data is false  (thanks mike&#216;delusion*org)
+    * Bugfix: hash_data() for SHA1 was broken under Windows
+    * Bugfix: BigEndian2Float()/LittleEndian2Float() were broken
+    * Bugfix: LAME header calculated track peaks were incorrect for
+      LAME3.94a15 and earlier
+    * Bugfix: AVIs with VBR MP3 audio data reported incorrect bitrate
+      and bitrate_mode
+    * Bugfix: AVIs sometimes had incorrect or missing video and total
+      bitrates
+    * Bugifx: AVIs sometimes had incorrect ['avdataend'] and
+      therefore also incorrect data hashes (md5_data, sha1_data)
+    * Bugfix: ID3v1 genreid no longer returned for Unknown genre
+    * Bugfix: ID3v1 SCMPX genres were broken
+    Modified LAME header parsing to correctly process peak track
+      value for LAME3.94a16+ (thanks Gabriel)
+    md5_file() and sha1_file() now work under Windows in PHP &lt; 4.2.0
+      and 4.3.0 respectively with helper apps
+    Default md5_data() tempfile location is now system temp directory
+      instead of same directory as file (thanks towb&#216;tiscali*de)
+    Improved list of RIFF ['INFO'] comment key translations
+    More helpful error message when GETID3_HELPERAPPSDIR has spaces
+    /demo/demo.browse.php now autogets both MD5 and SHA1 hashes for
+      files &lt; 50MB
+    Replaced PHP_OS comparisons with GETID3_OS_ISWINDOWS define
+      (thanks necrotic&#216;users*sourceforge*net)
+
+
+1.7.0b5: [December-29-2003] James Heinrich
+    &#187; Windows only: Various binary files are now required for some
+      file formats, especially for tag writing, as well as md5sum
+      (and other) calculations. These binaries are now stored in the
+      directory defined as GETID3_HELPERAPPSDIR in getid3.php
+      (default is /helperapps/ parallel to /getid3/).
+      Note: This directory must not have any spaces in the pathname.
+      All neccesary files are available as a seperate download.
+      See /helperapps/readme.txt for more information
+      New file: /helperapps/readme.txt
+    &#187; Unified tag-writing interface for all tag formats
+      New file: /getid3/write.php
+                /getid3/write.apetag.php
+                /getid3/write.id3v1.php
+                /getid3/write.id3v2.php
+                /getid3/write.lyrics3.php
+                /getid3/write.metaflac.php
+                /getid3/write.vorbiscomment.php
+    &#187; Added support for Shorten - requires shorten binary (head.exe
+      is also required under Windows).
+      New file: /getid3/module.audio.shorten.php
+    &#187; Added support for RKAU
+      New file: /getid3/module.audio.rkau.php
+    &#187; Added (minimal) support for SZIP
+      New file: /getid3/module.archive.szip.php
+    &#187; Added MySQL caching extention  (thanks ah&#216;artemis*dk)
+      New file: /getid3/extention.cache.mysql.php
+    &#187; Added DBM caching extention  (thanks ah&#216;artemis*dk)
+      New file: /getid3/extention.cache.dbm.php
+    &#187; Added sha1_data hash option  (thanks ah&#216;artemis*dk)
+    &#187; Added option to allow getID3() to skip ID3v2 without parsing it
+      for faster scanning when ID3v2 data is not required. If you
+      want to enable this feature delete /getid3/module.tag.id3v2.php
+      (thanks ah&#216;artemis*dk)
+    &#164; 8-bit WAV data now calculates MD5 checksums as normal, not
+      converting to signed data as before, so stored md5_data_source
+      in FLAC files will no longer match md5_data for the equivalent
+      decoded 8-bit WAV. A warning will be generated for 8-bit FLAC
+      files
+    &#164; Added option_no_iconv option to allow getID3() to work
+      partially without iconv() support enabled in PHP
+      (thanks ah&#216;artemis*dk)
+    &#164; All '*_ascii' keys removed for ASF/WMA/WMV files
+    &#164; All 'ascii*' keys removed for ID3v2 tags
+    &#164; Ogg filetypes now return MIME of &quot;application/ogg&quot; instead of
+      the previous &quot;application/x-ogg&quot;
+      (thanks blakewatters&#216;users*sourceforge*net)
+    &#164; Force contents of ['id3v2']['comments'] to UTF-8 format from
+      whatever encoding each frame may have (text encoding can vary
+      from frame to frame in ID3v2)
+    &#164; MP3Gain information from APE tags suppressed from ['tags'] and
+      parsed into ['replay_gain']
+    &#164; ReplayGain information (all formats) changed from &quot;Radio&quot; and
+      &quot;Audiophile&quot; to &quot;Track&quot; and &quot;Album&quot; respectively
+    &#164; ['volume'] and ['max_noclip_gain'] are now available in both
+      ['replay_gain']['track'] and ['replay_gain']['album'] for all
+      formats that calculate ReplayGain.
+    &#164; ['video']['total_frames'] is available for AVIs
+    &#164; All parsed ID3v2 frame data is now in ['id3v2'][XXXX][#]
+      (previously some frame types would have numeric array keys if
+      multiple instances of that frame type were allowed and other
+      frame types would not)
+    &#164; ASF/WMA &quot;WM/Picture&quot; images are now parsed in the same manner
+      as ID3v2 with the image (ex JPEG) data returned in [data]
+      rather than [value]
+    * Bugfix: Optional tag processing options were being ignored (ie
+      ID3v1 still processed even if option_tag_id3v1 == false)
+      (thanks ah&#216;artemis*dk)
+    * Bugfix: fixed MultiByteCharString2HTML() for UTF-8
+    * Bugfix: Quicktime files not always reporting video frame_rate
+    * Bugfix: False ID3v1 synch patterns in APE or Lyrics3 tags are
+      now detected and incorrect ID3v1 data not returned
+      (thanks sebastian_mares&#216;users*sourceforge*net for the idea)
+    * Bugfix: WMA9 Lossless now reported as lossless
+    * Bugfix: two typos in ID3v1 genre list
+    * Bugfix: MPEG-2/2.5 ABR/VBR MP3 files had doubled playtime
+    * Bugfix: MPEG-2/2.5 LayerII (ie MP2: 24/22.05/16kHz) files were
+      not detected due to incorrect frame length calculation
+    * Bugfix: MPEG LayerI files were not detected due to incorrect
+      frame length calculation (must be multiple of slot length)
+    Added alternative md5_data via system call - twice as fast. Needs
+      &quot;getID3()-WindowsSupport&quot; to work under Windows.
+      (thanks ah&#216;artemis*dk)
+    ID3v2.4 compressed frames are now supported
+    php_uname() calls changed to use PHP_OS constant
+    Added SCMPX extensions to ID3v1 genres (0xF0-0xFE)
+    Obfuscated contributor email address in changelog and sourcecode
+    Added memory-saving EmbeddedLookup() function for lookup tables
+      in RIFF and ID3v2 modules (thanks ah&#216;artemis*dk)
+    Major memory patches to many modules by using
+      $var = &amp;$INFO_ARRAY_AT_SOME_INDEX
+      in place of large multi-dimensional array declarations.
+      Memory saved:  RIFF: ~200kB;  ID3v2: ~475kB;  ASF: ~50kB  etc.
+      (thanks ah&#216;artemis*dk)
+
+
+1.7.0b4: [November-19-2003] James Heinrich
+   &#187; Support added for MPC files with old SV4-SV6 structure
+   &#187; RealVideo now properly supported with resolution, framerate, etc
+     (thanks jcsston)
+   &#187; RealAudio files with old-style file format (v2-v4) are now
+     fully supported
+   &#187; Support added for DolbyDigital WAV files (thanks ah&#216;artemis*dk)
+   &#164; ['RIFF'] is now ['riff'] to conform to make all root key names
+     lowercase
+   &#164; ['OFR'] is now ['ofr'] to conform to make all root key names
+     lowercase
+   &#164; ['tags_html'] is now available as a copy of ['tags'] but
+     with all text replaced with an HTML version of all characters
+     above chr(127), translated according to whatever the encoding
+     of the source tag is, in the HTML form &#1234;
+   &#164; CopyTagsToComments() is now available in getid3_lib
+   &#164; QuicktimeVR files now return a ['video']['dataformat'] of
+     'quicktimevr' instead of 'quicktime' (thanks gts&#216;tsu*biz)
+   &#164; Quicktime video files with DivX, Xvid, 3ivx or MPEG4 video
+     streams now return those names as ['video']['dataformat']
+   &#164; MPEG video files are now identified with ['video']['codec'] set
+     to either 'MPEG-1' or 'MPEG-2' (rather than just 'MPEG'). If you
+     see a file wrongly identified, please report it!
+     (thanks fccHandler)
+   &#164; All bitrate values in ['mpeg']['audio'] is now reported in bps
+     rather than kbps (ie 128000 instead of 128) for consistancy
+   &#164; AVIs with MP2 audio now report ['audio']['dataformat'] as 'mp2'
+     rather than 'wav'  (thanks metalbrain&#216;netian*com)
+   &#164; Added ['md5_data_source'] for OptimFROG
+   &#164; AC3 in RIFF-WAV now identified with ['audio']['dataformat']
+     returning 'ac3'
+   &#164; WavPack ['extra_bc'] now returned as integer
+   &#164; WavPack ['extras'] now returned as 3-element array of integers
+   &#164; MP3 ['audio']['encoder options'] now returns 'VBR' or 'CBR' only
+     (no bitrate) if no LAME preset is used, or 'VBR q??' where ?? is
+     a number 0-100 for Fraunhofer-encoded VBR MP3s
+   * Bugfix: VBR MP3s could have incorrect bitrate reported
+   * Bugfix: Quicktime files with MP4 audio were not returning
+     ['video']['dataformat'] (thanks rob&#216;massive-interactive*nl)
+   * Bugfix: strpad vs str_pad typo in module.riff.php
+     (thanks nicojun&#216;users*sourceforge*net)
+   * Bugfix: ReplayGain information was often wrong for MPC files
+   * Bugfix: MD5 and other post-TAIL chunks were not being processed
+     in module.audio.optimfrog.php
+   * Bugfix: Undefined variable in table_var_dump() in demo/check.php
+   * Bugfix: QuickTime files now only return information in [audio]
+     or [video] if those exist in the file
+   * Bugfix: WavPack no longer tries to read entire compressed data
+     chunk
+   * Bugfix: Properly handle VBR MP3s with &quot;Info&quot; (rather than
+     &quot;Xing&quot;) header frame. foobar2000 adds this to MP3 files when
+     &quot;Fix MP3 Header&quot; function is used (thanks ah&#216;artemis*dk)
+   * Bugfix: Fraunhofer VBRI headers for MP3s were assuming 2-byte
+     entries for TOC rather than using stride, and were ignoring the
+     scaling value. (thanks sebastian&#216;maresweb*net)
+   Several QuickTime atoms have been added to an exclusion list
+     because they have been observed, but I have no idea what they
+     are supposed to do so I can't add real support for them, but
+     they should not generate warnings (rob&#216;massive-interactive*nl)
+   Old MPC encoder (before v1.06) was return as v0.00, now returned
+     as 'Buschmann v1.7.0-v1.7.9 or Klemm v0.90-v1.05'
+     (thanks ah&#216;artemis*dk)
+   Added check for magic_quotes_runtime and code to disable it if
+     neccesary (thanks stefan*kischkel&#216;t-online*de)
+   Added 3ivx fourCCs to module.audio-video.quicktime.php
+   MP3 and AC3 streams are now parsed when contained inside RIFF-WAV
+     or RIFF-AVI container formats
+   Better detection of named presets in LAME 3.93/3.94
+
+
+1.7.0b3: [October-17-2003] James Heinrich
+   &#187; AC-3 (aka Dolby Digital) is now supported.
+     New file: /getid3/module.audio.ac3.php
+   * Bugfix: ID3v2-writing function Unsynchronise() was broken, which
+     made ID3v2 tag containing binary data (typically pictures) get
+     corrupted. (thanks t*coombes&#216;bendigo*vic*gov*au,
+     i*kuehlborn&#216;ndh*net, mike&#216;delusion*org, mike&#216;ftl*com)
+   * Bugfix: Zip comments now returned as array instead of string,
+     as they're supposed to be.
+   * Bugfix: Quicktime/MP4 files may have reported extremely low
+     bitrates (thanks spunk&#216;dasspunk*com)
+   Improved double-ID3v1 check to prevent false detection when string
+     &quot;TAG&quot; is present in APE or Lyrics3
+   Fixed /demo/simple.php
+   Fixed /demo/joinmp3.php
+   Fixed /demo/mimeonly.php
+   Fixed /demo/write.php
+
+
+1.7.0b2: [October-15-2003] James Heinrich
+   &#187; TTA Lossless Audio Compressor format now supported.
+     (<A HREF="http://tta.iszf.irk.ru">http://tta.iszf.irk.ru</A>)
+     New file: /getid3/module.graphic.tta.php
+   &#187; PhotoCD (PCD) format now supported. Image data for the three
+     lowest resolutions (192x128, 384x256, 768x512) can be optionally
+     extracted.
+     New file: /getid3/module.graphic.pcd.php
+   &#164; RIFF-MP3 files now should return the same ['md5_data'] as the
+     identical MP3 file outside the RIFF container
+   &#164; Name of LAME preset used (if available, needs LAME v3.90+)
+     returned in ['mpeg']['audio']['LAME']['preset_used'] and also as
+     part of ['audio']['encoder_options']
+   &#164; VQF module now sets ['audio']['encoder_options'] to i.e. CBR96
+   &#164; MP3 module now sets ['audio']['encoder_options'] on CBR files
+     and all LAME-encoded files
+   &#164; MPC module now sets ['audio']['encoder_options']
+   &#164; Monkey module now sets ['audio']['encoder_options']
+   &#164; AAC module now sets ['audio']['encoder_options'] to profile name
+   &#164; ASF module now sets ['audio']['encoder_options']
+   &#164; Ogg module adds ['audio']['encoder_options'] -b 128 on
+     Ogg Vorbis 1.0+ ABR files
+   &#164; Ogg module adds ['audio']['encoder_options'] -q N   on
+     Ogg Vorbis 1.0+ VBR files 44k/48k sample rate/stereo files only.
+   &#164; Ogg module ['audio']['encoder_options'] &quot;Nominal birate: 80k&quot; to
+     other Ogg Vorbis files.
+   &#164; ID3v2 track number now returned as string (with leading zeros,
+     if present in data) rather than integer (thanks Plamen)
+   &#164; ASF module returns ['asf']['comments']['encoding_time_unix'] if
+     available (from WM/EncodingTime)
+   &#164; Fixed /demo/mysql.php and added some new features:
+     - encoder options
+     - ID3v2 &quot;Encoded By&quot;
+     - non-empty comments
+     - total entries in database summary (totals &amp; averages)
+     - database version update
+   * Bugfix: 'UNICODE' iconv() charset changed to 'UTF-16LE' or
+     'UTF-16BE' as appropriate
+   * Bugfix: iconv_fallback() function created in case iconv() fails
+   * Bugfix: fixed MD5 calls in demo/check.php
+   * Bugfix: reenabled detection of APE + Lyrics3 tags in same file
+   * Bugfix: ASF module now returns ID3v1 genre as string instead of
+     number - patch from Eugene Toder.
+   * Bugfix: ASF module now reads non-standard field names,
+     i.e. &quot;date&quot; as well as WM/Year - patch from Eugene Toder.
+   * Bugfix: ASF module now returns genre as-is if it is not a
+     standard ID3v1 genre (thanks wonderboy)
+   * Bugfix: Eliminated false-synch problem in MP3 module
+   * Bugfix: Fixed missing root ['bitrate'] for most formats
+   * Bugfix: ['audio']['compression_ration'] missing for MPC
+     (thanks WaldoMonster)
+   * Bugfix: NSV module died in 1.7.0b1
+   * Bugfix: ASF module died in 1.7.0b1 when WM/Picture preset
+   * Bugfix: ASF tracknumber incorrect when specified by WM/Track
+     rather than WM/TrackNumber (thanks jgriffiniii&#216;hotmail*com)
+   * Bugfix: MPEG audio+video playtime should now be pretty accurate
+     (ie within 0.1% variation at most)
+     (thanks mgrimm&#216;healthtvchannel*org)
+   * Bugfix: ID3v2 not being copied to ['tags'] in some cases
+   * Bugfix: LAME CBR files with Info tag were being incorrectly
+     flagged as VBR (thanks Jojo)
+   * Bugfix: LAME tag not being detected for LAME 3.90 (original)
+   Changed regex pattern match for MP3 to include 3rd byte for more
+     reliable/accurate pattern matching
+   Added duplicate-ID3v1 tag checking (two ID3v1 tags, one after the
+     other) that has been known to occur with iTunes
+     (thanks towb&#216;tiscali*de)
+   Added instructions for enabling iconv() support under Windows
+   Removed some unneccesary debugging code
+   Suppressed duplicate PHP warnings for missing include files
+   Included some missing dependencies in various files
+   /demo/audioinfo.class.php now copies ['audio']['encoder_options']
+
+
+1.7.0b1: [2003-09-28] Allan Hansen
+   This beta version was not made by James Heinrich. It was made by
+   Allan Hansen &lt;ah&#216;artemis*dk&gt; - please send bug reports on this
+   beta directly to me.
+
+   James Heinrich will release 1.7.0 final, but it may take some time
+   to work out the bugs from the major rewrite.
+
+   This version could be called getID3lite. It makes a lot of checks
+   optional and makes it easy to remove support for undesired formats
+
+   It also is more library-like. Older versions of getID3() declared
+   an incredible amount of global scope functions and defined several
+   constants. 1.7.0beta1 still declares constants, but they are all
+   prepended by GETID3_. It declares no global scope functions - they
+   are all wrapped into classes.
+
+   &#187; Made getID3() depend on iconv library: compile PHP --with-iconv
+   &#187; Created new directory structure
+       Moved all demos to demos/
+       Moved all getID3() files to getid3/
+       Renamed most files to module.something
+       Changed header in all module.something to explain what they do
+       Simply remove all modules you don't need
+       Wrapped all modules into classes
+   * Bugfix: Implemented misc patches from Eugene Toder
+   * Bugfix: Implemented misc patches from &quot;six&quot;
+   &#164; Added root key 'encoding'
+   &#164; Added prefix GETID3_ to all defined constants.
+   &#164; Wrapped getid3.php into getid3 class
+   &#164; Wrapped getid3.functions.php into getid3_lib class
+       Removed unused functions
+       Moved several functions away from getid3.functions.php and
+         into the files where they are actually used.
+       Renamed getid3.functions.php to getid3.lib.php
+       Moved getid3.rgad.php functions into getid3_lib
+       Moved getid3.getimagesize.php funcitons ingo getid3_lib
+   &#164; Moved getid3.ogginfo.php into ogg module
+   &#164; Combined GetTagOnly() and GetAllFileInfo() in method analyze
+   &#164; Removed redundant and unuseful root keys
+       'file_modified_time' == filemtime($filename)
+       'md5_file' == md5_file($filename)
+       'exist' == file_exists($filename)
+   &#164; Changed root key ['tags'] from array of string to array of array
+     of comments.
+   Simplified code for detecting base path.
+   Removed ob_ from InitializeFilepointerArray(). That was really a
+     ugly HACK to get output from fopen. If user want the reason,
+     he should open the file himself!
+   Checking for APE tags before lyrics3 - makes Lyrics3 not depend
+     on APE tag. It seems to work on my test file.
+   Changed ['error'] and ['warning'] in multiple files to append to
+     array instead of appending to string. That simplified code in
+     getid3.php too.
+   Simplified clean-up procedure: simply remove all empty root keys
+   Setting tags in individual modules instead of main getid3.php
+   Made Bonk and ASF modules non-dependent on id3 modules - id3
+     optional.
+   Rewrote HandleAllTags() - simplified and convert comments to
+     desired encoding.
+   Replaced all calls to RoughTranslateUnicodeToASCII() in ASF module
+     with a TrimConvert() method. This uses iconv() for conversion.
+     It also converts from UNICODE instead of UTF-16BE, as the spec
+     says it should.
+   Replaced all calls to RoughTranslateUnicodeToASCII() in id3v2
+     module with iconv(). id3v2 module also reads
+     $ThisFileInfo['encoding'] and converts all comments to this
+     format. All other formats just add their comments in their
+     native charset, but every comment field in id3v2 can have a
+     different encoding, so this is needed.
+   Did same thing as above with ISO module. However - it does not
+     work. I need to find out how to specify big-endian unicode !=
+     UNICODING encoding name given to iconv().
+   Built-in assume mp3 format in getid3.php
+   Temporarily nuked root key ['comments'] and CopyCommentsToRoot()
+   Updated demo/audioinfo.class.php
+   Updated demo/check.php - some thing don't work!
+   Other demos are out of order!
+
+
+1.6.5: [October-06-2003] James Heinrich
+   &#187; Added support for LiteWave (thanks support&#216;clearjump*com)
+   &#216; Split out speedup info from ['OFR']['OFR']['compression'] into
+     ['OFR']['OFR']['speedup']
+   &#216; If EXIF functions for JPEG not available, now warning not error
+   &#216; ID3v2 track number now returned as string (with leading zeros,
+     if present in data) rather than integer (thanks Plamen)
+   * Bugfix: now correctly parses cbSize element of WAVEFORMATEX
+     structure (thanks support&#216;clearjump*com)
+   * Bugfix: ASF module now reads non-standard field names,
+     i.e. &quot;date&quot; as well as WM/Year - patch from Eugene Toder.
+   * Bugfix: ASF module now returns genre as-is if it is not a
+     standard ID3v1 genre (thanks wonderboy)
+   * Bugfix: ['audio']['compression_ration'] missing for MPC
+     (thanks WaldoMonster)
+   Prevent infinite loop in MP3 histogram if framelength == 0
+   Added wFormatTag values 0x00FF and 0x2001 - 0x2005
+     (thanks steve&#216;headbands*com)
+   Added &quot;twos&quot; and &quot;sowt&quot; FourCCs for Mac AIFC
+
+
+1.6.4: [June-30-2003] James Heinrich
+   &#187; Added support for free-format MP3s
+     (thanks Sebastian Mares for the idea)
+   &#187; Compressed (Flash 6+) SWF files are now handled properly
+     (thanks alan*cheung&#216;alumni*ust*hk)
+   &#187; Added DeleteLyrics3() to getid3.lyrics3.php
+   &#187; Added FixID3v1Padding() to getid3.putid3.php
+   &#187; Added new simple MP3-splicing sample file
+     (thanks tommybob&#216;mailandnews*com for the idea)
+     New file: getid3.demo.joinmp3.php
+   &#187; Moved all contents of getid3.putid3.php into either
+     getid3.id3v1.php or getid3.id3v2.php or getid3.functions.php as
+     appropriate
+     Removed file: getid3.putid3.php
+   &#164; ['error'] and ['warning'] keys now return as arrays, not strings
+   &#164; New root key for all files: ['file_modified_time'] (UNIX time)
+   &#164; getid3.demo.scandir.php renamed to getid3.demo.mysql.php
+   &#164; New demo file returns the MIME type only for a single file
+     (thanks admin&#216;e-tones*co*uk for the idea)
+     New file: getid3.demo.mimeonly.php
+   &#164; Added check for valid ID3v1 padding (strings should be padded
+     with null characters but some taggers incorrectly use spaces).
+     A warning will be generated if padding is invalid. New boolean
+     key ['id3v1']['padding_valid'] indicates padding validity.
+   &#164; CleanUpGetAllMP3info() removes more useless root keys for
+     unknown-format files
+   &#164; Extended LAME information in ['mpeg']['audio']['LAME'] is now
+     only returned for LAME v3.90+
+   &#164; LAME-encoded MP3s now return
+     ['mpeg']['audio']['LAME']['long_version'] as well as
+     ['mpeg']['audio']['LAME']['short_version'] - these are identical
+     in LAME v3.90+ but older versions will report longer more
+     detailed version information if available
+   &#164; New Lyrics3 values: ['lyrics3']['raw']['offset_start'] and
+     ['lyrics3']['raw']['offset_end']
+   &#164; New optional parameter on getAPEtagFilepointer() to scan from a
+     defined offset rather than end-of-file to allow scanning of APE
+     tags before Lyrics3 tags
+   &#164; ['tag_offset_start'] and ['tag_offset_end'] are now present in
+     ['ape'], ['lyrics3'], ['id3v1'] and ['id3v2']
+   &#164; Numerous changes to the returned structure and content for La
+     files, including parsing the seektable (if applicable) and
+     parsing RIFF data occuring after the end of the compressed audio
+     data (notably RIFF comments)
+     (thanks mike&#216;bevin*de)
+   &#164; getSWFHeaderFilepointer() now has optional 3rd parameter
+     $ReturnAllTagData (default == false) which if set to true will
+     return data on all tags in ['swf']['tags']
+   &#164; ['swf']['bgcolor'] now returns the 6-character string
+     representing the background color in HTML hex color format
+     (thanks ubergeek&#216;ubergeek*tv)
+   &#164; ['swf']['header']['frame_delay'] is no longer returned
+   &#164; getQuicktimeHeaderFilepointer() now has two additional optional
+     parameters: $ReturnAtomData (default == true) and
+     $ParseAllPossibleAtoms (default == false). Setting
+     $ReturnAtomData to false will reduce the size of the returned
+     data array by unsetting ['quicktime']['moov'] before returning.
+     Leaving $ParseAllPossibleAtoms as false now suppresses parsing
+     of several atom types that contain very large tables of data
+     that are not typically useful. Atom type suppressed are:
+     stts, stss, stsc, stsz, and stco
+     (thanks ubergeek&#216;ubergeek*tv)
+   &#164; ['fileformat'] no longer set to 'id3' if ID3v1 or ID3v2 tag
+     detected but no other data format recognized
+   * Bugfix: La files now return the correct values for
+     ['avdataoffset'] and ['avdataend'] and therefore the correct
+     values for ['md5_data'] - note that ['md5_data'] values will not
+     match values from previous versions of getID3() - the previous
+     versions were incorrect
+     (thanks mike&#216;bevin*de)
+   * Bugfix: A temporary file was being created in the web server's
+     root directory (not DocumentRoot) each time ['md5_data'] was
+     calculated, and not removed due to lack of permissions. Temp
+     file is now created (as it was supposed to be) in the directory
+     of the file being examined, or the system temp directory, and
+     properly removed when done.
+   * Bugfix: Several incorrect values were being returned inside
+     ['mpeg']['audio']['LAME'] (thanks bouvigne&#216;mp3-tech*org)
+   * Bugfix: SWF frame rates values were usually incorrect.
+     (thanks alan.cheung&#216;alumni*ust*hk and ubergeek&#216;ubergeek*tv)
+   * Bugfix: ID3v2.2 files always flagged 4 bytes of invalid padding
+     (thanks marca&#216;mac*com)
+   * Bugfix: Lyrics3 without ID3v1 was not working properly
+   * Bugfix: Lyrics3, APE &amp; ID3v1 can all now exist in the same file.
+     A warning is issued if APE comes after Lyrics3 (because Lyrics3-
+     aware taggers probably are not APE-aware and therefore won't be
+     able to find the Lyrics3 tag)  (thanks mp3gain&#216;hotmail*com)
+   * Bugfix: WriteAPEtag() now writes the APE tag before any Lyrics3
+     tags (if present) and removes any incorrect ones that are after
+     existing Lyrics3 tags  (thanks mp3gain&#216;hotmail*com)
+   * Bugfix: RIFF-WAVE file with incorrect NumberOfSamples values in
+     the 'fact' chunk no longer cause incorrect playtime calculation
+     (thanks stprasad&#216;indusnetworks*com)
+   * Bugfix: getid3.demo.simple.php had undefined variables if the
+     file needed to be deep-scanned with assumeFormat
+   * Bugfix: fixed previously-incorrect ['avdataend'] values for APE
+     and Lyrics3 tags in some cases, which in some cases means that
+     ['md5_data'] is different than previously (now correct)
+   Much-improved detection of AAC-ADTS, which also means MP3
+     format detection should now be nearly twice as fast
+   Truncated AVIs and WAVs are now reported
+   Number of new features and bugfixes in getid3.demo.mysql.php
+   Quicktime 'meta' atoms now parsed, so Quicktime MP4 files can now
+     return artist, title, album, etc  (thanks spunk&#216;dasspunk*com)
+   Consolidated all comments processing functions (processing the
+     ['comments'] and ['tags'] keys) into HandleAllTags() which now
+     also checks to ensure that APE tags are really better than ID3v2
+     before using them in ['comments']
+   Known issue with Meracl ID3 Tag Writer v1.3.4 truncating last byte
+     of MP3 file when appending new ID3v1 tag now specifically noted
+     (rather than generic Probably Truncated File message)
+   getid3.demo.mysql.php now stores last-modified time for each file
+   getid3.demo.mysql.php is now case-sensitive for filenames
+   getid3.demo.mysql.php can generate M3U playlists of any of the
+     groups of files it can select (duplicate filenames, tag types,
+     etc.)
+   getid3.demo.mysql.php can now find mismatched tag contents and
+     filenames
+   getid3.demo.check.php now shows total number of errors &amp; warnings
+   GetFileFormatArray() now matches actual patterns for MP3 files
+     based on the first two bytes of the file, rather than just the
+     first one
+   Simplified DeleteAPEtag() and made it work properly with Lyrics3
+
+
+1.6.3: [May-17-2003] James Heinrich
+   &#187; Added support for Bonk  (thanks ah&#216;artemis*dk)
+     New file: getid3.bonk.php
+   &#187; Added support for AVR  (thanks ah&#216;artemis*dk)
+     New file: getid3.avr.php
+   &#164; Contents of getid3.id3.php moved to getid3.id3v1.php
+     Removed file: getid3.id3.php
+   &#164; Contents of getid3.frames.php moved to getid3.id3v2.php
+     Removed file: getid3.frames.php
+   &#164; Returned data structure documentation improved and updated and
+     now stored in getid3.structure.txt rather than getid3.readme.txt
+     New file: getid3.structure.txt
+   &#164; Now including the GNU General Public License in the distribution
+     as getid3.license.txt
+     New file: getid3.license.txt
+   &#164; Added new, optional, parameter to WriteAPEtag() (and also
+     GenerateAPEtag()) which must be set to TRUE if the values you
+     are passing are already UTF8-encoded, otherwise all data is
+     encoded to UTF8 by default. For all ASCII/ANSI data this value
+     should be left at the defaul value of FALSE.
+   &#164; Added third, optional, parameter to getID3v2Filepointer() -
+     $StartingOffset (default == 0) which can parse an ID3v2 tag
+     in a file at a position other than the start-of-file.
+   &#164; ['video']['pixel_aspect_ratio'] now returned when known
+   &#164; AVI files with WMA audio now return ['audio']['dataformat']
+     of 'wma' rather than 'wav'
+   &#164; ASF-WMA files now return the artist value from WM/AlbumArtist
+     in ['comments']['artist']  (thanks msibbald&#216;saebauld*com)
+   &#164; ASF-WMA files now return the 'author' value from
+     ['asf']['content_description'] in ['comments']['artist']
+     instead of ['comments']['author']
+   &#164; ASF-WMA files now return the 'description' value from
+     ['asf']['content_description'] in ['comments']['comment']
+     instead of ['comments']['description']
+   * Bugfix: APE tag writing with multiple values for a tag (more
+     than one ARTIST for example) was not being correctly written
+     (thanks ah&#216;artemis*dk)
+   * Bugfix: CreateDeepArray() was returning an empty-string key as
+     the top-level returned value - ['iso']['files'] now directly
+     contains the file listing without an empty array in between.
+   * Bugfix: ID3v2 genreid was not being returned in some cases.
+   * Bugfix: APEv1 tags would generate error messages
+   * Bugfix: APE tags would sometimes show phantom second entry for
+     each item (title, artist, etc) with no data
+   * Bugfix: APE tag writing was not UTF8-encoding the data -
+     non-ASCII characters (above chr(127)) were being incorrectly
+     stored  (thanks ah&#216;artemis*dk)
+   * Bugfix: getid3.demo.scandir.php had undefined function error
+   * Bugfix: getid3.demo.scandir.php would not display list of files
+     with no tags
+   Added link to getid3.demo.check.php from list of specific-tags
+     files in getid3.demo.scandir.php
+
+
+1.6.2: [May-04-2003] James Heinrich
+   &#187; New official mirror site for getID3() - <A HREF="http://www.getid3.org">http://www.getid3.org</A>
+   &#187; Added basic support for SWF (Flash)  (thanks n8n8&#216;yahoo*com)
+     New file: getid3.swf.php
+   &#187; Added experimental support for parsing the audio portion of
+     MPEG-video files. I don't have any actual documentation for
+     this, so this part is experimental and not guaranteed accurate,
+     but it seems to be working OK as far as I have been able to test
+     it. Bug reports (or even better - documentation!) are welcome at
+     <A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>
+   &#187; Added new simple directory-scanning sample file
+     New file: getid3.demo.simple.php
+   &#187; getid3.demo.write.php now writes APE tags as well.
+   &#164; Renamed getid3.write.php to getid3.demo.write.php
+   &#164; Renamed audioinfo.class.php to getid3.demo.audioinfo.class.php
+   &#164; getid3.php now automatically includes the getid3.functions.php
+     function library file, no need to include it seperately.
+   &#164; getLyrics3Filepointer() has been changed to be consistant with
+     all the other similar function structures - the parameters have
+     changed. The old function has been renamed to getLyrics3Data()
+   &#164; Added DeleteAPEtag() function to getid3.ape.php
+   &#164; HandleID3v1Tag() now only handles ID3v1. Lyrics3 processing is
+     now done by HandleLyrics3Tag()
+   &#164; If BitrateHistogram is enabled in getOnlyMPEGaudioInfo() it now
+     also returns ['mpeg']['audio']['version_distribution'] showing
+     the number of frames of each MPEG version (1, 2 or 2.5) - all
+     frames *should* be of the same MPEG version
+   &#164; getID3v1Filepointer() always returns TRUE now, even if it didn't
+     find a valid ID3v1 tag
+   &#164; getOnlyMPEGaudioInfo() now looks for MPEG sync in the first 128k
+     bytes rather than the first 64k bytes
+   &#164; Added dummy function GetAllMP3info() to generate warning not to
+     use that deprecated function.
+   &#164; ['video']['codec'] is now 'MPEG' for all MPEG video files (this
+     will change to 'MPEG-1' or 'MPEG-2' as soon as I figure out how
+     to determine that)  (thanks jigal&#216;spill*nl)
+   &#164; ['mpeg']['audio']['LAME']['mp3_gain'] renamed to
+     ['mpeg']['audio']['LAME']['mp3_gain_db'] (gain in dB)
+   &#164; Added ['mpeg']['audio']['LAME']['mp3_gain_factor'] (gain as a
+     multiplication factor)
+   &#164; Added support for Preset and Surround Info bytes from LAME VBR
+     tag (<A HREF="http://gabriel.mp3-tech.org/mp3infotag.html">http://gabriel.mp3-tech.org/mp3infotag.html</A>)
+   * Bugfix: APE tag writing would put the string 'Array' for all
+     values rather than the actual data  (thanks ah&#216;artemis*dk)
+   * Bugfix: Warning now generated for VBR MPEG-video files because
+     getID3() cannot determine average bitrate. If you know of
+     documentation that would tell me how to do this, please email
+     <A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>
+   * Bugfix: Replay Gain values from Vorbis comments are now
+     returned in ['replay_gain'] (and not in ['comments'])
+     (thanks ah&#216;artemis*dk)
+   * Bugfix: Replay Gain values from APE comments are now correctly
+     returned in ['replay_gain']  (thanks ah&#216;artemis*dk)
+   * Bugfix: getid3.demo.check.php is now case-insensitive when
+     assuming a format for a corrupted file if standard detection
+     does not identify the file type.
+   * Bugfix: RIFF comments were overwriting/suppressing ID3 comments
+     for RIFF-MP3 files  (thanks wm&#216;wofuer*com)
+   * Bugfix: RIFF-MP3 files with 'RMP3' chunks instead of 'WAVE' were
+     not being correctly identified.
+   * Bugfix: ID3v2 padding shorter than the length of an ID3v2 frame
+     header was not correctly detected
+   * Bugfix: getid3.demo.check.php now does in-depth scanning for MP2
+     and MP1 files the same as for MP3 files based on file extension
+     if a MPEG-audio structure isn't found immediately at the start
+     of the file
+   * Bugfix: removed condition where RIFF-WAV was being scanned for
+     MPEG-audio signature when it shouldn't be present (non-MP3 WAV)
+   * Bugfix: ASF files were not always showing correct audio datatype
+   * Bugfix: array_merge_clobber() and array_merge_noclobber() were
+     not being conditionally defined in getid3.functions.php
+     (thanks rich.martin&#216;reden-anders*com)
+   * Bugfix: stream_numbers was not being correctly returned in
+     bitrate_mutual_exclusion_object chunks of ASF files
+   * Bugfix: Added support for 24kHz and 12kHz audio in ASF files
+   * Bugfix: Removed possible undefined offset error in MP3s where
+     cannot find synch before end of file
+   * Bugfix: Removed potential out-of-memory crash situation when
+     parsing Real files with chunks larger than the available memory
+     (thanks jigal&#216;spill*nl)
+   * Bugfix: ID3v1 was incorrectly taking precedence over ID3v2 in
+     the ['comments'] array (thanks lionelfl&#216;wanadoo*fr)
+   * Bugfix: No longer calculates overall bitrate and playtime for
+     VBR MPEG video files based on the audio bitrate.
+   * Bugfix: AssumeFormat was not working properly
+   Added summary footer line to getid3.demo.check.php
+   Added '.mpeg' to the list of assume-format-from-filenames list in
+     getid3.demo.check.php
+   MPEG-video files now more reliably detected
+   A number of additional features have been added to
+     getid3.demo.scandir.php
+   Added many RIFF-AVI audio types and fourcc video types to the
+     lookup functions in getid3.riff.php
+   Now identifes files with Lyrics3 v1 tags that are of incorrect
+     length (v1 Lyrics3 is supposed to be 5100 bytes long, but
+     [unknown program] writes variable-length tags (which is illegal
+     for Lyrics3 v1)). getID3() now correctly parses these tags and
+     issues a warning.
+   Split GetFileFormat() to GetFileFormat() and GetFileFormatArray()
+   HTML colors in getid3.demo.check.php are now defined as constant
+     variables at the top of the file (if you want to change them)
+   Added support for OptimFROG v4.50x (non-alpha) (new header fields)
+     (thanks floringhido&#216;yahoo*com)
+   Added support for Lossless Audio v0.4 (thanks mike&#216;bevin*de)
+
+
+1.6.1: [March-03-2003] James Heinrich
+   &#187; Added support for writing APE v2.
+     WriteAPEtag() in getid3.ape.php
+     NOTE: APE v1 writing support will *not* be added to future
+     versions of getID3()
+     (thanks ah&#216;artemis*dk and adam&#216;physco*com for the idea)
+   &#187; Added support for AIFF (Audio Interchange File Format) including
+     AIFF, AIFC and 8SVX  (thanks ah&#216;artemis*dk for the idea)
+     Removed file: getid3.aiff.php
+   &#187; Added support for OptimFROG (v4.50a and v4.2x)
+     (thanks ah&#216;artemis*dk for the idea)
+     New file: getid3.optimfrog.php
+   &#187; Added support for WavPack  (thanks ah&#216;artemis*dk for the idea)
+   &#187; Added support for LPAC  (thanks ah&#216;artemis*dk for the idea)
+   &#187; Added support for NeXT/Sun .au format
+     New file: getid3.au.php
+   &#187; Added support for Creative SoundBlaster VOC format
+     New file: getid3.voc.php
+   &#187; Added support for the BWF (Broadcast Wave File) RIFF chunks
+     &quot;bext&quot; and &quot;MEXT&quot;  (thanks Ryan and njh&#216;surgeradio*co*uk)
+   &#187; Added support for the CART (Broadcast Wave File) RIFF chunks
+     (thanks Ryan)
+   &#187; Added getid3.demo.scandir.php - a sample recursive scanning demo
+     that scans every file in a given directory, and all sub-
+     directories, and stores the resulting data in MySQL database,
+     and then displays a list of duplicate files based on md5_data
+   &#164; ['md5_data_source'] now contains the MD5 value for the original
+     uncompressed data for formats that store that information
+     (currently only FLAC v0.5+). ['md5_data'] (if chosen to be
+     calculated) will contain the calculated MD5 value for the
+     compressed file. To check if 2 files are identical in every way,
+     including all comments: compare ['md5_file']. To check if two
+     files were compressed from the same source file: compare
+     ['md5_data_source']. To check if the compressed audio/video data
+     of two files is identical, even if comments or even the
+     container file format is different (MP3 in RIFF container,
+     FLAC in Ogg container, etc): compare ['md5_data'].
+   &#164; ['md5_data'] for 8-bit WAV files is now calculated based on a
+     converted version of the data from unsigned to signed (MSB
+     inverted) to match the MD5 value calculated by FLAC
+   &#164; New optional parameter added to GetAllFileInfo() -
+     $MD5dataIfMD5SourceKnown (default: false). If false the md5_data
+     value will NOT be calculated for files (such as FLAC) that have
+     ['md5_data_source'] set, even if $MD5data == true.
+     (thanks ah&#216;artemis*dk)
+   &#164; getid3.check.php renamed to getid3.demo.check.php
+   &#164; Added GetTagOnly() function to getid3.php - similar to
+     GetAllFileInfo() except only takes a filename as a parameter and
+     only returns ID3v2, APE, Lyrics3 and ID3v1 tag information - no
+     attempt is made to parse the data contents of the file at all.
+     (thanks Phil for the idea)
+   &#164; Added ['audio']['lossless'] and ['video']['lossless'] for all
+     formats (when known). Both are boolean values - true means the
+     data is lossless-compressed, false means the data is lossy-
+     compressed.
+   &#164; Added ['audio']['compression_ratio'] and/or
+     ['video']['compression_ratio'] for all formats. Returns a number
+     (usually) less than 1, where 1 represents no compression and 0.5
+     represents a compressed file half the size of the original file
+   &#164; Added ['video']['bits_per_sample'] to all video formats (when
+     known)
+   &#164; Added ['video']['frame_rate'] to all video formats (when known)
+   &#164; ['fileformat'] set to 'mp1' or 'mp2' instead of 'mp3' when
+     ['audio']['dataformat'] is one of those  (thanks ah&#216;artemis*dk)
+   &#164; Added 4th parameter to md5_data(), $invertsign, which will invert
+     the MSB of each byte before MD5'ing. This is needed for 8-bit
+     WAV files because FLAC calculates the stored MD5 value on
+     signed data rather than the original byte values. ['md5_data']
+     of an 8-bit WAV will now match the ['md5_data_source'] value
+     (thanks lichvarm&#216;phoenix*inf*upol*cz)
+   &#164; ['ape']['items']['data'] and ['ape']['items']['data_ascii'] now
+     contains an array of values, if the tag contains UTF-8 text (as
+     opposed to binary data)
+   &#164; ['mpeg']['audio']['bitratemode'] renamed to
+     ['mpeg']['audio']['bitrate_mode']
+   * Bugfix: Removed potential bug that could replace all MP3 file
+     contents with only the new ID3v2 tag in getid3.putid3.php
+   * Bugfix: md5_data values calculated for RIFF (WAV, AVI) files
+     were incorrect  (thanks ah&#216;artemis*dk)
+   * Bugfix: MP3 data in an MP4 wrapper fileformat could not identify
+     bitrate  (thanks ah&#216;artemis*dk)
+   * Bugfix: ['audio'] and/or ['video'] keys would sometimes get
+     removed even if not empty
+   * Bugfix: Prevented creation of null entries in
+     ['RIFF']['WAVE']['INFO'] if a comment entry was not present
+   * Bugfix: Potential infinite-loop condition in getid3.ogg.php
+     (thanks afshin.behnia&#216;sbcglobal*net)
+   * Bugfix: Ogg files with illegal ID3v1 (and/or APE or Lyrics3)
+     tags were not finding the last Ogg page
+     (thanks afshin.behnia&#216;sbcglobal*net)
+   * Bugfix: replay-gain values not properly set from LAME tag
+   * Bugfix: RIFF-MP3 had incorrect md5_data
+   * Bugfix: the LAME DLL CBR problem of not re-writing the LAME
+     frame at the beginning of the data is now detected for MP3s
+     with ID3v2 tags as well
+   * Bugfix: APE tags with multiple values (ie multiple entries in
+     the &quot;artist&quot; tag) are now shown properly in ['ape']['items']
+   * Bugfix: fixed condition where APE tag with no ID3v1 tag could be
+     mistaken for APE tag with ID3v1 (and incorrectly parsed)
+   * Bugfix: added warning if ID3v2 frame has zero-length data
+     (thanks cmasset&#216;clubinternet*fr)
+   * Bugfix: getid3.frames.php looking for non-existant key in USER
+     frames
+   Improved detection of RIFF-MP3 data. [unknown program] encodes
+     RIFF-WAV data with a chunk name of 'RMP3' instead of the
+     standard 'RIFF'
+   Encoder now returned in both ['comments'] and ['audio']['encoder']
+     for RIFF-WAV files with an INFO.ISFT chunk
+   Generate a warning for FLAC files encoded with v0.3 or v0.4
+     because audio_signature is not calculated during encoding
+     (thanks ah&#216;artemis*dk)
+   Modified getid3.check.php to display md5_data_source as well as
+     md5_file and md5_data if display-MD5 mode is selected
+   Modified getid3.check.php to assume-format based on file extension
+     in browse mode if fileformat is found to be 'id3' (formerly only
+     if the fileformat was null)
+   Changed scaling of BitrateColor() from representing 1-256kbps to
+     representing 1-768kbps for better display of high-bitrate files,
+     specifically lossless-compressed CD-audio (FLAC, LA, etc)
+
+
+1.6.0: [January-30-2003] James Heinrich
+   &#187; Added support for OggFLAC (FLAC data stored in an Ogg container)
+     (thanks ah&#216;artemis*dk for the idea)
+   &#187; Added support for Speex (the data stored in an Ogg container)
+   &#187; Comments are now available in the root 2-dimensional array
+     ['comments'] - each entry in this array will contain one or more
+     strings. For example, if there are two artists then
+     ['comments']['artist'][0] will contain the first one and
+     ['comments']['artist'][1] the other. All keys are forced
+     lowercase. Comments will be stored in the ['comments'] array in
+     this order of precedence:
+     1) Native format tags (ASF, VQF, NSV, RIFF, Quicktime, Vorbis)
+     2) APE tags
+     3) ID3v2
+     4) Lyrics3
+     5) ID3v1
+     Lower-priority tags will not overwrite or append existing values
+     of higher-priority tags (for example, 'artist' in ID3v1 will be
+     ignored if already specified in APE), but missing values will be
+     filled in (for example, if 'album' is specified in ID3v2 but not
+     in APE, it will be included in the ['comments'] array).
+     Note: Root keys (['title'], ['artist'], etc) are NOT available
+     in this or future versions of getID3().
+     (thanks ah&#216;artemis*dk)
+   &#187; MD5 hashes are now available for all formats for both the entire
+     file (['md5_file']) and the portion of the file containing only
+     the audio/video data, stripped of all prepended/appended tags
+     like ID3v2, ID3v1, APE, etc - ['md5_data']
+     (thanks ah&#216;artemis*dk for alternate md5_file() function that
+     runs on UNIX system running PHP &lt; 4.2.0)
+     NOTE: Ogg files require the use of vorbiscomment to obtain the
+     md5_data value. vorbiscomment must be downloaded from
+     <A HREF="http://www.vorbis.com/download.psp">http://www.vorbis.com/download.psp</A> and placed in the getID3()
+     directory. All Ogg formats (Vorbis, OggFLAC, Speex) are affected
+     by this problem, but only OggVorbis files can be processed with
+     vorbiscomment. OggFLAC and Speex files will be processed by
+     getID3(), but this may result in an incorrect value for md5_data
+     in the event that VorbisComments are larger than 1 page (4-8kB).
+     NOTE: md5_data for Ogg will not work if PHP is running in Safe
+     Mode
+   &#187; There is now a wrapper class available, written by Allan Hansen,
+     which should simplify extracting most common basic information
+     (such as format, bitrate, comments).
+     New file: audioinfo.class.php
+   &#187; OggWrite() in getid3.ogginfo.php has been replaced with a new
+     version that uses vorbiscomment to write the comments, because
+     of a reported bug that can corrupt OggVorbis files such they
+     cannot be played.
+     NOTE: Ogg comment writing now requires the use of vorbiscomment
+     which must be downloaded from <A HREF="http://www.vorbis.com/download.psp">http://www.vorbis.com/download.psp</A>
+     and placed in the getID3() directory.
+     NOTE: Ogg comment writing will not work if PHP is running in
+     Safe Mode
+   &#164; New root key ['tags'] is now always returned for all formats.
+     It is an array that may contain any of:
+     * Native format tags: 'vqf', 'riff', 'vorbiscomment', 'asf',
+       'nsv', 'real', 'midi', 'zip', 'quicktime'
+     * Appended data tags:  'ape', 'lyrics3', 'id3v2', 'id3v1'
+   &#164; New root key ['audio'] is an array containing any or all of:
+       codec, channels, channelmode, bitrate, bits_per_sample,
+       dataformat, bitrate_mode, sample_rate, encoder
+       Note: This replaces several root keys, including:
+         bitrate_audio, bits_per_sample, frequency, channels
+   &#164; New root key ['video'] is an array containing any or all of:
+       bitrate_mode, bitrate, codec, resolution_x,  resolution_y,
+       resolution_y, frame_rate, encoder
+       Note: This replaces several root keys, including:
+         bitrate_video, resolution_x, resolution_y, frame_rate
+   &#164; ['id3']['id3v1'] has moved to ['id3v1']
+   &#164; ['id3']['id3v2'] has moved to ['id3v2']
+   &#164; ['audiodataoffset'] and ['audiodataend'] have been renamed to
+     ['avdataoffset'] and ['avdataend'] respectively
+   &#164; GetAllMP3info() has been changed to GetAllFileInfo() with a
+     different parameter list ($allowedFormats is no longer a
+     parameter).  Check your code where you're calling
+     GetAllMP3Info() - you will need to change both the function
+     name and the parameter list if you pass more than 2 parameters
+   &#164; All formats now return ['audio']['dataformat'] and/or
+     ['video']['dataformat'] where appropriate - this goes along with
+     ['fileformat'] - ['fileformat'] will return the actual structure
+     of the file, whereas ['dataformat'] will return the format of
+     the data inside that structure. For example, an Ogg file can
+     contain Vobis data (normal), or it can contain FLAC data in the
+     Ogg container format. In that case, ['fileformat'] would be
+     'ogg', but ['dataformat'] would be 'flac'.
+     Note: this means that WAV and AVI files now return a
+     ['fileformat'] of 'riff' rather than 'wav' or 'avi'.
+   &#164; ['filesize'] is no longer returned for files larger than 2GB
+     because PHP does not support large file access. Attempting to
+     parse a file larger than 2GB will result in a message stored in
+     ['error'] and ['filesize'] not set.
+   &#164; APEtag, ID3v1, and ID3v2 are now supported on ALL multimedia
+     files - even if illegal by format. Ogg will return warning if
+     ID3/APE tags are present.  (thanks ah&#216;artemis*dk)
+   &#164; All files: non-critical errors are now returned in the root key
+     ['warning'] rather than ['error'] (only critical errors that
+     prevent getID3() from correctly parsing the file are returned in
+     ['error']  (thanks ah&#216;artemis*dk)
+   &#164; Renamed all references to $MP3fileInfo to $ThisFileInfo
+   &#164; Joliet now supported for ISO-9660.
+     ['iso']['supplementary_volume_descriptor'] is now returned, if
+     available, and ['iso']['files'] will contain ASCII equivalents
+     of the Unicode directory structure &amp; filenames stored.
+   &#164; Moved Monkey's Audio code from getid3.ape.php to seperate file.
+     New file: getid3.monkey.php
+   &#164; Added new keys for ISO-9660: ['name_ascii'] for directories,
+     ['file_identifier_ascii'] for files
+   &#164; Added root key ['track'] for CD-audio files
+   &#164; Ogg/Vorbis-comment files now have comments returned inside
+     ['ogg']['comments_common'] as an array of strings, rather than
+     simple strings in ['ogg']
+   &#164; Quicktime files now have comments returned inside
+     ['quicktime']['comments'] as an array of strings, rather than
+     simple strings in ['quicktime']
+   &#164; ['mime_type'] is a new root key returned for all supported
+     formats (thanks ah&#216;artemis*dk)
+   &#164; ['fileformat'] now returns 'mp1' instead of 'mp3' for MPEG-1
+     layer-I audio files (thanks ah&#216;artemis*dk)
+   &#164; ['mpeg']['audio']['bitratemode'] now returns lowercase
+   &#164; MPEG-4 audio files which consist of MP3 data wrapped in a
+     Quicktime fileformat will now return the usual data in
+     ['mpeg']['audio']
+   &#164; Type-1 DV AVIs are now supported
+   &#164; DV AVIs will return 1 or 2 in ['RIFF']['video'][x]['dv_type']
+   &#164; Changed ['fileformat'] from 'mpg' to 'mpeg' for MPEG video files
+   &#164; ASF comments are now stored in ['asf']['comments'] instead of
+     ['asf']
+   &#164; RealMedia chunk data is now returned inside ['real']['chunks']
+     instead of ['real']
+   &#164; ['replay_gain'] now properly populated from APE tags
+   &#164; Added support for ASF_Old_ASF_Index_Object in ASF files
+     (thanks ah&#216;artemis*dk)
+   &#164; AAC-ADTS files now return ['aac']['bitrate_distribution']
+   &#164; ParseVorbisComments() has been replaced with
+     ParseVorbisCommentsFilepointer() (with different parameters)
+   &#164; All references to any key ['frequency'] are now ['sample_rate']
+   &#164; Moved ID3v2 comments from ['id3v2'] into common root
+     ['comments'] structure, and now returns more values than before
+   * Bugfix: ['iso']['files'] and ['zip']['files'] could potentially
+     contain duplicate entries (in a numeric-indexed array) for files
+     if the directory structure specifies files multiple times.
+     Entries are now guaranteed unique, with the last entry for the
+     file overwriting any former ones.
+   * Bugfix: RIFF parsing had numerous issues, including:
+     - large AVIs would take a very very long time to parse
+     - chunks with odd (not even) sizes would cause the parser fail
+     - video and/or audio codecs not always identified
+     The ParseRIFF() function has been completely rewritten and fixes
+     all known issues with RIFF parsing. Users are, however,
+     encouraged to double-check output of any parsed (AVI/WAV/CDDA)
+     files.
+   * Bugfix: Modified getid3.riff.php to return correct total
+     bitrates for AVIs with multiple audio streams
+   * Bugfix: GetFileFormat() was not creating array structure
+     correctly  (thanks ah&#216;artemis*dk)
+   * Bugfix: LAME tag for MP3s can only specify up to 255kbps, so any
+     files with actual CBR bitrate of &gt;=256 were reported incorrectly
+   * Bugfix: Lyrics3 synched lyrics were not being correctly returned
+   * Bugfix: CreateDeepArray() was broken for non-nested cases, which
+     meant ZIP and ISO ['files'] structures were broken
+   * Bugfix: Incorrect pattern matching for ZIP files meant no zip
+     files were being detected as such
+   * Bugfix: AAC-ADIF was returning an incorrect number of channels
+     (too few) in some cases  (thanks ah&#216;artemis*dk)
+   * Bugfix: Vorbis comments were returning an incorrect value for
+     ['dataoffset'] in some cases
+   * Bugfix: MPEG video ['marker_bit'] and ['vbv_buffer_size'] were
+     incorrect
+   * Bugfix: ['playtime_string'] could potentially have a value of
+     x minutes and 60 seconds (ie 3:60 instead of 4:00)
+   Added support for FLAC cuesheets (FLAC 1.1.0+)
+     (thanks ah&#216;artemis*dk)
+   Improved parsing speed in MP3, MP2 and AAC  (thanks ah&#216;artemis*dk)
+   Extra error-checking added to try and identify corrupt files for
+     most audio formats  (thanks ah&#216;artemis*dk)
+   More accurate playtime calculation for RealMedia
+     (thanks ah&#216;artemis*dk)
+   Changed all relevant files to use ['audiodataoffset'] and
+     ['audiodataend'] rather than ['filesize'] where appropriate
+     (thanks ah&#216;artemis*dk)
+   Added text encoding type 255 as a duplicate of UTF-16BE but with
+     Big-Endian rather than Little-Endian byte order
+   Added many RIFF-AVI audio types and fourcc video types to the
+     lookup functions in getid3.riff.php
+   Added numerous new known GUIDs to getid3.asf.php
+   Added PoweredBygetID3() function to easily get a &quot;powered by&quot;
+     string with the current getID3() version.
+   Added &quot;Morgan Multimedia Motion JPEG2000&quot; (MJ2C), &quot;DivX v5&quot; (DX50)
+     and &quot;XviD&quot; (XVID) codecs to list of known codecs in
+     getid3.riff.php
+   Changed GETID3_INCLUDEPATH path seperators to forced /
+     (from \ for Windows)
+   Modified getid3.check.php to only change \ directory seperators to
+     / on Windows operating systems
+   Modified getid3.check.php to handle larger-than-2GB files (which
+     now do not return a filesize)
+   Modified getid3.check.php to handle ['dataformat_audio'] and
+     ['dataformat_video']
+   Modified getid3.check.php to show a list of present tags in one
+     column rather than one column for each of ID3v1, ID3v2, etc
+   Modified getid3.check.php to show MD5 values. Initially disabled
+     but can be enabled for a directory with a click. md5_file is
+     always calculated when displaying detailed info about a single
+     file; md5_data is calculated if the file is &lt; 50MB
+   Modified getid3.check.php to show errors and warnings. Details are
+     visible with a mouseover or a click.
+   Changed getid3.check.php to use SafeStripSlashes instead of a
+     manual conditional directory name replacement for special
+     characters
+   Added sample recursive scanning sample code to getid3.readme.txt
+     (thanks lipisin&#216;mail*ru for the idea)
+
+
+1.5.7: [January-10-2003] James Heinrich
+   &#187; Added support for ISO 9660 (CD-ROM image) format. Most-useful
+     data is directory structure returned under ['iso']['files']
+     Note: Only ISO-9660 supported, not (yet) Joliet extension
+     (thanks nebula_dj&#216;softhome*net for the idea)
+     New file: getid3.iso.php
+   &#164; ZIP files are now parsed by getID3() itself without relying on
+     built-in PHP functions and/or ZZipLib support.
+     (thanks Vince for the idea)
+   &#164; ZIP files now return a simple directory listing with filename
+     and filesize info only under ['zip']['files'].
+     Note: empty subdirectories will note appear in here, only files
+     and non-empty subdirectories. Information for all entries,
+     including empty subdirectories, is available under
+     ['zip']['central_directory'] (or under ['zip']['entries'] if the
+     Central Directory cannot be located (usually due to a trucated
+     file).
+   &#164; RIFF-WAV files with MP3 data (or MP3s with RIFF headers, if you
+     want to think of it that way) now have the MPEG audio portion
+     scanned and the usual data returned in ['mpeg']['audio'] if the
+     RIFF audio codec has wFormatTag of &quot;85&quot; (identified by getID3()
+     as &quot;MPEG Layer 3&quot;)
+     (thanks ah&#216;artemis*dk for the idea)
+   &#164; EXIF data (if present) is returned for JPEG files under
+     ['jpg']['exif']  (thanks nebula_dj&#216;softhome*net)
+   &#164; ['filepath'] now returned for all files with the directory part
+     of the full filename.
+   &#164; ['filenamepath'] is now returned for all files (equivalent to
+     ['filepath'].'/'.['filename'])
+   * Bugfix: ['id3']['id3v2'][&lt;framename&gt;]['dataoffset'] was wrong
+   * Bugfix: MP3s tagged with iTunes have an invalid comment field
+     frame name ('COM ' - should be 'COMM') but the data is valid
+     otherwise; the frame is now renamed to 'COMM' and parsed
+     normally (with the error noted in ['error'])
+     (thanks kheller2&#216;mac*com for the sample file)
+   * Bugfix: Some ASF/WMA audio files were not being identified as
+     any format  (thanks ah&#216;artemis*dk)
+   * Bugfix: Warning now generated and ASCII format assumed for
+     invalid text encoding values in ID3v2
+   * Bugfix: Changed ZIP detection pattern from 'PK' to 'PK\x04\x03'
+   * Bugfix: Ogg/FLAC files with large Vorbis comments were dying in
+     an infinite loop with lots of error messages due to missing $fd
+     parameter on ParseVorbisComments()  (thanks ah&#216;artemis*dk)
+   * Bugfix: ['data'] and ['image_mime'] were being returned for all
+     Ogg comments even if they were not images for versions of PHP
+     that have image_type_to_mime_type() built in (ie PHP 4.3.0+)
+
+
+1.5.6: [December-31-2002] James Heinrich
+   &#187; Added support for NSV (Nullsoft Streaming Video)
+     (www.nullsoft.com/nsv/)
+     (thanks demon&#216;soundplanet*com for the idea)
+     New file: getid3.nsv.php
+   &#187; Added support for CD-audio track files (track01.cda etc)
+   &#164; Added standard ['frame_rate'] root value when known (AVI, NSV,
+     MPEG-video)
+   &#164; ASF files now report ['fileformat'] of:
+     'wmv' when Windows Media Video codec v7/v8/v9 is used;
+     'wma' when any 'Windows Media Audio' named audio codec is used
+           and no video stream is present;
+     'asf' in all other cases (audio-only, video-only, or both)
+   &#164; Removed support for ZIP functions (will be rewritten to not
+     require ZZIPlib support in future versions)
+   &#164; Added function SafeStripSlashes() as a drop-in replacement for
+     stripslashes(), but that only strips slashes if magic_quotes_gpc
+     is set
+   &#164; Removed support for remote file scanning (HTTP / FTP)
+   &#164; Added ['aac']['frames'] (number of AAC frames in file)
+   &#164; Added ['mpeg']['audio']['frame_count'] when a bitrate histogram
+     is created
+   &#164; Average bitrate for VBR MP3/MP2 is calculated from actual counts
+     of frames of various bitrates (rather than relying on the header
+     values or filesize) when a bitrate histogram is created
+   &#164; RecursiveFrameScanning() split out into seperate function
+     (getid3.mp3.php)
+   &#164; Removed old function getMP3header() from getid3.mp3.php
+   &#164; Changed default MPEG_VALID_CHECK_FRAMES (number of mp3 frames
+     scanned to ensure a valid audio sequence has been located) from
+     10 to 25. This means scanning will be slightly slower, but more
+     reliable/accurate
+   * Bugfix: ID3v2.2 - valid frame names not correctly detected
+     (thanks maecker&#216;web*de for the sample file)
+   * Bugfix: ID3v2.2 - valid padding not correctly detected
+     (thanks maecker&#216;web*de for the sample file)
+   * Bugfix: MIDI files with flat key signatures were not being
+     correctly reported (thanks alexleeis&#216;shaw*ca for sample file)
+   * Bugfix: now returns message in ['error'] if file does not exist
+   * Bugfix: ['RIFF']['video'][x]['codec'] wasn't always being
+     correctly populated
+   * Bugfix: ['bitrate'] was incorrect for multi-stream RealMedia
+   * Bugfix: ['playtime_seconds'] was sometimes null or incorrect
+     for multi-stream RealMedia
+   * Bugfix: ChannelTypeID was incorrect in RVA2 ID3v2.4 frames
+   * Bugfix: Fixed potential divide-by-zero error for corrupt FLAC
+     files  (thanks ah&#216;artemis*dk)
+   * Bugfix: AAC-ADTS was not returning ['bitrate_mode'] unless
+     $ReturnExtendedInfo was TRUE  (thanks ah&#216;artemis*dk)
+   * Bugfix: LAME-encoded CBR MP3s now properly identified as CBR
+     with correct bitrate  (thanks ah&#216;artemis*dk)
+   * Bugfix: VBR MP2 (or headerless MP3) is now identified as VBR
+     rather than CBR. Note: to obtain VBR bitrate for headerless
+     files, the entire file is scanned and a histogram distribution
+     of bitrates is created, and the average bitrate calculated from
+     that.  (thanks ah&#216;artemis*dk for sample file)
+   Added support for DSIZ chunks in VQF, and checks to make sure size
+     of audio data matches DSIZ value, if present
+     (thanks ah&#216;artemis*dk for sample file)
+   Rewrote GetAllMP3info() - removed some unneccesary code, changed
+     format-detection routine from ParseAsThisFormat() to
+     GetFileFormat() to allow for more flexible format parsing
+     (needed for ISO CD-ROM images, helpful for Quicktime and others)
+   Changed references in all files from string-cast indexes: [&quot;$i&quot;]
+     to non-cast indexes: [$i] where appropriate
+   Put a sans-serif 9pt style on all text in getid3.check.php
+   getAACADTSheaderFilepointer() now return TRUE if synch is lost
+     after the first frame has been successfully parsed (previously
+     it would return FALSE if synch was lost at any time, meaning the
+     file is most likely MP3, which was incorrect)
+     (thanks ah&#216;artemis*dk for sample file)
+   Speed improvement code changes to getid3.mp3.php (up to 24% faster
+     in some cases)  (thanks ah&#216;artemis*dk for the code)
+   Changed all include_once() to require_once()
+
+
+1.5.5: [November-25-2002] James Heinrich
+   &#187; Added support for La (Lossless Audio - www.lossless-audio.com)
+     (thanks ah&#216;artemis*dk for the idea)
+     New file: getid3.la.php
+   &#164; Moved lookup functions from getid3.lookup.php to the files where
+     they are used.
+     New file: getid3.id3.php
+     New file: getid3.rgad.php
+     Removed file: getid3.lookup.php
+   &#164; getID3v1Filepointer() returns FALSE if ID3v1 tag not found
+   &#164; Added new paramter &quot;ReturnExtendedInfo&quot; to the function
+     getAACADTSheaderFilepointer() in getid3.aac.php which now
+     defaults to FALSE - if TRUE then the data for every frame is
+     returned (containing aac_frame_length, adts_buffer_fullness and
+     num_raw_data_blocks, which aren't usually very useful). Speed
+     improvement with FALSE is about 35%.
+   &#164; Now returns fopen() errors in ['error'], for example if a remote
+     file is not accessible.
+   &#164; Changed default number of MP3 audio frames to scan to determine
+     if a valid stream has been found from 5 to 10, now also defined
+     as a constant at the top of getid3.mp3.php  This will result in
+     slightly slower MP3 parsing, but greater reliability in
+     detecting false/invalid/corrupted VBR headers.
+   &#164; fopen() errors now displayed in getid3.putid3.php
+     (thanks miguel.dieckmann&#216;hamburg*de)
+   &#164; Added 4th parameter to decodeMPEGaudioHeader() $ScanAsCBR which
+     will force an MP3 audio frame sequence to be force-scanned in
+     CBR mode. You should never need to call this directly, it's only
+     used internally to scan for MP3 files that have an illegal VBR
+     header with CBR data. (thanks fletch&#216;pobox*com)
+   * Bugfix: ASF_Marker_Object in getid3.asf.php was always returning
+     an error in non-existant &quot;reserved_1&quot; and failing
+   * Bugfix: VBR bitrate calculations in getid3.mp3.php only occur if
+     ['mpeg']['audio']['VBR_frames'] is defined.
+     (thanks fletch&#216;pobox*com)
+   * Bugfix: getid3.putid3.php no longer deletes original MP3 if
+     ID3v2 tag writing fails (thanks miguel*dieckmann&#216;hamburg*de)
+   * Bugfix: incorrect order of if-statement error messages in
+     getid3.putid3.php (thanks miguel*dieckmann&#216;hamburg*de)
+   getid3.asf.php now notes the error and continues parsing rather
+     than failing when it encounters an error parsing a chunk
+   Now actually scan 1000 frames for AAC ADTS as reported in the
+     v1.5.4 changelog, rather than 100. (thanks ah&#216;artemis*dk)
+   Improved scanning speed in getAACADTSheaderFilepointer() by ~30%
+     (thanks ah&#216;artemis*dk for the fix)
+   Added FileSizeNiceDisplay() function to getid3.functions.php for
+     formatting filesize output in kB, MB, GB, etc.
+
+
+1.5.4: [October-07-2002] James Heinrich
+   &#187; Added support for Quicktime.
+     New file: getid3.quicktime.php
+   &#187; Added support for AAC files, both ADTS and ADIF header formats.
+     ADIF format is a pain because it's very similar to standard MP3
+     header format, and it's hard to distinguish between the two. I
+     have tried to make the detection accurate, but I have a limited
+     number of AAC test files to play with so if you have an AAC file
+     that gets detected as MP3/MP2 (or vice-versa), please send me
+     the details via email at getid3&#216;silisoftware*com
+     ADTS format is very slow to parse because to get the bitrate of
+     VBR files the whole file has to be stepped through frame by
+     frame (getID3() scans up to the first 1000 frames and assumes
+     that to be close enough).
+     Note: I would suggest commenting out support for AAC (see top of
+     GetAllMP3info() function in getid3.php) unless you need it.
+     (thanks jfaul&#216;gmx*de for the idea and sample Delphi source code)
+     New file: getid3.aac.php
+   &#187; Added bitrate distribution analysis option for MP3 VBR files. A
+     new boolean parameter for getOnlyMPEGaudioInfo() enabled this
+     feature which steps through the MP3 file frame by frame and
+     counts how many frames of each bitrate exist. This information
+     is returned in ['mpeg']['audio']['bitrate_distribution']
+     Caution: this feature is very inefficient for large files and
+     takes a very long time and does lots of disk I/O. Use with care.
+   &#164; Changed layout of allowedFormats in GetAllMP3info() function in
+     getid3.php to allow easy removal of support for any of the
+     supported format. As stated above, I recommend commenting out
+     AAC unless needed.
+   &#164; Added ['flac']['compressed_audio_bytes'],
+     ['flac']['uncompressed_audio_bytes'], and
+     ['flac']['compression_ratio']
+   &#164; Replaced FXPT2DOT30toFloat() function with FixedPoint2_30()
+   * Bugfix: getid3.mpc.php was slightly miscalculating the number of
+     samples, therefore also bitrate and playtime
+     (thanks ah&#216;artemis*dk for the fix)
+   * Bugfix: MonkeyCompressionLevelNameLookup() didn't know about
+     'insane' compression (thanks ah&#216;artemis*dk for the fix)
+   * Bugfix: MonkeySamplesPerFrame() was incorrect for MAC v3.95+
+     (thanks ah&#216;artemis*dk for the fix)
+   * Bugfix: getid3.check.php wasn't processing the assumeFormat
+     directive when (register_globals == off)
+   * Bugfix: detecting of synch pattern for MP3 files with invalid
+     data at the beginning wasn't always correct, also meant possible
+     incorrect bitrate/duration/etc info for such corrupt files.
+   getid3.functions.php now includes a replacement utf8_decode()
+     function for those PHP installations that are not configured
+     with the --with-xml option. (thanks stephane&#216;tekartists*com)
+
+
+1.5.3: [September-30-2002] James Heinrich
+   &#187; Added support for VQF. (thanks mt&#216;mansonthomas*com for the idea)
+     New file: getid3.vqf.php
+   &#187; Added support for FLAC. Comments, if present, are returned under
+     ['ogg'] because they follow the Ogg Vorbis structure standard.
+     New file: getid3.flac.php
+   &#164; OS/2-format bitmaps are now correctly interpreted. The format of
+     the bitmap is now returned in ['bmp']['type_os'] and
+     ['bmp']['type_version']. OS/2 bitmaps can be v1 or v2, Windows
+     can be v1, v4 or v5
+
+
+1.5.2: [September-25-2002] James Heinrich
+   &#187; Support for RealMedia (audio &amp; video) added
+     Note: only tested on G2 and v5 audio and video files - if anyone
+     has older and/or newer sample files, please test it and/or send
+     me the sample files.
+     (thanks stephane&#216;tekartists*com for idea)
+     New file: getid3.real.php
+   &#187; Support for BMP added. Palette and pixel data can optionally be
+     extracted as well - this is slow and generally unneccesary, but
+     the option is there if you need it. Also includes PlotBMP()
+     which will take the extracted pixel data and output it as a true
+     color PNG. This function requires GD v2.0+
+     Note: Untested on 16-bit and 32-bit BMPs because I couldn't find
+     any sample files - if you know of a program that can create such
+     files, please email getid3&#216;silisoftware*com
+     Note: Support for RGB (uncompressed), RLE8 and RLE4 is included
+     and tested. BITFIELDS support is also included for 16- &amp; 32-bit
+     formats, but it's untested, so if anybody has any test files
+     please send them to getid3&#216;silisoftware*com
+     Note: Support currently only for Windows-format BMPs, and trying
+     to parse an OS/2-format bitmap leads to unpredictable/invalid
+     results.
+     New file: getid3.bmp.php
+   &#187; PNG now fully parsed, including all information chunks
+     New file: getid3.png.php
+   &#164; Support for GIF/JPG/PNG moved to seperate files and expanded,
+     including standard ['resolution_x'] and ['resolution_y'] as well
+     as more thorough parsing of header information
+     New file: getid3.gif.php
+     New file: getid3.jpg.php
+   table_var_dump() simplified and now outputs &#123;-style character
+     entities for characters outside the normal alphanumeric range
+   CleanOggCommentName() changed to a regular expression
+     (thanks chris-getid3&#216;bolt*cx for rewriting the function)
+
+
+1.5.1: [September-20-2002] James Heinrich
+   &#187; Added support for MPEGplus/Musepack SV7. ['fileformat'] is 'SV7'
+     for version 7 files (versions 4, 5 ,6 and 8 are not supported
+     yet, but will be of ['fileformat'] SV4, SV5, SV6 and SV8) when
+     they are supported (thanks Christian Fritz for the idea)
+     New file: getid3.mpc.php
+   &#164; ['bitrate_audio'], ['bitrate_video'], ['bitrate_mode'],
+     ['channels'], ['resolution_x'], and ['resolution_y'] keys added
+     for all appropriate formats
+   &#164; Ogg files with a COVERART comment now save and display the
+     attached image the same way as is done with ID3v2 APICs
+   &#164; ['ogg']['comments'][n]['data'] and
+     ['ogg']['comments'][n]['dataoffset'] is now returned for all
+     comments. ['ogg']['comments'][n]['data'] is only useful if
+     the field is supposed to contain binary data. It is a
+     base64_decode()'d version of ['value'].
+     ['ogg']['comments'][n]['dataoffset'] is the byte offset in the
+     file at which the 'COMMENTNAME=value string' starts, not the
+     start of just 'value'
+   &#164; ['ogg']['comments'][n]['image_mime'] is now returned if
+     ['ogg']['comments'][n]['data'] contains valid image data.
+   &#164; More than 3 Ogg pages may now be read in, if the comment data
+     is longer than 1 page (usually about 4kB)
+   &#164; ['fileformat'] is now 'mp2' rather than 'mp3' if it's MPEG-1,
+     Layer-II audio
+   &#164; ASF bitrates now calculated even if stream_bitrate_properties
+     object not present
+   &#164; ['asf']['stream_properties_object'] is now a numeric-key array
+     with one entry for each stream - the key being the stream number
+   &#164; ['replay_gain'] is returned for all audio formats that support
+     it (MP3-LAME, ID3v2, Ogg) (thanks Christian Fritz for the idea)
+   &#164; ['mpeg']['audio']['LAME']['RGAD']['radio_replay_gain'] is now
+     ['mpeg']['audio']['LAME']['RGAD']['radio'] (same for audiophile)
+   &#164; ASF/WMA files now use WM/Track to get track number from if
+     WM/TrackNumber is not available (thanks stephane&#216;tekartists*com)
+   &#164; ASF/WMV files now returns ['year'] and ['asf']['year']
+   &#164; ASV/WMV files now use ['content_description']['description'] for
+     the ['comment'] field (thanks stephane&#216;tekartists*com)
+   &#164; ['track'] is now always returned as an integer
+   * Bugfix: Ogg comments that are larger than one data page (usually
+     about 4kB) are now correctly parsed (thanks Christian Fritz)
+   * Bugfix: Ogg comment data is now UTF8-decoded
+   * Bugfix: Ogg comment writing now UTF8-encodes the data
+   * Bugfix: playtime for ASF files was off by &lt;preroll&gt; (usually
+     between 3 and 12 seconds)
+   * Bugfix: ['asf']['stream_properties_objects']['flags'] data was
+     possibly incorrect
+   * Bugfix: ASF Padding Object was overwriting
+     Stream Bitrate Properties Object data (now returned correctly in
+     ['asf']['padding_object']
+   * Bugfix: ASF Marker Object Reserved_2 field was incorrect
+   * Bugfix: ASF Bitrate Mutual Exclusion Object had incorrect stream
+     numbers
+   Warning displayed if incorrectly-formatted Ogg comment is present
+     (known to be an issue with CDex v1.40, but fixed by v1.50b7)
+     (thanks Christian Fritz)
+   Ogg comment writing now checks for valid comment names
+   Added bitrate column in getid3.check.php, and added some formatting
+     (font, colour)
+   Performance tweaks using bitwise math instead of binary string
+     operations
+
+
+1.5.0: [September-18-2002] James Heinrich
+   &#187; Ogg comment writing support added. getid3.write.php has been
+     updated to allow for writing comment tags to both MP3 and Ogg.
+     Big thanks to Chris Bolt &lt;chris-getid3&#216;bolt*cx&gt; for writing the
+     OggWrite() function and offering it for inclusion in getID3()
+     New file: getid3.ogginfo.php
+   &#187; Support for Monkey's Audio and APE tag added.
+     (thanks Christian Fritz for the idea)
+     New file: getid3.ape.php
+     ['fileformat'] now returns 'mac' for Monkey's Audio files, or
+     'ape' for files with an APE tag (Monkey's Audio or other format)
+   &#187; getid3.thumbnail.php has been removed from the distribution and
+     the table_var_dump() function now outputs APICs as seperate
+     files in the same directory as the analyzed file. This should
+     make the image-displaying more reliable as well as reduce
+     complexity. The naming convention for the images is
+     filename.ext.[byte offset of APIC data].[jpg|gif|png]
+     If anybody still has any problems with corrupted images please
+     let me know at getid3&#216;silisoftware*com
+   &#187; Support for extended Xing/LAME tag
+     (see <A HREF="http://users.belgacom.net/gc247244/extra/tag.html">http://users.belgacom.net/gc247244/extra/tag.html</A>)
+     Data is returned in ['mpeg']['audio']['LAME']
+   &#164; ['ogg']['tracknumber'] has been renamed to ['ogg']['track'] and
+     ['track'] is now returned in the root of the array
+   &#164; ['ogg']['pageheader'][n]['flag'] has been renamed to
+     ['ogg']['pageheader'][n]['flags'] and the unprocessed flag byte
+     is available in ['ogg']['pageheader'][n]['flags_raw']
+   &#164; ['frequency'] is now returned for WAVE files in the root of the
+     array (thanks daniel&#216;electroteque*org)
+   &#164; ASF files now return codec, bitrate, resolution, etc information
+     under ['asf']['video_media'] or ['asf']['audio_media']
+   * Bugfix: RVA2 and EQU2 writing in getid3.putid3.php were
+     incorrectly writing Volume Adjustment field
+   * Bugfix: EQU2 in getid3.frames.php was reading Volume Adjustment
+     as unsigned integer instead of signed integer
+   * Bugfix: handling of remote files over HTTP &amp; FTP was broken
+     (thanks Vince)
+   * Bugfix: incorrect handling of some ASF packets
+   ASF/Windows Media format now more fully parsed, including Index
+     Objects
+   Added several new fourCC video codecs
+
+
+1.4.3: [September-15-2002] James Heinrich
+   &#187; Now parses ASF / WMV / WMA files
+   &#164; New file: getid3.asf.php
+   * Bugfix: RoughTranslateUnicodeToASCII() would return nothing
+     if didn't find a terminator it was expecting
+   Added FILETIMEtoUNIXtime() function (for converting 64-bit
+     Microsoft FILETIME timestamps, used in ASF files and elsewhere,
+     to UNIX Epoch timestamps)
+   Added GUIDtoBytestring() and BytestringToGUID() functions
+
+
+1.4.2: [September-12-2002] James Heinrich
+   &#187; getID3() now requires PHP v4.1.0 or higher because it now is
+     designed to work with register_globals = off and the new auto-
+     globals ($_GET, $_SERVER, etc).
+   * Bugfix: VBR MP3 files with Fraunhofer-style VBR header were not
+     being correctly detected in most cases
+     (thanks dkushner&#216;oddcast*com and mike&#216;ftl*com for sample files)
+   * Bugfix: IsValidTextEncoding() was broken
+   * Bugfix: Add stripslashes($EditorFilename) to getid3.write.php
+     (writing was broken for files with ' or &quot; in the filename)
+     (thanks mike&#216;ftl*com and kthejoker)
+   * Bugfix: If there is garbage data between a valid VBR header
+     frame and a sequence of valid MPEG-audio frames the VBR data is
+     no longer discarded. (thanks to mike&#216;ftl*com for sample
+     Fraunhofer-style VBR file produced with MusicMatch v7.2)
+   &#164; Changed variable system to work with (register_globals = off)
+   &#164; Moved relevant code into seperate PlaytimeString() function
+   &#164; Added nl2br() to table_var_dump() for cleaner output
+   &#164; Now returns the following keys from Fraunhofer-VBR files:
+     ['VBR_seek_offsets'], ['VBR_seek_offsets_stride'],
+     ['VBR_offsets_relative'] and ['VBR_offsets_absolute']
+   &#164; Added ID3v1matchesID3v2() function and implemented in
+     getid3.check.php (thanks to &quot;Guest&quot; in the forums for the idea)
+   Changed amount of data read in getid3.getimagesize.php from 10kB
+     to entire file. (thanks mike&#216;ftl*com)
+   Wrapped function_exists() checks around function definitions in
+     getid3.functions.php
+   Fixed a lot of E_WARNING and E_NOTICE situations, especially in
+     ID3-writing code (getid3.putid3.php, etc)
+   Added checks to make sure all needed data is available for writing
+     ID3v2 tags
+
+
+1.4.1b5: [May-30-2002] James Heinrich
+   * Bugfix: Unsynchronise() was broken, now fixed
+     (thanks mike&#216;ftl*com)
+   * Bugfix: GenerateID3v2Tag() now correctly uses non-synchsafe
+     integers for frame size descriptors in ID3v2.3 and ID3v2.2
+     (thanks mike&#216;ftl*com)
+   &#164; Added ['artist'], ['title'], etc keys to root of returned
+     array to provide a common place to access any returned info
+     from any file type. Currently gets info from ID3v1, ID3v2,
+     Ogg, and RIFF/WAVE. Possible returned keys are:
+     title, artist, album, year, genre, comment, track
+   &#164; Modified LookupGenre() function to search for either genre based
+     on numeric ID, or now reverse lookup as well
+   &#164; Added ['artist'], ['title'], etc keys to ['RIFF'] information
+     if info tags are present
+   Added functionality to attach a picture to the ID3v2 tag in
+     getid3.write.php
+   Sorted genres into alphabetical order (special 3 at end of list)
+     in getid3.write.php
+   Changed the comment-edit field in getid3.write.php to a multi-line
+     &lt;textarea&gt; from a single-line &lt;input&gt;
+   getid3.write.php now only writes ID3v2 frames that have data
+   Added default TXXX field to getid3.write.php to put a tagger info
+     field when writing ID3v2 tags. Description is &quot;ID3v2-tagged by&quot;
+     and data is &quot;getID3() v[version] (www.silisoftware.com)&quot;
+   Changed getid3.check.php to use the new common info keys
+   Improved file-format detection in getid3.check.php - if the auto-
+     detect based on the first few bytes of the file doesn't find a
+     known format (for example if the header is corrupt), a more
+     thorough scan is done based on the file extension
+   Added 'Edit ID3' link from getid3.check.php to getid3.write.php for
+     MP3 files  (thanks max&#216;gutalin*com for the idea)
+   Added 'Delete file' link from getid3.check.php to getid3.write.php
+     allowing you to permanently delete a file (be careful with this!!)
+     (thanks max&#216;gutalin*com for the idea)
+   Added some mouse-over titles for links in getid3.check.php
+
+
+1.4.1b4: [May-15-2002] James Heinrich
+   * Bugfix: getid3.check.php wasn't parsing MP3s with invalid headers
+     or padding at the beginning of the file - added 'assumeFormat'
+     parameter and 'Parse this file as:' options to force parsing in a
+     particular format  (thanks Alcohol for the sample file)
+   * Bugfix: unset(['fileformat']) and ['error'] added in cases where
+     file cannot be parsed in the assumed or forced format
+
+
+1.4.1b3: [May-01-2002] James Heinrich
+   &#164; For Ogg files, now calculates the real average bitrate (returned
+     in ['ogg']['bitrate_average']) and so the playtime of the file is
+     calculated on actual average bitrate, not nominal bitrate, so it
+     should be accurate now  (thanks to stephane&#216;tekartists*com for
+     telling me it was wrong)
+   * Bugfix: ID3v2FrameIsAllowed() wasn't behaving properly if the
+     writing functions were called for more than one file, because of
+     the static array not being cleared between uses. This is an
+     updated fix because the one in 1.4.1b2 didn't work :o)
+     (thanks soulcatcher&#216;evilsoft*org and yoyo)
+   Added rawurlencode() to the filename parameter in table_var_dump()
+     for images (wouldn't work with path/file names containing special
+     characters (#, &amp;, &quot;, +)  (thanks Christian Fritz)
+   getid3.check.php no longer attempts to scan all MIDI tracks in
+     directory-browse mode, since this can take a long time. Detailed
+     single-file view is still fully scanned (new third parameter for
+     getMIDIHeaderFilepointer() controls this)
+   Small improvements to MoreNaturalSort()
+
+
+1.4.1b2: [April-18-2002] James Heinrich
+   &#164; GetAllMP3Info()'s 2nd parameter has changed from boolean to string
+     (now specifying the parse-this-file-as-this format, like 'mp3',
+     but also can be FALSE to mean don't assume any format, auto-detect
+     only), and a third parameter (array containing allowed formats)
+     has been added. The assumedFormat parameter allows a file to be
+     forced to be parsed as a certain format rather than relying on the
+     auto-detection of getID3() (ex: an MP3 wrapped in a RIFF/WAV
+     header will be auto-detected as RIFF/WAV, but if forced to parse
+     as MP3 will extract the original MP3 information)
+     (thanks reel_taz&#216;users*sourceforge*net)
+   * Bugfix: ID3v2FrameIsAllowed() wasn't behaving properly if the
+     writing functions were called for more than one file, because of
+     the static array not being cleared between uses (thanks yoyo)
+   * Bugfix: Lyrics3 data wasn't being properly copied from the ['raw']
+     keys to the easy keys (['title'], etc.)  (thanks Christian Fritz)
+   * Bugfix: some testing code was accidentally left in
+     getid3.thumbnail.php  (thanks Christian Fritz)
+   * Bugfix: RIFF/WAVE files are now more likely to have all their
+     chunks parsed.
+   * Bugfix: RIFF/WAVE bitrate &amp; playtime now better calculated
+   * Bugfix: MP3 scanning for synch doesn't go beyond 64k now, to stop
+     intensive scanning through large file that don't have a synch
+     (thanks soulcatcher&#216;evilsoft*org for a weird sample file)
+   Improved performance when scanning for MP3 synch (about 600% faster
+     if the synch is never found)
+   ZIP files no longer return the contents of each compressed file, as
+     that would very easily be more data than PHP could handle.
+     (thanks davidbullock&#216;tech-center*com)
+   getid3.check.php now displays entries in a more natural sort order:
+     case insensitive, ignores most punctuation, treats accented chars
+     the same as their unaccent equivalent  (thanks mike&#216;ftl*com)
+   Added support for SmartSound-format RIFF files (which are regular
+     RIFF/WAVE files with the first 4 chars changed from RIFF to SDSS)
+   All instances of while(list() = each()) replaced with foreach()
+
+
+1.4.1b1: [April-11-2002] James Heinrich
+   &#187; Parses MIDI files.
+     NOTE: very slow at parsing, much slower than any other file type
+     NOTE: playtime is generally mostly accurate, but not always 100%
+   &#187; Parses ZIP files (if ZZIPlib available, and only in PHP 4.0.7RC1
+     and later (see <A HREF="http://www.php.net/manual/en/ref.zip.php">http://www.php.net/manual/en/ref.zip.php</A>)
+     NOTE: currently untested as I'm unable to find php_zip.dll for
+     PHP/Win32 - if someone has a copy of this file, please email me:
+     getid3&#216;silisoftware*com
+   &#187; Parses JPEG files (requires GD installed)
+   &#187; Parses PNG files  (requires GD v1.6+ installed)
+   &#187; Parses GIF files  (requires GD &lt; v1.6 installed)
+   &#187; For MP3s, once a valid synch is detected, the next 5 frames are
+     also scanned for valid synch signatures, to prevent false
+     identification of synch. For corrupt MP3 files this will be a bit
+     slower, but hopefully produce more reliable results.
+     (Thanks to mpdj&#216;btinternet*com for bringing this to my attention,
+     and xbhoff&#216;pacbell*net for explaining what was happening)
+     (Thanks also to macik for helping me with MP3 frame lengths:
+     <A HREF="http://66.96.216.160/cgi-bin/YaBB.pl">http://66.96.216.160/cgi-bin/YaBB.pl</A>
+     ?board=c&amp;action=display&amp;num=1018474068)
+   &#187; The actual image data is now displayed (for JPEG, PNG and GIF
+     images only) rather than a binary text dump in getid3.check.php
+     (specifically table_var_dump()) for APIC frames. Made possible
+     by the inclusion of (a modified version of) GetURLImageSize() by
+     Filipe Laborde-Basto (www.rezox.com). You can right-click, save-as
+     to extract the image to a file.
+     NOTE: The actual image data is still returned in ['data']
+   &#164; ['image_mime'], ['image_width'], ['image_height'], ['image_bytes']
+     are now returned for APICs
+   &#164; split parsing functions out into seperate files: lyrics3, id3v1,
+     id3v2, mp3, ogg, riff, mpeg, midi, zip
+   &#164; ['ogg']['bitrate_ave'] -&gt; ['ogg']['bitrate_nominal'] (thanks to
+     stephane&#216;tekartists*com for pointing out that &quot;nominal&quot; bitrate
+     may actually differ significantly from the &quot;average&quot; bitrate)
+     The real average bitrate seems to be only extractable by parsing
+     the entire file and calculating the average bitrate. This is not
+     yet an option, but hopefully in a future version of getID3()
+   &#164; ['filename'] now returned for all files
+   &#164; ['ogg']['date'] and ['ogg']['description'] now returned when
+     available  (thanks stephane&#216;tekartists*com)
+   &#164; ['mpeg']['audio']['crc'] now contains the CRC (if present)
+   &#164; ['bitrate'] is now returned as a double instead of an int
+   &#164; ['dataoffset'] is now returned for all ID3v2 frames
+   * Bugfix: MP3 CRC presence ['mpeg']['audio']['protection'] was being
+     reported as opposite of what it actually should be
+   * Bugfix: MPEG videos weren't being detected (they were being
+     parsed as MP3), and even if they were, there was a typo in
+     getMPEGHeaderFilepointer()  (thanks Christian Fritz)
+   * Bugfix: getid3.functions.php wasn't being included in
+     getid3.write.php  (thanks mike&#216;ftl*com)
+   * Bugfix: Browse:___ directory name in getid3.check.php wasn't
+     correct with directory names with ' and other strange characters
+     (thanks Christian Fritz)
+   ID3v2FrameProcessing() now checks to see if the next frame is valid
+     after it encounters an invalid FrameID, and if the next frameID
+     appears valid, it will just skip the current (invalid) frame and
+     continue processing (it would previously abort at the first sign
+     of incorrect structure)   (thanks stephane&#216;tekartists*com)
+   getid3.check.php now scans filetypes based on content, not filename
+     extension, and shows the filetype in the displayed output. Files
+     are only scanned as MP3 if ID3v2 or MPEG-audio signatures are at
+     the immediate beginning of the file (MP3 used to be the default
+     format), so a corrupt file may not show up as MP3 format in the
+     browse screen, but in detail it will scan in-depth
+   getid3.check.php now has columns to show the presence of ID3v1,
+     ID3v2 and Lyrics3 content
+   Helium2 (www.helium2.com) has been known to write ID3v2.4 tags with
+     non-synchsafe-integer framesizes, getID3() now checks for this and
+     will override and parse the tag as ID3v2.3 if the tag would parse
+     fine as ID3v2.3 when it's really specified as ID3v2.4  (thanks
+     Christian Fritz for the test files)
+
+
+1.4.0b9: [April-05-2002] James Heinrich
+   &#187; Ogg files now return bitrate and playtime (playtime calculated
+     from nominal bitrate and filesize, so it's only approximately
+     accurate).  (thanks stephane&#216;tekartists*com for the idea)
+   * Bugfix: ID3v1 tags were not properly being parsed - track, genre
+     and comment fields were incorrect.  (thanks Christian Fritz)
+   * Bugfix: getid3.check.php would not browse directories with single
+     quotes (') or double quotes (&quot;) in the directory name.
+     (thanks Christian Fritz)
+   * Bugfix: Improved detection of MPEG-video files (a sample MP3 file
+     had a false MPEG video signature at the beginning), and the MPEG-
+     video parsing function now only looks for the MPEG-video header
+     in the first 100k bytes of the file, to prevent needlessly
+     scanning very large files. Also will not infinitely loop if it
+     does not find what it's looking for.  (thanks Christian Fritz)
+   ['error'] now returned if MP3 synch doesn't occur at beginning of
+     file if ID3v2 not used (ie there's some kind of padding there that
+     should not be)
+   Reduced use of fread() in getMPEGHeaderFilepointer() (now faster)
+   Added &quot;file parsed in x.xxx seconds&quot; to getid3.check.php
+   Added &quot;browse: &lt;directory&gt;&quot; link to getid3.check.php
+   Changed default ID3v2 majorversion from 2.4 to 2.3 in
+     getid3.write.php because Winamp (and probably many other
+     ID3v2-aware tools) can only read up to ID3v2.3
+     (thanks mike&#216;ftl*com)
+
+
+1.4.0b8: [April-04-2002] James Heinrich
+   &#187; Lyrics3 support added  (thanks Christian Fritz for the idea)
+   &#164; check.php renamed to getid3.check.php
+   &#164; write.php renamed to getid3.write.php
+   &#164; ['id3']['id3v2']['error'] (if present) now reported in ['error']
+   &#164; ['mpeg']['audio']['error'] (if present) now reported in ['error']
+   * Bugfix: RoughTranslateUnicodeToASCII() was completely mangling
+     UTF-16/UTF-16BE encoded text
+   * Bugfix: The warning about MP3ext wasn't always showing up
+     (thanks davidbullock&#216;tech-center*com)
+   getID3v1Filepointer() cleaned up &amp; shortened
+   Moved the include_once() statements around so that a minimum of code
+     is included
+
+
+1.4.0b7: [April-03-2002] James Heinrich
+   &#187; RIFFs (specifically AVIs) are now more completely parsed,
+     almost everything in the returned ['RIFF'] array has been moved
+     around and/or restructured. A lot of new data is in there too -
+     codecs, frame size, etc.
+   &#164; Better recursive parsing of RIFFs (sub-arrays are now in the right
+     place)
+   * Bugfix: the isset() idea introduced in beta 5 was incorrectly
+     implemented, such that ['asciidata'] and ['asciidescription'] were
+     never returned - this had the side effect that ID3v2 comments were
+     not copied to ['id3']['id3v2']['comment']  (thanks mike&#216;ftl*com)
+   * Bugfix: MPEG audio synch wasn't being detected, and therefore MPEG
+     audio data not parsed, if no ID3v2 header present in an MP3
+   ID3v1 track number only returned if greater than zero
+   Removed !== FALSE (introduced in 1.4.0b6) from while(fread()) loops,
+     some users were reporting problems with that syntax.
+   Changed substr($string, 0, 1) to $string{0} syntax in most files
+   Reformatted changelog.txt to 72-column width
+
+
+1.4.0b6: [April-01-2002] James Heinrich
+   * Bugfix: 1.4.0b5 introduced a bug where any RIFF file other than
+     PCM WAVE (this includes any compressed WAV, as well as all AVIs)
+     would crash getID3()
+   Reduced use of fread() in getOggHeaderFilepointer() for increased
+     speed
+   Added constant FREAD_BUFFER_SIZE for many fread() operations
+   Added !== FALSE check to while(fread()) loops
+     (thanks davidbullock&#216;tech-center*com)
+   Added more entries to RIFFwFormatTagLookup()
+     (still looking for a good complete list)
+   Converted use of hexdec() in getid3.lookup.php to 0x1234 notation
+
+
+1.4.0b5: [March-28-2002] James Heinrich
+   &#164; Renamed decodeheader() to decodeMPEGaudioHeader()
+   * Bugfix: Fixed infinite loop problem for RIFF/WAV files with
+     unknown chunks
+   * Bugfix: WXXX frames were incorrectly writing from ['URL'] instead
+     of ['url']
+   * Bugfix: RoughTranslateUnicodeToASCII() wasn't properly decoding
+     UTF-16/UTF-16BE
+   Changed all quoted strings from &quot; to ' to hopefully improve speed
+     (although benchmarks have not yet shown any significant
+     improvement in speed)  (thanks davidbullock&#216;tech-center*com)
+   Improved code in check.php for dealing with symbolic links
+     (thanks davidbullock&#216;tech-center*com)
+   Changed '&lt;?' tags to '&lt;?php'  (thanks davidbullock&#216;tech-center*com)
+   Added processing time indicator in check.php
+     (ie 'directory scanned in 2.45 seconds')
+   Replaced all instances of feof() to prevent infinite loop conditions
+   Moved lookup portions of decodeMPEGaudioHeader() to
+     getid3.lookup.php
+   Replaced $arrayname[$index] with $arrayname[&quot;$index&quot;] to avoid PHP
+     E_NOTICEs  (thanks davidbullock&#216;tech-center*com)
+   Wrapped isset() around many if statements, to avoid PHP E_NOTICEs,
+     hence improve speed (up to 30x speed improvement reported in some
+     cases :)
+
+
+1.4.0b4: [March-26-2002] James Heinrich
+   &#164; RIFF/WAV file format now parsed, returned under ['riff']
+   &#164; Support for Relative Gain Adjustment in RIFF/WAV files
+   &#164; ['channels'] (1 or 2) now returned for MP3 and WAV files
+   &#164; ['bitrate'] now returned (in bits-per-second) at root level for
+     MP3 and WAV files
+   Added support for RGAD (Relative Gain ADjustment) ID3v2 frames, both
+     reading &amp; writing
+     (see <A HREF="http://privatewww.essex.ac.uk/~djmrob/replaygain/">http://privatewww.essex.ac.uk/~djmrob/replaygain/</A> for details
+     on RGAD)  (thanks Christian Fritz for the idea)
+   Removed some test data-dumping from the ID3v2 writing functions
+   Language code 'XXX' now returns descriptive string 'unknown' instead
+     of NULL
+   Seperated out comments from top of getid3.php into getid3.readme.txt
+     and changelog.txt
+   Split out non-lookup functions from getid3.lookup.php to
+     getid3.functions.php
+
+
+1.4.0b3: [March-25-2002] James Heinrich
+   &#164; ['asciidata'] for WXXX frames now returns correct information, but
+     under ['asciidescription']  (thanks Christian Fritz)
+   &#164; Added ['framenamelong'] to all returned frame data arrays with
+     text description of that frame (ie 'RVA2' would return 'Relative
+     volume adjustment (2)')  (thanks Christian Fritz)
+   &#164; ['datalength'] is now ['indexeddatalength'] in ASPI frames (was
+     confliciting with the all-frames ['datalength'] as introduced in
+     v1.4.0b1
+   &#164; ['datalength'] now returned as integer (rather than double) where
+     possible
+
+
+1.4.0b2: [March-21-2002] James Heinrich
+   &#164; ['mpeg']['audio']['bitrate'] now returned as int rather than
+     double for VBR files
+   * Bugfix: MPEG audio information wasn't being parsed on files that
+     had neither ID3v1 or ID3v2
+   * Bugfix: COMM/WXXX frames weren't returning 'asciidata' in
+     ID3v2.2, which also meant the ['id3']['id3v2']['comment'] field
+     wasn't being returned  (thanks stephane&#216;tekartists*com)
+   * Bugfix: file might not be found if filename actually contains
+     escaped chars or %xx-formatted characters
+     (thanks reel_taz&#216;users*sourceforge*net)
+   Added support for running with Register Globals turned off
+     (thanks reel_taz&#216;users*sourceforge*net)
+   Added urlencode() where needed in check.php
+     (thanks reel_taz&#216;users*sourceforge*net)
+   Fixed IE buffering/display problem in progress counter in check.php
+
+
+1.4.0b1: [March-11-2002] James Heinrich
+   &#187; ID3v2 writing support via WriteID3v2() in putid3.php
+     RemoveID3v2() and RemoveID3v1() functions now available in
+     putid3.php  All ID3v1 and ID3v2 writing functions have been moved
+     to putid3.php and example file write.php has been added to the
+     distribution
+   &#164; MPEG audio frame information (bitrate, frequency, etc) now
+     returned inside ['mpeg']['audio'] instead of just ['mpeg']
+   &#164; MPEG video information now parsed, returned in ['mpeg']['video']
+     Note: audio portion of video system files is not yet being parsed
+   &#164; All flag bits are now returned as boolean rather than int or
+     string
+   &#164; RVA2 data now returned as an array (multiple RVA2 tags are
+     allowed)
+   &#164; RVA2/EQU2 description returned under ['description'] rather than
+     ['identification']
+   &#164; RVAD/EQUA adjustments now returned as signed integers, rather than
+     absolute values which required you to check flag bytes
+   &#164; RVRB/REV data no longer returns under ['reverb'] array
+   &#164; WXXX/W???/LINK frames now return ['url'] instead of ['URL']
+   &#164; USER now properly returns both ['language'] and ['languagename']
+   &#164; OWNE now returns ['purchasedateunix'] as a UNIX timestamp
+     (only if ['purchasedate'] is a valid date)
+   &#164; ['id3']['id3v2']['padding'] now returned with information on padding
+   &#164; ['headerlength'] now includes the initial 6 or 10 bytes of the
+     ID3v2 header
+   &#164; ['artist'], ['title'], ['album'], ['tracknumber'], ['genre'] now
+     returned for easier access for Ogg files
+   &#164; added ['datalength'] to all ID3v2 frames: length of frame data,
+     not including frame header
+   &#164; ['fileformat'] now returns 'id3' if there are ID3v1 or ID3v2 tags
+     but no audio data
+   &#164; ['fileformat'] now returns 'mpg' if it's an MPEG system (video +
+     audio) file
+   * Bugfix: RVAD was being parsed incorrectly
+   * Bugfix: ['currency'] and ['purchasedate'] now correctly returned
+     in OWNE
+   * Bugfix: Frequncies in 'EQU2' frames were incorrectly double
+   * Bugfix: ['bytedeviation'] and ['msdeviation'] now properly
+     returned as integer rather than binary string for 'MLLT' frames
+   * Bugfix: ['filename'] now properly returned for 'GEOB' frames
+   * Bugfix: ['imagetype'] now properly returned for 'PIC' frames in
+     ID3v2.2
+   * Bugfix: Genre not being written if not set in WriteID3v1()
+     (thanks reel_taz&#216;users*sourceforge*net)
+   * Bugfix: Changed write mode to 'r+b' from 'a+' because ID3v1 tags
+     were being appended instead of overwritten if they already existed
+     (thanks reel_taz&#216;users*sourceforge*net)
+   * Bugfix: open would fail on filenames containing quotes
+     (thanks javier&#216;crackdealer*com)
+   * Bugfix: various values were incorrectly returned (unneeded ord())
+     in these frames: COMR, USER, ENCR, GRID, PRIV, SIGN
+   * Bugfix: ASPI ['bitsperpoint'] was not correctly returned
+   * Bugfix: RoughTranslateUnicodeToASCII() was not returning the last
+     char for UTF-16
+   * Bugfix: ['audiobytes'] now correctly 0 if no synch found
+   * Bugfix: GenreLookup was incorrectly returning 'Remix' instead of
+     'Blues' for GenreID 0
+   Added sample directory browser to check.php
+   Seperated out MPEGaudio-parsing functionality into
+     getOnlyMPEGaudioInfo() which may be called directly if you don't
+     need any ID3 parsing  (thanks djpretzel&#216;cox*rr*com for idea)
+   Reduced use of fread() for increased performance in
+     getID3v1Filepointer()
+   Added clearstatcache() before checking filesize - size after writing
+     tag now correct
+   Added hack for mp3Rage (www.chaoticsoftware.com) that puts
+     ID3v2.3-formatted MIME type instead of 3-char ID3v2.2-format image
+     type  (thanks xbhoff&#216;pacbell*net for test file)
+
+
+1.3.2: [February-15-2002] James Heinrich
+   &#164; UFID/UFI, USLT/ULT, COMM/COM, APIC/PIC, GEOB/GEO, CRM, RVA2, EQU2,
+     POPM/POP, AENC/CRA, ENCR and GRID frame data now returned under
+     numeric array index rather than by ownerID
+   &#164; RVA2 frame data is now returned keyed by $channeltypeid instead of
+     $frame_idstring
+   &#164; WXXX/WXX frame description now returned under ['description']
+     instead of ['data']
+   Trailing null bytes now trimmed from frame (W??? &amp; T???) text data
+     (it shouldn't be there to begin with, but a sample file encoded by
+     [unknown program] had data padded to 50 chars with null bytes,
+     which caused ParseID3v2GenreString() to freeze).
+
+
+1.3.1: [February-13-2002] James Heinrich
+   * Bugfix: ['playtime_seconds'] and ['playtime_string'] were not
+     being returned
+   * Bugfix: ['fileformat'] was incorrectly being returned as a
+     2-element array
+   * Bugfix: USLT wasn't being correctly parsed
+   Improved RoughTranslateUnicodeToASCII()
+     (thanks reel_taz&#216;users*sourceforge*net for Unicode test file)
+
+
+1.3.0: [February-13-2002] James Heinrich
+   &#187; ID3v1 writing support via WriteID3v1()
+   &#164; MPEG audio frame information (bitrate, frequency, etc) now
+     returned inside ['mpeg']
+   &#164; ['mpeg']['raw'] returns the integer values of the bits for MPEG
+     audio information as returned in ['mpeg'] by decodeheader()
+     (thanks reel_taz&#216;users*sourceforge*net)
+   &#164; 'protection', 'padding', 'private', 'copyright' and 'original' now
+     return as boolean
+   &#164; 'bitrate' and 'frequency' now return as int (except in special
+     case of 'free')
+   Language name as well as code retured where appropriate
+     (ie 'English' and 'eng')
+   Text frames with invalid TextEncoding value are now passed through
+     anyway
+   ID3v1 data (title, artist, album, year, comment) is now trimmed
+     (no more nulls)
+   RoughTranslateUnicodeToASCII() now uses utf8_decode() for UTF-8
+
+
+1.2.5: [January-30-2002] James Heinrich
+   * Bugfix: Playtime calculations for VBR files were off slightly
+     (rounding error)
+   * Bugfix: Extended header length was incorrectly calculated
+   * Bugfix: Genre strings such as '03' weren't being handled correctly
+   More complete support for ID3v2.3 FrameIDs
+   Split out getid3.frames.php (FrameID-specific parsing function)
+   Split out getid3.lookup.php (assorted lookup-table functions)
+   Searches for what directory getid3.*.php support files are in (must
+     be same as getid3.php, but doesn't have to be same as main file -
+     for example your main file could be /index.php, but including
+     /lib/getid3/getid3.php)
+   Simplified, tweaked, changed and/or eliminated several functions.
+
+
+1.2.4: [January-26-2002] James Heinrich
+   &#187; Basic support for reading Ogg-Vorbis comment tags
+
+
+1.2.3: [January-24-2002] James Heinrich
+   &#187; ID3v2.2.x 3-char FrameIDs are now fully parsed
+     Note: While I've included support for 22 FrameIDs as defined in
+     the specs, I don't have test files for all of them. If anyone
+     knows of programs that generate any of the untested tags, please
+     email getid3&#216;silisoftware*com ! Here's what's tested and not:
+       Tested: T??, COM
+     Untested: UFI, TXX, W??, WXX, IPL, MCI, ETC, MLL, STC, ULT, SLT,
+               RVA, EQU, REV, PIC, GEO, CNT, POP, BUF, CRM, CRA, LNK
+   table_var_dump() now displays boolean variables as TRUE or FALSE
+   table_var_dump() now uses htmlspecialchars() to avoid broken-table
+     problems
+
+
+1.2.2: [January-18-2002] James Heinrich
+   &#164; Parses ID3v2 genres into ['id3']['id3v2']['genreid'] and
+     ['id3']['id3v2']['genrelist'] where appropriate
+     (thanks stephane&#216;tekartists*com for the idea)
+   Added ID3v2 genre abbreviations 'RX' (remix) and 'CR' (cover)
+
+
+1.2.1: [January-17-2002] James Heinrich
+   * Bugfix: 'mp3' was being returned in ['format'], but 'zip' was
+     being returned in ['fileformat'], both are now returned in
+     ['fileformat']
+   &#164; Splits ['id3']['id3v2']['track'] in the format '5/12' into
+     ['track'] = '5' and ['totaltracks'] = '12'
+   &#164; Enabled ['id3']['id3v2']['title'] etc for ID3v2.2.x
+     (3-char frame names)  (thanks stephane&#216;tekartists*com)
+   &#164; Changed v1.?? version number format to v1.?.?
+   Scans through the file until it finds the MPEG synch (start of audio
+     frame) - some files encoded by LAME 3.91 had undocumented padding
+     after the ID3v2 header; getMP3headerFilepointer() now scans until
+     it finds synch (or EOF)  (thanks adam&#216;trekjapan*com)
+   Improved Unicode conversion in RoughTranslateUnicodeToASCII()
+
+
+1.20:  [January-15-2002] James Heinrich
+   &#187; Support for variable-bitrate (VBR) files, both Xing and Fraunhofer
+     headers
+   &#187; All 4-character FrameIDs are now fully parsed according to the
+     specs at <A HREF="http://www.id3.org/id3v2.4.0-frames.txt">http://www.id3.org/id3v2.4.0-frames.txt</A>
+     &#164; This means that most no longer return ['flags'] and ['data']
+     Note: While I've included support for 30 FrameIDs as defined in
+     the specs, I don't have test files for all of them. If anyone
+     knows of programs that generate any of the untested tags, please
+     email getid3&#216;silisoftware*com ! Here's what's tested and not:
+       Tested: UFID, T???, WXXX, USLT, SYLT, COMM, APIC, GEOB
+     Untested: TXXX, W???, MCDI, ETCO, MLLT, SYTC, RVA2, EQU2, RVRB,
+               PCNT, POPM, RBUF, AENC, USER, OWNE, COMR, ENCR, GRID,
+               PRIV, SIGN, SEEK, ASPI
+   &#164; Added 'title', 'artist', etc names to ID3v2 data (easier to access
+     than the 4-character FrameIDs of the ID3v2 standard)
+     (thanks jakson&#216;gmx.net)
+   * Bugfix: added fclose() at end of GetAllMP3Info()
+     (thanks stephane&#216;tekartists*com)
+   * Bugfix: ID3v1 wasn't being parsed if ID3v2 wasn't present
+     (thanks jakson&#216;gmx.net)
+   * Bugfix: several flags were being parsed incorrectly (the structure
+     had changed from ID3v2.3 to ID3v2.4) - v2.3 flags were being
+     incorrectly parsed
+   Much more compact implementation of decodeheader()
+     (thanks jakson&#216;gmx.net for the idea)
+   ID3v1 genres 126 through 147  (thanks jakson&#216;gmx.net)
+   New table_var_dump() function in check.php
+     (based partially on idea by jakson&#216;gmx.net)
+   Seperated ID3v1 retrieval into seperate function
+
+
+1.11:  [December-23-2001] James Heinrich
+   All functions merged into file getid3.php
+   Updated documentation to reflect new returned information
+
+
+1.10:  [December-20-2001] James Heinrich
+   * Bugfix: ID3v1 Track# was incorrectly being parsed whether it
+     existed or not
+   Changed calling procedure to recommend using
+     GetAllMP3info($filename) from getmp3header.php
+   Now includes check.php - example file
+   &#164; Checks to see if file is in ZIP or MP3 format
+     (returned in ['format'])
+     [Ed. Note: ['fileformat'] as of v1.2.1]
+
+
+1.06:  [November-05-2001] James Heinrich
+   * Bugfix: ID3v2.2.x frames weren't being parsed since they use
+     6-byte rather than 10-byte headers as v2.3+ does
+     (thanks spunk&#216;mac*com for pointing that out)
+
+
+1.05:  [September-06-2001] James Heinrich
+   * Bugfix: ID3v2 was being parsed even if it didn't exist
+
+
+1.04:  [July-16-2001] James Heinrich
+   * Bugfix: typo in Extended Header section (strpad() should be
+     str_pad()) (thanks jurroon&#216;yahoo*com)
+
+
+1.03:  [May-07-2001] James Heinrich
+   * Bugfix: Added missing ['id3']['id3v1']['genreid'] and
+     ['id3']['id3v1']['genre']
+
+
+1.02:  [May-05-2001] James Heinrich
+   &#164; Added ['getID3version']
+
+
+1.01:  [May-04-2001] James Heinrich
+   &#187; Added support for frame-level de-unsynchronisation (as per
+     ID3v2.4.0 specs) in addition to ID3v2.3.x tag-level
+     de-unsynchronisation
+
+
+1.00:  [May-04-2001] James Heinrich
+   &#187; Initial public release
+
+
+///////////////////////////////////////////////////////////////////////
+
+Future Plans
+============
+
+ Features
+ --------
+
+  * Writing support for Real
+  * Better support for MP4 container format
+  * Support for Matroska (www.matroska.org)  (thanks ah&#216;artemis*dk)
+    <A HREF="http://corecodec.com/modules.php?op=modload&amp;name=PNphpBB2&amp;file=viewtopic&amp;t=227">http://corecodec.com/modules.php?op=modload&amp;name=PNphpBB2&amp;file=viewtopic&amp;t=227</A>
+  * scan for appended ID3v2 tag at end of file per ID3v2.4 specs (Section 5.0)
+  * Support for JPEG-2000 (<A HREF="http://www.morgan-multimedia.com/jpeg2000_overview.htm">http://www.morgan-multimedia.com/jpeg2000_overview.htm</A>)
+  * Support for MOD (mod/stm/s3m/it/xm/mtm/ult/669) (thanks ah&#216;artemis*dk)
+  * Support for FROG (<A HREF="http://ghido.shelter.ro/FROG.php">http://ghido.shelter.ro/FROG.php</A>)
+  * Lyrics3 v1 &amp; v2 writing support
+  * Support for gzip
+  * Support for ACE (thanks Vince)
+  * Support for Ogg other than Vorbis, Speex and OggFlac (ie. Ogg+Xvid)
+    (thanks ah&#216;artemis*dk)
+  * Ability to create Xing/LAME VBR header for VBR MP3s that are missing VBR header
+  * Ability to &quot;clean&quot; ID3v2 padding (replace invalid padding with valid padding)
+  * Ability to convert RIFF-MP3 to regular MP3 (strip RIFF headers)
+  * Warn if MP3s change version mid-stream (in full-scan mode)
+  * check for corrupt/broken mid-file MP3 streams in histogram scan
+  * Support for lossless-compression formats
+    (<A HREF="http://www.firstpr.com.au/audiocomp/lossless/#Links">http://www.firstpr.com.au/audiocomp/lossless/#Links</A>)
+    (<A HREF="http://compression.ca/act-sound.html">http://compression.ca/act-sound.html</A>)
+    (<A HREF="http://web.inter.nl.net/users/hvdh/lossless/lossless.htm">http://web.inter.nl.net/users/hvdh/lossless/lossless.htm</A>)
+    * Support for Sonarc (<A HREF="http://www.firstpr.com.au/audiocomp/lossless/sonarc/">http://www.firstpr.com.au/audiocomp/lossless/sonarc/</A>)
+    * Support for WavArc (<A HREF="http://www.firstpr.com.au/audiocomp/lossless/wavarc/">http://www.firstpr.com.au/audiocomp/lossless/wavarc/</A>)
+    * Support for WaveZip/MUSICompress (<A HREF="http://hometown.aol.com/sndspace">http://hometown.aol.com/sndspace</A>)
+    * Support for LTAC (<A HREF="http://www.nue.tu-berlin.de/wer/liebchen/ltac.html">http://www.nue.tu-berlin.de/wer/liebchen/ltac.html</A>)
+  * Support for RIFF-INFO chunks
+    * <A HREF="http://lotto.st-andrews.ac.uk/~njh/tag_interchange.html">http://lotto.st-andrews.ac.uk/~njh/tag_interchange.html</A>
+      (thanks Nick Humfrey &lt;njh&#216;surgeradio*co*uk&gt;)
+    * <A HREF="http://abcavi.narod.ru/sof/abcavi/infotags.htm">http://abcavi.narod.ru/sof/abcavi/infotags.htm</A>
+      (thanks Kibi)
+  * Better support for Bink video
+  * <A HREF="http://www.hr/josip/DSP/AudioFile2.html">http://www.hr/josip/DSP/AudioFile2.html</A>
+  * <A HREF="http://www.pcisys.net/~melanson/codecs/">http://www.pcisys.net/~melanson/codecs/</A>
+  * <A HREF="http://sox.sourceforge.net/AudioFormats-11.html">http://sox.sourceforge.net/AudioFormats-11.html</A>
+    * DiamondWare Digitized .dwd
+    * Tandy Deskmate .snd
+    * Sample Vision
+  * Detect mp3PRO
+  * Support for PSD
+  * Support for JPC
+  * Support for JP2
+  * Support for JPX
+  * Support for JB2
+  * Support for IFF
+  * Support for ICO
+  * Support for ANI
+  * Support for EXE (comments, author, etc) (thanks p*quaedackers&#216;planet*nl)
+  * Support for DVD-IFO (region, subtitles, aspect ratio, etc)
+    (thanks p*quaedackers&#216;planet*nl)
+  * More complete support for SWF - parsing encapsulated MP3 and/or JPEG content
+      (thanks n8n8&#216;yahoo*com)
+  * Support for a2b
+  * MPC-SV8 (<A HREF="http://www.uni-jena.de/~pfk/mpp/sv8/components.html">http://www.uni-jena.de/~pfk/mpp/sv8/components.html</A>)
+    <A HREF="http://www.personal.uni-jena.de/~pfk/mpp/">http://www.personal.uni-jena.de/~pfk/mpp/</A>
+  * Optional scan-through-frames for AVI verification
+    (thanks rockcohen&#216;massive-interactive*nl)
+  * Support for TTF (thanks info&#216;butterflyx*com)
+  * Support for DSS (<A HREF="http://www.getid3.org/phpBB2/viewtopic.php?t=171">http://www.getid3.org/phpBB2/viewtopic.php?t=171</A>)
+  * Support for SMAF (<A HREF="http://smaf-yamaha.com/what/demo.html">http://smaf-yamaha.com/what/demo.html</A>)
+    <A HREF="http://www.getid3.org/phpBB2/viewtopic.php?t=182">http://www.getid3.org/phpBB2/viewtopic.php?t=182</A>
+  * Support for AMR (<A HREF="http://www.getid3.org/phpBB2/viewtopic.php?t=195">http://www.getid3.org/phpBB2/viewtopic.php?t=195</A>)
+  * Support for 3gpp (<A HREF="http://www.getid3.org/phpBB2/viewtopic.php?t=195">http://www.getid3.org/phpBB2/viewtopic.php?t=195</A>)
+  * Support for ID4 (<A HREF="http://www.wackysoft.cjb.net">http://www.wackysoft.cjb.net</A> grizlyY2K&#216;hotmail*com)
+  * Parse XML data returned in Ogg comments
+  * Parse XML data from Quicktime SMIL metafiles (klausrath&#216;mac*com)
+  * ID3v2.2 tag writing support
+  * ID3v2 genre string creator function
+  * Support for optional XML-format output (thanks moisei for the idea)
+  * More complete parsing of JPG
+  * Support for all old-style ASF packets
+  * ASF framerate guess
+  * ASF/WMA/WMV tag writing
+  * Parse declared T??? ID3v2 text information frames, where appropriate
+      (thanks Christian Fritz for the idea)
+  * Recognize encoder:
+    <A HREF="http://www.guerillasoft.com/EncSpot2/index.html">http://www.guerillasoft.com/EncSpot2/index.html</A>
+    <A HREF="http://ff123.net/identify.html">http://ff123.net/identify.html</A>
+    <A HREF="http://www.hydrogenaudio.org/?act=ST&amp;f=16&amp;t=9414">http://www.hydrogenaudio.org/?act=ST&amp;f=16&amp;t=9414</A>
+    <A HREF="http://www.hydrogenaudio.org/?showtopic=11785">http://www.hydrogenaudio.org/?showtopic=11785</A>
+  * Support for other OS/2 bitmap structures: Bitmap Array('BA'),
+    Color Icon('CI'), Color Pointer('CP'), Icon('IC'), Pointer ('PT')
+    <A HREF="http://netghost.narod.ru/gff/graphics/summary/os2bmp.htm">http://netghost.narod.ru/gff/graphics/summary/os2bmp.htm</A>
+  * Support for WavPack RAW mode
+  * ASF/WMA/WMV data packet parsing
+  * ID3v2FrameFlagsLookupTagAlter()
+  * ID3v2FrameFlagsLookupFileAlter()
+  * obey ID3v2 tag alter/preserve/discard rules
+  * <A HREF="http://www.geocities.com/SiliconValley/Sector/9654/Softdoc/Illyrium/Aolyr.htm">http://www.geocities.com/SiliconValley/Sector/9654/Softdoc/Illyrium/Aolyr.htm</A>
+  * proper checking for LINK/LNK frame validity in ID3v2 writing
+  * proper checking for ASPI-TLEN frame validity in ID3v2 writing
+  * proper checking for COMR frame validity in ID3v2 writing
+  * <A HREF="http://www.geocities.co.jp/SiliconValley-Oakland/3664/index.html">http://www.geocities.co.jp/SiliconValley-Oakland/3664/index.html</A>
+  * decode GEOB ID3v2 structure as encoded by RealJukebox,
+    decode NCON ID3v2 structure as encoded by MusicMatch
+    (probably won't happen - the formats are proprietary)
+
+
+ Known Bugs/Issues in getID3() that may be fixed eventually
+ -----------------------------------------------------------
+
+  * Cannot determine bitrate for MPEG video with VBR video data
+    (need documentation)
+  * Interlace/progressive cannot be determined for MPEG video
+    (need documentation)
+  * MIDI playtime is sometimes inaccurate
+  * AAC-RAW mode files cannot be identified
+  * WavPack-RAW mode files cannot be identified
+  * mp4 files report lots of &quot;Unknown QuickTime atom type&quot;
+     (need documentation)
+  * Encrypted ASF/WMA/WMV files warn about &quot;unhandled GUID
+    ASF_Content_Encryption_Object&quot;
+  * Bitrate split between audio and video cannot be calculated for
+    NSV, only the total bitrate. (need documentation)
+  * All Ogg formats (Vorbis, OggFLAC, Speex) are affected by the
+    problem of large VorbisComments spanning multiple Ogg pages, but
+    but only OggVorbis files can be processed with vorbiscomment.
+  * The version of &quot;head&quot; supplied with Mac OS 10.2.8 (maybe other
+    versions too) does only understands a single option (-n) and
+    therefore fails. getID3 ignores this and returns wrong md5_data.
+
+
+
+ Known Bugs/Issues in getID3() that cannot be fixed
+ --------------------------------------------------
+
+  * Files larger than 2GB (of any format) cannot be parsed by
+    getID3() due to limitations in the PHP filesystem functions
+
+
+ Known Bugs/Issues in other programs
+ -----------------------------------
+
+  * Winamp (up to v2.80 at least) does not support ID3v2.4 tags,
+      only ID3v2.3
+      see: <A HREF="http://forums.winamp.com/showthread.php?postid=387524">http://forums.winamp.com/showthread.php?postid=387524</A>
+  * Some versions of Helium2 (www.helium2.com) do not write
+      ID3v2.4-compliant Frame Sizes, even though the tag is marked
+      as ID3v2.4)  (detected by getID3())
+  * MP3ext V3.3.17 places a non-compliant padding string at the end
+      of the ID3v2 header. This is supposedly fixed in v3.4b21 but
+      only if you manually add a registry key. This fix is not yet
+      confirmed.  (detected by getID3())
+  * CDex v1.40 (fixed by v1.50b7) writes non-compliant Ogg comment
+      strings, supposed to be in the format &quot;NAME=value&quot; but actually
+      written just &quot;value&quot;  (detected by getID3())
+  * Oggenc 0.9-rc3 flags the encoded file as ABR whether it's
+      actually ABR or VBR.
+  * iTunes (versions &quot;X v2.0.3&quot;, &quot;v3.0.1&quot; are known-guilty, probably
+      other versions are too) writes ID3v2.3 comment tags using a
+      frame name 'COM ' which is not valid for ID3v2.3+ (it's an
+      ID3v2.2-style frame name)  (detected by getID3())
+  * MP2enc does not encode mono CBR MP2 files properly (half speed
+      sound and double playtime)
+  * MP2enc does not encode mono VBR MP2 files properly (actually
+      encoded as stereo)
+  * tooLAME does not encode mono VBR MP2 files properly (actually
+      encoded as stereo)
+  * AACenc encodes files in VBR mode (actually ABR) even if CBR is
+     specified
+  * AAC/ADIF - bitrate_mode = cbr for vbr files
+  * LAME 3.90-3.92 prepends one frame of null data (space for the
+    LAME/VBR header, but it never gets written) when encoding in CBR
+    mode with the DLL
+  * Ahead Nero encodes TwinVQF with a DSIZ value (which is supposed
+    to be the filesize in bytes) of &quot;0&quot; for TwinVQF v1.0 and &quot;1&quot; for
+    TwinVQF v2.0  (detected by getID3())
+  * Ahead Nero encodes TwinVQF files 1 second shorter than they
+    should be
+  * AAC-ADTS files are always actually encoded VBR, even if CBR mode
+    is specified (the CBR-mode switches on the encoder enable ABR
+    mode, not CBR as such, but it's not possible to tell the
+    difference between such ABR files and true VBR)
+  * STREAMINFO.audio_signature in OggFLAC is always null. &quot;The reason
+    it's like that is because there is no seeking support in
+    libOggFLAC yet, so it has no way to go back and write the
+    computed sum after encoding. Seeking support in Ogg FLAC is the
+    #1 item for the next release.&quot; - Josh Coalson (FLAC developer)
+    NOTE: getID3() will calculate md5_data in a method similar to
+    other file formats, but that value cannot be compared to the
+    md5_data value from FLAC data in a FLAC file format.
+  * STREAMINFO.audio_signature is not calculated in FLAC v0.3.0 &amp;
+    v0.4.0 - getID3() will calculate md5_data in a method similar to
+    other file formats, but that value cannot be compared to the
+    md5_data value from FLAC v0.5.0+
+  * RioPort (various versions including 2.0 and 3.11) tags ID3v2 with
+    a WCOM frame that has no data portion
+  * Earlier versions of Coolplayer adds illegal ID3 tags to Ogg Vorbis
+    files, thus making them corrupt.
+  * Meracl ID3 Tag Writer v1.3.4 (and older) incorrectly truncates the
+    last byte of data from an MP3 file when appending a new ID3v1 tag.
+    (detected by getID3())
+  * Lossless-Audio files encoded with and without the -noseek switch
+    do actually differ internally and therefore cannot match md5_data
+  * iTunes has been known to append a new ID3v1 tag on the end of an
+    existing ID3v1 tag when ID3v2 tag is also present
+    (detected by getID3())

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.audioinfo.class.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.audioinfo.class.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.audioinfo.class.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,319 @@
+&lt;?php
+
+// +----------------------------------------------------------------------+
+// | PHP version 4.1.0                                                    |
+// +----------------------------------------------------------------------+
+// | Placed in public domain by Allan Hansen, 2002. Share and enjoy!      |
+// +----------------------------------------------------------------------+
+// | /demo/demo.audioinfo.class.php                                       |
+// |                                                                      |
+// | Example wrapper class to extract information from audio files        |
+// | through getID3().                                                    |
+// |                                                                      |
+// | getID3() returns a lot of information. Much of this information is   |
+// | not needed for the end-application. It is also possible that some    |
+// | users want to extract specific info. Modifying getID3() files is a   |
+// | bad idea, as modifications needs to be done to future versions of    |
+// | getID3().                                                            |
+// |                                                                      |
+// | Modify this wrapper class instead. This example extracts certain     |
+// | fields only and adds a new root value - encoder_options if possible. |
+// | It also checks for mp3 files with wave headers.                      |
+// +----------------------------------------------------------------------+
+// | Example code:                                                        |
+// |   $au = new AudioInfo();                                             |
+// |   print_r($au-&gt;Info('file.flac');                                    |
+// +----------------------------------------------------------------------+
+// | Authors: Allan Hansen &lt;ah&#216;artemis*dk&gt;                                |
+// +----------------------------------------------------------------------+
+//
+
+
+
+/**
+* getID3() settings
+*/
+
+require_once('../getid3/getid3.php');
+
+
+
+
+/**
+* Class for extracting information from audio files with getID3().
+*/
+
+class AudioInfo {
+
+	/**
+	* Private variables
+	*/
+	var $result = NULL;
+	var $info   = NULL;
+
+
+
+
+	/**
+	* Constructor
+	*/
+
+	function AudioInfo() {
+
+		// Initialize getID3 engine
+		$this-&gt;getID3 = new getID3;
+		$this-&gt;getID3-&gt;option_md5_data        = true;
+		$this-&gt;getID3-&gt;option_md5_data_source = true;
+		$this-&gt;getID3-&gt;encoding               = 'UTF-8';
+	}
+
+
+
+
+	/**
+	* Extract information - only public function
+	*
+	* @access   public
+	* @param    string  file    Audio file to extract info from.
+	*/
+
+	function Info($file) {
+
+		// Analyze file
+		$this-&gt;info = $this-&gt;getID3-&gt;analyze($file);
+
+		// Exit here on error
+		if (isset($this-&gt;info['error'])) {
+			return array ('error' =&gt; $this-&gt;info['error']);
+		}
+
+		// Init wrapper object
+		$this-&gt;result = array ();
+		$this-&gt;result['format_name']     = @$this-&gt;info['fileformat'].'/'.@$this-&gt;info['audio']['dataformat'].(isset($this-&gt;info['video']['dataformat']) ? '/'.@$this-&gt;info['video']['dataformat'] : '');
+		$this-&gt;result['encoder_version'] = @$this-&gt;info['audio']['encoder'];
+		$this-&gt;result['encoder_options'] = @$this-&gt;info['audio']['encoder_options'];
+		$this-&gt;result['bitrate_mode']    = @$this-&gt;info['audio']['bitrate_mode'];
+		$this-&gt;result['channels']        = @$this-&gt;info['audio']['channels'];
+		$this-&gt;result['sample_rate']     = @$this-&gt;info['audio']['sample_rate'];
+		$this-&gt;result['bits_per_sample'] = @$this-&gt;info['audio']['bits_per_sample'];
+		$this-&gt;result['playing_time']    = @$this-&gt;info['playtime_seconds'];
+		$this-&gt;result['avg_bit_rate']    = @$this-&gt;info['audio']['bitrate'];
+		$this-&gt;result['tags']            = @$this-&gt;info['tags'];
+		$this-&gt;result['comments']        = @$this-&gt;info['comments'];
+		$this-&gt;result['warning']         = @$this-&gt;info['warning'];
+		$this-&gt;result['md5']             = @$this-&gt;info['md5_data'];
+
+		// Post getID3() data handling based on file format
+		$method = @$this-&gt;info['fileformat'].'Info';
+		if (@$this-&gt;info['fileformat'] &amp;&amp; method_exists($this, $method)) {
+			$this-&gt;$method();
+		}
+
+		return $this-&gt;result;
+	}
+
+
+
+
+	/**
+	* post-getID3() data handling for AAC files.
+	*
+	* @access   private
+	*/
+
+	function aacInfo() {
+		$this-&gt;result['format_name']     = 'AAC';
+	}
+
+
+
+
+	/**
+	* post-getID3() data handling for Wave files.
+	*
+	* @access   private
+	*/
+
+	function riffInfo() {
+		if ($this-&gt;info['audio']['dataformat'] == 'wav') {
+
+			$this-&gt;result['format_name'] = 'Wave';
+
+		} else if (ereg('^mp[1-3]$', $this-&gt;info['audio']['dataformat'])) {
+
+			$this-&gt;result['format_name'] = strtoupper($this-&gt;info['audio']['dataformat']);
+
+		} else {
+
+			$this-&gt;result['format_name'] = 'riff/'.$this-&gt;info['audio']['dataformat'];
+
+		}
+	}
+
+
+
+
+	/**
+	* * post-getID3() data handling for FLAC files.
+	*
+	* @access   private
+	*/
+
+	function flacInfo() {
+		$this-&gt;result['format_name']     = 'FLAC';
+	}
+
+
+
+
+
+	/**
+	* post-getID3() data handling for Monkey's Audio files.
+	*
+	* @access   private
+	*/
+
+	function macInfo() {
+		$this-&gt;result['format_name']     = 'Monkey\'s Audio';
+	}
+
+
+
+
+
+	/**
+	* post-getID3() data handling for Lossless Audio files.
+	*
+	* @access   private
+	*/
+
+	function laInfo() {
+		$this-&gt;result['format_name']     = 'La';
+	}
+
+
+
+
+
+	/**
+	* post-getID3() data handling for Ogg Vorbis files.
+	*
+	* @access   private
+	*/
+
+	function oggInfo() {
+		if ($this-&gt;info['audio']['dataformat'] == 'vorbis') {
+
+			$this-&gt;result['format_name']     = 'Ogg Vorbis';
+
+		} else if ($this-&gt;info['audio']['dataformat'] == 'flac') {
+
+			$this-&gt;result['format_name'] = 'Ogg FLAC';
+
+		} else if ($this-&gt;info['audio']['dataformat'] == 'speex') {
+
+			$this-&gt;result['format_name'] = 'Ogg Speex';
+
+		} else {
+
+			$this-&gt;result['format_name'] = 'Ogg '.$this-&gt;info['audio']['dataformat'];
+
+		}
+	}
+
+
+
+
+	/**
+	* post-getID3() data handling for Musepack files.
+	*
+	* @access   private
+	*/
+
+	function mpcInfo() {
+		$this-&gt;result['format_name']     = 'Musepack';
+	}
+
+
+
+
+	/**
+	* post-getID3() data handling for MPEG files.
+	*
+	* @access   private
+	*/
+
+	function mp3Info() {
+		$this-&gt;result['format_name']     = 'MP3';
+	}
+
+
+
+
+	/**
+	* post-getID3() data handling for MPEG files.
+	*
+	* @access   private
+	*/
+
+	function mp2Info() {
+		$this-&gt;result['format_name']     = 'MP2';
+	}
+
+
+
+
+
+	/**
+	* post-getID3() data handling for MPEG files.
+	*
+	* @access   private
+	*/
+
+	function mp1Info() {
+		$this-&gt;result['format_name']     = 'MP1';
+	}
+
+
+
+
+	/**
+	* post-getID3() data handling for WMA files.
+	*
+	* @access   private
+	*/
+
+	function asfInfo() {
+		$this-&gt;result['format_name']     = strtoupper($this-&gt;info['audio']['dataformat']);
+	}
+
+
+
+	/**
+	* post-getID3() data handling for Real files.
+	*
+	* @access   private
+	*/
+
+	function realInfo() {
+		$this-&gt;result['format_name']     = 'Real';
+	}
+
+
+
+
+
+	/**
+	* post-getID3() data handling for VQF files.
+	*
+	* @access   private
+	*/
+
+	function vqfInfo() {
+		$this-&gt;result['format_name']     = 'VQF';
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.basic.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.basic.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.basic.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,38 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.basic.php - part of getID3()                     //
+// Sample script showing most basic use of getID3()            //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+// include getID3() library (can be in a different directory if full path is specified)
+require_once('../getid3/getid3.php');
+
+// Initialize getID3 engine
+$getID3 = new getID3;
+
+// Analyze file and store returned data in $ThisFileInfo
+$ThisFileInfo = $getID3-&gt;analyze($filename);
+
+// Optional: copies data from all subarrays of [tags] into [comments] so
+// metadata is all available in one location for all tag formats
+// metainformation is always available under [tags] even if this is not called
+getid3_lib::CopyTagsToComments($ThisFileInfo);
+
+// Output desired information in whatever format you want
+// Note: all entries in [comments] or [tags] are arrays of strings
+// See structure.txt for information on what information is available where
+// or check out the output of /demos/demo.browse.php for a particular file
+// to see the full detail of what information is returned where in the array
+echo @$ThisFileInfo['comments_html']['artist'][0]; // artist from any/all available tag formats
+echo @$ThisFileInfo['tags']['id3v2']['title'][0];  // title from ID3v2
+echo @$ThisFileInfo['audio']['bitrate'];           // audio bitrate
+echo @$ThisFileInfo['playtime_string'];            // playtime in minutes:seconds, formatted string
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.browse.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.browse.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.browse.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,645 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.browse.php - part of getID3()                     //
+// Sample script for browsing/scanning files and displaying    //
+// information returned by getID3()                            //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+
+/////////////////////////////////////////////////////////////////
+// set predefined variables as if magic_quotes_gpc was off,
+// whether the server's got it or not:
+UnifyMagicQuotes(false);
+/////////////////////////////////////////////////////////////////
+
+
+/////////////////////////////////////////////////////////////////
+// showfile is used to display embedded images from table_var_dump()
+// md5 of requested file is required to prevent abuse where any
+// random file on the server could be viewed
+if (@$_REQUEST['showfile']) {
+	if (is_readable($_REQUEST['showfile'])) {
+		if (md5_file($_REQUEST['showfile']) == @$_REQUEST['md5']) {
+			readfile($_REQUEST['showfile']);
+			exit;
+		}
+	}
+	die('Cannot display &quot;'.$_REQUEST['showfile'].'&quot;');
+}
+/////////////////////////////////////////////////////////////////
+
+
+if (!function_exists('getmicrotime')) {
+	function getmicrotime() {
+		list($usec, $sec) = explode(' ', microtime());
+		return ((float) $usec + (float) $sec);
+	}
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+
+$writescriptfilename = 'demo.write.php';
+
+require_once('../getid3/getid3.php');
+
+// Initialize getID3 engine
+$getID3 = new getID3;
+$getID3-&gt;encoding = 'UTF-8';
+
+$getID3checkColor_Head           = 'CCCCDD';
+$getID3checkColor_DirectoryLight = 'FFCCCC';
+$getID3checkColor_DirectoryDark  = 'EEBBBB';
+$getID3checkColor_FileLight      = 'EEEEEE';
+$getID3checkColor_FileDark       = 'DDDDDD';
+$getID3checkColor_UnknownLight   = 'CCCCFF';
+$getID3checkColor_UnknownDark    = 'BBBBDD';
+
+
+///////////////////////////////////////////////////////////////////////////////
+
+
+header('Content-Type: text/html; charset=UTF-8');
+ob_start();
+echo '&lt;html&gt;&lt;head&gt;';
+echo '&lt;title&gt;getID3() - /demo/demo.browse.php (sample script)&lt;/title&gt;';
+echo '&lt;style&gt;BODY,TD,TH { font-family: sans-serif; font-size: 9pt; }&lt;/style&gt;';
+echo '&lt;/head&gt;&lt;body&gt;';
+
+if (isset($_REQUEST['deletefile'])) {
+	if (file_exists($_REQUEST['deletefile'])) {
+		if (unlink($_REQUEST['deletefile'])) {
+			$deletefilemessage = 'Successfully deleted '.addslashes($_REQUEST['deletefile']);
+		} else {
+			$deletefilemessage = 'FAILED to delete '.addslashes($_REQUEST['deletefile']).' - error deleting file';
+		}
+	} else {
+		$deletefilemessage = 'FAILED to delete '.addslashes($_REQUEST['deletefile']).' - file does not exist';
+	}
+	if (isset($_REQUEST['noalert'])) {
+		echo '&lt;b&gt;&lt;font color=&quot;'.(($deletefilemessage{0} == 'F') ? '#FF0000' : '#008000').'&quot;&gt;'.$deletefilemessage.'&lt;/font&gt;&lt;/b&gt;&lt;hr&gt;';
+	} else {
+		echo '&lt;script language=&quot;JavaScript&quot;&gt;alert(&quot;'.$deletefilemessage.'&quot;);&lt;/script&gt;';
+	}
+}
+
+
+if (isset($_REQUEST['filename'])) {
+
+	if (!file_exists($_REQUEST['filename'])) {
+		die(getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-8', $_REQUEST['filename'].' does not exist'));
+	}
+	$starttime = getmicrotime();
+	$AutoGetHashes = (bool) (filesize($_REQUEST['filename']) &lt; 52428800); // auto-get md5_data, md5_file, sha1_data, sha1_file if filesize &lt; 50MB
+
+	$getID3-&gt;option_md5_data  = $AutoGetHashes;
+	$getID3-&gt;option_sha1_data = $AutoGetHashes;
+	$ThisFileInfo = $getID3-&gt;analyze($_REQUEST['filename']);
+	if ($AutoGetHashes) {
+		$ThisFileInfo['md5_file']  = getid3_lib::md5_file($_REQUEST['filename']);
+		$ThisFileInfo['sha1_file'] = getid3_lib::sha1_file($_REQUEST['filename']);
+	}
+
+
+	getid3_lib::CopyTagsToComments($ThisFileInfo);
+
+	$listdirectory = dirname(getid3_lib::SafeStripSlashes($_REQUEST['filename']));
+	$listdirectory = realpath($listdirectory); // get rid of /../../ references
+
+	if (GETID3_OS_ISWINDOWS) {
+		// this mostly just gives a consistant look to Windows and *nix filesystems
+		// (windows uses \ as directory seperator, *nix uses /)
+		$listdirectory = str_replace('\\', '/', $listdirectory.'/');
+	}
+
+	if (strstr($_REQUEST['filename'], '<A HREF="http://">http://</A>') || strstr($_REQUEST['filename'], '<A HREF="ftp://">ftp://</A>')) {
+		echo '&lt;i&gt;Cannot browse remote filesystems&lt;/i&gt;&lt;br&gt;';
+	} else {
+		echo 'Browse: &lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?listdirectory='.urlencode($listdirectory).'&quot;&gt;'.getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-8', $listdirectory).'&lt;/a&gt;&lt;br&gt;';
+	}
+
+	echo table_var_dump($ThisFileInfo);
+	$endtime = getmicrotime();
+	echo 'File parsed in '.number_format($endtime - $starttime, 3).' seconds.&lt;br&gt;';
+
+} else {
+
+	$listdirectory = (isset($_REQUEST['listdirectory']) ? getid3_lib::SafeStripSlashes($_REQUEST['listdirectory']) : '.');
+	$listdirectory = realpath($listdirectory); // get rid of /../../ references
+	$currentfulldir = $listdirectory.'/';
+
+	if (GETID3_OS_ISWINDOWS) {
+		// this mostly just gives a consistant look to Windows and *nix filesystems
+		// (windows uses \ as directory seperator, *nix uses /)
+		$currentfulldir = str_replace('\\', '/', $listdirectory.'/');
+	}
+
+	if ($handle = @opendir($listdirectory)) {
+
+		echo str_repeat(' ', 300); // IE buffers the first 300 or so chars, making this progressive display useless - fill the buffer with spaces
+		echo 'Processing';
+
+		$starttime = getmicrotime();
+
+		$TotalScannedUnknownFiles  = 0;
+		$TotalScannedKnownFiles    = 0;
+		$TotalScannedPlaytimeFiles = 0;
+		$TotalScannedBitrateFiles  = 0;
+		$TotalScannedFilesize      = 0;
+		$TotalScannedPlaytime      = 0;
+		$TotalScannedBitrate       = 0;
+		$FilesWithWarnings         = 0;
+		$FilesWithErrors           = 0;
+
+		while ($file = readdir($handle)) {
+			set_time_limit(30); // allocate another 30 seconds to process this file - should go much quicker than this unless intense processing (like bitrate histogram analysis) is enabled
+			echo ' .'; // progress indicator dot
+			flush();  // make sure the dot is shown, otherwise it's useless
+			$currentfilename = $listdirectory.'/'.$file;
+
+			switch ($file) {
+				case '..':
+					$ParentDir = realpath($file.'/..').'/';
+					if (GETID3_OS_ISWINDOWS) {
+						$ParentDir = str_replace('\\', '/', $ParentDir);
+					}
+					$DirectoryContents[$currentfulldir]['dir'][$file]['filename'] = $ParentDir;
+					continue 2;
+					break;
+
+				case '.':
+					// ignore
+					continue 2;
+					break;
+			}
+
+			// symbolic-link-resolution enhancements by davidbullock&#216;tech-center*com
+			$TargetObject     = realpath($currentfilename);  // Find actual file path, resolve if it's a symbolic link
+			$TargetObjectType = filetype($TargetObject);     // Check file type without examining extension
+
+			if ($TargetObjectType == 'dir') {
+
+				$DirectoryContents[$currentfulldir]['dir'][$file]['filename'] = $file;
+
+			} elseif ($TargetObjectType == 'file') {
+
+				$getID3-&gt;option_md5_data = isset($_REQUEST['ShowMD5']);
+				$fileinformation = $getID3-&gt;analyze($currentfilename);
+
+				getid3_lib::CopyTagsToComments($fileinformation);
+
+				$TotalScannedFilesize += @$fileinformation['filesize'];
+
+				if (isset($_REQUEST['ShowMD5'])) {
+					$fileinformation['md5_file'] = md5($currentfilename);
+					$fileinformation['md5_file']  = getid3_lib::md5_file($currentfilename);
+				}
+
+				if (!empty($fileinformation['fileformat'])) {
+					$DirectoryContents[$currentfulldir]['known'][$file] = $fileinformation;
+					$TotalScannedPlaytime += @$fileinformation['playtime_seconds'];
+					$TotalScannedBitrate  += @$fileinformation['bitrate'];
+					$TotalScannedKnownFiles++;
+				} else {
+					$DirectoryContents[$currentfulldir]['other'][$file] = $fileinformation;
+					$DirectoryContents[$currentfulldir]['other'][$file]['playtime_string'] = '-';
+					$TotalScannedUnknownFiles++;
+				}
+				if (isset($fileinformation['playtime_seconds']) &amp;&amp; ($fileinformation['playtime_seconds'] &gt; 0)) {
+					$TotalScannedPlaytimeFiles++;
+				}
+				if (isset($fileinformation['bitrate']) &amp;&amp; ($fileinformation['bitrate'] &gt; 0)) {
+					$TotalScannedBitrateFiles++;
+				}
+			}
+		}
+		$endtime = getmicrotime();
+		closedir($handle);
+		echo 'done&lt;br&gt;';
+		echo 'Directory scanned in '.number_format($endtime - $starttime, 2).' seconds.&lt;br&gt;';
+		flush();
+
+		$columnsintable = 14;
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+
+		echo '&lt;tr bgcolor=&quot;#'.$getID3checkColor_Head.'&quot;&gt;&lt;th colspan=&quot;'.$columnsintable.'&quot;&gt;Files in '.getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-8', $currentfulldir).'&lt;/th&gt;&lt;/tr&gt;';
+		$rowcounter = 0;
+		foreach ($DirectoryContents as $dirname =&gt; $val) {
+			if (is_array($DirectoryContents[$dirname]['dir'])) {
+				uksort($DirectoryContents[$dirname]['dir'], 'MoreNaturalSort');
+				foreach ($DirectoryContents[$dirname]['dir'] as $filename =&gt; $fileinfo) {
+					echo '&lt;tr bgcolor=&quot;#'.(($rowcounter++ % 2) ? $getID3checkColor_DirectoryLight : $getID3checkColor_DirectoryDark).'&quot;&gt;';
+					if ($filename == '..') {
+						echo '&lt;form action=&quot;'.$_SERVER['PHP_SELF'].'&quot; method=&quot;get&quot;&gt;';
+						echo '&lt;td colspan=&quot;'.$columnsintable.'&quot;&gt;Parent directory: ';
+						echo '&lt;input type=&quot;text&quot; name=&quot;listdirectory&quot; size=&quot;50&quot; style=&quot;background-color: '.$getID3checkColor_DirectoryDark.';&quot; value=&quot;';
+						if (GETID3_OS_ISWINDOWS) {
+							echo htmlentities(str_replace('\\', '/', realpath($dirname.$filename)), ENT_QUOTES);
+						} else {
+							echo htmlentities(realpath($dirname.$filename), ENT_QUOTES);
+						}
+						echo '&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Go&quot;&gt;';
+						echo '&lt;/td&gt;&lt;/form&gt;';
+					} else {
+						echo '&lt;td colspan=&quot;'.$columnsintable.'&quot;&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?listdirectory='.urlencode($dirname.$filename).'&quot;&gt;&lt;b&gt;'.FixTextFields($filename).'&lt;/b&gt;&lt;/a&gt;&lt;/td&gt;';
+					}
+					echo '&lt;/tr&gt;';
+				}
+			}
+
+			echo '&lt;tr bgcolor=&quot;#'.$getID3checkColor_Head.'&quot;&gt;';
+			echo '&lt;th&gt;Filename&lt;/th&gt;';
+			echo '&lt;th&gt;File Size&lt;/th&gt;';
+			echo '&lt;th&gt;Format&lt;/th&gt;';
+			echo '&lt;th&gt;Playtime&lt;/th&gt;';
+			echo '&lt;th&gt;Bitrate&lt;/th&gt;';
+			echo '&lt;th&gt;Artist&lt;/th&gt;';
+			echo '&lt;th&gt;Title&lt;/th&gt;';
+			if (isset($_REQUEST['ShowMD5'])) {
+				echo '&lt;th&gt;MD5&nbsp;File (File) (&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?listdirectory='.rawurlencode(isset($_REQUEST['listdirectory']) ? $_REQUEST['listdirectory'] : '.').'&quot;&gt;disable&lt;/a&gt;)&lt;/th&gt;';
+				echo '&lt;th&gt;MD5&nbsp;Data (File) (&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?listdirectory='.rawurlencode(isset($_REQUEST['listdirectory']) ? $_REQUEST['listdirectory'] : '.').'&quot;&gt;disable&lt;/a&gt;)&lt;/th&gt;';
+				echo '&lt;th&gt;MD5&nbsp;Data (Source) (&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?listdirectory='.rawurlencode(isset($_REQUEST['listdirectory']) ? $_REQUEST['listdirectory'] : '.').'&quot;&gt;disable&lt;/a&gt;)&lt;/th&gt;';
+			} else {
+				echo '&lt;th colspan=&quot;3&quot;&gt;MD5&nbsp;Data (&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?listdirectory='.rawurlencode(isset($_REQUEST['listdirectory']) ? $_REQUEST['listdirectory'] : '.').'&amp;ShowMD5=1&quot;&gt;enable&lt;/a&gt;)&lt;/th&gt;';
+			}
+			echo '&lt;th&gt;Tags&lt;/th&gt;';
+			echo '&lt;th&gt;Errors &amp; Warnings&lt;/th&gt;';
+			echo '&lt;th&gt;Edit&lt;/th&gt;';
+			echo '&lt;th&gt;Delete&lt;/th&gt;';
+			echo '&lt;/tr&gt;';
+
+			if (isset($DirectoryContents[$dirname]['known']) &amp;&amp; is_array($DirectoryContents[$dirname]['known'])) {
+				uksort($DirectoryContents[$dirname]['known'], 'MoreNaturalSort');
+				foreach ($DirectoryContents[$dirname]['known'] as $filename =&gt; $fileinfo) {
+					echo '&lt;tr bgcolor=&quot;#'.(($rowcounter++ % 2) ? $getID3checkColor_FileDark : $getID3checkColor_FileLight).'&quot;&gt;';
+					echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?filename='.urlencode($dirname.$filename).'&quot; TITLE=&quot;View detailed analysis&quot;&gt;'.FixTextFields(getid3_lib::SafeStripSlashes($filename)).'&lt;/a&gt;&lt;/td&gt;';
+					echo '&lt;td align=&quot;right&quot;&gt;&nbsp;'.number_format($fileinfo['filesize']).'&lt;/td&gt;';
+					echo '&lt;td align=&quot;right&quot;&gt;&nbsp;'.NiceDisplayFiletypeFormat($fileinfo).'&lt;/td&gt;';
+					echo '&lt;td align=&quot;right&quot;&gt;&nbsp;'.(isset($fileinfo['playtime_string']) ? $fileinfo['playtime_string'] : '-').'&lt;/td&gt;';
+					echo '&lt;td align=&quot;right&quot;&gt;&nbsp;'.(isset($fileinfo['bitrate']) ? BitrateText($fileinfo['bitrate'] / 1000, 0, ((@$fileinfo['audio']['bitrate_mode'] == 'vbr') ? true : false)) : '-').'&lt;/td&gt;';
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;'.(isset($fileinfo['comments_html']['artist']) ? implode('&lt;br&gt;', $fileinfo['comments_html']['artist']) : '').'&lt;/td&gt;';
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;'.(isset($fileinfo['comments_html']['title']) ? implode('&lt;br&gt;', $fileinfo['comments_html']['title']) : '').'&lt;/td&gt;';
+					if (isset($_REQUEST['ShowMD5'])) {
+						echo '&lt;td align=&quot;left&quot;&gt;&lt;tt&gt;'.(isset($fileinfo['md5_file'])        ? $fileinfo['md5_file']        : '&nbsp;').'&lt;/tt&gt;&lt;/td&gt;';
+						echo '&lt;td align=&quot;left&quot;&gt;&lt;tt&gt;'.(isset($fileinfo['md5_data'])        ? $fileinfo['md5_data']        : '&nbsp;').'&lt;/tt&gt;&lt;/td&gt;';
+						echo '&lt;td align=&quot;left&quot;&gt;&lt;tt&gt;'.(isset($fileinfo['md5_data_source']) ? $fileinfo['md5_data_source'] : '&nbsp;').'&lt;/tt&gt;&lt;/td&gt;';
+					} else {
+						echo '&lt;td align=&quot;center&quot; colspan=&quot;3&quot;&gt;-&lt;/td&gt;';
+					}
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;'<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">. at implode</A>(', ', array_keys($fileinfo['tags'])).'&lt;/td&gt;';
+
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;';
+					if (!empty($fileinfo['warning'])) {
+						$FilesWithWarnings++;
+						echo '&lt;a href=&quot;javascript:alert(\''.FixTextFields(implode('\\n', $fileinfo['warning'])).'\');&quot; TITLE=&quot;'.FixTextFields(implode(&quot;\n&quot;, $fileinfo['warning'])).'&quot;&gt;warning&lt;/a&gt;&lt;br&gt;';
+					}
+					if (!empty($fileinfo['error'])) {
+						$FilesWithErrors++;
+						echo '&lt;a href=&quot;javascript:alert(\''.FixTextFields(implode('\\n', $fileinfo['error'])).'\');&quot; TITLE=&quot;'.FixTextFields(implode(&quot;\n&quot;, $fileinfo['error'])).'&quot;&gt;error&lt;/a&gt;&lt;br&gt;';
+					}
+					echo '&lt;/td&gt;';
+
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;';
+					switch (@$fileinfo['fileformat']) {
+						case 'mp3':
+						case 'mp2':
+						case 'mp1':
+						case 'flac':
+						case 'mpc':
+						case 'real':
+							echo '&lt;a href=&quot;'.$writescriptfilename.'?Filename='.urlencode($dirname.$filename).'&quot; TITLE=&quot;Edit tags&quot;&gt;edit&nbsp;tags&lt;/a&gt;';
+							break;
+						case 'ogg':
+							switch (@$fileinfo['audio']['dataformat']) {
+								case 'vorbis':
+									echo '&lt;a href=&quot;'.$writescriptfilename.'?Filename='.urlencode($dirname.$filename).'&quot; TITLE=&quot;Edit tags&quot;&gt;edit&nbsp;tags&lt;/a&gt;';
+									break;
+							}
+							break;
+						default:
+							break;
+					}
+					echo '&lt;/td&gt;';
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?listdirectory='.urlencode($listdirectory).'&amp;deletefile='.urlencode($dirname.$filename).'&quot; onClick=&quot;return confirm(\'Are you sure you want to delete '.addslashes($dirname.$filename).'? \n(this action cannot be un-done)\');&quot; TITLE=&quot;Permanently delete '.&quot;\n&quot;.FixTextFields($filename).&quot;\n&quot;.' from'.&quot;\n&quot;.' '.FixTextFields($dirname).'&quot;&gt;delete&lt;/a&gt;&lt;/td&gt;';
+					echo '&lt;/tr&gt;';
+				}
+			}
+
+			if (isset($DirectoryContents[$dirname]['other']) &amp;&amp; is_array($DirectoryContents[$dirname]['other'])) {
+				uksort($DirectoryContents[$dirname]['other'], 'MoreNaturalSort');
+				foreach ($DirectoryContents[$dirname]['other'] as $filename =&gt; $fileinfo) {
+					echo '&lt;tr bgcolor=&quot;#'.(($rowcounter++ % 2) ? $getID3checkColor_UnknownDark : $getID3checkColor_UnknownLight).'&quot;&gt;';
+					echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?filename='.urlencode($dirname.$filename).'&quot;&gt;&lt;i&gt;'.$filename.'&lt;/i&gt;&lt;/a&gt;&lt;/td&gt;';
+					echo '&lt;td align=&quot;right&quot;&gt;&nbsp;'.(isset($fileinfo['filesize']) ? number_format($fileinfo['filesize']) : '-').'&lt;/td&gt;';
+					echo '&lt;td align=&quot;right&quot;&gt;&nbsp;'.NiceDisplayFiletypeFormat($fileinfo).'&lt;/td&gt;';
+					echo '&lt;td align=&quot;right&quot;&gt;&nbsp;'.(isset($fileinfo['playtime_string']) ? $fileinfo['playtime_string'] : '-').'&lt;/td&gt;';
+					echo '&lt;td align=&quot;right&quot;&gt;&nbsp;'.(isset($fileinfo['bitrate']) ? BitrateText($fileinfo['bitrate'] / 1000) : '-').'&lt;/td&gt;';
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;&lt;/td&gt;'; // Artist
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;&lt;/td&gt;'; // Title
+					echo '&lt;td align=&quot;left&quot; colspan=&quot;3&quot;&gt;&nbsp;&lt;/td&gt;'; // MD5_data
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;&lt;/td&gt;'; // Tags
+
+					//echo '&lt;td align=&quot;left&quot;&gt;&nbsp;&lt;/td&gt;'; // Warning/Error
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;';
+					if (!empty($fileinfo['warning'])) {
+						$FilesWithWarnings++;
+						echo '&lt;a href=&quot;javascript:alert(\''.FixTextFields(implode('\\n', $fileinfo['warning'])).'\');&quot; TITLE=&quot;'.FixTextFields(implode(&quot;\n&quot;, $fileinfo['warning'])).'&quot;&gt;warning&lt;/a&gt;&lt;br&gt;';
+					}
+					if (!empty($fileinfo['error'])) {
+						if ($fileinfo['error'][0] != 'unable to determine file format') {
+							$FilesWithErrors++;
+							echo '&lt;a href=&quot;javascript:alert(\''.FixTextFields(implode('\\n', $fileinfo['error'])).'\');&quot; TITLE=&quot;'.FixTextFields(implode(&quot;\n&quot;, $fileinfo['error'])).'&quot;&gt;error&lt;/a&gt;&lt;br&gt;';
+						}
+					}
+					echo '&lt;/td&gt;';
+
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;&lt;/td&gt;'; // Edit
+					echo '&lt;td align=&quot;left&quot;&gt;&nbsp;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?listdirectory='.urlencode($listdirectory).'&amp;deletefile='.urlencode($dirname.$filename).'&quot; onClick=&quot;return confirm(\'Are you sure you want to delete '.addslashes($dirname.$filename).'? \n(this action cannot be un-done)\');&quot; TITLE=&quot;Permanently delete '.addslashes($dirname.$filename).'&quot;&gt;delete&lt;/a&gt;&lt;/td&gt;';
+					echo '&lt;/tr&gt;';
+				}
+			}
+
+			echo '&lt;tr bgcolor=&quot;#'.$getID3checkColor_Head.'&quot;&gt;';
+			echo '&lt;td&gt;&lt;b&gt;Average:&lt;/b&gt;&lt;/td&gt;';
+			echo '&lt;td align=&quot;right&quot;&gt;'.number_format($TotalScannedFilesize / max($TotalScannedKnownFiles, 1)).'&lt;/td&gt;';
+			echo '&lt;td&gt;&nbsp;&lt;/td&gt;';
+			echo '&lt;td align=&quot;right&quot;&gt;'.getid3_lib::PlaytimeString($TotalScannedPlaytime / max($TotalScannedPlaytimeFiles, 1)).'&lt;/td&gt;';
+			echo '&lt;td align=&quot;right&quot;&gt;'.BitrateText(round(($TotalScannedBitrate / 1000) / max($TotalScannedBitrateFiles, 1))).'&lt;/td&gt;';
+			echo '&lt;td rowspan=&quot;2&quot; colspan=&quot;'.($columnsintable - 5).'&quot;&gt;&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tr&gt;&lt;th align=&quot;right&quot;&gt;Identified Files:&lt;/th&gt;&lt;td align=&quot;right&quot;&gt;'.number_format($TotalScannedKnownFiles).'&lt;/td&gt;&lt;td&gt;&nbsp;&nbsp;&nbsp;&lt;/td&gt;&lt;th align=&quot;right&quot;&gt;Errors:&lt;/th&gt;&lt;td align=&quot;right&quot;&gt;'.number_format($FilesWithErrors).'&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th align=&quot;right&quot;&gt;Unknown Files:&lt;/th&gt;&lt;td align=&quot;right&quot;&gt;'.number_format($TotalScannedUnknownFiles).'&lt;/td&gt;&lt;td&gt;&nbsp;&nbsp;&nbsp;&lt;/td&gt;&lt;th align=&quot;right&quot;&gt;Warnings:&lt;/th&gt;&lt;td align=&quot;right&quot;&gt;'.number_format($FilesWithWarnings).'&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;';
+			echo '&lt;/tr&gt;';
+			echo '&lt;tr bgcolor=&quot;#'.$getID3checkColor_Head.'&quot;&gt;';
+			echo '&lt;td&gt;&lt;b&gt;Total:&lt;/b&gt;&lt;/td&gt;';
+			echo '&lt;td align=&quot;right&quot;&gt;'.number_format($TotalScannedFilesize).'&lt;/td&gt;';
+			echo '&lt;td&gt;&nbsp;&lt;/td&gt;';
+			echo '&lt;td align=&quot;right&quot;&gt;'.getid3_lib::PlaytimeString($TotalScannedPlaytime).'&lt;/td&gt;';
+			echo '&lt;td&gt;&nbsp;&lt;/td&gt;';
+			echo '&lt;/tr&gt;';
+		}
+		echo '&lt;/table&gt;';
+	} else {
+		echo '&lt;b&gt;ERROR: Could not open directory: &lt;u&gt;'.$currentfulldir.'&lt;/u&gt;&lt;/b&gt;&lt;br&gt;';
+	}
+}
+echo PoweredBygetID3();
+echo 'Running on PHP v'.phpversion();
+echo '&lt;/body&gt;&lt;/html&gt;';
+ob_end_flush();
+
+
+/////////////////////////////////////////////////////////////////
+
+
+function RemoveAccents($string) {
+	// Revised version by marksteward&#216;hotmail*com
+	return strtr(strtr($string, '&#138;&#142;&#154;&#158;&#159;&#192;&#193;&#194;&#195;&#196;&#197;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#209;&#210;&#211;&#212;&#213;&#214;&#216;&#217;&#218;&#219;&#220;&#221;&#224;&#225;&#226;&#227;&#228;&#229;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#241;&#242;&#243;&#244;&#245;&#246;&#248;&#249;&#250;&#251;&#252;&#253;&#255;', 'SZszYAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy'), array('&#222;' =&gt; 'TH', '&#254;' =&gt; 'th', '&#208;' =&gt; 'DH', '&#240;' =&gt; 'dh', '&#223;' =&gt; 'ss', '&#140;' =&gt; 'OE', '&#156;' =&gt; 'oe', '&#198;' =&gt; 'AE', '&#230;' =&gt; 'ae', '&#181;' =&gt; 'u'));
+}
+
+
+function BitrateColor($bitrate, $BitrateMaxScale=768) {
+	// $BitrateMaxScale is bitrate of maximum-quality color (bright green)
+	// below this is gradient, above is solid green
+
+	$bitrate *= (256 / $BitrateMaxScale); // scale from 1-[768]kbps to 1-256
+	$bitrate = round(min(max($bitrate, 1), 256));
+	$bitrate--;    // scale from 1-256kbps to 0-255kbps
+
+	$Rcomponent = max(255 - ($bitrate * 2), 0);
+	$Gcomponent = max(($bitrate * 2) - 255, 0);
+	if ($bitrate &gt; 127) {
+		$Bcomponent = max((255 - $bitrate) * 2, 0);
+	} else {
+		$Bcomponent = max($bitrate * 2, 0);
+	}
+	return str_pad(dechex($Rcomponent), 2, '0', STR_PAD_LEFT).str_pad(dechex($Gcomponent), 2, '0', STR_PAD_LEFT).str_pad(dechex($Bcomponent), 2, '0', STR_PAD_LEFT);
+}
+
+function BitrateText($bitrate, $decimals=0, $vbr=false) {
+	return '&lt;SPAN STYLE=&quot;color: #'.BitrateColor($bitrate).($vbr ? '; font-weight: bold;' : '').'&quot;&gt;'.number_format($bitrate, $decimals).' kbps&lt;/SPAN&gt;';
+}
+
+function FixTextFields($text) {
+	$text = getid3_lib::SafeStripSlashes($text);
+	$text = htmlentities($text, ENT_QUOTES);
+	return $text;
+}
+
+
+function string_var_dump($variable) {
+	ob_start();
+	var_dump($variable);
+	$dumpedvariable = ob_get_contents();
+	ob_end_clean();
+	return $dumpedvariable;
+}
+
+
+function table_var_dump($variable) {
+	$returnstring = '';
+	switch (gettype($variable)) {
+		case 'array':
+			$returnstring .= '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;';
+			foreach ($variable as $key =&gt; $value) {
+				$returnstring .= '&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;b&gt;'.str_replace(&quot;\x00&quot;, ' ', $key).'&lt;/b&gt;&lt;/td&gt;';
+				$returnstring .= '&lt;td valign=&quot;top&quot;&gt;'.gettype($value);
+				if (is_array($value)) {
+					$returnstring .= '&nbsp;('.count($value).')';
+				} elseif (is_string($value)) {
+					$returnstring .= '&nbsp;('.strlen($value).')';
+				}
+				if (($key == 'data') &amp;&amp; isset($variable['image_mime']) &amp;&amp; isset($variable['dataoffset'])) {
+					$imagechunkcheck = getid3_lib::GetDataImageSize($value);
+					$DumpedImageSRC = (!empty($_REQUEST['filename']) ? $_REQUEST['filename'] : '.getid3').'.'.$variable['dataoffset'].'.'.getid3_lib::ImageTypesLookup($imagechunkcheck[2]);
+					if ($tempimagefile = @fopen($DumpedImageSRC, 'wb')) {
+						fwrite($tempimagefile, $value);
+						fclose($tempimagefile);
+					}
+					$returnstring .= '&lt;/td&gt;&lt;td&gt;&lt;img src=&quot;'.$_SERVER['PHP_SELF'].'?showfile='.urlencode($DumpedImageSRC).'&amp;md5='.md5_file($DumpedImageSRC).'&quot; width=&quot;'.$imagechunkcheck[0].'&quot; height=&quot;'.$imagechunkcheck[1].'&quot;&gt;&lt;/td&gt;&lt;/tr&gt;';
+				} else {
+					$returnstring .= '&lt;/td&gt;&lt;td&gt;'.table_var_dump($value).'&lt;/td&gt;&lt;/tr&gt;';
+				}
+			}
+			$returnstring .= '&lt;/table&gt;';
+			break;
+
+		case 'boolean':
+			$returnstring .= ($variable ? 'TRUE' : 'FALSE');
+			break;
+
+		case 'integer':
+		case 'double':
+		case 'float':
+			$returnstring .= $variable;
+			break;
+
+		case 'object':
+		case 'null':
+			$returnstring .= string_var_dump($variable);
+			break;
+
+		case 'string':
+			$variable = str_replace(&quot;\x00&quot;, ' ', $variable);
+			$varlen = strlen($variable);
+			for ($i = 0; $i &lt; $varlen; $i++) {
+				if (ereg('['.&quot;\x0A\x0D&quot;.' -;0-9A-Za-z]', $variable{$i})) {
+					$returnstring .= $variable{$i};
+				} else {
+					$returnstring .= '&amp;#'.str_pad(ord($variable{$i}), 3, '0', STR_PAD_LEFT).';';
+				}
+			}
+			$returnstring = nl2br($returnstring);
+			break;
+
+		default:
+			$imagechunkcheck = getid3_lib::GetDataImageSize($variable);
+			if (($imagechunkcheck[2] &gt;= 1) &amp;&amp; ($imagechunkcheck[2] &lt;= 3)) {
+				$returnstring .= '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;';
+				$returnstring .= '&lt;tr&gt;&lt;td&gt;&lt;b&gt;type&lt;/b&gt;&lt;/td&gt;&lt;td&gt;'.getid3_lib::ImageTypesLookup($imagechunkcheck[2]).'&lt;/td&gt;&lt;/tr&gt;';
+				$returnstring .= '&lt;tr&gt;&lt;td&gt;&lt;b&gt;width&lt;/b&gt;&lt;/td&gt;&lt;td&gt;'.number_format($imagechunkcheck[0]).' px&lt;/td&gt;&lt;/tr&gt;';
+				$returnstring .= '&lt;tr&gt;&lt;td&gt;&lt;b&gt;height&lt;/b&gt;&lt;/td&gt;&lt;td&gt;'.number_format($imagechunkcheck[1]).' px&lt;/td&gt;&lt;/tr&gt;';
+				$returnstring .= '&lt;tr&gt;&lt;td&gt;&lt;b&gt;size&lt;/b&gt;&lt;/td&gt;&lt;td&gt;'.number_format(strlen($variable)).' bytes&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;';
+			} else {
+				$returnstring .= nl2br(htmlspecialchars(str_replace(&quot;\x00&quot;, ' ', $variable)));
+			}
+			break;
+	}
+	return $returnstring;
+}
+
+
+function NiceDisplayFiletypeFormat(&amp;$fileinfo) {
+
+	if (empty($fileinfo['fileformat'])) {
+		return '-';
+	}
+
+	$output  = $fileinfo['fileformat'];
+	if (empty($fileinfo['video']['dataformat']) &amp;&amp; empty($fileinfo['audio']['dataformat'])) {
+		return $output;  // 'gif'
+	}
+	if (empty($fileinfo['video']['dataformat']) &amp;&amp; !empty($fileinfo['audio']['dataformat'])) {
+		if ($fileinfo['fileformat'] == $fileinfo['audio']['dataformat']) {
+			return $output; // 'mp3'
+		}
+		$output .= '.'.$fileinfo['audio']['dataformat']; // 'ogg.flac'
+		return $output;
+	}
+	if (!empty($fileinfo['video']['dataformat']) &amp;&amp; empty($fileinfo['audio']['dataformat'])) {
+		if ($fileinfo['fileformat'] == $fileinfo['video']['dataformat']) {
+			return $output; // 'mpeg'
+		}
+		$output .= '.'.$fileinfo['video']['dataformat']; // 'riff.avi'
+		return $output;
+	}
+	if ($fileinfo['video']['dataformat'] == $fileinfo['audio']['dataformat']) {
+		if ($fileinfo['fileformat'] == $fileinfo['video']['dataformat']) {
+			return $output; // 'real'
+		}
+		$output .= '.'.$fileinfo['video']['dataformat']; // any examples?
+		return $output;
+	}
+	$output .= '.'.$fileinfo['video']['dataformat'];
+	$output .= '.'.$fileinfo['audio']['dataformat']; // asf.wmv.wma
+	return $output;
+
+}
+
+function MoreNaturalSort($ar1, $ar2) {
+	if ($ar1 === $ar2) {
+		return 0;
+	}
+	$len1     = strlen($ar1);
+	$len2     = strlen($ar2);
+	$shortest = min($len1, $len2);
+	if (substr($ar1, 0, $shortest) === substr($ar2, 0, $shortest)) {
+		// the shorter argument is the beginning of the longer one, like &quot;str&quot; and &quot;string&quot;
+		if ($len1 &lt; $len2) {
+			return -1;
+		} elseif ($len1 &gt; $len2) {
+			return 1;
+		}
+		return 0;
+	}
+	$ar1 = RemoveAccents(strtolower(trim($ar1)));
+	$ar2 = RemoveAccents(strtolower(trim($ar2)));
+	$translatearray = array('\''=&gt;'', '&quot;'=&gt;'', '_'=&gt;' ', '('=&gt;'', ')'=&gt;'', '-'=&gt;' ', '  '=&gt;' ', '.'=&gt;'', ','=&gt;'');
+	foreach ($translatearray as $key =&gt; $val) {
+		$ar1 = str_replace($key, $val, $ar1);
+		$ar2 = str_replace($key, $val, $ar2);
+	}
+
+	if ($ar1 &lt; $ar2) {
+		return -1;
+	} elseif ($ar1 &gt; $ar2) {
+		return 1;
+	}
+	return 0;
+}
+
+function PoweredBygetID3($string='&lt;br&gt;&lt;HR NOSHADE&gt;&lt;DIV STYLE=&quot;font-size: 8pt; font-face: sans-serif;&quot;&gt;Powered by &lt;a href=&quot;<A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>&quot; TARGET=&quot;_blank&quot;&gt;&lt;b&gt;getID3() v&lt;!--GETID3VER--&gt;&lt;/b&gt;&lt;br&gt;<A HREF="http://getid3.sourceforge.net&lt;/a">http://getid3.sourceforge.net&lt;/a</A>&gt;&lt;/DIV&gt;') {
+	return str_replace('&lt;!--GETID3VER--&gt;', GETID3_VERSION, $string);
+}
+
+
+/////////////////////////////////////////////////////////////////
+// Unify the contents of GPC,
+// whether magic_quotes_gpc is on or off
+
+function AddStripSlashesArray($input, $addslashes=false) {
+	if (is_array($input)) {
+
+		$output = $input;
+		foreach ($input as $key =&gt; $value) {
+			$output[$key] = AddStripSlashesArray($input[$key]);
+		}
+		return $output;
+
+	} elseif ($addslashes) {
+		return addslashes($input);
+	}
+	return stripslashes($input);
+}
+
+function UnifyMagicQuotes($turnon=false) {
+	global $HTTP_GET_VARS, $HTTP_POST_VARS, $HTTP_COOKIE_VARS;
+
+	if (get_magic_quotes_gpc() &amp;&amp; !$turnon) {
+
+		// magic_quotes_gpc is on and we want it off!
+		$_GET    = AddStripSlashesArray($_GET,    true);
+		$_POST   = AddStripSlashesArray($_POST,   true);
+		$_COOKIE = AddStripSlashesArray($_COOKIE, true);
+
+		unset($_REQUEST);
+		$_REQUEST = array_merge_recursive($_GET, $_POST, $_COOKIE);
+
+	} elseif (!get_magic_quotes_gpc() &amp;&amp; $turnon) {
+
+		// magic_quotes_gpc is off and we want it on (why??)
+		$_GET    = AddStripSlashesArray($_GET,    true);
+		$_POST   = AddStripSlashesArray($_POST,   true);
+		$_COOKIE = AddStripSlashesArray($_COOKIE, true);
+
+		unset($_REQUEST);
+		$_REQUEST = array_merge_recursive($_GET, $_POST, $_COOKIE);
+
+	}
+	$HTTP_GET_VARS    = $_GET;
+	$HTTP_POST_VARS   = $_POST;
+	$HTTP_COOKIE_VARS = $_COOKIE;
+
+	return true;
+}
+/////////////////////////////////////////////////////////////////
+
+
+?&gt;
+&lt;/BODY&gt;
+&lt;/HTML&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.cache.dbm.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.cache.dbm.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.cache.dbm.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,29 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.cache.dbm.php - part of getID3()                 //
+// Sample script demonstrating the use of the DBM caching      //
+// extension for getID3()                                      //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+require_once('../getid3/getid3.php');
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'extension.cache.dbm.php', __FILE__, true);
+
+$getID3 = new getID3_cached_dbm('db3', '/zimweb/test/test.dbm', '/zimweb/test/test.lock');
+
+$r = $getID3-&gt;analyze('/path/to/files/filename.mp3');
+
+echo '&lt;pre&gt;';
+var_dump($r);
+echo '&lt;/pre&gt;';
+
+// uncomment to clear cache
+// $getID3-&gt;clear_cache();
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.cache.mysql.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.cache.mysql.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.cache.mysql.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,29 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.cache.mysql.php - part of getID3()               //
+// Sample script demonstrating the use of the DBM caching      //
+// extension for getID3()                                      //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+require_once('../getid3/getid3.php');
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'extension.cache.mysql.php', __FILE__, true);
+
+$getID3 = new getID3_cached_mysql('localhost', 'database', 'username', 'password');
+
+$r = $getID3-&gt;analyze('/path/to/files/filename.mp3');
+
+echo '&lt;pre&gt;';
+var_dump($r);
+echo '&lt;/pre&gt;';
+
+// uncomment to clear cache
+//$getID3-&gt;clear_cache();
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.joinmp3.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.joinmp3.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.joinmp3.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,96 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.joinmp3.php - part of getID3()                   //
+// Sample script for splicing two or more MP3s together into   //
+// one file. Does not attempt to fix VBR header frames.        //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+// sample usage:
+// $FilenameOut   = 'combined.mp3';
+// $FilenamesIn[] = 'file1.mp3';
+// $FilenamesIn[] = 'file2.mp3';
+// $FilenamesIn[] = 'file3.mp3';
+//
+// if (CombineMultipleMP3sTo($FilenameOut, $FilenamesIn)) {
+//     echo 'Successfully copied '.implode(' + ', $FilenamesIn).' to '.$FilenameOut;
+// } else {
+//     echo 'Failed to copy '.implode(' + ', $FilenamesIn).' to '.$FilenameOut;
+// }
+
+function CombineMultipleMP3sTo($FilenameOut, $FilenamesIn) {
+
+	foreach ($FilenamesIn as $nextinputfilename) {
+		if (!is_readable($nextinputfilename)) {
+			echo 'Cannot read &quot;'.$nextinputfilename.'&quot;&lt;BR&gt;';
+			return false;
+		}
+	}
+	if (!is_writeable($FilenameOut)) {
+		echo 'Cannot write &quot;'.$FilenameOut.'&quot;&lt;BR&gt;';
+		return false;
+	}
+
+	require_once('../getid3/getid3.php');
+	if ($fp_output = @fopen($FilenameOut, 'wb')) {
+
+		// Initialize getID3 engine
+		$getID3 = new getID3;
+		foreach ($FilenamesIn as $nextinputfilename) {
+
+			$CurrentFileInfo = $getID3-&gt;analyze($nextinputfilename);
+			if ($CurrentFileInfo['fileformat'] == 'mp3') {
+
+				if ($fp_source = @fopen($nextinputfilename, 'rb')) {
+
+					$CurrentOutputPosition = ftell($fp_output);
+
+					// copy audio data from first file
+					fseek($fp_source, $CurrentFileInfo['avdataoffset'], SEEK_SET);
+					while (!feof($fp_source) &amp;&amp; (ftell($fp_source) &lt; $CurrentFileInfo['avdataend'])) {
+						fwrite($fp_output, fread($fp_source, 32768));
+					}
+					fclose($fp_source);
+
+					// trim post-audio data (if any) copied from first file that we don't need or want
+					$EndOfFileOffset = $CurrentOutputPosition + ($CurrentFileInfo['avdataend'] - $CurrentFileInfo['avdataoffset']);
+					fseek($fp_output, $EndOfFileOffset, SEEK_SET);
+					ftruncate($fp_output, $EndOfFileOffset);
+
+				} else {
+
+					echo 'failed to open '.$nextinputfilename.' for reading';
+					fclose($fp_output);
+					return false;
+
+				}
+
+			} else {
+
+				echo $nextinputfilename.' is not MP3 format';
+				fclose($fp_output);
+				return false;
+
+			}
+
+		}
+
+	} else {
+
+		echo 'failed to open '.$FilenameOut.' for writing';
+		return false;
+
+	}
+
+	fclose($fp_output);
+	return true;
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.mimeonly.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.mimeonly.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.mimeonly.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,53 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.mimeonly.php - part of getID3()                  //
+// Sample script for scanning a single file and returning only //
+// the MIME information                                        //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+echo '&lt;HTML&gt;&lt;HEAD&gt;&lt;STYLE&gt;BODY, TD, TH { font-family: sans-serif; font-size: 10pt; }&lt;/STYLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;';
+
+if (!empty($_REQUEST['filename'])) {
+
+	echo 'The file &quot;'.$_REQUEST['filename'].'&quot; has a MIME type of &quot;'.GetMIMEtype($_REQUEST['filename']).'&quot;';
+
+} else {
+
+	echo 'Usage: &lt;TT&gt;'.$_SERVER['PHP_SELF'].'?filename=&lt;I&gt;filename.ext&lt;/I&gt;&lt;/TT&gt;';
+
+}
+
+
+function GetMIMEtype($filename) {
+	// include getID3() library (can be in a different directory if full path is specified)
+	require_once('../getid3/getid3.php');
+	// Initialize getID3 engine
+	$getID3 = new getID3;
+
+	$DeterminedMIMEtype = '';
+	if ($fp = fopen($filename, 'rb')) {
+		$ThisFileInfo = array('avdataoffset'=&gt;0, 'avdataend'=&gt;0);
+
+		getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v2.php', __FILE__, true);
+		$tag = new getid3_id3v2($fp, $ThisFileInfo);
+
+		fseek($fp, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$formattest = fread($fp, 16);  // 16 bytes is sufficient for any format except ISO CD-image
+		fclose($fp);
+
+		$DeterminedFormatInfo = $getID3-&gt;GetFileFormat($formattest);
+		$DeterminedMIMEtype = $DeterminedFormatInfo['mime_type'];
+	}
+	return $DeterminedMIMEtype;
+}
+
+?&gt;
+&lt;/BODY&gt;
+&lt;/HTML&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.mysql.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.mysql.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.mysql.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,2128 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.mysql.php - part of getID3()                     //
+// Sample script for recursively scanning directories and      //
+// storing the results in a database                           //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+// OPTIONS:
+$getid3_demo_mysql_encoding = 'ISO-8859-1';
+$getid3_demo_mysql_md5_data = false;        // All data hashes are by far the slowest part of scanning
+$getid3_demo_mysql_md5_file = false;
+
+define('GETID3_DB_HOST',  'localhost');
+define('GETID3_DB_USER',  'getid3');
+define('GETID3_DB_PASS',  'getid3');
+define('GETID3_DB_DB',    'getid3');
+define('GETID3_DB_TABLE', 'files');
+
+
+if (!@mysql_connect(GETID3_DB_HOST, GETID3_DB_USER, GETID3_DB_PASS)) {
+	die('Could not connect to MySQL host: &lt;blockquote style=&quot;background-color: #FF9933; padding: 10px;&quot;&gt;'.mysql_error().'&lt;/blockquote&gt;');
+}
+if (!@mysql_select_db(GETID3_DB_DB)) {
+	die('Could not select database: &lt;blockquote style=&quot;background-color: #FF9933; padding: 10px;&quot;&gt;'.mysql_error().'&lt;/blockquote&gt;');
+}
+
+if (!@include_once('../getid3/getid3.php')) {
+	die('Cannot open '.realpath('../getid3/getid3.php'));
+}
+// Initialize getID3 engine
+$getID3 = new getID3;
+$getID3-&gt;option_md5_data = $getid3_demo_mysql_md5_data;
+$getID3-&gt;encoding        = $getid3_demo_mysql_encoding;
+
+
+function RemoveAccents($string) {
+	// Revised version by marksteward&#216;hotmail*com
+	return strtr(strtr($string, '&#138;&#142;&#154;&#158;&#159;&#192;&#193;&#194;&#195;&#196;&#197;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#209;&#210;&#211;&#212;&#213;&#214;&#216;&#217;&#218;&#219;&#220;&#221;&#224;&#225;&#226;&#227;&#228;&#229;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#241;&#242;&#243;&#244;&#245;&#246;&#248;&#249;&#250;&#251;&#252;&#253;&#255;', 'SZszYAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy'), array('&#222;' =&gt; 'TH', '&#254;' =&gt; 'th', '&#208;' =&gt; 'DH', '&#240;' =&gt; 'dh', '&#223;' =&gt; 'ss', '&#140;' =&gt; 'OE', '&#156;' =&gt; 'oe', '&#198;' =&gt; 'AE', '&#230;' =&gt; 'ae', '&#181;' =&gt; 'u'));
+}
+
+function FixTextFields($text) {
+	$text = getid3_lib::SafeStripSlashes($text);
+	$text = htmlentities($text, ENT_QUOTES);
+	return $text;
+}
+
+function BitrateColor($bitrate, $BitrateMaxScale=768) {
+	// $BitrateMaxScale is bitrate of maximum-quality color (bright green)
+	// below this is gradient, above is solid green
+
+	$bitrate *= (256 / $BitrateMaxScale); // scale from 1-[768]kbps to 1-256
+	$bitrate = round(min(max($bitrate, 1), 256));
+	$bitrate--;    // scale from 1-256kbps to 0-255kbps
+
+	$Rcomponent = max(255 - ($bitrate * 2), 0);
+	$Gcomponent = max(($bitrate * 2) - 255, 0);
+	if ($bitrate &gt; 127) {
+		$Bcomponent = max((255 - $bitrate) * 2, 0);
+	} else {
+		$Bcomponent = max($bitrate * 2, 0);
+	}
+	return str_pad(dechex($Rcomponent), 2, '0', STR_PAD_LEFT).str_pad(dechex($Gcomponent), 2, '0', STR_PAD_LEFT).str_pad(dechex($Bcomponent), 2, '0', STR_PAD_LEFT);
+}
+
+function BitrateText($bitrate, $decimals=0) {
+	return '&lt;span style=&quot;color: #'.BitrateColor($bitrate).'&quot;&gt;'.number_format($bitrate, $decimals).' kbps&lt;/span&gt;';
+}
+
+function fileextension($filename, $numextensions=1) {
+	if (strstr($filename, '.')) {
+		$reversedfilename = strrev($filename);
+		$offset = 0;
+		for ($i = 0; $i &lt; $numextensions; $i++) {
+			$offset = strpos($reversedfilename, '.', $offset + 1);
+			if ($offset === false) {
+				return '';
+			}
+		}
+		return strrev(substr($reversedfilename, 0, $offset));
+	}
+	return '';
+}
+
+function RenameFileFromTo($from, $to, &amp;$results) {
+	$success = true;
+	if ($from === $to) {
+		$results = '&lt;span style=&quot;color: #FF0000;&quot;&gt;&lt;b&gt;Source and Destination filenames identical&lt;/b&gt;&lt;br&gt;FAILED to rename';
+	} elseif (!file_exists($from)) {
+		$results = '&lt;span style=&quot;color: #FF0000;&quot;&gt;&lt;b&gt;Source file does not exist&lt;/b&gt;&lt;br&gt;FAILED to rename';
+	} elseif (file_exists($to) &amp;&amp; (strtolower($from) !== strtolower($to))) {
+		$results = '&lt;span style=&quot;color: #FF0000;&quot;&gt;&lt;b&gt;Destination file already exists&lt;/b&gt;&lt;br&gt;FAILED to rename';
+	} elseif (@rename($from, $to)) {
+		$SQLquery  = 'DELETE FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`filename` = &quot;'.mysql_escape_string($from).'&quot;)';
+		safe_mysql_query($SQLquery);
+		$results = '&lt;span style=&quot;color: #008000;&quot;&gt;Successfully renamed';
+	} else {
+		$results = '&lt;br&gt;&lt;span style=&quot;color: #FF0000;&quot;&gt;FAILED to rename';
+		$success = false;
+	}
+	$results .= ' from:&lt;br&gt;&lt;i&gt;'.$from.'&lt;/i&gt;&lt;br&gt;to:&lt;br&gt;&lt;i&gt;'.$to.'&lt;/i&gt;&lt;/span&gt;&lt;hr&gt;';
+	return $success;
+}
+
+if (!empty($_REQUEST['renamefilefrom']) &amp;&amp; !empty($_REQUEST['renamefileto'])) {
+
+	$results = '';
+	RenameFileFromTo($_REQUEST['renamefilefrom'], $_REQUEST['renamefileto'], $results);
+	echo $results;
+	exit;
+
+} elseif (!empty($_REQUEST['m3ufilename'])) {
+
+	header('Content-type: audio/x-mpegurl');
+	echo '#EXTM3U'.&quot;\n&quot;;
+	echo WindowsShareSlashTranslate($_REQUEST['m3ufilename']).&quot;\n&quot;;
+	exit;
+
+} elseif (!isset($_REQUEST['m3u']) &amp;&amp; !isset($_REQUEST['m3uartist']) &amp;&amp; !isset($_REQUEST['m3utitle'])) {
+
+	echo '&lt;html&gt;&lt;head&gt;&lt;title&gt;getID3() demo - /demo/mysql.php&lt;/title&gt;&lt;style&gt;BODY, TD, TH { font-family: sans-serif; font-size: 10pt; } A { text-decoration: none; } A:hover { text-decoration: underline; } A:visited { font-style: italic; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;';
+
+}
+
+
+function WindowsShareSlashTranslate($filename) {
+	if (substr($filename, 0, 2) == '//') {
+		return str_replace('/', '\\', $filename);
+	}
+	return $filename;
+}
+
+function safe_mysql_query($SQLquery) {
+	$result = @mysql_query($SQLquery);
+	if (mysql_error()) {
+		die('&lt;FONT COLOR=&quot;red&quot;&gt;'.mysql_error().'&lt;/FONT&gt;&lt;hr&gt;&lt;TT&gt;'.$SQLquery.'&lt;/TT&gt;');
+	}
+	return $result;
+}
+
+function mysql_table_exists($tablename) {
+	return (bool) mysql_query('DESCRIBE '.$tablename);
+}
+
+function AcceptableExtensions($fileformat, $audio_dataformat='', $video_dataformat='') {
+	static $AcceptableExtensionsAudio = array();
+	if (empty($AcceptableExtensionsAudio)) {
+		$AcceptableExtensionsAudio['mp3']['mp3']  = array('mp3');
+		$AcceptableExtensionsAudio['mp2']['mp2']  = array('mp2');
+		$AcceptableExtensionsAudio['mp1']['mp1']  = array('mp1');
+		$AcceptableExtensionsAudio['asf']['asf']  = array('asf');
+		$AcceptableExtensionsAudio['asf']['wma']  = array('wma');
+		$AcceptableExtensionsAudio['riff']['mp3'] = array('wav');
+		$AcceptableExtensionsAudio['riff']['wav'] = array('wav');
+	}
+	static $AcceptableExtensionsVideo = array();
+	if (empty($AcceptableExtensionsVideo)) {
+		$AcceptableExtensionsVideo['mp3']['mp3']  = array('mp3');
+		$AcceptableExtensionsVideo['mp2']['mp2']  = array('mp2');
+		$AcceptableExtensionsVideo['mp1']['mp1']  = array('mp1');
+		$AcceptableExtensionsVideo['asf']['asf']  = array('asf');
+		$AcceptableExtensionsVideo['asf']['wmv']  = array('wmv');
+		$AcceptableExtensionsVideo['gif']['gif']  = array('gif');
+		$AcceptableExtensionsVideo['jpg']['jpg']  = array('jpg');
+		$AcceptableExtensionsVideo['png']['png']  = array('png');
+		$AcceptableExtensionsVideo['bmp']['bmp']  = array('bmp');
+	}
+	if (!empty($video_dataformat)) {
+		return (isset($AcceptableExtensionsVideo[$fileformat][$video_dataformat]) ? $AcceptableExtensionsVideo[$fileformat][$video_dataformat] : array());
+	} else {
+		return (isset($AcceptableExtensionsAudio[$fileformat][$audio_dataformat]) ? $AcceptableExtensionsAudio[$fileformat][$audio_dataformat] : array());
+	}
+}
+
+
+if (!empty($_REQUEST['scan'])) {
+	if (mysql_table_exists(GETID3_DB_TABLE)) {
+		$SQLquery  = 'DROP TABLE `'.GETID3_DB_TABLE.'`';
+		safe_mysql_query($SQLquery);
+	}
+}
+if (!mysql_table_exists(GETID3_DB_TABLE)) {
+	$SQLquery  = 'CREATE TABLE `'.GETID3_DB_TABLE.'` (';
+	$SQLquery .= ' `ID` mediumint(8) unsigned NOT NULL auto_increment,';
+	$SQLquery .= ' `filename` text NOT NULL,';
+	$SQLquery .= ' `LastModified` text NOT NULL,';
+	$SQLquery .= ' `md5_file` varchar(32) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `md5_data` varchar(32) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `md5_data_source` varchar(32) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `filesize` int(10) unsigned NOT NULL default &quot;0&quot;,';
+	$SQLquery .= ' `fileformat` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `audio_dataformat` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `video_dataformat` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `audio_bitrate` float NOT NULL default &quot;0&quot;,';
+	$SQLquery .= ' `video_bitrate` float NOT NULL default &quot;0&quot;,';
+	$SQLquery .= ' `playtime_seconds` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `tags` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `artist` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `title` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `remix` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `album` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `genre` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `comment` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `track` varchar(7) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `comments_all` text NOT NULL,';
+	$SQLquery .= ' `comments_id3v2` text NOT NULL,';
+	$SQLquery .= ' `comments_ape` text NOT NULL,';
+	$SQLquery .= ' `comments_lyrics3` text NOT NULL,';
+	$SQLquery .= ' `comments_id3v1` text NOT NULL,';
+	$SQLquery .= ' `warning` text NOT NULL,';
+	$SQLquery .= ' `error` text NOT NULL,';
+	$SQLquery .= ' `track_volume` float NOT NULL default &quot;0&quot;,';
+	$SQLquery .= ' `encoder_options` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' `vbr_method` varchar(255) NOT NULL default &quot;&quot;,';
+	$SQLquery .= ' PRIMARY KEY (`ID`)';
+	$SQLquery .= ') TYPE=MyISAM;';
+
+	safe_mysql_query($SQLquery);
+}
+
+$ExistingTableFields = array();
+$result = mysql_query('DESCRIBE `'.GETID3_DB_TABLE.'`');
+while ($row = mysql_fetch_array($result)) {
+	$ExistingTableFields[$row['Field']] = $row;
+}
+if (!isset($ExistingTableFields['encoder_options'])) { // Added in 1.7.0b2
+	echo '&lt;b&gt;adding field `encoder_options`&lt;/b&gt;&lt;br&gt;';
+	mysql_query('ALTER TABLE `'.GETID3_DB_TABLE.'` ADD `encoder_options` VARCHAR(255) DEFAULT &quot;&quot; NOT NULL AFTER `error`');
+	mysql_query('OPTIMIZE TABLE `'.GETID3_DB_TABLE.'`');
+}
+if (isset($ExistingTableFields['track']) &amp;&amp; ($ExistingTableFields['track']['Type'] != 'varchar(7)')) { // Changed in 1.7.0b2
+	echo '&lt;b&gt;changing field `track` to VARCHAR(7)&lt;/b&gt;&lt;br&gt;';
+	mysql_query('ALTER TABLE `'.GETID3_DB_TABLE.'` CHANGE `track` `track` VARCHAR(7) DEFAULT &quot;&quot; NOT NULL');
+	mysql_query('OPTIMIZE TABLE `'.GETID3_DB_TABLE.'`');
+}
+if (!isset($ExistingTableFields['track_volume'])) { // Added in 1.7.0b5
+	echo '&lt;H1&gt;&lt;FONT COLOR=&quot;red&quot;&gt;WARNING! You should erase your database and rescan everything because the comment storing has been changed since the last version&lt;/FONT&gt;&lt;/H1&gt;&lt;hr&gt;';
+	echo '&lt;b&gt;adding field `track_volume`&lt;/b&gt;&lt;br&gt;';
+	mysql_query('ALTER TABLE `'.GETID3_DB_TABLE.'` ADD `track_volume` FLOAT NOT NULL AFTER `error`');
+	mysql_query('OPTIMIZE TABLE `'.GETID3_DB_TABLE.'`');
+}
+if (!isset($ExistingTableFields['remix'])) { // Added in 1.7.3b1
+	echo '&lt;b&gt;adding field `encoder_options`, `alternate_name`, `parody`&lt;/b&gt;&lt;br&gt;';
+	mysql_query('ALTER TABLE `'.GETID3_DB_TABLE.'` ADD `remix` VARCHAR(255) DEFAULT &quot;&quot; NOT NULL AFTER `title`');
+	mysql_query('ALTER TABLE `'.GETID3_DB_TABLE.'` ADD `alternate_name` VARCHAR(255) DEFAULT &quot;&quot; NOT NULL AFTER `track`');
+	mysql_query('ALTER TABLE `'.GETID3_DB_TABLE.'` ADD `parody` VARCHAR(255) DEFAULT &quot;&quot; NOT NULL AFTER `alternate_name`');
+	mysql_query('OPTIMIZE TABLE `'.GETID3_DB_TABLE.'`');
+}
+
+
+function SynchronizeAllTags($filename, $synchronizefrom='all', $synchronizeto='A12', &amp;$errors) {
+	global $getID3;
+
+	set_time_limit(30);
+
+	$ThisFileInfo = $getID3-&gt;analyze($filename);
+	getid3_lib::CopyTagsToComments($ThisFileInfo);
+
+	if ($synchronizefrom == 'all') {
+		$SourceArray = @$ThisFileInfo['comments'];
+	} elseif (!empty($ThisFileInfo['tags'][$synchronizefrom])) {
+		$SourceArray = @$ThisFileInfo['tags'][$synchronizefrom];
+	} else {
+		die('ERROR: $ThisFileInfo[tags]['.$synchronizefrom.'] does not exist');
+	}
+
+	$SQLquery  = 'DELETE FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`filename` = &quot;'.mysql_escape_string($filename).'&quot;)';
+	safe_mysql_query($SQLquery);
+
+
+	$TagFormatsToWrite = array();
+	if ((strpos($synchronizeto, '2') !== false) &amp;&amp; ($synchronizefrom != 'id3v2')) {
+		$TagFormatsToWrite[] = 'id3v2.3';
+	}
+	if ((strpos($synchronizeto, 'A') !== false) &amp;&amp; ($synchronizefrom != 'ape')) {
+		$TagFormatsToWrite[] = 'ape';
+	}
+	if ((strpos($synchronizeto, 'L') !== false) &amp;&amp; ($synchronizefrom != 'lyrics3')) {
+		$TagFormatsToWrite[] = 'lyrics3';
+	}
+	if ((strpos($synchronizeto, '1') !== false) &amp;&amp; ($synchronizefrom != 'id3v1')) {
+		$TagFormatsToWrite[] = 'id3v1';
+	}
+
+	getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'write.php', __FILE__, true);
+	$tagwriter = new getid3_writetags;
+	$tagwriter-&gt;filename       = $filename;
+	$tagwriter-&gt;tagformats     = $TagFormatsToWrite;
+	$tagwriter-&gt;overwrite_tags = true;
+	$tagwriter-&gt;tag_encoding   = $getID3-&gt;encoding;
+	$tagwriter-&gt;tag_data       = $SourceArray;
+
+	if ($tagwriter-&gt;WriteTags()) {
+		$errors = $tagwriter-&gt;errors;
+		return true;
+	}
+	$errors = $tagwriter-&gt;errors;
+	return false;
+}
+
+$IgnoreNoTagFormats = array('', 'png', 'jpg', 'gif', 'bmp', 'swf', 'zip', 'mid', 'mod', 'xm', 'it', 's3m');
+
+if (!empty($_REQUEST['scan']) || !empty($_REQUEST['newscan']) || !empty($_REQUEST['rescanerrors'])) {
+
+	$SQLquery  = 'DELETE from `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`fileformat` = &quot;&quot;)';
+	safe_mysql_query($SQLquery);
+
+	$FilesInDir = array();
+
+	if (!empty($_REQUEST['rescanerrors'])) {
+
+		echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'&quot;&gt;abort&lt;/a&gt;&lt;hr&gt;';
+
+		echo 'Re-scanning all media files already in database that had errors and/or warnings in last scan&lt;hr&gt;';
+
+		$SQLquery  = 'SELECT `filename`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`error` &lt;&gt; &quot;&quot;)';
+		$SQLquery .= ' OR (`warning` &lt;&gt; &quot;&quot;)';
+		$SQLquery .= ' ORDER BY `filename` ASC';
+		$result = safe_mysql_query($SQLquery);
+		while ($row = mysql_fetch_array($result)) {
+
+			if (!file_exists($row['filename'])) {
+				echo '&lt;b&gt;File missing: '.$row['filename'].'&lt;/b&gt;&lt;br&gt;';
+				$SQLquery = 'DELETE FROM `'.GETID3_DB_TABLE.'`';
+				$SQLquery .= ' WHERE (`filename` = &quot;'.mysql_escape_string($row['filename']).'&quot;)';
+				safe_mysql_query($SQLquery);
+			} else {
+				$FilesInDir[] = $row['filename'];
+			}
+
+		}
+
+	} elseif (!empty($_REQUEST['scan']) || !empty($_REQUEST['newscan'])) {
+
+		echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'&quot;&gt;abort&lt;/a&gt;&lt;hr&gt;';
+
+		echo 'Scanning all media files in &lt;b&gt;'.str_replace('\\', '/', realpath(!empty($_REQUEST['scan']) ? $_REQUEST['scan'] : $_REQUEST['newscan'])).'&lt;/b&gt; (and subdirectories)&lt;hr&gt;';
+
+		$SQLquery  = 'SELECT COUNT(*) AS `num`, `filename`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' GROUP BY `filename`';
+		$SQLquery .= ' ORDER BY `num` DESC';
+		$result = safe_mysql_query($SQLquery);
+		$DupesDeleted = 0;
+		while ($row = mysql_fetch_array($result)) {
+			set_time_limit(30);
+			if ($row['num'] &lt;= 1) {
+				break;
+			}
+			$SQLquery  = 'DELETE FROM `'.GETID3_DB_TABLE.'`';
+			$SQLquery .= ' WHERE `filename` LIKE &quot;'.mysql_escape_string($row['filename']).'&quot;';
+			safe_mysql_query($SQLquery);
+			$DupesDeleted++;
+		}
+		if ($DupesDeleted &gt; 0) {
+			echo 'Deleted &lt;b&gt;'.number_format($DupesDeleted).'&lt;/b&gt; duplicate filenames&lt;hr&gt;';
+		}
+
+		if (!empty($_REQUEST['newscan'])) {
+			$AlreadyInDatabase = array();
+			set_time_limit(60);
+			$SQLquery  = 'SELECT `filename`';
+			$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+			$SQLquery .= ' ORDER BY `filename` ASC';
+			$result = safe_mysql_query($SQLquery);
+			while ($row = mysql_fetch_array($result)) {
+				//$AlreadyInDatabase[] = strtolower($row['filename']);
+				$AlreadyInDatabase[] = $row['filename'];
+			}
+		}
+
+		$DirectoriesToScan  = array(@$_REQUEST['scan'] ? $_REQUEST['scan'] : $_REQUEST['newscan']);
+		$DirectoriesScanned = array();
+		while (count($DirectoriesToScan) &gt; 0) {
+			foreach ($DirectoriesToScan as $DirectoryKey =&gt; $startingdir) {
+				if ($dir = opendir($startingdir)) {
+					set_time_limit(30);
+					echo '&lt;b&gt;'.str_replace('\\', '/', $startingdir).'&lt;/b&gt;&lt;br&gt;';
+					flush();
+					while (($file = readdir($dir)) !== false) {
+						if (($file != '.') &amp;&amp; ($file != '..')) {
+							$RealPathName = realpath($startingdir.'/'.$file);
+							if (is_dir($RealPathName)) {
+								if (!in_array($RealPathName, $DirectoriesScanned) &amp;&amp; !in_array($RealPathName, $DirectoriesToScan)) {
+									$DirectoriesToScan[] = $RealPathName;
+								}
+							} else if (is_file($RealPathName)) {
+								if (!empty($_REQUEST['newscan'])) {
+									if (!in_array(str_replace('\\', '/', $RealPathName), $AlreadyInDatabase)) {
+										$FilesInDir[] = $RealPathName;
+									}
+								} elseif (!empty($_REQUEST['scan'])) {
+									$FilesInDir[] = $RealPathName;
+								}
+							}
+						}
+					}
+					closedir($dir);
+				} else {
+					echo '&lt;FONT COLOR=&quot;RED&quot;&gt;Failed to open directory &quot;&lt;b&gt;'.$startingdir.'&lt;/b&gt;&quot;&lt;/FONT&gt;&lt;br&gt;&lt;br&gt;';
+				}
+				$DirectoriesScanned[] = $startingdir;
+				unset($DirectoriesToScan[$DirectoryKey]);
+			}
+		}
+		echo '&lt;i&gt;List of files to scan complete (added '.number_format(count($FilesInDir)).' files to scan)&lt;/i&gt;&lt;hr&gt;';
+		flush();
+	}
+
+	$FilesInDir = array_unique($FilesInDir);
+	sort($FilesInDir);
+
+	$starttime = time();
+	$rowcounter = 0;
+	$totaltoprocess = count($FilesInDir);
+
+	foreach ($FilesInDir as $filename) {
+		set_time_limit(300);
+
+		echo '&lt;br&gt;'.date('H:i:s').' ['.number_format(++$rowcounter).' / '.number_format($totaltoprocess).'] '.str_replace('\\', '/', $filename);
+
+		$ThisFileInfo = $getID3-&gt;analyze($filename);
+		getid3_lib::CopyTagsToComments($ThisFileInfo);
+
+		if (file_exists($filename)) {
+			$ThisFileInfo['file_modified_time'] = filemtime($filename);
+			$ThisFileInfo['md5_file']           = ($getid3_demo_mysql_md5_file ? md5_file($filename) : '');
+		}
+
+		if (empty($ThisFileInfo['fileformat'])) {
+
+			echo ' (&lt;span style=&quot;color: #990099;&quot;&gt;unknown file type&lt;/span&gt;)';
+
+		} else {
+
+			if (!empty($ThisFileInfo['error'])) {
+				echo ' (&lt;span style=&quot;color: #FF0000;&quot;&gt;errors&lt;/span&gt;)';
+			} elseif (!empty($ThisFileInfo['warning'])) {
+				echo ' (&lt;span style=&quot;color: #FF9999;&quot;&gt;warnings&lt;/span&gt;)';
+			} else {
+				echo ' (&lt;span style=&quot;color: #009900;&quot;&gt;OK&lt;/span&gt;)';
+			}
+
+			$this_track_track = '';
+			if (!empty($ThisFileInfo['comments']['track'])) {
+				foreach ($ThisFileInfo['comments']['track'] as $key =&gt; $value) {
+					if (strlen($value) &gt; strlen($this_track_track)) {
+						$this_track_track = str_pad($value, 2, '0', STR_PAD_LEFT);
+					}
+				}
+				if (ereg('^([0-9]+)/([0-9]+)$', $this_track_track, $matches)) {
+					// change &quot;1/5&quot;-&gt;&quot;01/05&quot;, &quot;3/12&quot;-&gt;&quot;03/12&quot;, etc
+					$this_track_track = str_pad($matches[1], 2, '0', STR_PAD_LEFT).'/'.str_pad($matches[2], 2, '0', STR_PAD_LEFT);
+				}
+			}
+
+			$this_track_remix = '';
+			$this_track_title = '';
+			if (!empty($ThisFileInfo['comments']['title'])) {
+				foreach ($ThisFileInfo['comments']['title'] as $possible_title) {
+					if (strlen($possible_title) &gt; strlen($this_track_title)) {
+						$this_track_title = $possible_title;
+					}
+				}
+			}
+
+			$ParenthesesPairs = array('()', '[]', '{}');
+			foreach ($ParenthesesPairs as $pair) {
+				if (preg_match_all('/(.*) '.preg_quote($pair{0}).'(([^'.preg_quote($pair).']*[\- '.preg_quote($pair{0}).'])?(cut|dub|edit|version|live|reprise|[a-z]*mix))'.preg_quote($pair{1}).'/iU', $this_track_title, $matches)) {
+					$this_track_title = $matches[1][0];
+					$this_track_remix = implode(&quot;\t&quot;, $matches[2]);
+				}
+			}
+
+
+
+			if (!empty($_REQUEST['rescanerrors'])) {
+
+				$SQLquery  = 'UPDATE `'.GETID3_DB_TABLE.'` SET ';
+				$SQLquery .= '`LastModified` = &quot;'.mysql_escape_string(@$ThisFileInfo['file_modified_time']).'&quot;, ';
+				$SQLquery .= '`md5_file` = &quot;'.mysql_escape_string(@$ThisFileInfo['md5_file']).'&quot;, ';
+				$SQLquery .= '`md5_data` = &quot;'.mysql_escape_string(@$ThisFileInfo['md5_data']).'&quot;, ';
+				$SQLquery .= '`md5_data_source` = &quot;'.mysql_escape_string(@$ThisFileInfo['md5_data_source']).'&quot;, ';
+				$SQLquery .= '`filesize` = &quot;'.mysql_escape_string(@$ThisFileInfo['filesize']).'&quot;, ';
+				$SQLquery .= '`fileformat` = &quot;'.mysql_escape_string(@$ThisFileInfo['fileformat']).'&quot;, ';
+				$SQLquery .= '`audio_dataformat` = &quot;'.mysql_escape_string(@$ThisFileInfo['audio']['dataformat']).'&quot;, ';
+				$SQLquery .= '`video_dataformat` = &quot;'.mysql_escape_string(@$ThisFileInfo['video']['dataformat']).'&quot;, ';
+				$SQLquery .= '`audio_bitrate` = &quot;'.mysql_escape_string(@$ThisFileInfo['audio']['bitrate']).'&quot;, ';
+				$SQLquery .= '`video_bitrate` = &quot;'.mysql_escape_string(@$ThisFileInfo['video']['bitrate']).'&quot;, ';
+				$SQLquery .= '`playtime_seconds` = &quot;'.mysql_escape_string(@$ThisFileInfo['playtime_seconds']).'&quot;, ';
+				$SQLquery .= '`tags` = &quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @array_keys(@$ThisFileInfo['tags']))).'&quot;, ';
+				$SQLquery .= '`artist` = &quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['comments']['artist'])).'&quot;, ';
+
+				$SQLquery .= '`title` = &quot;'.mysql_escape_string($this_track_title).'&quot;, ';
+				$SQLquery .= '`remix` = &quot;'.mysql_escape_string($this_track_remix).'&quot;, ';
+
+				$SQLquery .= '`album` = &quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['comments']['album'])).'&quot;, ';
+				$SQLquery .= '`genre` = &quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['comments']['genre'])).'&quot;, ';
+				$SQLquery .= '`comment` = &quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['comments']['comment'])).'&quot;, ';
+
+				$SQLquery .= '`track` = &quot;'.mysql_escape_string($this_track_track).'&quot;, ';
+
+				$SQLquery .= '`comments_all` = &quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['comments'])).'&quot;, ';
+				$SQLquery .= '`comments_id3v2` = &quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['tags']['id3v2'])).'&quot;, ';
+				$SQLquery .= '`comments_ape` = &quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['tags']['ape'])).'&quot;, ';
+				$SQLquery .= '`comments_lyrics3` = &quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['tags']['lyrics3'])).'&quot;, ';
+				$SQLquery .= '`comments_id3v1` = &quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['tags']['id3v1'])).'&quot;, ';
+				$SQLquery .= '`warning` = &quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['warning'])).'&quot;, ';
+				$SQLquery .= '`error` = &quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['error'])).'&quot;, ';
+				$SQLquery .= '`encoder_options` = &quot;'.mysql_escape_string(trim(@$ThisFileInfo['audio']['encoder'].' '.@$ThisFileInfo['audio']['encoder_options'])).'&quot;, ';
+				$SQLquery .= '`vbr_method` = &quot;'.mysql_escape_string(@$ThisFileInfo['mpeg']['audio']['VBR_method']).'&quot;, ';
+				$SQLquery .= '`track_volume` = &quot;'.mysql_escape_string(@$ThisFileInfo['replay_gain']['track']['volume']).'&quot; ';
+				$SQLquery .= 'WHERE (`filename` = &quot;'.mysql_escape_string(@$ThisFileInfo['filenamepath']).'&quot;)';
+
+			} elseif (!empty($_REQUEST['scan']) || !empty($_REQUEST['newscan'])) {
+
+				$SQLquery  = 'INSERT INTO `'.GETID3_DB_TABLE.'` (`filename`, `LastModified`, `md5_file`, `md5_data`, `md5_data_source`, `filesize`, `fileformat`, `audio_dataformat`, `video_dataformat`, `audio_bitrate`, `video_bitrate`, `playtime_seconds`, `tags`, `artist`, `title`, `remix`, `album`, `genre`, `comment`, `track`, `comments_all`, `comments_id3v2`, `comments_ape`, `comments_lyrics3`, `comments_id3v1`, `warning`, `error`, `encoder_options`, `vbr_method`, `track_volume`) VALUES (';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['filenamepath']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['file_modified_time']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['md5_file']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['md5_data']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['md5_data_source']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['filesize']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['fileformat']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['audio']['dataformat']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['video']['dataformat']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['audio']['bitrate']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['video']['bitrate']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['playtime_seconds']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @array_keys(@$ThisFileInfo['tags']))).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['comments']['artist'])).'&quot;, ';
+
+				$SQLquery .= '&quot;'.mysql_escape_string($this_track_title).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string($this_track_remix).'&quot;, ';
+
+				$SQLquery .= '&quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['comments']['album'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['comments']['genre'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['comments']['comment'])).'&quot;, ';
+
+				$SQLquery .= '&quot;'.mysql_escape_string($this_track_track).'&quot;, ';
+
+				$SQLquery .= '&quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['comments'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['tags']['id3v2'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['tags']['ape'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['tags']['lyrics3'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@serialize(@$ThisFileInfo['tags']['id3v1'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['warning'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@implode(&quot;\t&quot;, @$ThisFileInfo['error'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(trim(@$ThisFileInfo['audio']['encoder'].' '.@$ThisFileInfo['audio']['encoder_options'])).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(!empty($ThisFileInfo['mpeg']['audio']['LAME']) ? 'LAME' : @$ThisFileInfo['mpeg']['audio']['VBR_method']).'&quot;, ';
+				$SQLquery .= '&quot;'.mysql_escape_string(@$ThisFileInfo['replay_gain']['track']['volume']).'&quot;)';
+
+			}
+			flush();
+			safe_mysql_query($SQLquery);
+		}
+
+	}
+
+	$SQLquery = 'OPTIMIZE TABLE `'.GETID3_DB_TABLE.'`';
+	safe_mysql_query($SQLquery);
+
+	echo '&lt;hr&gt;Done scanning!&lt;hr&gt;';
+
+} elseif (!empty($_REQUEST['missingtrackvolume'])) {
+
+	$MissingTrackVolumeFilesScanned  = 0;
+	$MissingTrackVolumeFilesAdjusted = 0;
+	$MissingTrackVolumeFilesDeleted  = 0;
+	$SQLquery  = 'SELECT `filename`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`track_volume` = &quot;0&quot;)';
+	$SQLquery .= ' AND (`audio_bitrate` &gt; &quot;0&quot;)';
+	$result = safe_mysql_query($SQLquery);
+	echo 'Scanning &lt;span ID=&quot;missingtrackvolumeNowScanning&quot;&gt;0&lt;/span&gt; / '.number_format(mysql_num_rows($result)).' files for track volume information:&lt;hr&gt;';
+	while ($row = mysql_fetch_array($result)) {
+		set_time_limit(30);
+		echo '&lt;script&gt;if (document.getElementById(&quot;missingtrackvolumeNowScanning&quot;)) document.getElementById(&quot;missingtrackvolumeNowScanning&quot;).innerHTML = &quot;'.number_format($MissingTrackVolumeFilesScanned++).'&quot;;&lt;/script&gt;. ';
+		flush();
+		if (file_exists($row['filename'])) {
+
+			$ThisFileInfo = $getID3-&gt;analyze($row['filename']);
+			if (!empty($ThisFileInfo['replay_gain']['track']['volume'])) {
+				$MissingTrackVolumeFilesAdjusted++;
+				$SQLquery  = 'UPDATE `'.GETID3_DB_TABLE.'`';
+				$SQLquery .= ' SET `track_volume` = &quot;'.$ThisFileInfo['replay_gain']['track']['volume'].'&quot;';
+				$SQLquery .= ' WHERE (`filename` = &quot;'.mysql_escape_string($row['filename']).'&quot;)';
+				safe_mysql_query($SQLquery);
+			}
+
+		} else {
+
+			$MissingTrackVolumeFilesDeleted++;
+			$SQLquery  = 'DELETE FROM `'.GETID3_DB_TABLE.'`';
+			$SQLquery .= ' WHERE (`filename` = &quot;'.mysql_escape_string($row['filename']).'&quot;)';
+			safe_mysql_query($SQLquery);
+
+		}
+	}
+	echo '&lt;hr&gt;Scanned '.number_format($MissingTrackVolumeFilesScanned).' files with no track volume information.&lt;br&gt;';
+	echo 'Found track volume information for '.number_format($MissingTrackVolumeFilesAdjusted).' of them (could not find info for '.number_format($MissingTrackVolumeFilesScanned - $MissingTrackVolumeFilesAdjusted).' files; deleted '.number_format($MissingTrackVolumeFilesDeleted).' records of missing files)&lt;hr&gt;';
+
+} elseif (!empty($_REQUEST['deadfilescheck'])) {
+
+	$SQLquery  = 'SELECT COUNT(*) AS `num`, `filename`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' GROUP BY `filename`';
+	$SQLquery .= ' ORDER BY `num` DESC';
+	$result = safe_mysql_query($SQLquery);
+	$DupesDeleted = 0;
+	while ($row = mysql_fetch_array($result)) {
+		set_time_limit(30);
+		if ($row['num'] &lt;= 1) {
+			break;
+		}
+		echo '&lt;br&gt;'.FixTextFields($row['filename']).' (&lt;font color=&quot;#FF9999&quot;&gt;duplicate&lt;/font&gt;)';
+		$SQLquery  = 'DELETE FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE `filename` LIKE &quot;'.mysql_escape_string($row['filename']).'&quot;';
+		safe_mysql_query($SQLquery);
+		$DupesDeleted++;
+	}
+	if ($DupesDeleted &gt; 0) {
+		echo '&lt;hr&gt;Deleted &lt;b&gt;'.number_format($DupesDeleted).'&lt;/b&gt; duplicate filenames&lt;hr&gt;';
+	}
+
+	$SQLquery  = 'SELECT `filename`, `filesize`, `LastModified`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+	$totalchecked = 0;
+	$totalremoved = 0;
+	$previousdir = '';
+	while ($row = mysql_fetch_array($result)) {
+		$totalchecked++;
+		set_time_limit(30);
+		$reason = '';
+		if (!file_exists($row['filename'])) {
+			$reason = 'deleted';
+		} elseif (filesize($row['filename']) != $row['filesize']) {
+			$reason = 'filesize changed';
+		} elseif (filemtime($row['filename']) != $row['LastModified']) {
+			if (abs(filemtime($row['filename']) - $row['LastModified']) != 3600) {
+				// off by exactly one hour == daylight savings time
+				$reason = 'last-modified time changed';
+			}
+		}
+
+		$thisdir = dirname($row['filename']);
+		if ($reason) {
+
+			$totalremoved++;
+			echo '&lt;br&gt;'.FixTextFields($row['filename']).' (&lt;font color=&quot;#FF9999&quot;&gt;'.$reason.'&lt;/font&gt;)';
+			flush();
+			$SQLquery  = 'DELETE FROM `'.GETID3_DB_TABLE.'`';
+			$SQLquery .= ' WHERE (`filename` = &quot;'.mysql_escape_string($row['filename']).'&quot;)';
+			safe_mysql_query($SQLquery);
+
+		} elseif ($thisdir != $previousdir) {
+
+			echo '. ';
+			flush();
+
+		}
+		$previousdir = $thisdir;
+	}
+
+	echo '&lt;hr&gt;&lt;b&gt;'.number_format($totalremoved).' of '.number_format($totalchecked).' files in database no longer exist, or have been altered since last scan. Removed from database.&lt;/b&gt;&lt;hr&gt;';
+
+} elseif (!empty($_REQUEST['encodedbydistribution'])) {
+
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+
+		$SQLquery  = 'SELECT `filename`, `comments_id3v2`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`encoder_options` = &quot;'.mysql_escape_string($_REQUEST['encodedbydistribution']).'&quot;)';
+		$result = mysql_query($SQLquery);
+		$NonBlankEncodedBy = '';
+		$BlankEncodedBy = '';
+		while ($row = mysql_fetch_array($result)) {
+			set_time_limit(30);
+			$CommentArray = unserialize($row['comments_id3v2']);
+			if (isset($CommentArray['encoded_by'][0])) {
+				$NonBlankEncodedBy .= WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+			} else {
+				$BlankEncodedBy    .= WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+			}
+		}
+		echo $NonBlankEncodedBy;
+		echo $BlankEncodedBy;
+		exit;
+
+	} elseif (!empty($_REQUEST['showfiles'])) {
+
+		echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?encodedbydistribution='.urlencode('%').'&quot;&gt;show all&lt;/a&gt;&lt;br&gt;';
+		echo '&lt;table border=&quot;1&quot;&gt;';
+
+		$SQLquery  = 'SELECT `filename`, `comments_id3v2`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$result = mysql_query($SQLquery);
+		while ($row = mysql_fetch_array($result)) {
+			set_time_limit(30);
+			$CommentArray = unserialize($row['comments_id3v2']);
+			if (($_REQUEST['encodedbydistribution'] == '%') || (!empty($CommentArray['encoded_by'][0]) &amp;&amp; ($_REQUEST['encodedbydistribution'] == $CommentArray['encoded_by'][0]))) {
+				echo '&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;';
+			}
+		}
+		echo '&lt;/table&gt;';
+
+	} else {
+
+		$SQLquery  = 'SELECT `encoder_options`, `comments_id3v2`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' ORDER BY (`encoder_options` LIKE &quot;LAME%&quot;) DESC, (`encoder_options` LIKE &quot;CBR%&quot;) DESC';
+		$result = mysql_query($SQLquery);
+		$EncodedBy = array();
+		while ($row = mysql_fetch_array($result)) {
+			set_time_limit(30);
+			$CommentArray = unserialize($row['comments_id3v2']);
+			if (isset($EncodedBy[$row['encoder_options']][@$CommentArray['encoded_by'][0]])) {
+				$EncodedBy[$row['encoder_options']][@$CommentArray['encoded_by'][0]]++;
+			} else {
+				$EncodedBy[$row['encoder_options']][@$CommentArray['encoded_by'][0]] = 1;
+			}
+		}
+		echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?encodedbydistribution='.urlencode('%').'&amp;m3u=1&quot;&gt;.m3u version&lt;/a&gt;&lt;br&gt;';
+		echo '&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;m3u&lt;/th&gt;&lt;th&gt;Encoder Options&lt;/th&gt;&lt;th&gt;Encoded By (ID3v2)&lt;/th&gt;&lt;/tr&gt;';
+		foreach ($EncodedBy as $key =&gt; $value) {
+			echo '&lt;tr&gt;&lt;TD VALIGN=&quot;TOP&quot;&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?encodedbydistribution='.urlencode($key).'&amp;showfiles=1&amp;m3u=1&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;TD VALIGN=&quot;TOP&quot;&gt;&lt;b&gt;'.$key.'&lt;/b&gt;&lt;/td&gt;';
+			echo '&lt;td&gt;&lt;table border=&quot;0&quot; WIDTH=&quot;100%&quot;&gt;';
+			arsort($value);
+			foreach ($value as $string =&gt; $count) {
+				echo '&lt;tr&gt;&lt;TD ALIGN=&quot;RIGHT&quot; WIDTH=&quot;50&quot;&gt;&lt;i&gt;'.number_format($count).'&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&nbsp;&lt;/td&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?encodedbydistribution='.urlencode($string).'&amp;showfiles=1&quot;&gt;'.$string.'&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;';
+			}
+			echo '&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;';
+		}
+		echo '&lt;/table&gt;';
+
+	}
+
+} elseif (!empty($_REQUEST['audiobitrates'])) {
+
+	getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.mp3.php', __FILE__, true);
+	$BitrateDistribution = array();
+	$SQLquery  = 'SELECT ROUND(audio_bitrate / 1000) AS `RoundBitrate`, COUNT(*) AS `num`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`audio_bitrate` &gt; 0)';
+	$SQLquery .= ' GROUP BY `RoundBitrate`';
+	$result = safe_mysql_query($SQLquery);
+	while ($row = mysql_fetch_array($result)) {
+		@$BitrateDistribution[getid3_mp3::ClosestStandardMP3Bitrate($row['RoundBitrate'] * 1000)] += $row['num'];  // safe_inc
+	}
+
+	echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+	echo '&lt;tr&gt;&lt;th&gt;Bitrate&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;/tr&gt;';
+	foreach ($BitrateDistribution as $Bitrate =&gt; $Count) {
+		echo '&lt;tr&gt;';
+		echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;'.round($Bitrate / 1000).' kbps&lt;/td&gt;';
+		echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;'.number_format($Count).'&lt;/td&gt;';
+		echo '&lt;/tr&gt;';
+	}
+	echo '&lt;/table&gt;';
+
+
+} elseif (!empty($_REQUEST['emptygenres'])) {
+
+	$SQLquery  = 'SELECT `fileformat`, `filename`, `genre`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`genre` = &quot;&quot;)';
+	$SQLquery .= ' OR (`genre` = &quot;Unknown&quot;)';
+	$SQLquery .= ' OR (`genre` = &quot;Other&quot;)';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		while ($row = mysql_fetch_array($result)) {
+			if (!in_array($row['fileformat'], $IgnoreNoTagFormats)) {
+				echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+			}
+		}
+		exit;
+
+	} else {
+
+		echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?emptygenres='.urlencode($_REQUEST['emptygenres']).'&amp;m3u=1&quot;&gt;.m3u version&lt;/a&gt;&lt;br&gt;';
+		$EmptyGenreCounter = 0;
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th&gt;m3u&lt;/th&gt;&lt;th&gt;filename&lt;/th&gt;&lt;/tr&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			if (!in_array($row['fileformat'], $IgnoreNoTagFormats)) {
+				$EmptyGenreCounter++;
+				echo '&lt;tr&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;/tr&gt;';
+			}
+		}
+		echo '&lt;/table&gt;';
+		echo '&lt;b&gt;'.number_format($EmptyGenreCounter).'&lt;/b&gt; files with empty genres';
+
+	}
+
+} elseif (!empty($_REQUEST['nonemptycomments'])) {
+
+	$SQLquery  = 'SELECT `filename`, `comment`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`comment` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' ORDER BY `comment` ASC';
+	$result = safe_mysql_query($SQLquery);
+
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		while ($row = mysql_fetch_array($result)) {
+			echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+		}
+		exit;
+
+	} else {
+
+		$NonEmptyCommentsCounter = 0;
+		echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?nonemptycomments='.urlencode($_REQUEST['nonemptycomments']).'&amp;m3u=1&quot;&gt;.m3u version&lt;/a&gt;&lt;br&gt;';
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th&gt;m3u&lt;/th&gt;&lt;th&gt;filename&lt;/th&gt;&lt;th&gt;comments&lt;/th&gt;&lt;/tr&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			$NonEmptyCommentsCounter++;
+			echo '&lt;tr&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+			if (strlen(trim($row['comment'])) &gt; 0) {
+				echo '&lt;td&gt;'.FixTextFields($row['comment']).'&lt;/td&gt;';
+			} else {
+				echo '&lt;td&gt;&lt;i&gt;space&lt;/i&gt;&lt;/td&gt;';
+			}
+			echo '&lt;/tr&gt;';
+		}
+		echo '&lt;/table&gt;';
+		echo '&lt;b&gt;'.number_format($NonEmptyCommentsCounter).'&lt;/b&gt; files with non-empty comments';
+
+	}
+
+} elseif (!empty($_REQUEST['trackzero'])) {
+
+	$SQLquery  = 'SELECT `filename`, `track`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`track` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' AND ((`track` &lt; &quot;1&quot;)';
+	$SQLquery .= ' OR (`track` &gt; &quot;99&quot;))';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		while ($row = mysql_fetch_array($result)) {
+			if ((strlen($row['track']) &gt; 0) &amp;&amp; ($row['track'] &lt; 1) || ($row['track'] &gt; 99)) {
+				echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+			}
+		}
+		exit;
+
+	} else {
+
+		echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?trackzero='.urlencode($_REQUEST['trackzero']).'&amp;m3u=1&quot;&gt;.m3u version&lt;/a&gt;&lt;br&gt;';
+		$TrackZeroCounter = 0;
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th&gt;m3u&lt;/th&gt;&lt;th&gt;filename&lt;/th&gt;&lt;th&gt;track&lt;/th&gt;&lt;/tr&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			if ((strlen($row['track']) &gt; 0) &amp;&amp; ($row['track'] &lt; 1) || ($row['track'] &gt; 99)) {
+				$TrackZeroCounter++;
+				echo '&lt;tr&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;td&gt;'.FixTextFields($row['track']).'&lt;/td&gt;';
+				echo '&lt;/tr&gt;';
+			}
+		}
+		echo '&lt;/table&gt;';
+		echo '&lt;b&gt;'.number_format($TrackZeroCounter).'&lt;/b&gt; files with track &quot;zero&quot;';
+
+	}
+
+
+} elseif (!empty($_REQUEST['titlefeat'])) {
+
+	$SQLquery  = 'SELECT `filename`, `title`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`title` LIKE &quot;%feat.%&quot;)';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		while ($row = mysql_fetch_array($result)) {
+			echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+		}
+		exit;
+
+	} else {
+
+		echo '&lt;b&gt;'.number_format(mysql_num_rows($result)).'&lt;/b&gt; files with &quot;feat.&quot; in the title (instead of the artist)&lt;br&gt;&lt;br&gt;';
+		echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?titlefeat='.urlencode($_REQUEST['titlefeat']).'&amp;m3u=1&quot;&gt;.m3u version&lt;/a&gt;&lt;br&gt;';
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th&gt;m3u&lt;/th&gt;&lt;th&gt;filename&lt;/th&gt;&lt;th&gt;title&lt;/th&gt;&lt;/tr&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			echo '&lt;tr&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;td&gt;'.eregi_replace('(feat\. .*)', '&lt;b&gt;\\1&lt;/b&gt;', FixTextFields($row['title'])).'&lt;/td&gt;';
+			echo '&lt;/tr&gt;';
+		}
+		echo '&lt;/table&gt;';
+
+	}
+
+
+} elseif (!empty($_REQUEST['tracknoalbum'])) {
+
+	$SQLquery  = 'SELECT `filename`, `track`, `album`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`track` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' AND (`album` = &quot;&quot;)';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		while ($row = mysql_fetch_array($result)) {
+			echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+		}
+		exit;
+
+	} else {
+
+		echo '&lt;b&gt;'.number_format(mysql_num_rows($result)).'&lt;/b&gt; files with a track number, but no album&lt;br&gt;&lt;br&gt;';
+		echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?tracknoalbum='.urlencode($_REQUEST['tracknoalbum']).'&amp;m3u=1&quot;&gt;.m3u version&lt;/a&gt;&lt;br&gt;';
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th&gt;m3u&lt;/th&gt;&lt;th&gt;filename&lt;/th&gt;&lt;th&gt;track&lt;/th&gt;&lt;th&gt;album&lt;/th&gt;&lt;/tr&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			echo '&lt;tr&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;td&gt;'.FixTextFields($row['track']).'&lt;/td&gt;';
+			echo '&lt;td&gt;'.FixTextFields($row['album']).'&lt;/td&gt;';
+			echo '&lt;/tr&gt;';
+		}
+		echo '&lt;/table&gt;';
+
+	}
+
+
+} elseif (!empty($_REQUEST['synchronizetagsfrom']) &amp;&amp; !empty($_REQUEST['filename'])) {
+
+	echo 'Applying new tags from &lt;b&gt;'.$_REQUEST['synchronizetagsfrom'].'&lt;/b&gt; in &lt;b&gt;'.FixTextFields($_REQUEST['filename']).'&lt;/b&gt;&lt;ul&gt;';
+	$errors = array();
+	if (SynchronizeAllTags($_REQUEST['filename'], $_REQUEST['synchronizetagsfrom'], 'A12', $errors)) {
+		echo '&lt;li&gt;Sucessfully wrote tags&lt;/li&gt;';
+	} else {
+		echo '&lt;li&gt;Tag writing had errors: &lt;ul&gt;&lt;li&gt;'.implode('&lt;/li&gt;&lt;li&gt;', $errors).'&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;';
+	}
+	echo '&lt;/ul&gt;';
+
+
+} elseif (!empty($_REQUEST['unsynchronizedtags'])) {
+
+	$NotOKfiles        = 0;
+	$Autofixedfiles    = 0;
+	$FieldsToCompare   = array('title', 'artist', 'album', 'year', 'genre', 'comment', 'track');
+	$TagsToCompare     = array('id3v2'=&gt;false, 'ape'=&gt;false, 'lyrics3'=&gt;false, 'id3v1'=&gt;false);
+	$ID3v1FieldLengths = array('title'=&gt;30, 'artist'=&gt;30, 'album'=&gt;30, 'year'=&gt;4, 'genre'=&gt;99, 'comment'=&gt;28);
+	if (strpos($_REQUEST['unsynchronizedtags'], '2') !== false) {
+		$TagsToCompare['id3v2'] = true;
+	}
+	if (strpos($_REQUEST['unsynchronizedtags'], 'A') !== false) {
+		$TagsToCompare['ape'] = true;
+	}
+	if (strpos($_REQUEST['unsynchronizedtags'], 'L') !== false) {
+		$TagsToCompare['lyrics3'] = true;
+	}
+	if (strpos($_REQUEST['unsynchronizedtags'], '1') !== false) {
+		$TagsToCompare['id3v1'] = true;
+	}
+
+	echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?unsynchronizedtags='.urlencode($_REQUEST['unsynchronizedtags']).'&amp;autofix=1&quot;&gt;Auto-fix empty tags&lt;/a&gt;&lt;br&gt;&lt;br&gt;';
+	echo '&lt;div id=&quot;Autofixing&quot;&gt;&lt;/div&gt;';
+	echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+	echo '&lt;tr&gt;';
+	echo '&lt;th&gt;View&lt;/th&gt;';
+	echo '&lt;th&gt;Filename&lt;/th&gt;';
+	echo '&lt;th&gt;Combined&lt;/th&gt;';
+	if ($TagsToCompare['id3v2']) {
+		echo '&lt;th&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?unsynchronizedtags='.urlencode($_REQUEST['unsynchronizedtags']).'&amp;autofix=1&amp;autofixforcesource=id3v2&amp;autofixforcedest=A1&quot; TITLE=&quot;Auto-fix all tags to match ID3v2 contents&quot; onClick=&quot;return confirm(\'Are you SURE you want to synchronize all tags to match ID3v2?\');&quot;&gt;ID3v2&lt;/a&gt;&lt;/th&gt;';
+	}
+	if ($TagsToCompare['ape']) {
+		echo '&lt;th&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?unsynchronizedtags='.urlencode($_REQUEST['unsynchronizedtags']).'&amp;autofix=1&amp;autofixforcesource=ape&amp;autofixforcedest=21&quot; TITLE=&quot;Auto-fix all tags to match APE contents&quot; onClick=&quot;return confirm(\'Are you SURE you want to synchronize all tags to match APE?\');&quot;&gt;APE&lt;/a&gt;&lt;/th&gt;';
+	}
+	if ($TagsToCompare['lyrics3']) {
+		echo '&lt;th&gt;Lyrics3&lt;/th&gt;';
+	}
+	if ($TagsToCompare['id3v1']) {
+		echo '&lt;th&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?unsynchronizedtags='.urlencode($_REQUEST['unsynchronizedtags']).'&amp;autofix=1&amp;autofixforcesource=ape&amp;autofixforcedest=2A&quot; TITLE=&quot;Auto-fix all tags to match ID3v1 contents&quot; onClick=&quot;return confirm(\'Are you SURE you want to synchronize all tags to match ID3v1?\');&quot;&gt;ID3v1&lt;/a&gt;&lt;/th&gt;';
+	}
+	echo '&lt;/tr&gt;';
+
+	$SQLquery  = 'SELECT `filename`, `comments_all`, `comments_id3v2`, `comments_ape`, `comments_lyrics3`, `comments_id3v1`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`fileformat` = &quot;mp3&quot;)';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+	$lastdir = '';
+	while ($row = mysql_fetch_array($result)) {
+		set_time_limit(30);
+		if ($lastdir != dirname($row['filename'])) {
+			echo '&lt;script&gt;if (document.getElementById(&quot;Autofixing&quot;)) document.getElementById(&quot;Autofixing&quot;).innerHTML = &quot;'.htmlentities($lastdir, ENT_QUOTES).'&quot;;&lt;/script&gt;';
+			flush();
+		}
+
+		$FileOK      = true;
+		$Mismatched  = array('id3v2'=&gt;false, 'ape'=&gt;false, 'lyrics3'=&gt;false, 'id3v1'=&gt;false);
+		$SemiMatched = array('id3v2'=&gt;false, 'ape'=&gt;false, 'lyrics3'=&gt;false, 'id3v1'=&gt;false);
+		$EmptyTags   = array('id3v2'=&gt;true,  'ape'=&gt;true,  'lyrics3'=&gt;true,  'id3v1'=&gt;true);
+
+		$Comments['all']     = @unserialize($row['comments_all']);
+		$Comments['id3v2']   = @unserialize($row['comments_id3v2']);
+		$Comments['ape']     = @unserialize($row['comments_ape']);
+		$Comments['lyrics3'] = @unserialize($row['comments_lyrics3']);
+		$Comments['id3v1']   = @unserialize($row['comments_id3v1']);
+
+		if (isset($Comments['ape']['tracknumber'])) {
+			$Comments['ape']['track'] = $Comments['ape']['tracknumber'];
+			unset($Comments['ape']['tracknumber']);
+		}
+		if (!empty($Comments['all']['track'])) {
+			$besttrack = '';
+			foreach ($Comments['all']['track'] as $key =&gt; $value) {
+				if (strlen($value) &gt; strlen($besttrack)) {
+					$besttrack = $value;
+				}
+			}
+			$Comments['all']['track'] = array(0=&gt;$besttrack);
+		}
+
+		$ThisLine  = '&lt;tr&gt;';
+		$ThisLine .= '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;view&lt;/a&gt;&lt;/td&gt;';
+		$ThisLine .= '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+		$tagvalues = '';
+		foreach ($FieldsToCompare as $fieldname) {
+			$tagvalues .= $fieldname.' = '<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">. at implode</A>(&quot; \n&quot;, @$Comments['all'][$fieldname]).&quot; \n&quot;;
+		}
+		$ThisLine .= '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?synchronizetagsfrom=all&amp;filename='.urlencode($row['filename']).'&quot; TITLE=&quot;'.htmlentities(rtrim($tagvalues, &quot;\n&quot;), ENT_QUOTES).'&quot; TARGET=&quot;retagwindow&quot;&gt;all&lt;/a&gt;&lt;/td&gt;';
+		foreach ($TagsToCompare as $tagtype =&gt; $CompareThisTagType) {
+			if ($CompareThisTagType) {
+				$tagvalues = '';
+				foreach ($FieldsToCompare as $fieldname) {
+
+					if ($tagtype == 'id3v1') {
+
+						getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v1.php', __FILE__, true);
+						if (($fieldname == 'genre') &amp;&amp; !getid3_id3v1::LookupGenreID(@$Comments['all'][$fieldname][0])) {
+
+							// non-standard genres can never match, so just ignore
+							$tagvalues .= $fieldname.' = '.@$Comments[$tagtype][$fieldname][0].&quot;\n&quot;;
+
+						} elseif ($fieldname == 'comment') {
+
+							if (rtrim(substr(@$Comments[$tagtype][$fieldname][0], 0, 28)) != rtrim(substr(@$Comments['all'][$fieldname][0], 0, 28))) {
+								$tagvalues .= $fieldname.' = [['.@$Comments[$tagtype][$fieldname][0].']]'.&quot;\n&quot;;
+								if (trim(strtolower(RemoveAccents(substr(@$Comments[$tagtype][$fieldname][0], 0, 28)))) == trim(strtolower(RemoveAccents(substr(@$Comments['all'][$fieldname][0], 0, 28))))) {
+									$SemiMatched[$tagtype] = true;
+								} else {
+									$Mismatched[$tagtype]  = true;
+								}
+								$FileOK = false;
+							} else {
+								$tagvalues .= $fieldname.' = '.@$Comments[$tagtype][$fieldname][0].&quot;\n&quot;;
+							}
+
+						} elseif ($fieldname == 'track') {
+
+							// intval('01/20') == intval('1')
+							if (intval(@$Comments[$tagtype][$fieldname][0]) != intval(@$Comments['all'][$fieldname][0])) {
+								$tagvalues .= $fieldname.' = [['.@$Comments[$tagtype][$fieldname][0].']]'.&quot;\n&quot;;
+								$Mismatched[$tagtype]  = true;
+								$FileOK = false;
+							} else {
+								$tagvalues .= $fieldname.' = '.@$Comments[$tagtype][$fieldname][0].&quot;\n&quot;;
+							}
+
+						} elseif (rtrim(substr(@$Comments[$tagtype][$fieldname][0], 0, 30)) != rtrim(substr(@$Comments['all'][$fieldname][0], 0, 30))) {
+
+							$tagvalues .= $fieldname.' = [['.@$Comments[$tagtype][$fieldname][0].']]'.&quot;\n&quot;;
+							if (strtolower(RemoveAccents(trim(substr(@$Comments[$tagtype][$fieldname][0], 0, 30)))) == strtolower(RemoveAccents(trim(substr(@$Comments['all'][$fieldname][0], 0, 30))))) {
+								$SemiMatched[$tagtype] = true;
+							} else {
+								$Mismatched[$tagtype]  = true;
+							}
+							$FileOK = false;
+							if (strlen(trim(@$Comments[$tagtype][$fieldname][0])) &gt; 0) {
+								$EmptyTags[$tagtype] = false;
+							}
+
+						} else {
+
+							$tagvalues .= $fieldname.' = '.@$Comments[$tagtype][$fieldname][0].&quot;\n&quot;;
+							if (strlen(trim(@$Comments[$tagtype][$fieldname][0])) &gt; 0) {
+								$EmptyTags[$tagtype] = false;
+							}
+
+						}
+
+					} elseif (($tagtype == 'ape') &amp;&amp; ($fieldname == 'year')) {
+
+						if ((@$Comments['ape']['date'][0] != @$Comments['all']['year'][0]) &amp;&amp; (@$Comments['ape']['year'][0] != @$Comments['all']['year'][0])) {
+
+							$tagvalues .= $fieldname.' = [['.@$Comments['ape']['date'][0].']]'.&quot;\n&quot;;
+							$Mismatched[$tagtype]  = true;
+							$FileOK = false;
+							if (strlen(trim(@$Comments['ape']['date'][0])) &gt; 0) {
+								$EmptyTags[$tagtype] = false;
+							}
+
+						} else {
+
+							$tagvalues .= $fieldname.' = '.@$Comments[$tagtype][$fieldname][0].&quot;\n&quot;;
+							if (strlen(trim(@$Comments[$tagtype][$fieldname][0])) &gt; 0) {
+								$EmptyTags[$tagtype] = false;
+							}
+
+						}
+
+					} elseif (($fieldname == 'genre') &amp;&amp; !empty($Comments['all'][$fieldname]) &amp;&amp; !empty($Comments[$tagtype][$fieldname]) &amp;&amp; in_array($Comments[$tagtype][$fieldname][0], $Comments['all'][$fieldname])) {
+
+						$tagvalues .= $fieldname.' = '.@$Comments[$tagtype][$fieldname][0].&quot;\n&quot;;
+						if (strlen(trim(@$Comments[$tagtype][$fieldname][0])) &gt; 0) {
+							$EmptyTags[$tagtype] = false;
+						}
+
+					} elseif (@$Comments[$tagtype][$fieldname][0] != @$Comments['all'][$fieldname][0]) {
+
+						$tagvalues .= $fieldname.' = [['.@$Comments[$tagtype][$fieldname][0].']]'.&quot;\n&quot;;
+						if (trim(strtolower(RemoveAccents(@$Comments[$tagtype][$fieldname][0]))) == trim(strtolower(RemoveAccents(@$Comments['all'][$fieldname][0])))) {
+							$SemiMatched[$tagtype] = true;
+						} else {
+							$Mismatched[$tagtype]  = true;
+						}
+						$FileOK = false;
+						if (strlen(trim(@$Comments[$tagtype][$fieldname][0])) &gt; 0) {
+							$EmptyTags[$tagtype] = false;
+						}
+
+					} else {
+
+						$tagvalues .= $fieldname.' = '.@$Comments[$tagtype][$fieldname][0].&quot;\n&quot;;
+						if (strlen(trim(@$Comments[$tagtype][$fieldname][0])) &gt; 0) {
+							$EmptyTags[$tagtype] = false;
+						}
+
+					}
+				}
+
+				if ($EmptyTags[$tagtype]) {
+					$FileOK = false;
+					$ThisLine .= '&lt;TD BGCOLOR=&quot;#0099CC&quot;&gt;';
+				} elseif ($SemiMatched[$tagtype]) {
+					$ThisLine .= '&lt;TD BGCOLOR=&quot;#FF9999&quot;&gt;';
+				} elseif ($Mismatched[$tagtype]) {
+					$ThisLine .= '&lt;TD BGCOLOR=&quot;#FF0000&quot;&gt;';
+				} else {
+					$ThisLine .= '&lt;TD BGCOLOR=&quot;#00CC00&quot;&gt;';
+				}
+				$ThisLine .= '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?synchronizetagsfrom='.$tagtype.'&amp;filename='.urlencode($row['filename']).'&quot; TITLE=&quot;'.htmlentities(rtrim($tagvalues, &quot;\n&quot;), ENT_QUOTES).'&quot; TARGET=&quot;retagwindow&quot;&gt;'.$tagtype.'&lt;/a&gt;';
+				$ThisLine .= '&lt;/td&gt;';
+			}
+		}
+		$ThisLine .= '&lt;/tr&gt;';
+
+		if (!$FileOK) {
+			$NotOKfiles++;
+
+			echo '&lt;script&gt;if (document.getElementById(&quot;Autofixing&quot;)) document.getElementById(&quot;Autofixing&quot;).innerHTML = &quot;'.htmlentities($row['filename'], ENT_QUOTES).'&quot;;&lt;/script&gt;';
+			flush();
+
+			if (!empty($_REQUEST['autofix'])) {
+
+				$AnyMismatched = false;
+				foreach ($Mismatched as $key =&gt; $value) {
+					if ($value &amp;&amp; ($EmptyTags[&quot;$key&quot;] === false)) {
+						$AnyMismatched = true;
+					}
+				}
+				if ($AnyMismatched &amp;&amp; empty($_REQUEST['autofixforcesource'])) {
+
+					echo $ThisLine;
+
+				} else {
+
+					$TagsToSynch = '';
+					foreach ($EmptyTags as $key =&gt; $value) {
+						if ($value) {
+							switch ($key) {
+								case 'id3v1':
+									$TagsToSynch .= '1';
+									break;
+								case 'id3v2':
+									$TagsToSynch .= '2';
+									break;
+								case 'ape':
+									$TagsToSynch .= 'A';
+									break;
+							}
+						}
+					}
+
+					$autofixforcesource = (@$_REQUEST['autofixforcesource'] ? $_REQUEST['autofixforcesource'] : 'all');
+					$TagsToSynch        = (@$_REQUEST['autofixforcedest']   ? $_REQUEST['autofixforcedest']   : $TagsToSynch);
+
+					$errors = array();
+					if (SynchronizeAllTags($row['filename'], $autofixforcesource, $TagsToSynch, $errors)) {
+						$Autofixedfiles++;
+						echo '&lt;tr bgcolor=&quot;#00CC00&quot;&gt;';
+					} else {
+						echo '&lt;tr bgcolor=&quot;#FF0000&quot;&gt;';
+					}
+					echo '&lt;td&gt;&nbsp;&lt;/th&gt;';
+					echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot; TITLE=&quot;'.FixTextFields(implode(&quot;\n&quot;, $errors)).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+					echo '&lt;td&gt;&lt;table border=&quot;0&quot;&gt;';
+					echo '&lt;tr&gt;&lt;td&gt;&lt;b&gt;'.$TagsToSynch.'&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;';
+					echo '&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;';
+				}
+
+			} else {
+
+				echo $ThisLine;
+
+			}
+		}
+	}
+
+	echo '&lt;/table&gt;&lt;br&gt;';
+	echo '&lt;script&gt;if (document.getElementById(&quot;Autofixing&quot;)) document.getElementById(&quot;Autofixing&quot;).innerHTML = &quot;&quot;;&lt;/script&gt;';
+	echo 'Found &lt;b&gt;'.number_format($NotOKfiles).'&lt;/b&gt; files with unsynchronized tags, and auto-fixed '.number_format($Autofixedfiles).' of them.';
+
+} elseif (!empty($_REQUEST['filenamepattern'])) {
+
+	$patterns['A'] = 'artist';
+	$patterns['T'] = 'title';
+	$patterns['M'] = 'album';
+	$patterns['N'] = 'track';
+	$patterns['G'] = 'genre';
+	$patterns['R'] = 'remix';
+
+	$FieldsToUse = explode(' ', wordwrap(eregi_replace('[^A-Z]', '', $_REQUEST['filenamepattern']), 1, ' ', 1));
+	//$FieldsToUse = explode(' ', wordwrap($_REQUEST['filenamepattern'], 1, ' ', 1));
+	foreach ($FieldsToUse as $FieldID) {
+		$FieldNames[] = $patterns[&quot;$FieldID&quot;];
+	}
+
+	$SQLquery  = 'SELECT `filename`, `fileformat`, '.implode(', ', $FieldNames);
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`fileformat` NOT LIKE &quot;'.implode('&quot;) AND (`fileformat` NOT LIKE &quot;', $IgnoreNoTagFormats).'&quot;)';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+	echo 'Files that do not match naming pattern: (&lt;a href=&quot;?filenamepattern='.urlencode($_REQUEST['filenamepattern']).'&amp;autofix=1&quot;&gt;auto-fix&lt;/a&gt;)&lt;br&gt;';
+	echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+	echo '&lt;tr&gt;&lt;th&gt;view&lt;/th&gt;&lt;th&gt;Why&lt;/th&gt;&lt;td&gt;&lt;b&gt;Actual filename&lt;/b&gt;&lt;br&gt;(click to play/edit file)&lt;/td&gt;&lt;td&gt;&lt;b&gt;Correct filename (based on tags)&lt;/b&gt;'.(!@$_REQUEST['autofix'] ? '&lt;br&gt;(click to rename file to this)' : '').'&lt;/td&gt;&lt;/tr&gt;';
+	$nonmatchingfilenames = 0;
+	$Pattern = $_REQUEST['filenamepattern'];
+	$PatternLength = strlen($Pattern);
+	while ($row = mysql_fetch_array($result)) {
+		set_time_limit(10);
+		$PatternFilename = '';
+		for ($i = 0; $i &lt; $PatternLength; $i++) {
+			if (isset($patterns[$Pattern{$i}])) {
+				$PatternFilename .= trim(strtr($row[$patterns[$Pattern{$i}]], ':\\*&lt;&gt;|', ';-&#164;&#171;&#187;&#166;'), ' ');
+			} else {
+				$PatternFilename .= $Pattern{$i};
+			}
+		}
+
+		// Replace &quot;~&quot; with &quot;-&quot; if characters immediately before and after are both numbers,
+		// &quot;/&quot; has been replaced with &quot;~&quot; above which is good for multi-song medley dividers,
+		// but for things like 24/7, 7/8ths, etc it looks better if it's 24-7, 7-8ths, etc.
+		$PatternFilename = eregi_replace('([ a-z]+)/([ a-z]+)', '\\1~\\2', $PatternFilename);
+		$PatternFilename = str_replace('/',  '&#215;',  $PatternFilename);
+
+		$PatternFilename = str_replace('?',  '&#191;',  $PatternFilename);
+		$PatternFilename = str_replace(' &quot;', ' &#147;', $PatternFilename);
+		$PatternFilename = str_replace('(&quot;', '(&#147;', $PatternFilename);
+		$PatternFilename = str_replace('-&quot;', '-&#147;', $PatternFilename);
+		$PatternFilename = str_replace('&quot; ', '&#148; ', $PatternFilename.' ');
+		$PatternFilename = str_replace('&quot;',  '&#148;',  $PatternFilename);
+		$PatternFilename = str_replace('  ', ' ',  $PatternFilename);
+
+
+		$ParenthesesPairs = array('()', '[]', '{}');
+		foreach ($ParenthesesPairs as $pair) {
+
+			// multiple remixes are stored tab-seperated in the database.
+			// change &quot;{2000 Version\tSomebody Remix}&quot; into &quot;{2000 Version} {Somebody Remix}&quot;
+			while (ereg('^(.*)'.preg_quote($pair{0}).'([^'.preg_quote($pair{1}).']*)('.&quot;\t&quot;.')([^'.preg_quote($pair{0}).']*)'.preg_quote($pair{1}), $PatternFilename, $matches)) {
+				$PatternFilename = $matches[1].$pair{0}.$matches[2].$pair{1}.' '.$pair{0}.$matches[4].$pair{1};
+			}
+
+			// remove empty parenthesized pairs (probably where no track numbers, remix version, etc)
+			$PatternFilename = ereg_replace(preg_quote($pair), '', $PatternFilename);
+
+			// &quot;[01]  - Title With No Artist.mp3&quot;  ==&gt;  &quot;[01] Title With No Artist.mp3&quot;
+			$PatternFilename = ereg_replace(preg_quote($pair{1}).' +\- ', $pair{1}.' ', $PatternFilename);
+
+		}
+
+		// get rid of leading &amp; trailing spaces if end items (artist or title for example) are missing
+		$PatternFilename  = trim($PatternFilename, ' -');
+
+		if (!$PatternFilename) {
+			// no tags to create a filename from -- skip this file
+			continue;
+		}
+		$PatternFilename .= '.'.$row['fileformat'];
+
+		$ActualFilename = basename($row['filename']);
+		if ($ActualFilename != $PatternFilename) {
+
+			$NotMatchedReasons = '';
+			if (strtolower($ActualFilename) === strtolower($PatternFilename)) {
+				$NotMatchedReasons .= 'Aa ';
+			} elseif (RemoveAccents($ActualFilename) === RemoveAccents($PatternFilename)) {
+				$NotMatchedReasons .= '&#233;e ';
+			}
+
+
+			$actualExt  = '.'.fileextension($ActualFilename);
+			$patternExt = '.'.fileextension($PatternFilename);
+			$ActualFilenameNoExt  = (($actualExt  != '.') ? substr($ActualFilename,   0, 0 - strlen($actualExt))  : $ActualFilename);
+			$PatternFilenameNoExt = (($patternExt != '.') ? substr($PatternFilename,  0, 0 - strlen($patternExt)) : $PatternFilename);
+
+			if (strpos($PatternFilenameNoExt, $ActualFilenameNoExt) !== false) {
+				$DifferenceBoldedName  = str_replace($ActualFilenameNoExt, '&lt;/b&gt;'.$ActualFilenameNoExt.'&lt;b&gt;', $PatternFilenameNoExt);
+			} else {
+				$ShortestNameLength = min(strlen($ActualFilenameNoExt), strlen($PatternFilenameNoExt));
+				for ($DifferenceOffset = 0; $DifferenceOffset &lt; $ShortestNameLength; $DifferenceOffset++) {
+					if ($ActualFilenameNoExt{$DifferenceOffset} !== $PatternFilenameNoExt{$DifferenceOffset}) {
+						break;
+					}
+				}
+				$DifferenceBoldedName  = '&lt;/b&gt;'.substr($PatternFilenameNoExt, 0, $DifferenceOffset).'&lt;b&gt;'.substr($PatternFilenameNoExt, $DifferenceOffset);
+			}
+			$DifferenceBoldedName .= (($actualExt == $patternExt) ? '&lt;/b&gt;'.$patternExt.'&lt;b&gt;' : $patternExt);
+
+
+			echo '&lt;tr&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;view&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;td&gt;&nbsp;'.$NotMatchedReasons.'&lt;/td&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;'.FixTextFields($ActualFilename).'&lt;/a&gt;&lt;/td&gt;';
+
+			if (@$_REQUEST['autofix']) {
+
+				$results = '';
+				if (RenameFileFromTo($row['filename'], dirname($row['filename']).'/'.$PatternFilename, $results)) {
+					echo '&lt;TD BGCOLOR=&quot;#009900&quot;&gt;';
+				} else {
+					echo '&lt;TD BGCOLOR=&quot;#FF0000&quot;&gt;';
+				}
+				echo '&lt;b&gt;'.$DifferenceBoldedName.'&lt;/b&gt;&lt;/td&gt;';
+
+
+			} else {
+
+				echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?filenamepattern='.urlencode($_REQUEST['filenamepattern']).'&amp;renamefilefrom='.urlencode($row['filename']).'&amp;renamefileto='.urlencode(dirname($row['filename']).'/'.$PatternFilename).'&quot; TITLE=&quot;'.FixTextFields(basename($row['filename'])).&quot;\n&quot;.FixTextFields(basename($PatternFilename)).'&quot; TARGET=&quot;renamewindow&quot;&gt;';
+				echo '&lt;b&gt;'.$DifferenceBoldedName.'&lt;/b&gt;&lt;/a&gt;&lt;/td&gt;';
+
+			}
+			echo '&lt;/tr&gt;';
+
+			$nonmatchingfilenames++;
+		}
+	}
+	echo '&lt;/table&gt;&lt;br&gt;';
+	echo 'Found '.number_format($nonmatchingfilenames).' files that do not match naming pattern&lt;br&gt;';
+
+
+} elseif (!empty($_REQUEST['encoderoptionsdistribution'])) {
+
+	if (isset($_REQUEST['showtagfiles'])) {
+		$SQLquery  = 'SELECT `filename`, `encoder_options` FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`encoder_options` LIKE &quot;'.mysql_escape_string($_REQUEST['showtagfiles']).'&quot;)';
+		$SQLquery .= ' AND (`fileformat` NOT LIKE &quot;'.implode('&quot;) AND (`fileformat` NOT LIKE &quot;', $IgnoreNoTagFormats).'&quot;)';
+		$SQLquery .= ' ORDER BY `filename` ASC';
+		$result = safe_mysql_query($SQLquery);
+
+		if (!empty($_REQUEST['m3u'])) {
+
+			header('Content-type: audio/x-mpegurl');
+			echo '#EXTM3U'.&quot;\n&quot;;
+			while ($row = mysql_fetch_array($result)) {
+				echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+			}
+			exit;
+
+		} else {
+
+			echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?encoderoptionsdistribution=1&quot;&gt;Show all Encoder Options&lt;/a&gt;&lt;hr&gt;';
+			echo 'Files with Encoder Options &lt;b&gt;'.$_REQUEST['showtagfiles'].'&lt;/b&gt;:&lt;br&gt;';
+			echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+			while ($row = mysql_fetch_array($result)) {
+				echo '&lt;tr&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;td&gt;'.$row['encoder_options'].'&lt;/td&gt;';
+				echo '&lt;/tr&gt;';
+			}
+			echo '&lt;/table&gt;';
+
+		}
+
+	} elseif (!isset($_REQUEST['m3u'])) {
+
+		$SQLquery  = 'SELECT `encoder_options`, COUNT(*) AS `num` FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`fileformat` NOT LIKE &quot;'.implode('&quot;) AND (`fileformat` NOT LIKE &quot;', $IgnoreNoTagFormats).'&quot;)';
+		$SQLquery .= ' GROUP BY `encoder_options`';
+		$SQLquery .= ' ORDER BY (`encoder_options` LIKE &quot;LAME%&quot;) DESC, (`encoder_options` LIKE &quot;CBR%&quot;) DESC, `num` DESC, `encoder_options` ASC';
+		$result = safe_mysql_query($SQLquery);
+		echo 'Files with Encoder Options:&lt;br&gt;';
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th&gt;Encoder Options&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;th&gt;M3U&lt;/th&gt;&lt;/tr&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			echo '&lt;tr&gt;';
+			echo '&lt;td&gt;'.$row['encoder_options'].'&lt;/td&gt;';
+			echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?encoderoptionsdistribution=1&amp;showtagfiles='.($row['encoder_options'] ? urlencode($row['encoder_options']) : '').'&quot;&gt;'.number_format($row['num']).'&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?encoderoptionsdistribution=1&amp;showtagfiles='.($row['encoder_options'] ? urlencode($row['encoder_options']) : '').'&amp;m3u=.m3u&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;/tr&gt;';
+		}
+		echo '&lt;/table&gt;&lt;hr&gt;';
+
+	}
+
+} elseif (!empty($_REQUEST['tagtypes'])) {
+
+	if (!isset($_REQUEST['m3u'])) {
+		$SQLquery  = 'SELECT `tags`, COUNT(*) AS `num` FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`fileformat` NOT LIKE &quot;'.implode('&quot;) AND (`fileformat` NOT LIKE &quot;', $IgnoreNoTagFormats).'&quot;)';
+		$SQLquery .= ' GROUP BY `tags`';
+		$SQLquery .= ' ORDER BY `num` DESC';
+		$result = safe_mysql_query($SQLquery);
+		echo 'Files with tags:&lt;br&gt;';
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th&gt;Tags&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;th&gt;M3U&lt;/th&gt;&lt;/tr&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			echo '&lt;tr&gt;';
+			echo '&lt;td&gt;'.$row['tags'].'&lt;/td&gt;';
+			echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?tagtypes=1&amp;showtagfiles='.($row['tags'] ? urlencode($row['tags']) : '').'&quot;&gt;'.number_format($row['num']).'&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?tagtypes=1&amp;showtagfiles='.($row['tags'] ? urlencode($row['tags']) : '').'&amp;m3u=.m3u&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;/tr&gt;';
+		}
+		echo '&lt;/table&gt;&lt;hr&gt;';
+	}
+
+	if (isset($_REQUEST['showtagfiles'])) {
+		$SQLquery  = 'SELECT `filename`, `tags` FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`tags` LIKE &quot;'.mysql_escape_string($_REQUEST['showtagfiles']).'&quot;)';
+		$SQLquery .= ' AND (`fileformat` NOT LIKE &quot;'.implode('&quot;) AND (`fileformat` NOT LIKE &quot;', $IgnoreNoTagFormats).'&quot;)';
+		$SQLquery .= ' ORDER BY `filename` ASC';
+		$result = safe_mysql_query($SQLquery);
+
+		if (!empty($_REQUEST['m3u'])) {
+
+			header('Content-type: audio/x-mpegurl');
+			echo '#EXTM3U'.&quot;\n&quot;;
+			while ($row = mysql_fetch_array($result)) {
+				echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+			}
+			exit;
+
+		} else {
+
+			echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+			while ($row = mysql_fetch_array($result)) {
+				echo '&lt;tr&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;td&gt;'.$row['tags'].'&lt;/td&gt;';
+				echo '&lt;/tr&gt;';
+			}
+			echo '&lt;/table&gt;';
+
+		}
+	}
+
+
+} elseif (!empty($_REQUEST['md5datadupes'])) {
+
+	$OtherFormats = '';
+	$AVFormats    = '';
+
+	$SQLquery  = 'SELECT `md5_data`, `filename`, COUNT(*) AS `num`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`md5_data` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' GROUP BY `md5_data`';
+	$SQLquery .= ' ORDER BY `num` DESC';
+	$result = safe_mysql_query($SQLquery);
+	while (($row = mysql_fetch_array($result)) &amp;&amp; ($row['num'] &gt; 1)) {
+		set_time_limit(30);
+
+		$filenames = array();
+		$tags      = array();
+		$md5_data  = array();
+		$SQLquery  = 'SELECT `fileformat`, `filename`, `tags`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`md5_data` = &quot;'.mysql_escape_string($row['md5_data']).'&quot;)';
+		$SQLquery .= ' ORDER BY `filename` ASC';
+		$result2 = safe_mysql_query($SQLquery);
+		while ($row2 = mysql_fetch_array($result2)) {
+			$thisfileformat = $row2['fileformat'];
+			$filenames[] = $row2['filename'];
+			$tags[]      = $row2['tags'];
+			$md5_data[]  = $row['md5_data'];
+		}
+
+		$thisline  = '&lt;tr&gt;';
+		$thisline .= '&lt;TD VALIGN=&quot;TOP&quot; style=&quot;font-family: monospace;&quot;&gt;'.implode('&lt;br&gt;', $md5_data).'&lt;/td&gt;';
+		$thisline .= '&lt;TD VALIGN=&quot;TOP&quot; NOWRAP&gt;'.implode('&lt;br&gt;', $tags).'&lt;/td&gt;';
+		$thisline .= '&lt;TD VALIGN=&quot;TOP&quot;&gt;'.implode('&lt;br&gt;', $filenames).'&lt;/td&gt;';
+		$thisline .= '&lt;/tr&gt;';
+
+		if (in_array($thisfileformat, $IgnoreNoTagFormats)) {
+			$OtherFormats .= $thisline;
+		} else {
+			$AVFormats .= $thisline;
+		}
+	}
+	echo 'Duplicated MD5_DATA (Audio/Video files):&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;';
+	echo $AVFormats.'&lt;/table&gt;&lt;hr&gt;';
+	echo 'Duplicated MD5_DATA (Other files):&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;';
+	echo $OtherFormats.'&lt;/table&gt;&lt;hr&gt;';
+
+
+} elseif (!empty($_REQUEST['artisttitledupes'])) {
+
+	if (isset($_REQUEST['m3uartist']) &amp;&amp; isset($_REQUEST['m3utitle'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		$SQLquery  = 'SELECT `filename`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`artist` = &quot;'.mysql_escape_string($_REQUEST['m3uartist']).'&quot;)';
+		$SQLquery .= ' AND (`title` = &quot;'.mysql_escape_string($_REQUEST['m3utitle']).'&quot;)';
+		$SQLquery .= ' ORDER BY `playtime_seconds` ASC, `remix` ASC, `filename` ASC';
+		$result = safe_mysql_query($SQLquery);
+		while ($row = mysql_fetch_array($result)) {
+			echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+		}
+		exit;
+
+	}
+
+	$SQLquery  = 'SELECT `artist`, `title`, `filename`, COUNT(*) AS `num`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`artist` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' AND (`title` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' GROUP BY `artist`, `title`'.(@$_REQUEST['samemix'] ? ', `remix`' : '');
+	$SQLquery .= ' ORDER BY `num` DESC, `artist` ASC, `title` ASC, `playtime_seconds` ASC, `remix` ASC';
+	$result = safe_mysql_query($SQLquery);
+	$uniquetitles = 0;
+	$uniquefiles  = 0;
+
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		while (($row = mysql_fetch_array($result)) &amp;&amp; ($row['num'] &gt; 1)) {
+			$SQLquery  = 'SELECT `filename`';
+			$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+			$SQLquery .= ' WHERE (`artist` = &quot;'.mysql_escape_string($row['artist']).'&quot;)';
+			$SQLquery .= ' AND (`title` = &quot;'.mysql_escape_string($row['title']).'&quot;)';
+			if (@$_REQUEST['samemix']) {
+				$SQLquery .= ' AND (`remix` = &quot;'.mysql_escape_string($row['remix']).'&quot;)';
+			}
+			$SQLquery .= ' ORDER BY `playtime_seconds` ASC, `remix` ASC, `filename` ASC';
+			$result2 = safe_mysql_query($SQLquery);
+			while ($row2 = mysql_fetch_array($result2)) {
+				echo WindowsShareSlashTranslate($row2['filename']).&quot;\n&quot;;
+			}
+		}
+		exit;
+
+	} else {
+
+		echo 'Duplicated aritst + title: (&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?artisttitledupes=1&amp;samemix=1&quot;&gt;Identical Mix/Version only&lt;/a&gt;)&lt;br&gt;';
+		echo '(&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?artisttitledupes=1&amp;m3u=.m3u&quot;&gt;.m3u version&lt;/a&gt;)&lt;br&gt;';
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th colspan=&quot;3&quot;&gt;&nbsp;&lt;/th&gt;&lt;th&gt;Artist&lt;/th&gt;&lt;th&gt;Title&lt;/th&gt;&lt;th&gt;Version&lt;/th&gt;&lt;th&gt;&nbsp;&lt;/th&gt;&lt;th&gt;&nbsp;&lt;/th&gt;&lt;th&gt;Filename&lt;/th&gt;&lt;/tr&gt;';
+
+		while (($row = mysql_fetch_array($result)) &amp;&amp; ($row['num'] &gt; 1)) {
+			$uniquetitles++;
+			set_time_limit(30);
+
+			$filenames = array();
+			$artists   = array();
+			$titles    = array();
+			$remixes   = array();
+			$bitrates  = array();
+			$playtimes = array();
+			$SQLquery  = 'SELECT `filename`, `artist`, `title`, `remix`, `audio_bitrate`, `vbr_method`, `playtime_seconds`, `encoder_options`';
+			$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+			$SQLquery .= ' WHERE (`artist` = &quot;'.mysql_escape_string($row['artist']).'&quot;)';
+			$SQLquery .= ' AND (`title` = &quot;'.mysql_escape_string($row['title']).'&quot;)';
+			$SQLquery .= ' ORDER BY `playtime_seconds` ASC, `remix` ASC, `filename` ASC';
+			$result2 = safe_mysql_query($SQLquery);
+			while ($row2 = mysql_fetch_array($result2)) {
+				$uniquefiles++;
+				$filenames[] = $row2['filename'];
+				$artists[]   = $row2['artist'];
+				$titles[]    = $row2['title'];
+				$remixes[]   = $row2['remix'];
+				if ($row2['vbr_method']) {
+					$bitrates[]  = '&lt;B'.($row2['encoder_options'] ? ' style=&quot;text-decoration: underline; cursor: help;&quot; TITLE=&quot;'.$row2['encoder_options'] : '').'&quot;&gt;'.BitrateText($row2['audio_bitrate'] / 1000).'&lt;/b&gt;';
+				} else {
+					$bitrates[]  = BitrateText($row2['audio_bitrate'] / 1000);
+				}
+				$playtimes[] = getid3_lib::PlaytimeString($row2['playtime_seconds']);
+			}
+
+			echo '&lt;tr&gt;';
+			echo '&lt;TD NOWRAP VALIGN=&quot;TOP&quot;&gt;';
+			foreach ($filenames as $file) {
+				echo '&lt;a href=&quot;demo.browse.php?deletefile='.urlencode($file).'&amp;noalert=1&quot; onClick=&quot;return confirm(\'Are you sure you want to delete '.addslashes($file).'? \n(this action cannot be un-done)\');&quot; TITLE=&quot;Permanently delete '.&quot;\n&quot;.FixTextFields($file).&quot;\n&quot;.'&quot; TARGET=&quot;deletedupewindow&quot;&gt;delete&lt;/a&gt;&lt;br&gt;';
+			}
+			echo '&lt;/td&gt;';
+			echo '&lt;TD NOWRAP VALIGN=&quot;TOP&quot;&gt;';
+			foreach ($filenames as $file) {
+				echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($file).'&quot;&gt;play&lt;/a&gt;&lt;br&gt;';
+			}
+			echo '&lt;/td&gt;';
+			echo '&lt;TD VALIGN=&quot;MIDDLE&quot; ALIGN=&quot;CENTER&quot; &gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?artisttitledupes=1&amp;m3uartist='.urlencode($artists[0]).'&amp;m3utitle='.urlencode($titles[0]).'&quot;&gt;play all&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;TD VALIGN=&quot;TOP&quot; NOWRAP&gt;'.implode('&lt;br&gt;', $artists).'&lt;/td&gt;';
+			echo '&lt;TD VALIGN=&quot;TOP&quot; NOWRAP&gt;'.implode('&lt;br&gt;', $titles).'&lt;/td&gt;';
+			echo '&lt;TD VALIGN=&quot;TOP&quot; NOWRAP&gt;'.implode('&lt;br&gt;', $remixes).'&lt;/td&gt;';
+			echo '&lt;TD VALIGN=&quot;TOP&quot; NOWRAP ALIGN=&quot;RIGHT&quot;&gt;'.implode('&lt;br&gt;', $bitrates).'&lt;/td&gt;';
+			echo '&lt;TD VALIGN=&quot;TOP&quot; NOWRAP ALIGN=&quot;RIGHT&quot;&gt;'.implode('&lt;br&gt;', $playtimes).'&lt;/td&gt;';
+
+			echo '&lt;TD VALIGN=&quot;TOP&quot; NOWRAP ALIGN=&quot;LEFT&quot;&gt;&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;';
+			foreach ($filenames as $file) {
+				echo '&lt;tr&gt;&lt;TD NOWRAP ALIGN=&quot;RIGHT&quot;&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($file).'&quot;&gt;&lt;span style=&quot;color: #339966;&quot;&gt;'.dirname($file).'/&lt;/span&gt;'.basename($file).'&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;';
+			}
+			echo '&lt;/table&gt;&lt;/td&gt;';
+
+			echo '&lt;/tr&gt;';
+		}
+
+	}
+	echo '&lt;/table&gt;';
+	echo number_format($uniquefiles).' files with '.number_format($uniquetitles).' unique &lt;i&gt;aritst + title&lt;/i&gt;&lt;br&gt;';
+	echo '&lt;hr&gt;';
+
+} elseif (!empty($_REQUEST['filetypelist'])) {
+
+	list($fileformat, $audioformat) = explode('|', $_REQUEST['filetypelist']);
+	$SQLquery  = 'SELECT `filename`, `fileformat`, `audio_dataformat`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`fileformat` = &quot;'.mysql_escape_string($fileformat).'&quot;)';
+	$SQLquery .= ' AND (`audio_dataformat` = &quot;'.mysql_escape_string($audioformat).'&quot;)';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+	echo 'Files of format &lt;b&gt;'.$fileformat.'.'.$audioformat.'&lt;/b&gt;:&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;';
+	echo '&lt;tr&gt;&lt;th&gt;file&lt;/th&gt;&lt;th&gt;audio&lt;/th&gt;&lt;th&gt;filename&lt;/th&gt;&lt;/tr&gt;';
+	while ($row = mysql_fetch_array($result)) {
+		echo '&lt;tr&gt;';
+		echo '&lt;td&gt;'.$row['fileformat'].'&lt;/td&gt;';
+		echo '&lt;td&gt;'.$row['audio_dataformat'].'&lt;/td&gt;';
+		echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+		echo '&lt;/tr&gt;';
+	}
+	echo '&lt;/table&gt;&lt;hr&gt;';
+
+} elseif (!empty($_REQUEST['trackinalbum'])) {
+
+	$SQLquery  = 'SELECT `filename`, `album`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`album` LIKE &quot;% [%&quot;)';
+	$SQLquery .= ' ORDER BY `album` ASC, `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		while ($row = mysql_fetch_array($result)) {
+			echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+		}
+		exit;
+
+	} elseif (!empty($_REQUEST['autofix'])) {
+
+		getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v1.php', __FILE__, true);
+		getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v2.php', __FILE__, true);
+
+		while ($row = mysql_fetch_array($result)) {
+			set_time_limit(30);
+			$ThisFileInfo = $getID3-&gt;analyze($filename);
+			getid3_lib::CopyTagsToComments($ThisFileInfo);
+
+			if (!empty($ThisFileInfo['tags'])) {
+
+				$Album = trim(str_replace(strstr($ThisFileInfo['comments']['album'][0], ' ['), '', $ThisFileInfo['comments']['album'][0]));
+				$Track = (string) intval(str_replace(' [', '', str_replace(']', '', strstr($ThisFileInfo['comments']['album'][0], ' ['))));
+				if ($Track == '0') {
+					$Track = '';
+				}
+				if ($Album &amp;&amp; $Track) {
+					echo '&lt;hr&gt;'.FixTextFields($row['filename']).'&lt;br&gt;';
+					echo '&lt;i&gt;'.$Album.'&lt;/i&gt; (track #'.$Track.')&lt;br&gt;';
+					echo '&lt;b&gt;ID3v2:&lt;/b&gt; '.(RemoveID3v2($row['filename'], false) ? 'removed' : 'REMOVAL FAILED!').', ';
+					echo '&lt;b&gt;ID3v1:&lt;/b&gt; '.(WriteID3v1($row['filename'], @$ThisFileInfo['comments']['title'][0], @$ThisFileInfo['comments']['artist'][0], $Album, @$ThisFileInfo['comments']['year'][0], @$ThisFileInfo['comments']['comment'][0], @$ThisFileInfo['comments']['genreid'][0], $Track, false) ? 'updated' : 'UPDATE FAILED').'&lt;br&gt;';
+				} else {
+					echo ' . ';
+				}
+
+			} else {
+
+				echo '&lt;hr&gt;FAILED&lt;br&gt;'.FixTextFields($row['filename']).'&lt;hr&gt;';
+
+			}
+			flush();
+		}
+
+	} else {
+
+		echo '&lt;b&gt;'.number_format(mysql_num_rows($result)).'&lt;/b&gt; files with &lt;b&gt;[??]&lt;/b&gt;-format track numbers in album field:&lt;br&gt;';
+		if (mysql_num_rows($result) &gt; 0) {
+			echo '(&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?trackinalbum=1&amp;m3u=.m3u&quot;&gt;.m3u version&lt;/a&gt;)&lt;br&gt;';
+			echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?trackinalbum=1&amp;autofix=1&quot;&gt;Try to auto-fix&lt;/a&gt;&lt;br&gt;';
+			echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;';
+			while ($row = mysql_fetch_array($result)) {
+				echo '&lt;tr&gt;';
+				echo '&lt;td&gt;'.$row['album'].'&lt;/td&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;/tr&gt;';
+			}
+			echo '&lt;/table&gt;';
+		}
+		echo '&lt;hr&gt;';
+
+	}
+
+} elseif (!empty($_REQUEST['fileextensions'])) {
+
+	$SQLquery  = 'SELECT `filename`, `fileformat`, `audio_dataformat`, `video_dataformat`, `tags`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+	$invalidextensionfiles = 0;
+	$invalidextensionline  = '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;';
+	$invalidextensionline .= '&lt;tr&gt;&lt;th&gt;file&lt;/th&gt;&lt;th&gt;audio&lt;/th&gt;&lt;th&gt;video&lt;/th&gt;&lt;th&gt;tags&lt;/th&gt;&lt;th&gt;actual&lt;/th&gt;&lt;th&gt;correct&lt;/th&gt;&lt;th&gt;filename&lt;/th&gt;&lt;/tr&gt;';
+	while ($row = mysql_fetch_array($result)) {
+		set_time_limit(30);
+
+		$acceptableextensions = AcceptableExtensions($row['fileformat'], $row['audio_dataformat'], $row['video_dataformat']);
+		$actualextension      = strtolower(fileextension($row['filename']));
+		if ($acceptableextensions &amp;&amp; !in_array($actualextension, $acceptableextensions)) {
+			$invalidextensionfiles++;
+
+			$invalidextensionline .= '&lt;tr&gt;';
+			$invalidextensionline .= '&lt;td&gt;'.$row['fileformat'].'&lt;/td&gt;';
+			$invalidextensionline .= '&lt;td&gt;'.$row['audio_dataformat'].'&lt;/td&gt;';
+			$invalidextensionline .= '&lt;td&gt;'.$row['video_dataformat'].'&lt;/td&gt;';
+			$invalidextensionline .= '&lt;td&gt;'.$row['tags'].'&lt;/td&gt;';
+			$invalidextensionline .= '&lt;td&gt;'.$actualextension.'&lt;/td&gt;';
+			$invalidextensionline .= '&lt;td&gt;'.implode('; ', $acceptableextensions).'&lt;/td&gt;';
+			$invalidextensionline .= '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+			$invalidextensionline .= '&lt;/tr&gt;';
+		}
+	}
+	$invalidextensionline .= '&lt;/table&gt;&lt;hr&gt;';
+	echo number_format($invalidextensionfiles).' files with incorrect filename extension:&lt;br&gt;';
+	echo $invalidextensionline;
+
+} elseif (isset($_REQUEST['genredistribution'])) {
+
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		$SQLquery  = 'SELECT `filename`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (BINARY `genre` = &quot;'.$_REQUEST['genredistribution'].'&quot;)';
+		$SQLquery .= ' AND (`fileformat` NOT LIKE &quot;'.implode('&quot;) AND (`fileformat` NOT LIKE &quot;', $IgnoreNoTagFormats).'&quot;)';
+		$SQLquery .= ' ORDER BY `filename` ASC';
+		$result = safe_mysql_query($SQLquery);
+		while ($row = mysql_fetch_array($result)) {
+			echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+		}
+		exit;
+
+	} else {
+
+		if ($_REQUEST['genredistribution'] == '%') {
+
+			$SQLquery  = 'SELECT COUNT(*) AS `num`, `genre`';
+			$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+			$SQLquery .= ' WHERE (`fileformat` NOT LIKE &quot;'.implode('&quot;) AND (`fileformat` NOT LIKE &quot;', $IgnoreNoTagFormats).'&quot;)';
+			$SQLquery .= ' GROUP BY `genre`';
+			$SQLquery .= ' ORDER BY `num` DESC';
+			$result = safe_mysql_query($SQLquery);
+			getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v1.php', __FILE__, true);
+			echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;';
+			echo '&lt;tr&gt;&lt;th&gt;Count&lt;/th&gt;&lt;th&gt;Genre&lt;/th&gt;&lt;th&gt;m3u&lt;/th&gt;&lt;/tr&gt;';
+			while ($row = mysql_fetch_array($result)) {
+				$GenreID = getid3_id3v1::LookupGenreID($row['genre']);
+				if (is_numeric($GenreID)) {
+					echo '&lt;tr bgcolor=&quot;#00FF00;&quot;&gt;';
+				} else {
+					echo '&lt;tr bgcolor=&quot;#FF9999;&quot;&gt;';
+				}
+				echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?genredistribution='.urlencode($row['genre']).'&quot;&gt;'.number_format($row['num']).'&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;TD NOWRAP&gt;'.str_replace(&quot;\t&quot;, '&lt;br&gt;', $row['genre']).'&lt;/td&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3u=.m3u&amp;genredistribution='.urlencode($row['genre']).'&quot;&gt;.m3u&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;/tr&gt;';
+			}
+			echo '&lt;/table&gt;&lt;hr&gt;';
+
+		} else {
+
+			$SQLquery  = 'SELECT `filename`, `genre`';
+			$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+			$SQLquery .= ' WHERE (`genre` LIKE &quot;'.mysql_escape_string($_REQUEST['genredistribution']).'&quot;)';
+			$SQLquery .= ' ORDER BY `filename` ASC';
+			$result = safe_mysql_query($SQLquery);
+			echo '&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?genredistribution='.urlencode('%').'&quot;&gt;All Genres&lt;/a&gt;&lt;br&gt;';
+			echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;';
+			echo '&lt;tr&gt;&lt;th&gt;Genre&lt;/th&gt;&lt;th&gt;m3u&lt;/th&gt;&lt;th&gt;Filename&lt;/th&gt;&lt;/tr&gt;';
+			while ($row = mysql_fetch_array($result)) {
+				echo '&lt;tr&gt;';
+				echo '&lt;TD NOWRAP&gt;'.str_replace(&quot;\t&quot;, '&lt;br&gt;', $row['genre']).'&lt;/td&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+				echo '&lt;/tr&gt;';
+			}
+			echo '&lt;/table&gt;&lt;hr&gt;';
+
+		}
+
+
+	}
+
+} elseif (!empty($_REQUEST['formatdistribution'])) {
+
+	$SQLquery  = 'SELECT `fileformat`, `audio_dataformat`, COUNT(*) AS `num`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' GROUP BY `fileformat`, `audio_dataformat`';
+	$SQLquery .= ' ORDER BY `num` DESC';
+	$result = safe_mysql_query($SQLquery);
+	echo 'File format distribution:&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;';
+	echo '&lt;tr&gt;&lt;th&gt;Number&lt;/th&gt;&lt;th&gt;Format&lt;/th&gt;&lt;/tr&gt;';
+	while ($row = mysql_fetch_array($result)) {
+		echo '&lt;tr&gt;';
+		echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;'.number_format($row['num']).'&lt;/td&gt;';
+		echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?filetypelist='.$row['fileformat'].'|'.$row['audio_dataformat'].'&quot;&gt;'.($row['fileformat'] ? $row['fileformat'] : '&lt;i&gt;unknown&lt;/i&gt;').(($row['audio_dataformat'] &amp;&amp; ($row['audio_dataformat'] != $row['fileformat'])) ? '.'.$row['audio_dataformat'] : '').'&lt;/a&gt;&lt;/td&gt;';
+		echo '&lt;/tr&gt;';
+	}
+	echo '&lt;/table&gt;&lt;hr&gt;';
+
+} elseif (!empty($_REQUEST['errorswarnings'])) {
+
+	$SQLquery  = 'SELECT `filename`, `error`, `warning`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`error` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' OR (`warning` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+
+	if (!empty($_REQUEST['m3u'])) {
+
+		header('Content-type: audio/x-mpegurl');
+		echo '#EXTM3U'.&quot;\n&quot;;
+		while ($row = mysql_fetch_array($result)) {
+			echo WindowsShareSlashTranslate($row['filename']).&quot;\n&quot;;
+		}
+		exit;
+
+	} else {
+
+		echo number_format(mysql_num_rows($result)).' files with errors or warnings:&lt;br&gt;';
+		echo '(&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?errorswarnings=1&amp;m3u=.m3u&quot;&gt;.m3u version&lt;/a&gt;)&lt;br&gt;';
+		echo '&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th&gt;Filename&lt;/th&gt;&lt;th&gt;Error&lt;/th&gt;&lt;th&gt;Warning&lt;/th&gt;&lt;/tr&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			echo '&lt;tr&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;td&gt;'.(!empty($row['error'])   ? '&lt;li&gt;'.str_replace(&quot;\t&quot;, '&lt;li&gt;', FixTextFields($row['error'])).'&lt;/li&gt;' : '&nbsp;').'&lt;/td&gt;';
+			echo '&lt;td&gt;'.(!empty($row['warning']) ? '&lt;li&gt;'.str_replace(&quot;\t&quot;, '&lt;li&gt;', FixTextFields($row['warning'])).'&lt;/li&gt;' : '&nbsp;').'&lt;/td&gt;';
+			echo '&lt;/tr&gt;';
+		}
+	}
+	echo '&lt;/table&gt;&lt;hr&gt;';
+
+} elseif (!empty($_REQUEST['fixid3v1padding'])) {
+
+	getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'write.id3v1.php', __FILE__, true);
+	$id3v1_writer = new getid3_write_id3v1;
+
+	$SQLquery  = 'SELECT `filename`, `error`, `warning`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`fileformat` = &quot;mp3&quot;)';
+	$SQLquery .= ' AND (`warning` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+	$totaltofix = mysql_num_rows($result);
+	$rowcounter = 0;
+	while ($row = mysql_fetch_array($result)) {
+		set_time_limit(30);
+		if (strpos($row['warning'], 'Some ID3v1 fields do not use NULL characters for padding') !== false) {
+			set_time_limit(30);
+			$id3v1_writer-&gt;filename = $row['filename'];
+			echo ($id3v1_writer-&gt;FixID3v1Padding() ? '&lt;span style=&quot;color: #009900;&quot;&gt;fixed - ' : '&lt;span style=&quot;color: #FF0000;&quot;&gt;error - ');
+		} else {
+			echo '&lt;span style=&quot;color: #0000FF;&quot;&gt;No error? - ';
+		}
+		echo '['.++$rowcounter.' / '.$totaltofix.'] ';
+		echo FixTextFields($row['filename']).'&lt;/span&gt;&lt;br&gt;';
+		flush();
+	}
+
+} elseif (!empty($_REQUEST['vbrmethod'])) {
+
+	if ($_REQUEST['vbrmethod'] == '1') {
+
+		$SQLquery  = 'SELECT COUNT(*) AS `num`, `vbr_method`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' GROUP BY `vbr_method`';
+		$SQLquery .= ' ORDER BY `vbr_method`';
+		$result = safe_mysql_query($SQLquery);
+		echo 'VBR methods:&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;';
+		echo '&lt;tr&gt;&lt;th&gt;Count&lt;/th&gt;&lt;th&gt;VBR Method&lt;/th&gt;&lt;/tr&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			echo '&lt;tr&gt;';
+			echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;'.FixTextFields(number_format($row['num'])).'&lt;/td&gt;';
+			if ($row['vbr_method']) {
+				echo '&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?vbrmethod='.$row['vbr_method'].'&quot;&gt;'.FixTextFields($row['vbr_method']).'&lt;/a&gt;&lt;/td&gt;';
+			} else {
+				echo '&lt;td&gt;&lt;i&gt;CBR&lt;/i&gt;&lt;/td&gt;';
+			}
+			echo '&lt;/tr&gt;';
+		}
+		echo '&lt;/table&gt;';
+
+	} else {
+
+		$SQLquery  = 'SELECT `filename`';
+		$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+		$SQLquery .= ' WHERE (`vbr_method` = &quot;'.mysql_escape_string($_REQUEST['vbrmethod']).'&quot;)';
+		$result = safe_mysql_query($SQLquery);
+		echo number_format(mysql_num_rows($result)).' files with VBR_method of &quot;'.$_REQUEST['vbrmethod'].'&quot;:&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;';
+		while ($row = mysql_fetch_array($result)) {
+			echo '&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?m3ufilename='.urlencode($row['filename']).'&quot;&gt;m3u&lt;/a&gt;&lt;/td&gt;';
+			echo '&lt;td&gt;&lt;a href=&quot;demo.browse.php?filename='.rawurlencode($row['filename']).'&quot;&gt;'.FixTextFields($row['filename']).'&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;';
+		}
+		echo '&lt;/table&gt;';
+
+	}
+	echo '&lt;hr&gt;';
+
+} elseif (!empty($_REQUEST['correctcase'])) {
+
+	$SQLquery  = 'SELECT `filename`, `fileformat`';
+	$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+	$SQLquery .= ' WHERE (`fileformat` &lt;&gt; &quot;&quot;)';
+	$SQLquery .= ' ORDER BY `filename` ASC';
+	$result = safe_mysql_query($SQLquery);
+	echo 'Copy and paste the following into a DOS batch file. You may have to run this script more than once to catch all the changes (remember to scan for deleted/changed files and rescan directory between scans)&lt;hr&gt;';
+	echo '&lt;PRE&gt;';
+	$lastdir = '';
+	while ($row = mysql_fetch_array($result)) {
+		set_time_limit(30);
+		$CleanedFilename = CleanUpFileName($row['filename']);
+		if ($row['filename'] != $CleanedFilename) {
+			if (strtolower($lastdir) != strtolower(str_replace('/', '\\', dirname($row['filename'])))) {
+				$lastdir = str_replace('/', '\\', dirname($row['filename']));
+				echo 'cd &quot;'.$lastdir.'&quot;'.&quot;\n&quot;;
+			}
+			echo 'ren &quot;'.basename($row['filename']).'&quot; &quot;'.basename(CleanUpFileName($row['filename'])).'&quot;'.&quot;\n&quot;;
+		}
+	}
+	echo '&lt;/PRE&gt;';
+	echo '&lt;hr&gt;';
+
+}
+
+function CleanUpFileName($filename) {
+	$DirectoryName = dirname($filename);
+	$FileExtension = fileextension(basename($filename));
+	$BaseFilename  = basename($filename, '.'.$FileExtension);
+
+	$BaseFilename = strtolower($BaseFilename);
+	$BaseFilename = str_replace('_', ' ', $BaseFilename);
+	//$BaseFilename = str_replace('-', ' - ', $BaseFilename);
+	$BaseFilename = str_replace('(', ' (', $BaseFilename);
+	$BaseFilename = str_replace('( ', '(', $BaseFilename);
+	$BaseFilename = str_replace(')', ') ', $BaseFilename);
+	$BaseFilename = str_replace(' )', ')', $BaseFilename);
+	$BaseFilename = str_replace(' \'\'', ' &#147;', $BaseFilename);
+	$BaseFilename = str_replace('\'\' ', '&#148; ', $BaseFilename);
+	$BaseFilename = str_replace(' vs ', ' vs. ', $BaseFilename);
+	while (strstr($BaseFilename, '  ') !== false) {
+		$BaseFilename = str_replace('  ', ' ', $BaseFilename);
+	}
+	$BaseFilename = trim($BaseFilename);
+
+	return $DirectoryName.'/'.BetterUCwords($BaseFilename).'.'.strtolower($FileExtension);
+}
+
+function BetterUCwords($string) {
+	$stringlength = strlen($string);
+
+	$string{0} = strtoupper($string{0});
+	for ($i = 1; $i &lt; $stringlength; $i++) {
+		if (($string{$i - 1} == '\'') &amp;&amp; ($i &gt; 1) &amp;&amp; (($string{$i - 2} == 'O') || ($string{$i - 2} == ' '))) {
+			// O'Clock, 'Em
+			$string{$i} = strtoupper($string{$i});
+		} elseif (ereg('^[\'A-Za-z0-9&#192;-&#255;]$', $string{$i - 1})) {
+			$string{$i} = strtolower($string{$i});
+		} else {
+			$string{$i} = strtoupper($string{$i});
+		}
+	}
+
+	static $LowerCaseWords = array('vs.', 'feat.');
+	static $UpperCaseWords = array('DJ', 'USA', 'II', 'MC', 'CD', 'TV', '\'N\'');
+
+	$OutputListOfWords = array();
+	$ListOfWords = explode(' ', $string);
+	foreach ($ListOfWords as $ThisWord) {
+		if (in_array(strtolower(str_replace('(', '', $ThisWord)), $LowerCaseWords)) {
+			$ThisWord = strtolower($ThisWord);
+		} elseif (in_array(strtoupper(str_replace('(', '', $ThisWord)), $UpperCaseWords)) {
+			$ThisWord = strtoupper($ThisWord);
+		} elseif ((substr($ThisWord, 0, 2) == 'Mc') &amp;&amp; (strlen($ThisWord) &gt; 2)) {
+			$ThisWord{2} = strtoupper($ThisWord{2});
+		} elseif ((substr($ThisWord, 0, 3) == 'Mac') &amp;&amp; (strlen($ThisWord) &gt; 3)) {
+			$ThisWord{3} = strtoupper($ThisWord{3});
+		}
+		$OutputListOfWords[] = $ThisWord;
+	}
+	$UCstring = implode(' ', $OutputListOfWords);
+	$UCstring = str_replace(' From &#147;', ' from &#147;', $UCstring);
+	$UCstring = str_replace(' \'n\' ', ' \'N\' ', $UCstring);
+
+	return $UCstring;
+}
+
+
+
+echo '&lt;hr&gt;&lt;form action=&quot;'.FixTextFields($_SERVER['PHP_SELF']).'&quot;&gt;';
+echo '&lt;b&gt;Warning:&lt;/b&gt; Scanning a new directory will erase all previous entries in the database!&lt;br&gt;';
+echo 'Directory: &lt;input type=&quot;text&quot; name=&quot;scan&quot; size=&quot;50&quot; value=&quot;'.FixTextFields(!empty($_REQUEST['scan']) ? $_REQUEST['scan'] : '').'&quot;&gt; ';
+echo '&lt;input type=&quot;submit&quot; value=&quot;Go&quot; onClick=&quot;return confirm(\'Are you sure you want to erase all entries in the database and start scanning again?\');&quot;&gt;';
+echo '&lt;/form&gt;';
+echo '&lt;hr&gt;&lt;form action=&quot;'.FixTextFields($_SERVER['PHP_SELF']).'&quot;&gt;';
+echo 'Re-scanning a new directory will only add new, previously unscanned files into the list (and not erase the database).&lt;br&gt;';
+echo 'Directory: &lt;input type=&quot;text&quot; name=&quot;newscan&quot; size=&quot;50&quot; value=&quot;'.FixTextFields(!empty($_REQUEST['newscan']) ? $_REQUEST['newscan'] : '').'&quot;&gt; ';
+echo '&lt;input type=&quot;SUBMIT&quot; value=&quot;Go&quot;&gt;';
+echo '&lt;/form&gt;&lt;hr&gt;';
+echo '&lt;ul&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?deadfilescheck=1&quot;&gt;Remove deleted or changed files from database&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?md5datadupes=1&quot;&gt;List files with identical MD5_DATA values&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?artisttitledupes=1&quot;&gt;List files with identical artist + title&lt;/a&gt; (&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?artisttitledupes=1&amp;samemix=1&quot;&gt;same mix only&lt;/a&gt;)&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?fileextensions=1&quot;&gt;File with incorrect file extension&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?formatdistribution=1&quot;&gt;File Format Distribution&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?audiobitrates=1&quot;&gt;Audio Bitrate Distribution&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?vbrmethod=1&quot;&gt;VBR_Method Distribution&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?tagtypes=1&quot;&gt;Tag Type Distribution&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?genredistribution='.urlencode('%').'&quot;&gt;Genre Distribution&lt;/a&gt;&lt;/li&gt;';
+//echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?missingtrackvolume=1&quot;&gt;Scan for missing track volume information (update database from pre-v1.7.0b5)&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?encoderoptionsdistribution=1&quot;&gt;Encoder Options Distribution&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?encodedbydistribution='.urlencode('%').'&quot;&gt;Encoded By (ID3v2) Distribution&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?trackinalbum=1&quot;&gt;Track number in Album field&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?tracknoalbum=1&quot;&gt;Track number, but no Album&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?titlefeat=1&quot;&gt;&quot;feat.&quot; in Title field&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?emptygenres=1&quot;&gt;Blank genres&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?trackzero=1&quot;&gt;Track &quot;zero&quot;&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?nonemptycomments=1&quot;&gt;non-empty comments&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?unsynchronizedtags=2A1&quot;&gt;Tags that are not synchronized&lt;/a&gt; (&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?unsynchronizedtags=2A1&amp;autofix=1&quot;&gt;autofix&lt;/a&gt;)&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?filenamepattern='.urlencode('[N] A - T {R}').'&quot;&gt;Filenames that don\'t match pattern&lt;/a&gt; (&lt;a href=&quot;?filenamepattern='.urlencode('[N] A - T {R}').'&amp;autofix=1&quot;&gt;auto-fix&lt;/a&gt;)&lt;/li&gt;';
+//echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?filenamepattern='.urlencode('A - T').'&quot;&gt;Filenames that don\'t match pattern&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?correctcase=1&quot;&gt;Correct filename case (Win/DOS)&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?fixid3v1padding=1&quot;&gt;Fix ID3v1 invalid padding&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?errorswarnings=1&quot;&gt;Files with Errors and/or Warnings&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;li&gt;&lt;a href=&quot;'.$_SERVER['PHP_SELF'].'?rescanerrors=1&quot;&gt;Re-scan only files with Errors and/or Warnings&lt;/a&gt;&lt;/li&gt;';
+echo '&lt;/ul&gt;';
+
+$SQLquery  = 'SELECT COUNT(*) AS `TotalFiles`, SUM(`playtime_seconds`) AS `TotalPlaytime`, SUM(`filesize`) AS `TotalFilesize`, AVG(`playtime_seconds`) AS `AvgPlaytime`, AVG(`filesize`) AS `AvgFilesize`, AVG(`audio_bitrate` + `video_bitrate`) AS `AvgBitrate`';
+$SQLquery .= ' FROM `'.GETID3_DB_TABLE.'`';
+$result = mysql_query($SQLquery);
+if ($row = mysql_fetch_array($result)) {
+	echo '&lt;hr&gt;&lt;b&gt;Currently in the database:&lt;/b&gt;&lt;TABLE&gt;';
+	echo '&lt;tr&gt;&lt;TH ALIGN=&quot;LEFT&quot;&gt;Total Files&lt;/th&gt;&lt;td&gt;'.number_format($row['TotalFiles']).'&lt;/td&gt;&lt;/tr&gt;';
+	echo '&lt;tr&gt;&lt;TH ALIGN=&quot;LEFT&quot;&gt;Total Filesize&lt;/th&gt;&lt;td&gt;'.number_format($row['TotalFilesize'] / 1048576).' MB&lt;/td&gt;&lt;/tr&gt;';
+	echo '&lt;tr&gt;&lt;TH ALIGN=&quot;LEFT&quot;&gt;Total Playtime&lt;/th&gt;&lt;td&gt;'.number_format($row['TotalPlaytime'] / 3600, 1).' hours&lt;/td&gt;&lt;/tr&gt;';
+	echo '&lt;tr&gt;&lt;TH ALIGN=&quot;LEFT&quot;&gt;Average Filesize&lt;/th&gt;&lt;td&gt;'.number_format($row['AvgFilesize'] / 1048576, 1).' MB&lt;/td&gt;&lt;/tr&gt;';
+	echo '&lt;tr&gt;&lt;TH ALIGN=&quot;LEFT&quot;&gt;Average Playtime&lt;/th&gt;&lt;td&gt;'.getid3_lib::PlaytimeString($row['AvgPlaytime']).'&lt;/td&gt;&lt;/tr&gt;';
+	echo '&lt;tr&gt;&lt;TH ALIGN=&quot;LEFT&quot;&gt;Average Bitrate&lt;/th&gt;&lt;td&gt;'.BitrateText($row['AvgBitrate'] / 1000, 1).'&lt;/td&gt;&lt;/tr&gt;';
+	echo '&lt;/table&gt;';
+}
+
+?&gt;
+&lt;/BODY&gt;
+&lt;/HTML&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.simple.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.simple.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.simple.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,53 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.simple.php - part of getID3()                    //
+// Sample script for scanning a single directory and           //
+// displaying a few pieces of information for each file        //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+echo '&lt;HTML&gt;&lt;HEAD&gt;';
+echo '&lt;TITLE&gt;getID3() - /demo/demo.simple.php (sample script)&lt;/TITLE&gt;';
+echo '&lt;STYLE&gt;BODY,TD,TH { font-family: sans-serif; font-size: 9pt; }&lt;/STYLE&gt;';
+echo '&lt;/HEAD&gt;&lt;BODY&gt;';
+
+
+// include getID3() library (can be in a different directory if full path is specified)
+require_once('../getid3/getid3.php');
+
+// Initialize getID3 engine
+$getID3 = new getID3;
+
+$DirectoryToScan = '/change/to/directory/you/want/to/scan'; // change to whatever directory you want to scan
+$dir = opendir($DirectoryToScan);
+echo '&lt;TABLE BORDER=&quot;1&quot; CELLSPACING=&quot;0&quot; CELLPADDING=&quot;3&quot;&gt;';
+echo '&lt;TR&gt;&lt;TH&gt;Filename&lt;/TH&gt;&lt;TH&gt;Artist&lt;/TH&gt;&lt;TH&gt;Title&lt;/TH&gt;&lt;TH&gt;Bitrate&lt;/TH&gt;&lt;TH&gt;Playtime&lt;/TH&gt;&lt;/TR&gt;';
+while (($file = readdir($dir)) !== false) {
+	$FullFileName = realpath($DirectoryToScan.'/'.$file);
+	if (is_file($FullFileName)) {
+		set_time_limit(30);
+
+		$ThisFileInfo = $getID3-&gt;analyze($FullFileName);
+
+		getid3_lib::CopyTagsToComments($ThisFileInfo);
+
+		// output desired information in whatever format you want
+		echo '&lt;TR&gt;';
+		echo '&lt;TD&gt;'.$ThisFileInfo['filenamepath'].'&lt;/TD&gt;';
+		echo '&lt;TD&gt;'.(!empty($ThisFileInfo['comments_html']['artist']) ? implode('&lt;BR&gt;', $ThisFileInfo['comments_html']['artist']) : '&nbsp;').'&lt;/TD&gt;';
+		echo '&lt;TD&gt;'.(!empty($ThisFileInfo['comments_html']['title'])  ? implode('&lt;BR&gt;', $ThisFileInfo['comments_html']['title'])  : '&nbsp;').'&lt;/TD&gt;';
+		echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;'.(!empty($ThisFileInfo['audio']['bitrate'])        ? round($ThisFileInfo['audio']['bitrate'] / 1000).' kbps'   : '&nbsp;').'&lt;/TD&gt;';
+		echo '&lt;TD ALIGN=&quot;RIGHT&quot;&gt;'.(!empty($ThisFileInfo['playtime_string'])         ? $ThisFileInfo['playtime_string']                          : '&nbsp;').'&lt;/TD&gt;';
+		echo '&lt;/TR&gt;';
+	}
+}
+
+?&gt;
+&lt;/BODY&gt;
+&lt;/HTML&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.simple.write.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.simple.write.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.simple.write.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,54 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.simple.write.php - part of getID3()              //
+// Sample script showing basic syntax for writing tags         //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+$TaggingFormat = 'UTF-8';
+
+require_once('../getid3/getid3.php');
+// Initialize getID3 engine
+$getID3 = new getID3;
+$getID3-&gt;encoding = $TaggingFormat;
+
+require_once('../getid3/write.php');
+// Initialize getID3 tag-writing module
+$tagwriter = new getid3_writetags;
+//$tagwriter-&gt;filename       = '/path/to/file.mp3';
+$tagwriter-&gt;filename       = 'd:/file.mp3';
+$tagwriter-&gt;tagformats     = array('id3v1', 'id3v2.3');
+
+// set various options (optional)
+$tagwriter-&gt;overwrite_tags = true;
+$tagwriter-&gt;tag_encoding   = $TaggingFormat;
+$tagwriter-&gt;remove_other_tags = true;
+
+// populate data array
+$TagData['title'][]   = 'My Song';
+$TagData['artist'][]  = 'The Artist';
+$TagData['album'][]   = 'Greatest Hits';
+$TagData['year'][]    = '2004';
+$TagData['genre'][]   = 'Rock';
+$TagData['comment'][] = 'excellent!';
+$TagData['track'][]   = '04/16';
+
+$tagwriter-&gt;tag_data = $TagData;
+
+// write tags
+if ($tagwriter-&gt;WriteTags()) {
+	echo 'Successfully wrote tags&lt;br&gt;';
+	if (!empty($tagwriter-&gt;warnings)) {
+		echo 'There were some warnings:&lt;br&gt;'.implode('&lt;br&gt;&lt;br&gt;', $tagwriter-&gt;warnings);
+	}
+} else {
+	echo 'Failed to write tags!&lt;br&gt;'.implode('&lt;br&gt;&lt;br&gt;', $tagwriter-&gt;errors);
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/demo.write.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/demo.write.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/demo.write.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,267 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /demo/demo.write.php - part of getID3()                     //
+// sample script for demonstrating writing ID3v1 and ID3v2     //
+// tags for MP3, or Ogg comment tags for Ogg Vorbis            //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+$TaggingFormat = 'UTF-8';
+
+header('Content-Type: text/html; charset='.$TaggingFormat);
+echo '&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;getID3() - Sample tag writer&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;';
+
+require_once('../getid3/getid3.php');
+// Initialize getID3 engine
+$getID3 = new getID3;
+$getID3-&gt;encoding = $TaggingFormat;
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'write.php', __FILE__, true);
+
+$browsescriptfilename = 'demo.browse.php';
+
+function FixTextFields($text) {
+	return htmlentities(getid3_lib::SafeStripSlashes($text), ENT_QUOTES);
+}
+
+$Filename = (isset($_REQUEST['Filename']) ? getid3_lib::SafeStripSlashes($_REQUEST['Filename']) : '');
+
+
+
+if (isset($_POST['WriteTags'])) {
+
+	$TagFormatsToWrite = (isset($_POST['TagFormatsToWrite']) ? $_POST['TagFormatsToWrite'] : array());
+	if (!empty($TagFormatsToWrite)) {
+		echo 'starting to write tag(s)&lt;BR&gt;';
+
+		$tagwriter = new getid3_writetags;
+		$tagwriter-&gt;filename       = $Filename;
+		$tagwriter-&gt;tagformats     = $TagFormatsToWrite;
+		$tagwriter-&gt;overwrite_tags = true;
+		$tagwriter-&gt;tag_encoding   = $TaggingFormat;
+		if (!empty($_POST['remove_other_tags'])) {
+			$tagwriter-&gt;remove_other_tags = true;
+		}
+
+		$commonkeysarray = array('Title', 'Artist', 'Album', 'Year', 'Comment');
+		foreach ($commonkeysarray as $key) {
+			if (!empty($_POST[$key])) {
+				$TagData[strtolower($key)][] = getid3_lib::SafeStripSlashes($_POST[$key]);
+			}
+		}
+		if (!empty($_POST['Genre'])) {
+			$TagData['genre'][] = getid3_lib::SafeStripSlashes($_POST['Genre']);
+		}
+		if (!empty($_POST['GenreOther'])) {
+			$TagData['genre'][] = getid3_lib::SafeStripSlashes($_POST['GenreOther']);
+		}
+		if (!empty($_POST['Track'])) {
+			$TagData['track'][] = getid3_lib::SafeStripSlashes($_POST['Track'].(!empty($_POST['TracksTotal']) ? '/'.$_POST['TracksTotal'] : ''));
+		}
+
+		if (!empty($_FILES['userfile']['tmp_name'])) {
+			if (in_array('id3v2.4', $tagwriter-&gt;tagformats) || in_array('id3v2.3', $tagwriter-&gt;tagformats) || in_array('id3v2.2', $tagwriter-&gt;tagformats)) {
+				if (is_uploaded_file($_FILES['userfile']['tmp_name'])) {
+					if ($fd = @fopen($_FILES['userfile']['tmp_name'], 'rb')) {
+						$APICdata = fread($fd, filesize($_FILES['userfile']['tmp_name']));
+						fclose ($fd);
+
+						list($APIC_width, $APIC_height, $APIC_imageTypeID) = GetImageSize($_FILES['userfile']['tmp_name']);
+						$imagetypes = array(1=&gt;'gif', 2=&gt;'jpeg', 3=&gt;'png');
+						if (isset($imagetypes[$APIC_imageTypeID])) {
+
+							$TagData['attached_picture'][0]['data']          = $APICdata;
+							$TagData['attached_picture'][0]['picturetypeid'] = $_POST['APICpictureType'];
+							$TagData['attached_picture'][0]['description']   = $_FILES['userfile']['name'];
+							$TagData['attached_picture'][0]['mime']          = 'image/'.$imagetypes[$APIC_imageTypeID];
+
+						} else {
+							echo '&lt;B&gt;invalid image format (only GIF, JPEG, PNG)&lt;/B&gt;&lt;BR&gt;';
+						}
+					} else {
+						echo '&lt;B&gt;cannot open '.$_FILES['userfile']['tmp_name'].'&lt;/B&gt;&lt;BR&gt;';
+					}
+				} else {
+					echo '&lt;B&gt;!is_uploaded_file('.$_FILES['userfile']['tmp_name'].')&lt;/B&gt;&lt;BR&gt;';
+				}
+			} else {
+				echo '&lt;B&gt;WARNING:&lt;/B&gt; Can only embed images for ID3v2&lt;BR&gt;';
+			}
+		}
+
+		$tagwriter-&gt;tag_data = $TagData;
+		if ($tagwriter-&gt;WriteTags()) {
+			echo 'Successfully wrote tags&lt;BR&gt;';
+			if (!empty($tagwriter-&gt;warnings)) {
+				echo 'There were some warnings:&lt;BLOCKQUOTE STYLE=&quot;background-color:#FFCC33; padding: 10px;&quot;&gt;'.implode('&lt;BR&gt;&lt;BR&gt;', $tagwriter-&gt;warnings).'&lt;/BLOCKQUOTE&gt;';
+			}
+		} else {
+			echo 'Failed to write tags!&lt;BLOCKQUOTE STYLE=&quot;background-color:#FF9999; padding: 10px;&quot;&gt;'.implode('&lt;BR&gt;&lt;BR&gt;', $tagwriter-&gt;errors).'&lt;/BLOCKQUOTE&gt;';
+		}
+
+	} else {
+
+		echo 'WARNING: no tag formats selected for writing - nothing written';
+
+	}
+	echo '&lt;HR&gt;';
+
+}
+
+
+echo '&lt;H4&gt;Sample tag editor/writer&lt;/H4&gt;';
+echo '&lt;A HREF=&quot;'.$browsescriptfilename.'?listdirectory='.rawurlencode(realpath(dirname($Filename))).'&quot;&gt;Browse current directory&lt;/A&gt;&lt;BR&gt;';
+if (!empty($Filename)) {
+	echo '&lt;A HREF=&quot;'.$_SERVER['PHP_SELF'].'&quot;&gt;Start Over&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;';
+	echo '&lt;TABLE BORDER=&quot;3&quot; CELLSPACING=&quot;0&quot; CELLPADDING=&quot;4&quot;&gt;&lt;FORM ACTION=&quot;'.$_SERVER['PHP_SELF'].'&quot; METHOD=&quot;POST&quot; ENCTYPE=&quot;multipart/form-data&quot;&gt;';
+	echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Filename: &lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&lt;INPUT TYPE=&quot;HIDDEN&quot; NAME=&quot;Filename&quot; VALUE=&quot;'.FixTextFields($Filename).'&quot;&gt;&lt;A HREF=&quot;'.$browsescriptfilename.'?filename='.rawurlencode($Filename).'&quot; TARGET=&quot;_blank&quot;&gt;'.$Filename.'&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;';
+	if (file_exists($Filename)) {
+
+		// Initialize getID3 engine
+		$getID3 = new getID3;
+		$OldThisFileInfo = $getID3-&gt;analyze($Filename);
+		getid3_lib::CopyTagsToComments($OldThisFileInfo);
+
+		switch ($OldThisFileInfo['fileformat']) {
+			case 'mp3':
+			case 'mp2':
+			case 'mp1':
+				$ValidTagTypes = array('id3v1', 'id3v2.3', 'ape');
+				break;
+
+			case 'mpc':
+				$ValidTagTypes = array('ape');
+				break;
+
+			case 'ogg':
+				if (@$OldThisFileInfo['audio']['dataformat'] == 'flac') {
+					//$ValidTagTypes = array('metaflac');
+					// metaflac doesn't (yet) work with OggFLAC files
+					$ValidTagTypes = array();
+				} else {
+					$ValidTagTypes = array('vorbiscomment');
+				}
+				break;
+
+			case 'flac':
+				$ValidTagTypes = array('metaflac');
+				break;
+
+			case 'real':
+				$ValidTagTypes = array('real');
+				break;
+
+			default:
+				$ValidTagTypes = array();
+				break;
+		}
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Title&lt;/B&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=&quot;TEXT&quot; SIZE=&quot;40&quot; NAME=&quot;Title&quot;  VALUE=&quot;'.FixTextFields(@implode(', ', @$OldThisFileInfo['comments']['title'])).'&quot;&gt;&lt;/TD&gt;&lt;/TR&gt;';
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Artist&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&lt;INPUT TYPE=&quot;TEXT&quot; SIZE=&quot;40&quot; NAME=&quot;Artist&quot; VALUE=&quot;'.FixTextFields(@implode(', ', @$OldThisFileInfo['comments']['artist'])).'&quot;&gt;&lt;/TD&gt;&lt;/TR&gt;';
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Album&lt;/B&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT TYPE=&quot;TEXT&quot; SIZE=&quot;40&quot; NAME=&quot;Album&quot;  VALUE=&quot;'.FixTextFields(@implode(', ', @$OldThisFileInfo['comments']['album'])).'&quot;&gt;&lt;/TD&gt;&lt;/TR&gt;';
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Year&lt;/B&gt;&lt;/TD&gt;  &lt;TD&gt;&lt;INPUT TYPE=&quot;TEXT&quot; SIZE=&quot;4&quot;  NAME=&quot;Year&quot;   VALUE=&quot;'.FixTextFields(@implode(', ', @$OldThisFileInfo['comments']['year'])).'&quot;&gt;&lt;/TD&gt;&lt;/TR&gt;';
+
+		$TracksTotal = '';
+		$TrackNumber = '';
+		if (!empty($OldThisFileInfo['comments']['tracknumber']) &amp;&amp; is_array($OldThisFileInfo['comments']['tracknumber'])) {
+			$RawTrackNumberArray = $OldThisFileInfo['comments']['tracknumber'];
+		} elseif (!empty($OldThisFileInfo['comments']['track']) &amp;&amp; is_array($OldThisFileInfo['comments']['track'])) {
+			$RawTrackNumberArray = $OldThisFileInfo['comments']['track'];
+		} else {
+			$RawTrackNumberArray = array();
+		}
+		foreach ($RawTrackNumberArray as $key =&gt; $value) {
+			if (strlen($value) &gt; strlen($TrackNumber)) {
+				// ID3v1 may store track as &quot;3&quot; but ID3v2/APE would store as &quot;03/16&quot;
+				$TrackNumber = $value;
+			}
+		}
+		if (strstr($TrackNumber, '/')) {
+			list($TrackNumber, $TracksTotal) = explode('/', $TrackNumber);
+		}
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Track&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&lt;INPUT TYPE=&quot;TEXT&quot; SIZE=&quot;2&quot;  NAME=&quot;Track&quot;  VALUE=&quot;'.FixTextFields($TrackNumber).'&quot;&gt; of &lt;INPUT TYPE=&quot;TEXT&quot; SIZE=&quot;2&quot; NAME=&quot;TracksTotal&quot;  VALUE=&quot;'.FixTextFields($TracksTotal).'&quot;&gt;&lt;/TD&gt;&lt;/TR&gt;';
+
+		$ArrayOfGenresTemp = getid3_id3v1::ArrayOfGenres();   // get the array of genres
+		foreach ($ArrayOfGenresTemp as $key =&gt; $value) {      // change keys to match displayed value
+			$ArrayOfGenres[$value] = $value;
+		}
+		unset($ArrayOfGenresTemp);                            // remove temporary array
+		unset($ArrayOfGenres['Cover']);                       // take off these special cases
+		unset($ArrayOfGenres['Remix']);
+		unset($ArrayOfGenres['Unknown']);
+		$ArrayOfGenres['']      = '- Unknown -';              // Add special cases back in with renamed key/value
+		$ArrayOfGenres['Cover'] = '-Cover-';
+		$ArrayOfGenres['Remix'] = '-Remix-';
+		asort($ArrayOfGenres);                                // sort into alphabetical order
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Genre&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&lt;SELECT NAME=&quot;Genre&quot;&gt;';
+		$AllGenresArray = (!empty($OldThisFileInfo['comments']['genre']) ? $OldThisFileInfo['comments']['genre'] : array());
+		foreach ($ArrayOfGenres as $key =&gt; $value) {
+			echo '&lt;OPTION VALUE=&quot;'.$key.'&quot;';
+			if (in_array($key, $AllGenresArray)) {
+				echo ' SELECTED';
+				unset($AllGenresArray[array_search($key, $AllGenresArray)]);
+				sort($AllGenresArray);
+			}
+			echo '&gt;'.$value.'&lt;/OPTION&gt;';
+			//echo '&lt;OPTION VALUE=&quot;'.FixTextFields($value).'&quot;'.((@$OldThisFileInfo['comments']['genre'][0] == $value) ? ' SELECTED' : '').'&gt;'.$value.'&lt;/OPTION&gt;';
+		}
+		echo '&lt;/SELECT&gt;&lt;INPUT TYPE=&quot;TEXT&quot; NAME=&quot;GenreOther&quot; SIZE=&quot;10&quot; VALUE=&quot;'.FixTextFields(@$AllGenresArray[0]).'&quot;&gt;&lt;/TD&gt;&lt;/TR&gt;';
+
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Write Tags&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;';
+		foreach ($ValidTagTypes as $ValidTagType) {
+			echo '&lt;INPUT TYPE=&quot;CHECKBOX&quot; NAME=&quot;TagFormatsToWrite[]&quot; VALUE=&quot;'.$ValidTagType.'&quot;';
+			if (count($ValidTagTypes) == 1) {
+				echo ' CHECKED';
+			} else {
+				switch ($ValidTagType) {
+					case 'id3v2.2':
+					case 'id3v2.3':
+					case 'id3v2.4':
+						if (isset($OldThisFileInfo['tags']['id3v2'])) {
+							echo ' CHECKED';
+						}
+						break;
+
+					default:
+						if (isset($OldThisFileInfo['tags'][$ValidTagType])) {
+							echo ' CHECKED';
+						}
+						break;
+				}
+			}
+			echo '&gt;'.$ValidTagType.'&lt;BR&gt;';
+		}
+		if (count($ValidTagTypes) &gt; 1) {
+			echo '&lt;hr&gt;&lt;input type=&quot;checkbox&quot; name=&quot;remove_other_tags&quot; value=&quot;1&quot;&gt; Remove non-selected tag formats when writing new tag&lt;br&gt;';
+		}
+		echo '&lt;/TD&gt;&lt;/TR&gt;';
+
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Comment&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;&lt;TEXTAREA COLS=&quot;30&quot; ROWS=&quot;3&quot; NAME=&quot;Comment&quot; WRAP=&quot;VIRTUAL&quot;&gt;'.(isset($OldThisFileInfo['comments']['comment']) ? @implode(&quot;\n&quot;, $OldThisFileInfo['comments']['comment']) : '').'&lt;/TEXTAREA&gt;&lt;/TD&gt;&lt;/TR&gt;';
+
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Picture&lt;/B&gt;&lt;BR&gt;(ID3v2 only)&lt;/TD&gt;&lt;TD&gt;&lt;INPUT TYPE=&quot;FILE&quot; NAME=&quot;userfile&quot; ACCEPT=&quot;image/jpeg, image/gif, image/png&quot;&gt;&lt;BR&gt;';
+		echo '&lt;SELECT NAME=&quot;APICpictureType&quot;&gt;';
+		$APICtypes = getid3_id3v2::APICPictureTypeLookup('', true);
+		foreach ($APICtypes as $key =&gt; $value) {
+			echo '&lt;OPTION VALUE=&quot;'.FixTextFields($key).'&quot;&gt;'.FixTextFields($value).'&lt;/OPTION&gt;';
+		}
+		echo '&lt;/SELECT&gt;&lt;/TD&gt;&lt;/TR&gt;';
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;CENTER&quot; COLSPAN=&quot;2&quot;&gt;&lt;INPUT TYPE=&quot;SUBMIT&quot; NAME=&quot;WriteTags&quot; VALUE=&quot;Save Changes&quot;&gt; ';
+		echo '&lt;INPUT TYPE=&quot;RESET&quot; VALUE=&quot;Reset&quot;&gt;&lt;/TD&gt;&lt;/TR&gt;';
+
+	} else {
+
+		echo '&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;&lt;B&gt;Error&lt;/B&gt;&lt;/TD&gt;&lt;TD&gt;'.FixTextFields($Filename).' does not exist&lt;/TD&gt;&lt;/TR&gt;';
+
+	}
+	echo '&lt;/FORM&gt;&lt;/TABLE&gt;';
+
+}
+
+?&gt;
+&lt;/BODY&gt;
+&lt;/HTML&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/demos/index.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/demos/index.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/demos/index.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1 @@
+In this directory are a number of examples of how to use &lt;A HREF=&quot;<A HREF="http://www.getid3.org">http://www.getid3.org</A>&quot;&gt;getID3()&lt;/A&gt; - if you don't know what to run, take a look at &lt;A HREF=&quot;demo.browse.php&quot;&gt;demo.browse.php&lt;/A&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/dependencies.txt
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/dependencies.txt	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/dependencies.txt	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,24 @@
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// dependencies.txt - part of getID3()                         //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+lyrics3     depends on   apetag (optional)
+ogg         depends on   flac
+id3v2       depends on   id3v1
+apetag      depends on   id3v1 (optional, writing only)
+bonk        depends on   id3v2 (optional)
+riff        depends on   mp3
+mpeg        depends on   mp3
+quicktime   depends on   mp3
+flac        depends on   ogg
+optimfrog   depends on   riff
+la          depends on   riff
+lpac        depends on   riff
+asf         depends on   riff, id3v1 (optional)

Added: node/branches/video_test/code/getid3-1.7.5/getid3/extension.cache.dbm.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/extension.cache.dbm.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/extension.cache.dbm.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,222 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// extension.cache.dbm.php - part of getID3()                  //
+// Please see readme.txt for more information                  //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// This extension written by Allan Hansen &lt;ah&#216;artemis*dk&gt;      //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+/**
+* This is a caching extension for getID3(). It works the exact same
+* way as the getID3 class, but return cached information very fast
+*
+* Example:
+*
+*    Normal getID3 usage (example):
+*
+*       require_once 'getid3/getid3.php';
+*       $getID3 = new getID3;
+*       $getID3-&gt;encoding = 'UTF-8';
+*       $info1 = $getID3-&gt;analyze('file1.flac');
+*       $info2 = $getID3-&gt;analyze('file2.wv');
+*
+*    getID3_cached usage:
+*
+*       require_once 'getid3/getid3.php';
+*       require_once 'getid3/getid3/extension.cache.dbm.php';
+*       $getID3 = new getID3_cached('db3', '/tmp/getid3_cache.dbm',
+*                                          '/tmp/getid3_cache.lock');
+*       $getID3-&gt;encoding = 'UTF-8';
+*       $info1 = $getID3-&gt;analyze('file1.flac');
+*       $info2 = $getID3-&gt;analyze('file2.wv');
+*
+*
+* Supported Cache Types
+*
+*   SQL Databases:          (use extension.cache.mysql)
+*
+*   cache_type          cache_options
+*   -------------------------------------------------------------------
+*   mysql               host, database, username, password
+*
+*
+*   DBM-Style Databases:    (this extension)
+*
+*   cache_type          cache_options
+*   -------------------------------------------------------------------
+*   gdbm                dbm_filename, lock_filename
+*   ndbm                dbm_filename, lock_filename
+*   db2                 dbm_filename, lock_filename
+*   db3                 dbm_filename, lock_filename
+*   db4                 dbm_filename, lock_filename  (PHP5 required)
+*
+*   PHP must have write access to both dbm_filename and lock_filename.
+*
+*
+* Recommended Cache Types
+*
+*   Infrequent updates, many reads      any DBM
+*   Frequent updates                    mysql
+*/
+
+
+class getID3_cached_dbm extends getID3
+{
+
+	// public: constructor - see top of this file for cache type and cache_options
+	function getID3_cached_dbm($cache_type, $dbm_filename, $lock_filename) {
+
+		// Check for dba extension
+		if (!extension_loaded('dba')) {
+			die('PHP is not compiled with dba support, required to use DBM style cache.');
+		}
+
+		// Check for specific dba driver
+		if (function_exists('dba_handlers')) {  // PHP 4.3.0+
+			if (!in_array('db3', dba_handlers())) {
+				die('PHP is not compiled --with '.$cache_type.' support, required to use DBM style cache.');
+			}
+		}
+		else { // PHP &lt;= 4.2.3
+			ob_start(); // nasty, buy the only way to check...
+			phpinfo();
+			$contents = ob_get_contents();
+			ob_end_clean();
+			if (!strstr($contents, $cache_type)) {
+				die('PHP is not compiled --with '.$cache_type.' support, required to use DBM style cache.');
+			}
+		}
+
+		// Create lock file if needed
+		if (!file_exists($lock_filename)) {
+			if (!touch($lock_filename)) {
+				die('failed to create lock file: ' . $lock_filename);
+			}
+		}
+
+		// Open lock file for writing
+		if (!is_writeable($lock_filename)) {
+			die('lock file: ' . $lock_filename . ' is not writable');
+		}
+		$this-&gt;lock = fopen($lock_filename, 'w');
+
+		// Acquire exclusive write lock to lock file
+		flock($this-&gt;lock, LOCK_EX);
+
+		// Create dbm-file if needed
+		if (!file_exists($dbm_filename)) {
+			if (!touch($dbm_filename)) {
+				die('failed to create dbm file: ' . $dbm_filename);
+			}
+		}
+
+		// Try to open dbm file for writing
+		$this-&gt;dba = @dba_open($dbm_filename, 'w', $cache_type);
+		if (!$this-&gt;dba) {
+
+			// Failed - create new dbm file
+			$this-&gt;dba = dba_open($dbm_filename, 'n', $cache_type);
+
+			if (!$this-&gt;dba) {
+				die('failed to create dbm file: ' . $dbm_filename);
+			}
+
+			// Insert getID3 version number
+			dba_insert(GETID3_VERSION, GETID3_VERSION, $this-&gt;dba);
+		}
+
+		// Init misc values
+		$this-&gt;cache_type   = $cache_type;
+		$this-&gt;dbm_filename = $dbm_filename;
+
+		// Register destructor
+		register_shutdown_function(array($this, '__destruct'));
+
+		// Check version number and clear cache if changed
+		if (dba_fetch(GETID3_VERSION, $this-&gt;dba) != GETID3_VERSION) {
+			$this-&gt;clear_cache();
+		}
+
+		parent::getID3();
+	}
+
+
+
+	// public: destuctor
+	function __destruct() {
+
+		// Close dbm file
+		@dba_close($this-&gt;dba);
+
+		// Release exclusive lock
+		@flock($this-&gt;lock, LOCK_UN);
+
+		// Close lock file
+		@fclose($this-&gt;lock);
+	}
+
+
+
+	// public: clear cache
+	function clear_cache() {
+
+		// Close dbm file
+		dba_close($this-&gt;dba);
+
+		// Create new dbm file
+		$this-&gt;dba = dba_open($this-&gt;dbm_filename, 'n', $this-&gt;cache_type);
+
+		if (!$this-&gt;dba) {
+			die('failed to clear cache/recreate dbm file: ' . $this-&gt;dbm_filename);
+		}
+
+		// Insert getID3 version number
+		dba_insert(GETID3_VERSION, GETID3_VERSION, $this-&gt;dba);
+
+		// Reregister shutdown function
+		register_shutdown_function(array($this, '__destruct'));
+	}
+
+
+
+	// public: analyze file
+	function analyze($filename) {
+
+		if (file_exists($filename)) {
+
+			// Calc key     filename::mod_time::size    - should be unique
+			$key = $filename . '::' . filemtime($filename) . '::' . filesize($filename);
+
+			// Loopup key
+			$result = dba_fetch($key, $this-&gt;dba);
+
+			// Hit
+			if ($result !== false) {
+				return unserialize($result);
+			}
+		}
+
+		// Miss
+		$result = parent::analyze($filename);
+
+		// Save result
+		if (file_exists($filename)) {
+			dba_insert($key, serialize($result), $this-&gt;dba);
+		}
+
+		return $result;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/extension.cache.mysql.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/extension.cache.mysql.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/extension.cache.mysql.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,171 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// extension.cache.mysql.php - part of getID3()                //
+// Please see readme.txt for more information                  //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// This extension written by Allan Hansen &lt;ah&#216;artemis*dk&gt;      //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+/**
+* This is a caching extension for getID3(). It works the exact same
+* way as the getID3 class, but return cached information very fast
+*
+* Example:  (see also demo.cache.mysql.php in /demo/)
+*
+*    Normal getID3 usage (example):
+*
+*       require_once 'getid3/getid3.php';
+*       $getID3 = new getID3;
+*       $getID3-&gt;encoding = 'UTF-8';
+*       $info1 = $getID3-&gt;analyze('file1.flac');
+*       $info2 = $getID3-&gt;analyze('file2.wv');
+*
+*    getID3_cached usage:
+*
+*       require_once 'getid3/getid3.php';
+*       require_once 'getid3/getid3/extension.cache.mysql.php';
+*       $getID3 = new getID3_cached_mysql('localhost', 'database',
+*                                         'username', 'password');
+*       $getID3-&gt;encoding = 'UTF-8';
+*       $info1 = $getID3-&gt;analyze('file1.flac');
+*       $info2 = $getID3-&gt;analyze('file2.wv');
+*
+*
+* Supported Cache Types    (this extension)
+*
+*   SQL Databases:
+*
+*   cache_type          cache_options
+*   -------------------------------------------------------------------
+*   mysql               host, database, username, password
+*
+*
+*   DBM-Style Databases:    (use extension.cache.dbm)
+*
+*   cache_type          cache_options
+*   -------------------------------------------------------------------
+*   gdbm                dbm_filename, lock_filename
+*   ndbm                dbm_filename, lock_filename
+*   db2                 dbm_filename, lock_filename
+*   db3                 dbm_filename, lock_filename
+*   db4                 dbm_filename, lock_filename  (PHP5 required)
+*
+*   PHP must have write access to both dbm_filename and lock_filename.
+*
+*
+* Recommended Cache Types
+*
+*   Infrequent updates, many reads      any DBM
+*   Frequent updates                    mysql
+*/
+
+
+class getID3_cached_mysql extends getID3
+{
+
+	// private vars
+	var $cursor;
+	var $connection;
+
+
+	// public: constructor - see top of this file for cache type and cache_options
+	function getID3_cached_mysql($host, $database, $username, $password) {
+
+		// Check for mysql support
+		if (!function_exists('mysql_pconnect')) {
+			die('PHP not compiled with mysql support.');
+		}
+
+		// Connect to database
+		$this-&gt;connection = mysql_pconnect($host, $username, $password);
+		if (!$this-&gt;connection) {
+			die('mysql_pconnect() failed - check permissions and spelling.');
+		}
+
+		// Select database
+		if (!mysql_select_db($database, $this-&gt;connection)) {
+			die('Cannot use database '.$database);
+		}
+
+		// Create cache table if not exists
+		$this-&gt;create_table();
+
+		// Check version number and clear cache if changed
+		$this-&gt;cursor = mysql_query(&quot;SELECT `value` FROM `getid3_cache` WHERE (`filename` = '&quot;.GETID3_VERSION.&quot;') AND (`filesize` = '-1') AND (`filetime` = '-1') AND (`analyzetime` = '-1')&quot;, $this-&gt;connection);
+		list($version) = @mysql_fetch_array($this-&gt;cursor);
+		if ($version != GETID3_VERSION) {
+			$this-&gt;clear_cache();
+		}
+
+		parent::getID3();
+	}
+
+
+
+	// public: clear cache
+	function clear_cache() {
+
+		$this-&gt;cursor = mysql_query(&quot;DELETE FROM `getid3_cache`&quot;, $this-&gt;connection);
+		$this-&gt;cursor = mysql_query(&quot;INSERT INTO `getid3_cache` VALUES ('&quot;.GETID3_VERSION.&quot;', -1, -1, -1, '&quot;.GETID3_VERSION.&quot;')&quot;, $this-&gt;connection);
+	}
+
+
+
+	// public: analyze file
+	function analyze($filename) {
+
+		if (file_exists($filename)) {
+
+			// Short-hands
+			$filetime = filemtime($filename);
+			$filesize = filesize($filename);
+			$filenam2 = mysql_escape_string($filename);
+
+			// Loopup file
+			$this-&gt;cursor = mysql_query(&quot;SELECT `value` FROM `getid3_cache` WHERE (`filename`='&quot;.$filenam2.&quot;') AND (`filesize`='&quot;.$filesize.&quot;') AND (`filetime`='&quot;.$filetime.&quot;')&quot;, $this-&gt;connection);
+			list($result) = @mysql_fetch_array($this-&gt;cursor);
+
+			// Hit
+			if ($result) {
+				return unserialize($result);
+			}
+		}
+
+		// Miss
+		$result = parent::analyze($filename);
+
+		// Save result
+		if (file_exists($filename)) {
+			$res2 = mysql_escape_string(serialize($result));
+			$this-&gt;cursor = mysql_query(&quot;INSERT INTO `getid3_cache` (`filename`, `filesize`, `filetime`, `analyzetime`, `value`) VALUES ('&quot;.$filenam2.&quot;', '&quot;.$filesize.&quot;', '&quot;.$filetime.&quot;', '&quot;.time().&quot;', '&quot;.$res2.&quot;')&quot;, $this-&gt;connection);
+		}
+		return $result;
+	}
+
+
+
+	// private: (re)create sql table
+	function create_table($drop = false) {
+
+		$this-&gt;cursor = mysql_query(&quot;CREATE TABLE IF NOT EXISTS `getid3_cache` (
+			`filename` VARCHAR(255) NOT NULL DEFAULT '',
+			`filesize` INT(11) NOT NULL DEFAULT '0',
+			`filetime` INT(11) NOT NULL DEFAULT '0',
+			`analyzetime` INT(11) NOT NULL DEFAULT '0',
+			`value` TEXT NOT NULL,
+			PRIMARY KEY (`filename`,`filesize`,`filetime`)) TYPE=MyISAM&quot;, $this-&gt;connection);
+		echo mysql_error($this-&gt;connection);
+	}
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/getid3.lib.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/getid3.lib.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/getid3.lib.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,1427 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// getid3.lib.php - part of getID3()                           //
+// See readme.txt for more details                             //
+//                                                             //
+/////////////////////////////////////////////////////////////////
+// getid3_lib::GetURLImageSize( $urlpic ) determines the       //
+// dimensions of local/remote URL pictures.                    //
+// returns array with ($width, $height, $type)                 //
+//                                                             //
+// Thanks to: Oyvind Hallsteinsen aka Gosub / ELq -            //
+// gosub&#216;elq*org  for the original size determining code       //
+//                                                             //
+// PHP Hack by Filipe Laborde-Basto Oct 21/2000                //
+// FREELY DISTRIBUTABLE -- use at your sole discretion! :)     //
+// Enjoy. (Not to be sold in commercial packages though,       //
+// keep it free!) Feel free to contact me at fil&#216;rezox*com     //
+// (<A HREF="http://www.rezox.com">http://www.rezox.com</A>)                                      //
+//                                                             //
+// Modified by James Heinrich &lt;getid3&#216;users*sourceforge*net&gt;   //
+// June 1, 2001 - created GetDataImageSize($imgData) by        //
+// seperating the fopen() stuff to GetURLImageSize($urlpic)    //
+// which then calls GetDataImageSize($imgData). The idea being //
+// you can call GetDataImageSize($imgData) with image data     //
+// from a database etc.                                        //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+define('GETID3_GIF_SIG',     &quot;\x47\x49\x46&quot;);  // 'GIF'
+define('GETID3_PNG_SIG',     &quot;\x89\x50\x4E\x47\x0D\x0A\x1A\x0A&quot;);
+define('GETID3_JPG_SIG',     &quot;\xFF\xD8\xFF&quot;);
+define('GETID3_JPG_SOS',     &quot;\xDA&quot;); // Start Of Scan - image data start
+define('GETID3_JPG_SOF0',    &quot;\xC0&quot;); // Start Of Frame N
+define('GETID3_JPG_SOF1',    &quot;\xC1&quot;); // N indicates which compression process
+define('GETID3_JPG_SOF2',    &quot;\xC2&quot;); // Only SOF0-SOF2 are now in common use
+define('GETID3_JPG_SOF3',    &quot;\xC3&quot;);
+// NB: codes C4 and CC are *not* SOF markers
+define('GETID3_JPG_SOF5',    &quot;\xC5&quot;);
+define('GETID3_JPG_SOF6',    &quot;\xC6&quot;);
+define('GETID3_JPG_SOF7',    &quot;\xC7&quot;);
+define('GETID3_JPG_SOF9',    &quot;\xC9&quot;);
+define('GETID3_JPG_SOF10',   &quot;\xCA&quot;);
+define('GETID3_JPG_SOF11',   &quot;\xCB&quot;);
+// NB: codes C4 and CC are *not* SOF markers
+define('GETID3_JPG_SOF13',   &quot;\xCD&quot;);
+define('GETID3_JPG_SOF14',   &quot;\xCE&quot;);
+define('GETID3_JPG_SOF15',   &quot;\xCF&quot;);
+define('GETID3_JPG_EOI',     &quot;\xD9&quot;); // End Of Image (end of datastream)
+
+
+
+class getid3_lib
+{
+
+	function PrintHexBytes($string, $hex=true, $spaces=true, $htmlsafe=true) {
+		$returnstring = '';
+		for ($i = 0; $i &lt; strlen($string); $i++) {
+			if ($hex) {
+				$returnstring .= str_pad(dechex(ord($string{$i})), 2, '0', STR_PAD_LEFT);
+			} else {
+				$returnstring .= ' '.(ereg(&quot;[\x20-\x7E]&quot;, $string{$i}) ? $string{$i} : '&#164;');
+			}
+			if ($spaces) {
+				$returnstring .= ' ';
+			}
+		}
+		if ($htmlsafe) {
+			$returnstring = htmlentities($returnstring);
+		}
+		return $returnstring;
+	}
+
+	function SafeStripSlashes($text) {
+		if (get_magic_quotes_gpc()) {
+			return stripslashes($text);
+		}
+		return $text;
+	}
+
+
+	function trunc($floatnumber) {
+		// truncates a floating-point number at the decimal point
+		// returns int (if possible, otherwise float)
+		if ($floatnumber &gt;= 1) {
+			$truncatednumber = floor($floatnumber);
+		} elseif ($floatnumber &lt;= -1) {
+			$truncatednumber = ceil($floatnumber);
+		} else {
+			$truncatednumber = 0;
+		}
+		if ($truncatednumber &lt;= 1073741824) { // 2^30
+			$truncatednumber = (int) $truncatednumber;
+		}
+		return $truncatednumber;
+	}
+
+
+	function CastAsInt($floatnum) {
+		// convert to float if not already
+		$floatnum = (float) $floatnum;
+
+		// convert a float to type int, only if possible
+		if (getid3_lib::trunc($floatnum) == $floatnum) {
+			// it's not floating point
+			if ($floatnum &lt;= 1073741824) { // 2^30
+				// it's within int range
+				$floatnum = (int) $floatnum;
+			}
+		}
+		return $floatnum;
+	}
+
+
+	function DecimalBinary2Float($binarynumerator) {
+		$numerator   = getid3_lib::Bin2Dec($binarynumerator);
+		$denominator = getid3_lib::Bin2Dec('1'.str_repeat('0', strlen($binarynumerator)));
+		return ($numerator / $denominator);
+	}
+
+
+	function NormalizeBinaryPoint($binarypointnumber, $maxbits=52) {
+		// <A HREF="http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/binary.html">http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/binary.html</A>
+		if (strpos($binarypointnumber, '.') === false) {
+			$binarypointnumber = '0.'.$binarypointnumber;
+		} elseif ($binarypointnumber{0} == '.') {
+			$binarypointnumber = '0'.$binarypointnumber;
+		}
+		$exponent = 0;
+		while (($binarypointnumber{0} != '1') || (substr($binarypointnumber, 1, 1) != '.')) {
+			if (substr($binarypointnumber, 1, 1) == '.') {
+				$exponent--;
+				$binarypointnumber = substr($binarypointnumber, 2, 1).'.'.substr($binarypointnumber, 3);
+			} else {
+				$pointpos = strpos($binarypointnumber, '.');
+				$exponent += ($pointpos - 1);
+				$binarypointnumber = str_replace('.', '', $binarypointnumber);
+				$binarypointnumber = $binarypointnumber{0}.'.'.substr($binarypointnumber, 1);
+			}
+		}
+		$binarypointnumber = str_pad(substr($binarypointnumber, 0, $maxbits + 2), $maxbits + 2, '0', STR_PAD_RIGHT);
+		return array('normalized'=&gt;$binarypointnumber, 'exponent'=&gt;(int) $exponent);
+	}
+
+
+	function Float2BinaryDecimal($floatvalue) {
+		// <A HREF="http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/binary.html">http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/binary.html</A>
+		$maxbits = 128; // to how many bits of precision should the calculations be taken?
+		$intpart   = getid3_lib::trunc($floatvalue);
+		$floatpart = abs($floatvalue - $intpart);
+		$pointbitstring = '';
+		while (($floatpart != 0) &amp;&amp; (strlen($pointbitstring) &lt; $maxbits)) {
+			$floatpart *= 2;
+			$pointbitstring .= (string) getid3_lib::trunc($floatpart);
+			$floatpart -= getid3_lib::trunc($floatpart);
+		}
+		$binarypointnumber = decbin($intpart).'.'.$pointbitstring;
+		return $binarypointnumber;
+	}
+
+
+	function Float2String($floatvalue, $bits) {
+		// <A HREF="http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/ieee-expl.html">http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/ieee-expl.html</A>
+		switch ($bits) {
+			case 32:
+				$exponentbits = 8;
+				$fractionbits = 23;
+				break;
+
+			case 64:
+				$exponentbits = 11;
+				$fractionbits = 52;
+				break;
+
+			default:
+				return false;
+				break;
+		}
+		if ($floatvalue &gt;= 0) {
+			$signbit = '0';
+		} else {
+			$signbit = '1';
+		}
+		$normalizedbinary  = getid3_lib::NormalizeBinaryPoint(getid3_lib::Float2BinaryDecimal($floatvalue), $fractionbits);
+		$biasedexponent    = pow(2, $exponentbits - 1) - 1 + $normalizedbinary['exponent']; // (127 or 1023) +/- exponent
+		$exponentbitstring = str_pad(decbin($biasedexponent), $exponentbits, '0', STR_PAD_LEFT);
+		$fractionbitstring = str_pad(substr($normalizedbinary['normalized'], 2), $fractionbits, '0', STR_PAD_RIGHT);
+
+		return getid3_lib::BigEndian2String(getid3_lib::Bin2Dec($signbit.$exponentbitstring.$fractionbitstring), $bits % 8, false);
+	}
+
+
+	function LittleEndian2Float($byteword) {
+		return getid3_lib::BigEndian2Float(strrev($byteword));
+	}
+
+
+	function BigEndian2Float($byteword) {
+		// ANSI/IEEE Standard 754-1985, Standard for Binary Floating Point Arithmetic
+		// <A HREF="http://www.psc.edu/general/software/packages/ieee/ieee.html">http://www.psc.edu/general/software/packages/ieee/ieee.html</A>
+		// <A HREF="http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/ieee.html">http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/ieee.html</A>
+
+		$bitword = getid3_lib::BigEndian2Bin($byteword);
+		$signbit = $bitword{0};
+
+		switch (strlen($byteword) * 8) {
+			case 32:
+				$exponentbits = 8;
+				$fractionbits = 23;
+				break;
+
+			case 64:
+				$exponentbits = 11;
+				$fractionbits = 52;
+				break;
+
+			case 80:
+				// 80-bit Apple SANE format
+				// <A HREF="http://www.mactech.com/articles/mactech/Vol.06/06.01/SANENormalized/">http://www.mactech.com/articles/mactech/Vol.06/06.01/SANENormalized/</A>
+				$exponentstring = substr($bitword, 1, 15);
+				$isnormalized = intval($bitword{16});
+				$fractionstring = substr($bitword, 17, 63);
+				$exponent = pow(2, getid3_lib::Bin2Dec($exponentstring) - 16383);
+				$fraction = $isnormalized + getid3_lib::DecimalBinary2Float($fractionstring);
+				$floatvalue = $exponent * $fraction;
+				if ($signbit == '1') {
+					$floatvalue *= -1;
+				}
+				return $floatvalue;
+				break;
+
+			default:
+				return false;
+				break;
+		}
+		$exponentstring = substr($bitword, 1, $exponentbits);
+		$fractionstring = substr($bitword, $exponentbits + 1, $fractionbits);
+		$exponent = getid3_lib::Bin2Dec($exponentstring);
+		$fraction = getid3_lib::Bin2Dec($fractionstring);
+
+		if (($exponent == (pow(2, $exponentbits) - 1)) &amp;&amp; ($fraction != 0)) {
+			// Not a Number
+			$floatvalue = false;
+		} elseif (($exponent == (pow(2, $exponentbits) - 1)) &amp;&amp; ($fraction == 0)) {
+			if ($signbit == '1') {
+				$floatvalue = '-infinity';
+			} else {
+				$floatvalue = '+infinity';
+			}
+		} elseif (($exponent == 0) &amp;&amp; ($fraction == 0)) {
+			if ($signbit == '1') {
+				$floatvalue = -0;
+			} else {
+				$floatvalue = 0;
+			}
+			$floatvalue = ($signbit ? 0 : -0);
+		} elseif (($exponent == 0) &amp;&amp; ($fraction != 0)) {
+			// These are 'unnormalized' values
+			$floatvalue = pow(2, (-1 * (pow(2, $exponentbits - 1) - 2))) * getid3_lib::DecimalBinary2Float($fractionstring);
+			if ($signbit == '1') {
+				$floatvalue *= -1;
+			}
+		} elseif ($exponent != 0) {
+			$floatvalue = pow(2, ($exponent - (pow(2, $exponentbits - 1) - 1))) * (1 + getid3_lib::DecimalBinary2Float($fractionstring));
+			if ($signbit == '1') {
+				$floatvalue *= -1;
+			}
+		}
+		return (float) $floatvalue;
+	}
+
+
+	function BigEndian2Int($byteword, $synchsafe=false, $signed=false) {
+		$intvalue = 0;
+		$bytewordlen = strlen($byteword);
+		for ($i = 0; $i &lt; $bytewordlen; $i++) {
+			if ($synchsafe) { // disregard MSB, effectively 7-bit bytes
+				$intvalue = $intvalue | (ord($byteword{$i}) &amp; 0x7F) &lt;&lt; (($bytewordlen - 1 - $i) * 7);
+			} else {
+				$intvalue += ord($byteword{$i}) * pow(256, ($bytewordlen - 1 - $i));
+			}
+		}
+		if ($signed &amp;&amp; !$synchsafe) {
+			// synchsafe ints are not allowed to be signed
+			switch ($bytewordlen) {
+				case 1:
+				case 2:
+				case 3:
+				case 4:
+					$signmaskbit = 0x80 &lt;&lt; (8 * ($bytewordlen - 1));
+					if ($intvalue &amp; $signmaskbit) {
+						$intvalue = 0 - ($intvalue &amp; ($signmaskbit - 1));
+					}
+					break;
+
+				default:
+					die('ERROR: Cannot have signed integers larger than 32-bits in getid3_lib::BigEndian2Int()');
+					break;
+			}
+		}
+		return getid3_lib::CastAsInt($intvalue);
+	}
+
+
+	function LittleEndian2Int($byteword, $signed=false) {
+		return getid3_lib::BigEndian2Int(strrev($byteword), false, $signed);
+	}
+
+
+	function BigEndian2Bin($byteword) {
+		$binvalue = '';
+		$bytewordlen = strlen($byteword);
+		for ($i = 0; $i &lt; $bytewordlen; $i++) {
+			$binvalue .= str_pad(decbin(ord($byteword{$i})), 8, '0', STR_PAD_LEFT);
+		}
+		return $binvalue;
+	}
+
+
+	function BigEndian2String($number, $minbytes=1, $synchsafe=false, $signed=false) {
+		if ($number &lt; 0) {
+			return false;
+		}
+		$maskbyte = (($synchsafe || $signed) ? 0x7F : 0xFF);
+		$intstring = '';
+		if ($signed) {
+			if ($minbytes &gt; 4) {
+				die('ERROR: Cannot have signed integers larger than 32-bits in getid3_lib::BigEndian2String()');
+			}
+			$number = $number &amp; (0x80 &lt;&lt; (8 * ($minbytes - 1)));
+		}
+		while ($number != 0) {
+			$quotient = ($number / ($maskbyte + 1));
+			$intstring = chr(ceil(($quotient - floor($quotient)) * $maskbyte)).$intstring;
+			$number = floor($quotient);
+		}
+		return str_pad($intstring, $minbytes, &quot;\x00&quot;, STR_PAD_LEFT);
+	}
+
+
+	function Dec2Bin($number) {
+		while ($number &gt;= 256) {
+			$bytes[] = (($number / 256) - (floor($number / 256))) * 256;
+			$number = floor($number / 256);
+		}
+		$bytes[] = $number;
+		$binstring = '';
+		for ($i = 0; $i &lt; count($bytes); $i++) {
+			$binstring = (($i == count($bytes) - 1) ? decbin($bytes[$i]) : str_pad(decbin($bytes[$i]), 8, '0', STR_PAD_LEFT)).$binstring;
+		}
+		return $binstring;
+	}
+
+
+	function Bin2Dec($binstring, $signed=false) {
+		$signmult = 1;
+		if ($signed) {
+			if ($binstring{0} == '1') {
+				$signmult = -1;
+			}
+			$binstring = substr($binstring, 1);
+		}
+		$decvalue = 0;
+		for ($i = 0; $i &lt; strlen($binstring); $i++) {
+			$decvalue += ((int) substr($binstring, strlen($binstring) - $i - 1, 1)) * pow(2, $i);
+		}
+		return getid3_lib::CastAsInt($decvalue * $signmult);
+	}
+
+
+	function Bin2String($binstring) {
+		// return 'hi' for input of '0110100001101001'
+		$string = '';
+		$binstringreversed = strrev($binstring);
+		for ($i = 0; $i &lt; strlen($binstringreversed); $i += 8) {
+			$string = chr(getid3_lib::Bin2Dec(strrev(substr($binstringreversed, $i, 8)))).$string;
+		}
+		return $string;
+	}
+
+
+	function LittleEndian2String($number, $minbytes=1, $synchsafe=false) {
+		$intstring = '';
+		while ($number &gt; 0) {
+			if ($synchsafe) {
+				$intstring = $intstring.chr($number &amp; 127);
+				$number &gt;&gt;= 7;
+			} else {
+				$intstring = $intstring.chr($number &amp; 255);
+				$number &gt;&gt;= 8;
+			}
+		}
+		return str_pad($intstring, $minbytes, &quot;\x00&quot;, STR_PAD_RIGHT);
+	}
+
+
+	function array_merge_clobber($array1, $array2) {
+		// written by kc&#216;hireability*com
+		// taken from <A HREF="http://www.php.net/manual/en/function.array-merge-recursive.php">http://www.php.net/manual/en/function.array-merge-recursive.php</A>
+		if (!is_array($array1) || !is_array($array2)) {
+			return false;
+		}
+		$newarray = $array1;
+		foreach ($array2 as $key =&gt; $val) {
+			if (is_array($val) &amp;&amp; isset($newarray[$key]) &amp;&amp; is_array($newarray[$key])) {
+				$newarray[$key] = getid3_lib::array_merge_clobber($newarray[$key], $val);
+			} else {
+				$newarray[$key] = $val;
+			}
+		}
+		return $newarray;
+	}
+
+
+	function array_merge_noclobber($array1, $array2) {
+		if (!is_array($array1) || !is_array($array2)) {
+			return false;
+		}
+		$newarray = $array1;
+		foreach ($array2 as $key =&gt; $val) {
+			if (is_array($val) &amp;&amp; isset($newarray[$key]) &amp;&amp; is_array($newarray[$key])) {
+				$newarray[$key] = getid3_lib::array_merge_noclobber($newarray[$key], $val);
+			} elseif (!isset($newarray[$key])) {
+				$newarray[$key] = $val;
+			}
+		}
+		return $newarray;
+	}
+
+
+	function fileextension($filename, $numextensions=1) {
+		if (strstr($filename, '.')) {
+			$reversedfilename = strrev($filename);
+			$offset = 0;
+			for ($i = 0; $i &lt; $numextensions; $i++) {
+				$offset = strpos($reversedfilename, '.', $offset + 1);
+				if ($offset === false) {
+					return '';
+				}
+			}
+			return strrev(substr($reversedfilename, 0, $offset));
+		}
+		return '';
+	}
+
+
+	function PlaytimeString($playtimeseconds) {
+		$contentseconds = round((($playtimeseconds / 60) - floor($playtimeseconds / 60)) * 60);
+		$contentminutes = floor($playtimeseconds / 60);
+		if ($contentseconds &gt;= 60) {
+			$contentseconds -= 60;
+			$contentminutes++;
+		}
+		return intval($contentminutes).':'.str_pad($contentseconds, 2, 0, STR_PAD_LEFT);
+	}
+
+
+	function image_type_to_mime_type($imagetypeid) {
+		// only available in PHP v4.3.0+
+		static $image_type_to_mime_type = array();
+		if (empty($image_type_to_mime_type)) {
+			$image_type_to_mime_type[1]  = 'image/gif';                     // GIF
+			$image_type_to_mime_type[2]  = 'image/jpeg';                    // JPEG
+			$image_type_to_mime_type[3]  = 'image/png';                     // PNG
+			$image_type_to_mime_type[4]  = 'application/x-shockwave-flash'; // Flash
+			$image_type_to_mime_type[5]  = 'image/psd';                     // PSD
+			$image_type_to_mime_type[6]  = 'image/bmp';                     // BMP
+			$image_type_to_mime_type[7]  = 'image/tiff';                    // TIFF: little-endian (Intel)
+			$image_type_to_mime_type[8]  = 'image/tiff';                    // TIFF: big-endian (Motorola)
+			//$image_type_to_mime_type[9]  = 'image/jpc';                   // JPC
+			//$image_type_to_mime_type[10] = 'image/jp2';                   // JPC
+			//$image_type_to_mime_type[11] = 'image/jpx';                   // JPC
+			//$image_type_to_mime_type[12] = 'image/jb2';                   // JPC
+			$image_type_to_mime_type[13] = 'application/x-shockwave-flash'; // Shockwave
+			$image_type_to_mime_type[14] = 'image/iff';                     // IFF
+		}
+		return (isset($image_type_to_mime_type[$imagetypeid]) ? $image_type_to_mime_type[$imagetypeid] : 'application/octet-stream');
+	}
+
+
+	function DateMac2Unix($macdate) {
+		// Macintosh timestamp: seconds since 00:00h January 1, 1904
+		// UNIX timestamp:      seconds since 00:00h January 1, 1970
+		return getid3_lib::CastAsInt($macdate - 2082844800);
+	}
+
+
+	function FixedPoint8_8($rawdata) {
+		return getid3_lib::BigEndian2Int(substr($rawdata, 0, 1)) + (float) (getid3_lib::BigEndian2Int(substr($rawdata, 1, 1)) / pow(2, 8));
+	}
+
+
+	function FixedPoint16_16($rawdata) {
+		return getid3_lib::BigEndian2Int(substr($rawdata, 0, 2)) + (float) (getid3_lib::BigEndian2Int(substr($rawdata, 2, 2)) / pow(2, 16));
+	}
+
+
+	function FixedPoint2_30($rawdata) {
+		$binarystring = getid3_lib::BigEndian2Bin($rawdata);
+		return getid3_lib::Bin2Dec(substr($binarystring, 0, 2)) + (float) (getid3_lib::Bin2Dec(substr($binarystring, 2, 30)) / 1073741824);
+	}
+
+
+	function CreateDeepArray($ArrayPath, $Separator, $Value) {
+		// assigns $Value to a nested array path:
+		//   $foo = getid3_lib::CreateDeepArray('/path/to/my', '/', 'file.txt')
+		// is the same as:
+		//   $foo = array('path'=&gt;array('to'=&gt;'array('my'=&gt;array('file.txt'))));
+		// or
+		//   $foo['path']['to']['my'] = 'file.txt';
+		while ($ArrayPath &amp;&amp; ($ArrayPath{0} == $Separator)) {
+			$ArrayPath = substr($ArrayPath, 1);
+		}
+		if (($pos = strpos($ArrayPath, $Separator)) !== false) {
+			$ReturnedArray[substr($ArrayPath, 0, $pos)] = getid3_lib::CreateDeepArray(substr($ArrayPath, $pos + 1), $Separator, $Value);
+		} else {
+			$ReturnedArray[$ArrayPath] = $Value;
+		}
+		return $ReturnedArray;
+	}
+
+	function array_max($arraydata, $returnkey=false) {
+		$maxvalue = false;
+		$maxkey = false;
+		foreach ($arraydata as $key =&gt; $value) {
+			if (!is_array($value)) {
+				if ($value &gt; $maxvalue) {
+					$maxvalue = $value;
+					$maxkey = $key;
+				}
+			}
+		}
+		return ($returnkey ? $maxkey : $maxvalue);
+	}
+
+	function array_min($arraydata, $returnkey=false) {
+		$minvalue = false;
+		$minkey = false;
+		foreach ($arraydata as $key =&gt; $value) {
+			if (!is_array($value)) {
+				if ($value &gt; $minvalue) {
+					$minvalue = $value;
+					$minkey = $key;
+				}
+			}
+		}
+		return ($returnkey ? $minkey : $minvalue);
+	}
+
+
+	function md5_file($file) {
+
+		// md5_file() exists in PHP 4.2.0+.
+		if (function_exists('md5_file')) {
+			return md5_file($file);
+		}
+
+		if (GETID3_OS_ISWINDOWS) {
+
+			$RequiredFiles = array('cygwin1.dll', 'md5sum.exe');
+			foreach ($RequiredFiles as $required_file) {
+				if (!is_readable(GETID3_HELPERAPPSDIR.$required_file)) {
+					die(implode(' and ', $RequiredFiles).' are required in '.GETID3_HELPERAPPSDIR.' for getid3_lib::md5_file() to function under Windows in PHP &lt; v4.2.0');
+				}
+			}
+			$commandline = GETID3_HELPERAPPSDIR.'md5sum.exe &quot;'.str_replace('/', GETID3_OS_DIRSLASH, $file).'&quot;';
+			if (ereg(&quot;^[\\]?([0-9a-f]{32})&quot;, strtolower(`$commandline`), $r)) {
+				return $r[1];
+			}
+
+		} else {
+
+			// The following works under UNIX only
+			$file = str_replace('`', '\\`', $file);
+			if (ereg(&quot;^([0-9a-f]{32})[ \t\n\r]&quot;, `md5sum &quot;$file&quot;`, $r)) {
+				return $r[1];
+			}
+
+		}
+		return false;
+	}
+
+
+	function sha1_file($file) {
+
+		// sha1_file() exists in PHP 4.3.0+.
+		if (function_exists('sha1_file')) {
+			return sha1_file($file);
+		}
+
+		$file = str_replace('`', '\\`', $file);
+
+		if (GETID3_OS_ISWINDOWS) {
+
+			$RequiredFiles = array('cygwin1.dll', 'sha1sum.exe');
+			foreach ($RequiredFiles as $required_file) {
+				if (!is_readable(GETID3_HELPERAPPSDIR.$required_file)) {
+					die(implode(' and ', $RequiredFiles).' are required in '.GETID3_HELPERAPPSDIR.' for getid3_lib::sha1_file() to function under Windows in PHP &lt; v4.3.0');
+				}
+			}
+			$commandline = GETID3_HELPERAPPSDIR.'sha1sum.exe &quot;'.str_replace('/', GETID3_OS_DIRSLASH, $file).'&quot;';
+			if (ereg(&quot;^sha1=([0-9a-f]{40})&quot;, strtolower(`$commandline`), $r)) {
+				return $r[1];
+			}
+
+		} else {
+
+			$commandline = 'sha1sum &quot;'.$file.'&quot;';
+			if (ereg(&quot;^([0-9a-f]{40})[ \t\n\r]&quot;, strtolower(`$commandline`), $r)) {
+				return $r[1];
+			}
+
+		}
+
+		return false;
+	}
+
+
+	// Allan Hansen &lt;ah&#216;artemis*dk&gt;
+	// getid3_lib::md5_data() - returns md5sum for a file from startuing position to absolute end position
+	function hash_data($file, $offset, $end, $algorithm) {
+
+		switch ($algorithm) {
+			case 'md5':
+				$hash_function = 'md5_file';
+				$unix_call     = 'md5sum';
+				$windows_call  = 'md5sum.exe';
+				$hash_length   = 32;
+				break;
+
+			case 'sha1':
+				$hash_function = 'sha1_file';
+				$unix_call     = 'sha1sum';
+				$windows_call  = 'sha1sum.exe';
+				$hash_length   = 40;
+				break;
+
+			default:
+				die('Invalid algorithm ('.$algorithm.') in getid3_lib::hash_data()');
+				break;
+		}
+		$size = $end - $offset;
+		while (true) {
+			if (GETID3_OS_ISWINDOWS) {
+
+				// It seems that sha1sum.exe for Windows only works on physical files, does not accept piped data
+				// Fall back to create-temp-file method:
+				if ($algorithm == 'sha1') {
+					break;
+				}
+
+				$RequiredFiles = array('cygwin1.dll', 'head.exe', 'tail.exe', $windows_call);
+				foreach ($RequiredFiles as $required_file) {
+					if (!is_readable(GETID3_HELPERAPPSDIR.$required_file)) {
+						// helper apps not available - fall back to old method
+						break;
+					}
+				}
+				$commandline  = GETID3_HELPERAPPSDIR.'head.exe -c '.$end.' &quot;'.str_replace('/', GETID3_OS_DIRSLASH, $file).'&quot; | ';
+				$commandline .= GETID3_HELPERAPPSDIR.'tail.exe -c '.$size.' | ';
+				$commandline .= GETID3_HELPERAPPSDIR.$windows_call;
+
+			} else {
+
+				$commandline  = 'head -c '.$end.' &quot;'.$file.'&quot; | ';
+				$commandline .= 'tail -c '.$size.' | ';
+				$commandline .= $unix_call;
+
+			}
+			if ((bool) ini_get('safe_mode')) {
+				$ThisFileInfo['warning'][] = 'PHP running in Safe Mode - backtick operator not available, using slower non-system-call '.$algorithm.' algorithm';
+				break;
+			}
+			return substr(`$commandline`, 0, $hash_length);
+		}
+
+		// try to create a temporary file in the system temp directory - invalid dirname should force to system temp dir
+		if (($data_filename = tempnam('*', 'getID3')) === false) {
+			// can't find anywhere to create a temp file, just die
+			return false;
+		}
+
+		// Init
+		$result = false;
+
+		// copy parts of file
+		if ($fp = @fopen($file, 'rb')) {
+
+			if ($fp_data = @fopen($data_filename, 'wb')) {
+
+				fseek($fp, $offset, SEEK_SET);
+				$byteslefttowrite = $end - $offset;
+				while (($byteslefttowrite &gt; 0) &amp;&amp; ($buffer = fread($fp, GETID3_FREAD_BUFFER_SIZE))) {
+					$byteswritten = fwrite($fp_data, $buffer, $byteslefttowrite);
+					$byteslefttowrite -= $byteswritten;
+				}
+				fclose($fp_data);
+				$result = getid3_lib::$hash_function($data_filename);
+
+			}
+			fclose($fp);
+		}
+		unlink($data_filename);
+		return $result;
+	}
+
+
+	function iconv_fallback_int_utf8($charval) {
+		if ($charval &lt; 128) {
+			// 0bbbbbbb
+			$newcharstring = chr($charval);
+		} elseif ($charval &lt; 2048) {
+			// 110bbbbb 10bbbbbb
+			$newcharstring  = chr(($charval &gt;&gt; 6) | 0xC0);
+			$newcharstring .= chr(($charval &amp; 0x3F) | 0x80);
+		} elseif ($charval &lt; 65536) {
+			// 1110bbbb 10bbbbbb 10bbbbbb
+			$newcharstring  = chr(($charval &gt;&gt; 12) | 0xE0);
+			$newcharstring .= chr(($charval &gt;&gt;  6) | 0xC0);
+			$newcharstring .= chr(($charval &amp; 0x3F) | 0x80);
+		} else {
+			// 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
+			$newcharstring  = chr(($charval &gt;&gt; 18) | 0xF0);
+			$newcharstring .= chr(($charval &gt;&gt; 12) | 0xC0);
+			$newcharstring .= chr(($charval &gt;&gt;  6) | 0xC0);
+			$newcharstring .= chr(($charval &amp; 0x3F) | 0x80);
+		}
+		return $newcharstring;
+	}
+
+	// ISO-8859-1 =&gt; UTF-8
+	function iconv_fallback_iso88591_utf8($string, $bom=false) {
+		if (function_exists('utf8_encode')) {
+			return utf8_encode($string);
+		}
+		// utf8_encode() unavailable, use getID3()'s iconv_fallback() conversions (possibly PHP is compiled without XML support)
+		$newcharstring = '';
+		if ($bom) {
+			$newcharstring .= &quot;\xEF\xBB\xBF&quot;;
+		}
+		for ($i = 0; $i &lt; strlen($string); $i++) {
+			$charval = ord($string{$i});
+			$newcharstring .= getid3_lib::iconv_fallback_int_utf8($charval);
+		}
+		return $newcharstring;
+	}
+
+	// ISO-8859-1 =&gt; UTF-16BE
+	function iconv_fallback_iso88591_utf16be($string, $bom=false) {
+		$newcharstring = '';
+		if ($bom) {
+			$newcharstring .= &quot;\xFE\xFF&quot;;
+		}
+		for ($i = 0; $i &lt; strlen($string); $i++) {
+			$newcharstring .= &quot;\x00&quot;.$string{$i};
+		}
+		return $newcharstring;
+	}
+
+	// ISO-8859-1 =&gt; UTF-16LE
+	function iconv_fallback_iso88591_utf16le($string, $bom=false) {
+		$newcharstring = '';
+		if ($bom) {
+			$newcharstring .= &quot;\xFF\xFE&quot;;
+		}
+		for ($i = 0; $i &lt; strlen($string); $i++) {
+			$newcharstring .= $string{$i}.&quot;\x00&quot;;
+		}
+		return $newcharstring;
+	}
+
+	// ISO-8859-1 =&gt; UTF-16LE (BOM)
+	function iconv_fallback_iso88591_utf16($string) {
+		return getid3_lib::iconv_fallback_iso88591_utf16le($string, true);
+	}
+
+	// UTF-8 =&gt; ISO-8859-1
+	function iconv_fallback_utf8_iso88591($string) {
+		if (function_exists('utf8_decode')) {
+			return utf8_decode($string);
+		}
+		// utf8_decode() unavailable, use getID3()'s iconv_fallback() conversions (possibly PHP is compiled without XML support)
+		$newcharstring = '';
+		$offset = 0;
+		$stringlength = strlen($string);
+		while ($offset &lt; $stringlength) {
+			if ((ord($string{$offset}) | 0x07) == 0xF7) {
+				// 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
+				$charval = ((ord($string{($offset + 0)}) &amp; 0x07) &lt;&lt; 18) &amp;
+				           ((ord($string{($offset + 1)}) &amp; 0x3F) &lt;&lt; 12) &amp;
+				           ((ord($string{($offset + 2)}) &amp; 0x3F) &lt;&lt;  6) &amp;
+				            (ord($string{($offset + 3)}) &amp; 0x3F);
+				$offset += 4;
+			} elseif ((ord($string{$offset}) | 0x0F) == 0xEF) {
+				// 1110bbbb 10bbbbbb 10bbbbbb
+				$charval = ((ord($string{($offset + 0)}) &amp; 0x0F) &lt;&lt; 12) &amp;
+				           ((ord($string{($offset + 1)}) &amp; 0x3F) &lt;&lt;  6) &amp;
+				            (ord($string{($offset + 2)}) &amp; 0x3F);
+				$offset += 3;
+			} elseif ((ord($string{$offset}) | 0x1F) == 0xDF) {
+				// 110bbbbb 10bbbbbb
+				$charval = ((ord($string{($offset + 0)}) &amp; 0x1F) &lt;&lt;  6) &amp;
+				            (ord($string{($offset + 1)}) &amp; 0x3F);
+				$offset += 2;
+			} elseif ((ord($string{$offset}) | 0x7F) == 0x7F) {
+				// 0bbbbbbb
+				$charval = ord($string{$offset});
+				$offset += 1;
+			} else {
+				// error? throw some kind of warning here?
+				$charval = false;
+				$offset += 1;
+			}
+			if ($charval !== false) {
+				$newcharstring .= (($charval &lt; 256) ? chr($charval) : '?');
+			}
+		}
+		return $newcharstring;
+	}
+
+	// UTF-8 =&gt; UTF-16BE
+	function iconv_fallback_utf8_utf16be($string, $bom=false) {
+		$newcharstring = '';
+		if ($bom) {
+			$newcharstring .= &quot;\xFE\xFF&quot;;
+		}
+		$offset = 0;
+		$stringlength = strlen($string);
+		while ($offset &lt; $stringlength) {
+			if ((ord($string{$offset}) | 0x07) == 0xF7) {
+				// 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
+				$charval = ((ord($string{($offset + 0)}) &amp; 0x07) &lt;&lt; 18) &amp;
+				           ((ord($string{($offset + 1)}) &amp; 0x3F) &lt;&lt; 12) &amp;
+				           ((ord($string{($offset + 2)}) &amp; 0x3F) &lt;&lt;  6) &amp;
+				            (ord($string{($offset + 3)}) &amp; 0x3F);
+				$offset += 4;
+			} elseif ((ord($string{$offset}) | 0x0F) == 0xEF) {
+				// 1110bbbb 10bbbbbb 10bbbbbb
+				$charval = ((ord($string{($offset + 0)}) &amp; 0x0F) &lt;&lt; 12) &amp;
+				           ((ord($string{($offset + 1)}) &amp; 0x3F) &lt;&lt;  6) &amp;
+				            (ord($string{($offset + 2)}) &amp; 0x3F);
+				$offset += 3;
+			} elseif ((ord($string{$offset}) | 0x1F) == 0xDF) {
+				// 110bbbbb 10bbbbbb
+				$charval = ((ord($string{($offset + 0)}) &amp; 0x1F) &lt;&lt;  6) &amp;
+				            (ord($string{($offset + 1)}) &amp; 0x3F);
+				$offset += 2;
+			} elseif ((ord($string{$offset}) | 0x7F) == 0x7F) {
+				// 0bbbbbbb
+				$charval = ord($string{$offset});
+				$offset += 1;
+			} else {
+				// error? throw some kind of warning here?
+				$charval = false;
+				$offset += 1;
+			}
+			if ($charval !== false) {
+				$newcharstring .= (($charval &lt; 65536) ? getid3_lib::BigEndian2String($charval, 2) : &quot;\x00&quot;.'?');
+			}
+		}
+		return $newcharstring;
+	}
+
+	// UTF-8 =&gt; UTF-16LE
+	function iconv_fallback_utf8_utf16le($string, $bom=false) {
+		$newcharstring = '';
+		if ($bom) {
+			$newcharstring .= &quot;\xFF\xFE&quot;;
+		}
+		$offset = 0;
+		$stringlength = strlen($string);
+		while ($offset &lt; $stringlength) {
+			if ((ord($string{$offset}) | 0x07) == 0xF7) {
+				// 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
+				$charval = ((ord($string{($offset + 0)}) &amp; 0x07) &lt;&lt; 18) &amp;
+				           ((ord($string{($offset + 1)}) &amp; 0x3F) &lt;&lt; 12) &amp;
+				           ((ord($string{($offset + 2)}) &amp; 0x3F) &lt;&lt;  6) &amp;
+				            (ord($string{($offset + 3)}) &amp; 0x3F);
+				$offset += 4;
+			} elseif ((ord($string{$offset}) | 0x0F) == 0xEF) {
+				// 1110bbbb 10bbbbbb 10bbbbbb
+				$charval = ((ord($string{($offset + 0)}) &amp; 0x0F) &lt;&lt; 12) &amp;
+				           ((ord($string{($offset + 1)}) &amp; 0x3F) &lt;&lt;  6) &amp;
+				            (ord($string{($offset + 2)}) &amp; 0x3F);
+				$offset += 3;
+			} elseif ((ord($string{$offset}) | 0x1F) == 0xDF) {
+				// 110bbbbb 10bbbbbb
+				$charval = ((ord($string{($offset + 0)}) &amp; 0x1F) &lt;&lt;  6) &amp;
+				            (ord($string{($offset + 1)}) &amp; 0x3F);
+				$offset += 2;
+			} elseif ((ord($string{$offset}) | 0x7F) == 0x7F) {
+				// 0bbbbbbb
+				$charval = ord($string{$offset});
+				$offset += 1;
+			} else {
+				// error? maybe throw some warning here?
+				$charval = false;
+				$offset += 1;
+			}
+			if ($charval !== false) {
+				$newcharstring .= (($charval &lt; 65536) ? getid3_lib::LittleEndian2String($charval, 2) : '?'.&quot;\x00&quot;);
+			}
+		}
+		return $newcharstring;
+	}
+
+	// UTF-8 =&gt; UTF-16LE (BOM)
+	function iconv_fallback_utf8_utf16($string) {
+		return getid3_lib::iconv_fallback_utf8_utf16le($string, true);
+	}
+
+	// UTF-16BE =&gt; UTF-8
+	function iconv_fallback_utf16be_utf8($string) {
+		if (substr($string, 0, 2) == &quot;\xFE\xFF&quot;) {
+			// strip BOM
+			$string = substr($string, 2);
+		}
+		$newcharstring = '';
+		for ($i = 0; $i &lt; strlen($string); $i += 2) {
+			$charval = getid3_lib::BigEndian2Int(substr($string, $i, 2));
+			$newcharstring .= getid3_lib::iconv_fallback_int_utf8($charval);
+		}
+		return $newcharstring;
+	}
+
+	// UTF-16LE =&gt; UTF-8
+	function iconv_fallback_utf16le_utf8($string) {
+		if (substr($string, 0, 2) == &quot;\xFF\xFE&quot;) {
+			// strip BOM
+			$string = substr($string, 2);
+		}
+		$newcharstring = '';
+		for ($i = 0; $i &lt; strlen($string); $i += 2) {
+			$charval = getid3_lib::LittleEndian2Int(substr($string, $i, 2));
+			$newcharstring .= getid3_lib::iconv_fallback_int_utf8($charval);
+		}
+		return $newcharstring;
+	}
+
+	// UTF-16BE =&gt; ISO-8859-1
+	function iconv_fallback_utf16be_iso88591($string) {
+		if (substr($string, 0, 2) == &quot;\xFE\xFF&quot;) {
+			// strip BOM
+			$string = substr($string, 2);
+		}
+		$newcharstring = '';
+		for ($i = 0; $i &lt; strlen($string); $i += 2) {
+			$charval = getid3_lib::BigEndian2Int(substr($string, $i, 2));
+			$newcharstring .= (($charval &lt; 256) ? chr($charval) : '?');
+		}
+		return $newcharstring;
+	}
+
+	// UTF-16LE =&gt; ISO-8859-1
+	function iconv_fallback_utf16le_iso88591($string) {
+		if (substr($string, 0, 2) == &quot;\xFF\xFE&quot;) {
+			// strip BOM
+			$string = substr($string, 2);
+		}
+		$newcharstring = '';
+		for ($i = 0; $i &lt; strlen($string); $i += 2) {
+			$charval = getid3_lib::LittleEndian2Int(substr($string, $i, 2));
+			$newcharstring .= (($charval &lt; 256) ? chr($charval) : '?');
+		}
+		return $newcharstring;
+	}
+
+	// UTF-16 (BOM) =&gt; ISO-8859-1
+	function iconv_fallback_utf16_iso88591($string) {
+		$bom = substr($string, 0, 2);
+		if ($bom == &quot;\xFE\xFF&quot;) {
+			return getid3_lib::iconv_fallback_utf16be_iso88591(substr($string, 2));
+		} elseif ($bom == &quot;\xFF\xFE&quot;) {
+			return getid3_lib::iconv_fallback_utf16le_iso88591(substr($string, 2));
+		}
+		return $string;
+	}
+
+	// UTF-16 (BOM) =&gt; UTF-8
+	function iconv_fallback_utf16_utf8($string) {
+		$bom = substr($string, 0, 2);
+		if ($bom == &quot;\xFE\xFF&quot;) {
+			return getid3_lib::iconv_fallback_utf16be_utf8(substr($string, 2));
+		} elseif ($bom == &quot;\xFF\xFE&quot;) {
+			return getid3_lib::iconv_fallback_utf16le_utf8(substr($string, 2));
+		}
+		return $string;
+	}
+
+	function iconv_fallback($in_charset, $out_charset, $string) {
+
+		if ($in_charset == $out_charset) {
+			return $string;
+		}
+
+		static $iconv_broken_or_unavailable = array();
+		if (is_null(@$iconv_broken_or_unavailable[$in_charset.'_'.$out_charset])) {
+			$GETID3_ICONV_TEST_STRING = ' !&quot;#$%&amp;\'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~&#128;&#129;&#130;&#131;&#132;&#133;&#134;&#135;&#136;&#137;&#138;&#139;&#140;&#141;&#142;&#143;&#144;&#145;&#146;&#147;&#148;&#149;&#150;&#151;&#152;&#153;&#154;&#155;&#156;&#157;&#158;&#159; &#161;&#162;&#163;&#164;&#165;&#166;&#167;&#168;&#169;&#170;&#171;&#172;&#173;&#174;&#175;&#176;&#177;&#178;&#179;&#180;&#181;&#182;&#183;&#184;&#185;&#186;&#187;&#188;&#189;&#190;&#191;&#192;&#193;&#194;&#195;&#196;&#197;&#198;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#208;&#209;&#210;&#211;&#212;&#213;&#214;&#215;&#216;&#217;&#218;&#219;&#220;&#221;&#222;&#223;&#224;&#225;&#226;&#227;&#228;&#229;&#230;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#240;&#241;&#242;&#243;&#244;&#245;&#246;&#247;&#248;&#249;&#250;&#251;&#252;&#253;&#254;&#255;';
+
+			// Check iconv()
+			if (function_exists('iconv')) {
+				if (@iconv($in_charset, 'ISO-8859-1', @iconv('ISO-8859-1', $in_charset, $GETID3_ICONV_TEST_STRING)) == $GETID3_ICONV_TEST_STRING) {
+					if (@iconv($out_charset, 'ISO-8859-1', @iconv('ISO-8859-1', $out_charset, $GETID3_ICONV_TEST_STRING)) == $GETID3_ICONV_TEST_STRING) {
+						// everything works, use iconv()
+						$iconv_broken_or_unavailable[$in_charset.'_'.$out_charset] = false;
+					} else {
+						// iconv() available, but broken. Use getID3()'s iconv_fallback() conversions instead
+						// known issue in PHP v4.1.x
+						$iconv_broken_or_unavailable[$in_charset.'_'.$out_charset] = true;
+					}
+				} else {
+					// iconv() available, but broken. Use getID3()'s iconv_fallback() conversions instead
+					// known issue in PHP v4.1.x
+					$iconv_broken_or_unavailable[$in_charset.'_'.$out_charset] = true;
+				}
+			} else {
+				// iconv() unavailable, use getID3()'s iconv_fallback() conversions
+				$iconv_broken_or_unavailable[$in_charset.'_'.$out_charset] = true;
+			}
+		}
+
+		if ($iconv_broken_or_unavailable[$in_charset.'_'.$out_charset]) {
+			static $ConversionFunctionList = array();
+			if (empty($ConversionFunctionList)) {
+				$ConversionFunctionList['ISO-8859-1']['UTF-8']    = 'iconv_fallback_iso88591_utf8';
+				$ConversionFunctionList['ISO-8859-1']['UTF-16']   = 'iconv_fallback_iso88591_utf16';
+				$ConversionFunctionList['ISO-8859-1']['UTF-16BE'] = 'iconv_fallback_iso88591_utf16be';
+				$ConversionFunctionList['ISO-8859-1']['UTF-16LE'] = 'iconv_fallback_iso88591_utf16le';
+				$ConversionFunctionList['UTF-8']['ISO-8859-1']    = 'iconv_fallback_utf8_iso88591';
+				$ConversionFunctionList['UTF-8']['UTF-16']        = 'iconv_fallback_utf8_utf16';
+				$ConversionFunctionList['UTF-8']['UTF-16BE']      = 'iconv_fallback_utf8_utf16be';
+				$ConversionFunctionList['UTF-8']['UTF-16LE']      = 'iconv_fallback_utf8_utf16le';
+				$ConversionFunctionList['UTF-16']['ISO-8859-1']   = 'iconv_fallback_utf16_iso88591';
+				$ConversionFunctionList['UTF-16']['UTF-8']        = 'iconv_fallback_utf16_utf8';
+				$ConversionFunctionList['UTF-16LE']['ISO-8859-1'] = 'iconv_fallback_utf16le_iso88591';
+				$ConversionFunctionList['UTF-16LE']['UTF-8']      = 'iconv_fallback_utf16le_utf8';
+				$ConversionFunctionList['UTF-16BE']['ISO-8859-1'] = 'iconv_fallback_utf16be_iso88591';
+				$ConversionFunctionList['UTF-16BE']['UTF-8']      = 'iconv_fallback_utf16be_utf8';
+			}
+			if (isset($ConversionFunctionList[strtoupper($in_charset)][strtoupper($out_charset)])) {
+				$ConversionFunction = $ConversionFunctionList[strtoupper($in_charset)][strtoupper($out_charset)];
+				return getid3_lib::$ConversionFunction($string);
+			}
+			die('PHP does not have iconv() support - cannot convert from '.$in_charset.' to '.$out_charset);
+		}
+
+		if ($converted_string = @iconv($in_charset, $out_charset.'//TRANSLIT', $string)) {
+			switch ($out_charset) {
+				case 'ISO-8859-1':
+					$converted_string = rtrim($converted_string, &quot;\x00&quot;);
+					break;
+			}
+			return $converted_string;
+		}
+
+		// iconv() may sometimes fail with &quot;illegal character in input string&quot; error message
+		// and return an empty string, but returning the unconverted string is more useful
+		return $string;
+	}
+
+
+	function MultiByteCharString2HTML($string, $charset='ISO-8859-1') {
+		$HTMLstring = '';
+
+		switch ($charset) {
+			case 'ISO-8859-1':
+			case 'ISO8859-1':
+			case 'ISO-8859-15':
+			case 'ISO8859-15':
+			case 'cp866':
+			case 'ibm866':
+			case '866':
+			case 'cp1251':
+			case 'Windows-1251':
+			case 'win-1251':
+			case '1251':
+			case 'cp1252':
+			case 'Windows-1252':
+			case '1252':
+			case 'KOI8-R':
+			case 'koi8-ru':
+			case 'koi8r':
+			case 'BIG5':
+			case '950':
+			case 'GB2312':
+			case '936':
+			case 'BIG5-HKSCS':
+			case 'Shift_JIS':
+			case 'SJIS':
+			case '932':
+			case 'EUC-JP':
+			case 'EUCJP':
+				$HTMLstring = htmlentities($string, ENT_COMPAT, $charset);
+				break;
+
+			case 'UTF-8':
+				$strlen = strlen($string);
+				for ($i = 0; $i &lt; $strlen; $i++) {
+					$char_ord_val = ord($string{$i});
+					$charval = 0;
+					if ($char_ord_val &lt; 0x80) {
+						$charval = $char_ord_val;
+					} elseif ((($char_ord_val &amp; 0xF0) &gt;&gt; 4) == 0x0F) {
+						$charval  = (($char_ord_val &amp; 0x07) &lt;&lt; 18);
+						$charval += ((ord($string{++$i}) &amp; 0x3F) &lt;&lt; 12);
+						$charval += ((ord($string{++$i}) &amp; 0x3F) &lt;&lt; 6);
+						$charval +=  (ord($string{++$i}) &amp; 0x3F);
+					} elseif ((($char_ord_val &amp; 0xE0) &gt;&gt; 5) == 0x07) {
+						$charval  = (($char_ord_val &amp; 0x0F) &lt;&lt; 12);
+						$charval += ((ord($string{++$i}) &amp; 0x3F) &lt;&lt; 6);
+						$charval +=  (ord($string{++$i}) &amp; 0x3F);
+					} elseif ((($char_ord_val &amp; 0xC0) &gt;&gt; 6) == 0x03) {
+						$charval  = (($char_ord_val &amp; 0x1F) &lt;&lt; 6);
+						$charval += (ord($string{++$i}) &amp; 0x3F);
+					}
+					if (($charval &gt;= 32) &amp;&amp; ($charval &lt;= 127)) {
+						$HTMLstring .= chr($charval);
+					} else {
+						$HTMLstring .= '&amp;#'.$charval.';';
+					}
+				}
+				break;
+
+			case 'UTF-16LE':
+				for ($i = 0; $i &lt; strlen($string); $i += 2) {
+					$charval = getid3_lib::LittleEndian2Int(substr($string, $i, 2));
+					if (($charval &gt;= 32) &amp;&amp; ($charval &lt;= 127)) {
+						$HTMLstring .= chr($charval);
+					} else {
+						$HTMLstring .= '&amp;#'.$charval.';';
+					}
+				}
+				break;
+
+			case 'UTF-16BE':
+				for ($i = 0; $i &lt; strlen($string); $i += 2) {
+					$charval = getid3_lib::BigEndian2Int(substr($string, $i, 2));
+					if (($charval &gt;= 32) &amp;&amp; ($charval &lt;= 127)) {
+						$HTMLstring .= chr($charval);
+					} else {
+						$HTMLstring .= '&amp;#'.$charval.';';
+					}
+				}
+				break;
+
+			default:
+				$HTMLstring = 'ERROR: Character set &quot;'.$charset.'&quot; not supported in MultiByteCharString2HTML()';
+				break;
+		}
+		return $HTMLstring;
+	}
+
+
+
+	function RGADnameLookup($namecode) {
+		static $RGADname = array();
+		if (empty($RGADname)) {
+			$RGADname[0] = 'not set';
+			$RGADname[1] = 'Track Gain Adjustment';
+			$RGADname[2] = 'Album Gain Adjustment';
+		}
+
+		return (isset($RGADname[$namecode]) ? $RGADname[$namecode] : '');
+	}
+
+
+	function RGADoriginatorLookup($originatorcode) {
+		static $RGADoriginator = array();
+		if (empty($RGADoriginator)) {
+			$RGADoriginator[0] = 'unspecified';
+			$RGADoriginator[1] = 'pre-set by artist/producer/mastering engineer';
+			$RGADoriginator[2] = 'set by user';
+			$RGADoriginator[3] = 'determined automatically';
+		}
+
+		return (isset($RGADoriginator[$originatorcode]) ? $RGADoriginator[$originatorcode] : '');
+	}
+
+
+	function RGADadjustmentLookup($rawadjustment, $signbit) {
+		$adjustment = $rawadjustment / 10;
+		if ($signbit == 1) {
+			$adjustment *= -1;
+		}
+		return (float) $adjustment;
+	}
+
+
+	function RGADgainString($namecode, $originatorcode, $replaygain) {
+		if ($replaygain &lt; 0) {
+			$signbit = '1';
+		} else {
+			$signbit = '0';
+		}
+		$storedreplaygain = intval(round($replaygain * 10));
+		$gainstring  = str_pad(decbin($namecode), 3, '0', STR_PAD_LEFT);
+		$gainstring .= str_pad(decbin($originatorcode), 3, '0', STR_PAD_LEFT);
+		$gainstring .= $signbit;
+		$gainstring .= str_pad(decbin($storedreplaygain), 9, '0', STR_PAD_LEFT);
+
+		return $gainstring;
+	}
+
+	function RGADamplitude2dB($amplitude) {
+		return 20 * log10($amplitude);
+	}
+
+
+	function GetURLImageSize($urlpic) {
+		if ($fd = @fopen($urlpic, 'rb')){
+			$imgData = fread($fd, filesize($urlpic));
+			fclose($fd);
+			return getid3_lib::GetDataImageSize($imgData);
+		}
+		return array('', '', '');
+	}
+
+
+	function GetDataImageSize($imgData) {
+		$height = '';
+		$width  = '';
+		$type   = '';
+		if ((substr($imgData, 0, 3) == GETID3_GIF_SIG) &amp;&amp; (strlen($imgData) &gt; 10)) {
+			$dim = unpack('v2dim', substr($imgData, 6, 4));
+			$width  = $dim['dim1'];
+			$height = $dim['dim2'];
+			$type = 1;
+		} elseif ((substr($imgData, 0, 8) == GETID3_PNG_SIG) &amp;&amp; (strlen($imgData) &gt; 24)) {
+			$dim = unpack('N2dim', substr($imgData, 16, 8));
+			$width  = $dim['dim1'];
+			$height = $dim['dim2'];
+			$type = 3;
+		} elseif ((substr($imgData, 0, 3) == GETID3_JPG_SIG) &amp;&amp; (strlen($imgData) &gt; 4)) {
+			///////////////// JPG CHUNK SCAN ////////////////////
+			$imgPos = 2;
+			$type = 2;
+			$buffer = strlen($imgData) - 2;
+			while ($imgPos &lt; strlen($imgData)) {
+				// synchronize to the marker 0xFF
+				$imgPos = strpos($imgData, 0xFF, $imgPos) + 1;
+				$marker = $imgData[$imgPos];
+				do {
+					$marker = ord($imgData[$imgPos++]);
+				} while ($marker == 255);
+				// find dimensions of block
+				switch (chr($marker)) {
+					// Grab width/height from SOF segment (these are acceptable chunk types)
+					case GETID3_JPG_SOF0:
+					case GETID3_JPG_SOF1:
+					case GETID3_JPG_SOF2:
+					case GETID3_JPG_SOF3:
+					case GETID3_JPG_SOF5:
+					case GETID3_JPG_SOF6:
+					case GETID3_JPG_SOF7:
+					case GETID3_JPG_SOF9:
+					case GETID3_JPG_SOF10:
+					case GETID3_JPG_SOF11:
+					case GETID3_JPG_SOF13:
+					case GETID3_JPG_SOF14:
+					case GETID3_JPG_SOF15:
+						$dim = unpack('n2dim', substr($imgData, $imgPos + 3, 4));
+						$height = $dim['dim1'];
+						$width  = $dim['dim2'];
+						break 2; // found it so exit
+					case GETID3_JPG_EOI:
+					case GETID3_JPG_SOS:
+						return false;       // End loop in case we find one of these markers
+					default:            // We're not interested in other markers
+						$skiplen = (ord($imgData[$imgPos++]) &lt;&lt; 8) + ord($imgData[$imgPos++]) - 2;
+						// if the skip is more than what we've read in, read more
+						$buffer -= $skiplen;
+						if ($buffer &lt; 512) { // if the buffer of data is too low, read more file.
+							// $imgData .= fread($fd, $skiplen + 1024);
+							// $buffer += $skiplen + 1024;
+							return false; // End loop in case we find run out of data
+						}
+						$imgPos += $skiplen;
+						break;
+				} // endswitch check marker type
+			} // endif loop through JPG chunks
+		} // endif chk for valid file types
+
+		return array($width, $height, $type);
+	} // end function
+
+
+	function ImageTypesLookup($imagetypeid) {
+		static $ImageTypesLookup = array();
+		if (empty($ImageTypesLookup)) {
+			$ImageTypesLookup[1]  = 'gif';
+			$ImageTypesLookup[2]  = 'jpeg';
+			$ImageTypesLookup[3]  = 'png';
+			$ImageTypesLookup[4]  = 'swf';
+			$ImageTypesLookup[5]  = 'psd';
+			$ImageTypesLookup[6]  = 'bmp';
+			$ImageTypesLookup[7]  = 'tiff (little-endian)';
+			$ImageTypesLookup[8]  = 'tiff (big-endian)';
+			$ImageTypesLookup[9]  = 'jpc';
+			$ImageTypesLookup[10] = 'jp2';
+			$ImageTypesLookup[11] = 'jpx';
+			$ImageTypesLookup[12] = 'jb2';
+			$ImageTypesLookup[13] = 'swc';
+			$ImageTypesLookup[14] = 'iff';
+		}
+		return (isset($ImageTypesLookup[$imagetypeid]) ? $ImageTypesLookup[$imagetypeid] : '');
+	}
+
+	function CopyTagsToComments(&amp;$ThisFileInfo) {
+		// Copy all entries from ['tags'] into common ['comments'] and ['comments_html']
+		if (!empty($ThisFileInfo['tags'])) {
+			foreach ($ThisFileInfo['tags'] as $tagtype =&gt; $tagarray) {
+				foreach ($tagarray as $tagname =&gt; $tagdata) {
+					foreach ($tagdata as $key =&gt; $value) {
+						if (!empty($value)) {
+							if (empty($ThisFileInfo['comments'][$tagname])) {
+
+								// fall through and append value
+
+							} elseif ($tagtype == 'id3v1') {
+
+								$newvaluelength = strlen(trim($value));
+								foreach ($ThisFileInfo['comments'][$tagname] as $existingkey =&gt; $existingvalue) {
+									$oldvaluelength = strlen(trim($existingvalue));
+									if (($newvaluelength &lt;= $oldvaluelength) &amp;&amp; (substr($existingvalue, 0, $newvaluelength) == trim($value))) {
+										// new value is identical but shorter-than (or equal-length to) one already in comments - skip
+										break 2;
+									}
+								}
+
+							} else {
+
+								$newvaluelength = strlen(trim($value));
+								foreach ($ThisFileInfo['comments'][$tagname] as $existingkey =&gt; $existingvalue) {
+									$oldvaluelength = strlen(trim($existingvalue));
+									if (($newvaluelength &gt; $oldvaluelength) &amp;&amp; (substr(trim($value), 0, strlen($existingvalue)) == $existingvalue)) {
+										$ThisFileInfo['comments'][$tagname][$existingkey] = trim($value);
+										break 2;
+									}
+								}
+
+							}
+							if (empty($ThisFileInfo['comments'][$tagname]) || !in_array(trim($value), $ThisFileInfo['comments'][$tagname])) {
+								$ThisFileInfo['comments'][$tagname][] = trim($value);
+								if (isset($ThisFileInfo['tags_html'][$tagtype][$tagname][$key])) {
+									$ThisFileInfo['comments_html'][$tagname][] = $ThisFileInfo['tags_html'][$tagtype][$tagname][$key];
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+
+	function EmbeddedLookup($key, $begin, $end, $file, $name) {
+
+		// Cached
+		static $cache;
+		if (isset($cache[$file][$name])) {
+			return @$cache[$file][$name][$key];
+		}
+
+		// Init
+		$keylength  = strlen($key);
+		$line_count = $end - $begin - 7;
+
+		// Open php file
+		$fp = fopen($file, 'r');
+
+		// Discard $begin lines
+		for ($i = 0; $i &lt; ($begin + 3); $i++) {
+			fgets($fp, 1024);
+		}
+
+		// Loop thru line
+		while (0 &lt; $line_count--) {
+
+			// Read line
+			$line = ltrim(fgets($fp, 1024), &quot;\t &quot;);
+
+			// METHOD A: only cache the matching key - less memory but slower on next lookup of not-previously-looked-up key
+			//$keycheck = substr($line, 0, $keylength);
+			//if ($key == $keycheck)  {
+			//	$cache[$file][$name][$keycheck] = substr($line, $keylength + 1);
+			//	break;
+			//}
+
+			// METHOD B: cache all keys in this lookup - more memory but faster on next lookup of not-previously-looked-up key
+			//$cache[$file][$name][substr($line, 0, $keylength)] = trim(substr($line, $keylength + 1));
+			@list($ThisKey, $ThisValue) = explode(&quot;\t&quot;, $line, 2);
+			$cache[$file][$name][$ThisKey] = trim($ThisValue);
+		}
+
+		// Close and return
+		fclose($fp);
+		return @$cache[$file][$name][$key];
+	}
+
+	function IncludeDependency($filename, $sourcefile, $DieOnFailure=false) {
+		global $GETID3_ERRORARRAY;
+
+		if (file_exists($filename)) {
+			if (@include_once($filename)) {
+				return true;
+			} else {
+				$diemessage = basename($sourcefile).' depends on '.$filename.', which has errors';
+			}
+		} else {
+			$diemessage = basename($sourcefile).' depends on '.$filename.', which is missing';
+		}
+		if ($DieOnFailure) {
+			die($diemessage);
+		} else {
+			$GETID3_ERRORARRAY[] = $diemessage;
+		}
+		return false;
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/getid3.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/getid3.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/getid3.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,1281 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// Please see readme.txt for more information                  //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+// Defines
+define('GETID3_VERSION', '1.7.5-200512251515');
+define('GETID3_FREAD_BUFFER_SIZE', 16384); // read buffer size in bytes
+
+
+
+class getID3
+{
+	// public: Settings
+	var $encoding                 = 'ISO-8859-1';     // CASE SENSITIVE! - i.e. (must be supported by iconv())
+	                                                  // Examples:  ISO-8859-1  UTF-8  UTF-16  UTF-16BE
+
+	var $encoding_id3v1           = 'ISO-8859-1';     // Should always be 'ISO-8859-1', but some tags may be written
+	                                                  // in other encodings such as 'EUC-CN'
+
+	// public: Optional tag checks - disable for speed.
+	var $option_tag_id3v1         = true;             // Read and process ID3v1 tags
+	var $option_tag_id3v2         = true;             // Read and process ID3v2 tags
+	var $option_tag_lyrics3       = true;             // Read and process Lyrics3 tags
+	var $option_tag_apetag        = true;             // Read and process APE tags
+	var $option_tags_process      = true;             // Copy tags to root key 'tags' and encode to $this-&gt;encoding
+	var $option_tags_html         = true;             // Copy tags to root key 'tags_html' properly translated from various encodings to HTML entities
+
+	// public: Optional tag/comment calucations
+	var $option_extra_info        = true;             // Calculate additional info such as bitrate, channelmode etc
+
+	// public: Optional calculations
+	var $option_md5_data          = false;            // Get MD5 sum of data part - slow
+	var $option_md5_data_source   = false;            // Use MD5 of source file if availble - only FLAC and OptimFROG
+	var $option_sha1_data         = false;            // Get SHA1 sum of data part - slow
+	var $option_max_2gb_check     = true;             // Check whether file is larger than 2 Gb and thus not supported by PHP
+
+	// private
+	var $filename;
+
+
+	// public: constructor
+	function getID3()
+	{
+
+		$this-&gt;startup_error   = '';
+		$this-&gt;startup_warning = '';
+
+		// Check for PHP version &gt;= 4.1.0
+		if (phpversion() &lt; '4.1.0') {
+		    $this-&gt;startup_error .= 'getID3() requires PHP v4.1.0 or higher - you are running v'.phpversion();
+		}
+
+		// Check memory
+		$memory_limit = ini_get('memory_limit');
+		if (eregi('([0-9]+)M', $memory_limit, $matches)) {
+			// could be stored as &quot;16M&quot; rather than 16777216 for example
+			$memory_limit = $matches[1] * 1048576;
+		}
+		if ($memory_limit &lt;= 0) {
+			// memory limits probably disabled
+		} elseif ($memory_limit &lt;= 3145728) {
+	    	$this-&gt;startup_error .= 'PHP has less than 3MB available memory and will very likely run out. Increase memory_limit in php.ini';
+		} elseif ($memory_limit &lt;= 12582912) {
+	    	$this-&gt;startup_warning .= 'PHP has less than 12MB available memory and might run out if all modules are loaded. Increase memory_limit in php.ini';
+		}
+
+		// Check safe_mode off
+		if ((bool) ini_get('safe_mode')) {
+		    $this-&gt;warning('WARNING: Safe mode is on, shorten support disabled, md5data/sha1data for ogg vorbis disabled, ogg vorbos/flac tag writing disabled.');
+		}
+
+
+		// define a constant rather than looking up every time it is needed
+		if (!defined('GETID3_OS_ISWINDOWS')) {
+			if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') {
+				define('GETID3_OS_ISWINDOWS', true);
+			} else {
+				define('GETID3_OS_ISWINDOWS', false);
+			}
+		}
+
+		// Get base path of getID3() - ONCE
+		if (!defined('GETID3_INCLUDEPATH')) {
+			define('GETID3_OS_DIRSLASH', (GETID3_OS_ISWINDOWS ? '\\' : '/'));
+
+			foreach (get_included_files() as $key =&gt; $val) {
+				if (basename($val) == 'getid3.php') {
+					define('GETID3_INCLUDEPATH', dirname($val).GETID3_OS_DIRSLASH);
+					break;
+				}
+			}
+		}
+
+		// Load support library
+		if (!include_once(GETID3_INCLUDEPATH.'getid3.lib.php')) {
+			$this-&gt;startup_error .= 'getid3.lib.php is missing or corrupt';
+		}
+
+
+		// Needed for Windows only:
+		// Define locations of helper applications for Shorten, VorbisComment, MetaFLAC
+		//   as well as other helper functions such as head, tail, md5sum, etc
+		// IMPORTANT: This path cannot have spaces in it. If neccesary, use the 8dot3 equivalent
+		//   ie for &quot;C:/Program Files/Apache/&quot; put &quot;C:/PROGRA~1/APACHE/&quot;
+		// IMPORTANT: This path must include the trailing slash
+		if (GETID3_OS_ISWINDOWS &amp;&amp; !defined('GETID3_HELPERAPPSDIR')) {
+			$helperappsdir = GETID3_INCLUDEPATH.'..'.GETID3_OS_DIRSLASH.'helperapps'; // must not have any space in this path
+
+			if (!is_dir($helperappsdir)) {
+
+				$this-&gt;startup_error .= '&quot;'.$helperappsdir.'&quot; cannot be defined as GETID3_HELPERAPPSDIR because it does not exist';
+
+			} elseif (strpos(realpath($helperappsdir), ' ') !== false) {
+
+				$DirPieces = explode(GETID3_OS_DIRSLASH, realpath($helperappsdir));
+				$DirPieces8 = $DirPieces;
+				
+				$CLIdir = $DirPieces[0].' &amp;&amp; cd \\';
+				for ($i = 1; $i &lt; count($DirPieces); $i++) {
+				  if (strpos($DirPieces[$i], ' ') === false) {
+				    $CLIdir .= ' &amp;&amp; cd '.$DirPieces[$i];
+				  } else {
+				    ob_start();
+				    system($CLIdir.' &amp;&amp; dir /ad /x');
+				    $subdirsraw = explode(&quot;\n&quot;, ob_get_contents());
+				    ob_end_clean();
+				    foreach ($subdirsraw as $line) {
+				      if (eregi('^[0-9]{4}/[0-9]{2}/[0-9]{2}  [0-9]{2}:[0-9]{2} [AP]M    &lt;DIR&gt;          ([^ ]{8})     '.preg_quote($DirPieces[$i]).'$', trim($line), $matches)) {
+				        $CLIdir .= ' &amp;&amp; cd '.$matches[1];
+				        break;
+				      }
+				    }
+				    $DirPieces8[$i] = $matches[1];
+				  }
+				}
+				$helperappsdir = implode(GETID3_OS_DIRSLASH, $DirPieces8);
+
+			}
+			define('GETID3_HELPERAPPSDIR', realpath($helperappsdir).GETID3_OS_DIRSLASH);
+
+		}
+
+	}
+
+
+
+	// public: analyze file - replaces GetAllFileInfo() and GetTagOnly()
+	function analyze($filename) {
+
+		if (!empty($this-&gt;startup_error)) {
+			return $this-&gt;error($this-&gt;startup_error);
+		}
+		if (!empty($this-&gt;startup_warning)) {
+			$this-&gt;warning($this-&gt;startup_warning);
+		}
+
+		// init result array and set parameters
+		$this-&gt;info = array();
+		$this-&gt;info['GETID3_VERSION'] = GETID3_VERSION;
+
+		// Check encoding/iconv support
+		if (!function_exists('iconv') &amp;&amp; !in_array($this-&gt;encoding, array('ISO-8859-1', 'UTF-8', 'UTF-16LE', 'UTF-16BE', 'UTF-16'))) {
+			$errormessage = 'iconv() support is needed for encodings other than ISO-8859-1, UTF-8, UTF-16LE, UTF16-BE, UTF-16. ';
+			if (GETID3_OS_ISWINDOWS) {
+				$errormessage .= 'PHP does not have iconv() support. Please enable php_iconv.dll in php.ini, and copy iconv.dll from c:/php/dlls to c:/windows/system32';
+			} else {
+				$errormessage .= 'PHP is not compiled with iconv() support. Please recompile with the --with-iconv switch';
+			}
+	    	return $this-&gt;error($errormessage);
+		}
+
+		// Disable magic_quotes_runtime, if neccesary
+		$old_magic_quotes_runtime = get_magic_quotes_runtime(); // store current setting of magic_quotes_runtime
+		if ($old_magic_quotes_runtime) {
+			set_magic_quotes_runtime(0);                        // turn off magic_quotes_runtime
+			if (get_magic_quotes_runtime()) {
+				return $this-&gt;error('Could not disable magic_quotes_runtime - getID3() cannot work properly with this setting enabled');
+			}
+		}
+
+		// remote files not supported
+		if (preg_match('/^(ht|f)tp:\/\//', $filename)) {
+			return $this-&gt;error('Remote files are not supported in this version of getID3() - please copy the file locally first');
+		}
+
+		// open local file
+		if (!$fp = @fopen($filename, 'rb')) {
+			return $this-&gt;error('Could not open file &quot;'.$filename.'&quot;');
+		}
+
+		// set parameters
+		$this-&gt;info['filesize'] = filesize($filename);
+
+		// option_max_2gb_check
+		if ($this-&gt;option_max_2gb_check) {
+			// PHP doesn't support integers larger than 31-bit (~2GB)
+			// filesize() simply returns (filesize % (pow(2, 32)), no matter the actual filesize
+			// ftell() returns 0 if seeking to the end is beyond the range of unsigned integer
+			fseek($fp, 0, SEEK_END);
+			if ((($this-&gt;info['filesize'] != 0) &amp;&amp; (ftell($fp) == 0)) ||
+				($this-&gt;info['filesize'] &lt; 0) ||
+				(ftell($fp) &lt; 0)) {
+					unset($this-&gt;info['filesize']);
+					fclose($fp);
+					return $this-&gt;error('File is most likely larger than 2GB and is not supported by PHP');
+			}
+		}
+
+		// set more parameters
+		$this-&gt;info['avdataoffset']        = 0;
+		$this-&gt;info['avdataend']           = $this-&gt;info['filesize'];
+		$this-&gt;info['fileformat']          = '';                // filled in later
+		$this-&gt;info['audio']['dataformat'] = '';                // filled in later, unset if not used
+		$this-&gt;info['video']['dataformat'] = '';                // filled in later, unset if not used
+		$this-&gt;info['tags']                = array();           // filled in later, unset if not used
+		$this-&gt;info['error']               = array();           // filled in later, unset if not used
+		$this-&gt;info['warning']             = array();           // filled in later, unset if not used
+		$this-&gt;info['comments']            = array();           // filled in later, unset if not used
+		$this-&gt;info['encoding']            = $this-&gt;encoding;   // required by id3v2 and iso modules - can be unset at the end if desired
+
+		// set redundant parameters - might be needed in some include file
+		$this-&gt;info['filename']            = basename($filename);
+		$this-&gt;info['filepath']            = str_replace('\\', '/', realpath(dirname($filename)));
+		$this-&gt;info['filenamepath']        = $this-&gt;info['filepath'].'/'.$this-&gt;info['filename'];
+
+
+		// handle ID3v2 tag - done first - already at beginning of file
+		// ID3v2 detection (even if not parsing) is always done otherwise fileformat is much harder to detect
+		if ($this-&gt;option_tag_id3v2) {
+
+			$GETID3_ERRORARRAY = &amp;$this-&gt;info['warning'];
+			if (getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v2.php', __FILE__, false)) {
+				$tag = new getid3_id3v2($fp, $this-&gt;info);
+			}
+
+		} else {
+
+			fseek($fp, 0, SEEK_SET);
+			$header = fread($fp, 10);
+			if (substr($header, 0, 3) == 'ID3') {
+				$this-&gt;info['id3v2']['header']           = true;
+				$this-&gt;info['id3v2']['majorversion']     = ord($header{3});
+				$this-&gt;info['id3v2']['minorversion']     = ord($header{4});
+				$this-&gt;info['id3v2']['headerlength']     = getid3_lib::BigEndian2Int(substr($header, 6, 4), 1) + 10; // length of ID3v2 tag in 10-byte header doesn't include 10-byte header length
+
+				$this-&gt;info['id3v2']['tag_offset_start'] = 0;
+				$this-&gt;info['id3v2']['tag_offset_end']   = $this-&gt;info['id3v2']['tag_offset_start'] + $this-&gt;info['id3v2']['headerlength'];
+				$this-&gt;info['avdataoffset']              = $this-&gt;info['id3v2']['tag_offset_end'];
+			}
+
+		}
+
+
+		// handle ID3v1 tag
+		if ($this-&gt;option_tag_id3v1) {
+			if (!@include_once(GETID3_INCLUDEPATH.'module.tag.id3v1.php')) {
+				return $this-&gt;error('module.tag.id3v1.php is missing - you may disable option_tag_id3v1.');
+			}
+			$tag = new getid3_id3v1($fp, $this-&gt;info);
+		}
+
+		// handle APE tag
+		if ($this-&gt;option_tag_apetag) {
+			if (!@include_once(GETID3_INCLUDEPATH.'module.tag.apetag.php')) {
+				return $this-&gt;error('module.tag.apetag.php is missing - you may disable option_tag_apetag.');
+			}
+			$tag = new getid3_apetag($fp, $this-&gt;info);
+		}
+
+		// handle lyrics3 tag
+		if ($this-&gt;option_tag_lyrics3) {
+			if (!@include_once(GETID3_INCLUDEPATH.'module.tag.lyrics3.php')) {
+				return $this-&gt;error('module.tag.lyrics3.php is missing - you may disable option_tag_lyrics3.');
+			}
+			$tag = new getid3_lyrics3($fp, $this-&gt;info);
+		}
+
+		// read 32 kb file data
+		fseek($fp, $this-&gt;info['avdataoffset'], SEEK_SET);
+		$formattest = fread($fp, 32774);
+
+		// determine format
+		$determined_format = $this-&gt;GetFileFormat($formattest, $filename);
+
+		// unable to determine file format
+		if (!$determined_format) {
+			fclose($fp);
+			return $this-&gt;error('unable to determine file format');
+		}
+
+		// check for illegal ID3 tags
+		if (isset($determined_format['fail_id3']) &amp;&amp; (in_array('id3v1', $this-&gt;info['tags']) || in_array('id3v2', $this-&gt;info['tags']))) {
+			if ($determined_format['fail_id3'] === 'ERROR') {
+				fclose($fp);
+				return $this-&gt;error('ID3 tags not allowed on this file type.');
+			} elseif ($determined_format['fail_id3'] === 'WARNING') {
+				$this-&gt;info['warning'][] = 'ID3 tags not allowed on this file type.';
+			}
+		}
+
+		// check for illegal APE tags
+		if (isset($determined_format['fail_ape']) &amp;&amp; in_array('ape', $this-&gt;info['tags'])) {
+			if ($determined_format['fail_ape'] === 'ERROR') {
+				fclose($fp);
+				return $this-&gt;error('APE tags not allowed on this file type.');
+			} elseif ($determined_format['fail_ape'] === 'WARNING') {
+				$this-&gt;info['warning'][] = 'APE tags not allowed on this file type.';
+			}
+		}
+
+		// set mime type
+		$this-&gt;info['mime_type'] = $determined_format['mime_type'];
+
+		// supported format signature pattern detected, but module deleted
+		if (!file_exists(GETID3_INCLUDEPATH.$determined_format['include'])) {
+			fclose($fp);
+			return $this-&gt;error('Format not supported, module, '.$determined_format['include'].', was removed.');
+		}
+
+		// module requires iconv support
+        if (!function_exists('iconv') &amp;&amp; @$determined_format['iconv_req']) {
+		    return $this-&gt;error('iconv support is required for this module ('.$determined_format['include'].').');
+		}
+
+		// include module
+		include_once(GETID3_INCLUDEPATH.$determined_format['include']);
+
+		// instantiate module class
+		$class_name = 'getid3_'.$determined_format['module'];
+		if (!class_exists($class_name)) {
+			return $this-&gt;error('Format not supported, module, '.$determined_format['include'].', is corrupt.');
+		}
+		if (isset($determined_format['option'])) {
+			$class = new $class_name($fp, $this-&gt;info, $determined_format['option']);
+		} else {
+			$class = new $class_name($fp, $this-&gt;info);
+		}
+
+		// close file
+		fclose($fp);
+
+		// process all tags - copy to 'tags' and convert charsets
+		if ($this-&gt;option_tags_process) {
+			$this-&gt;HandleAllTags();
+		}
+
+		// perform more calculations
+		if ($this-&gt;option_extra_info) {
+			$this-&gt;ChannelsBitratePlaytimeCalculations();
+			$this-&gt;CalculateCompressionRatioVideo();
+			$this-&gt;CalculateCompressionRatioAudio();
+			$this-&gt;CalculateReplayGain();
+			$this-&gt;ProcessAudioStreams();
+		}
+
+		// get the MD5 sum of the audio/video portion of the file - without ID3/APE/Lyrics3/etc header/footer tags
+		if ($this-&gt;option_md5_data) {
+			// do not cald md5_data if md5_data_source is present - set by flac only - future MPC/SV8 too
+			if (!$this-&gt;option_md5_data_source || empty($this-&gt;info['md5_data_source'])) {
+				$this-&gt;getHashdata('md5');
+			}
+		}
+
+		// get the SHA1 sum of the audio/video portion of the file - without ID3/APE/Lyrics3/etc header/footer tags
+		if ($this-&gt;option_sha1_data) {
+			$this-&gt;getHashdata('sha1');
+		}
+
+		// remove undesired keys
+		$this-&gt;CleanUp();
+
+		// restore magic_quotes_runtime setting
+		set_magic_quotes_runtime($old_magic_quotes_runtime);
+
+		// return info array
+		return $this-&gt;info;
+	}
+
+
+	// private: error handling
+	function error($message) {
+
+		$this-&gt;CleanUp();
+
+		$this-&gt;info['error'][] = $message;
+		return $this-&gt;info;
+	}
+
+
+	// private: warning handling
+	function warning($message) {
+		$this-&gt;info['warning'][] = $message;
+		return true;
+	}
+
+
+	// private: CleanUp
+	function CleanUp() {
+
+		// remove possible empty keys
+		$AVpossibleEmptyKeys = array('dataformat', 'bits_per_sample', 'encoder_options', 'streams');
+		foreach ($AVpossibleEmptyKeys as $key) {
+			if (empty($this-&gt;info['audio'][$key]) &amp;&amp; isset($this-&gt;info['audio'][$key])) {
+				unset($this-&gt;info['audio'][$key]);
+			}
+			if (empty($this-&gt;info['video'][$key]) &amp;&amp; isset($this-&gt;info['video'][$key])) {
+				unset($this-&gt;info['video'][$key]);
+			}
+		}
+
+		// remove empty root keys
+		if (!empty($this-&gt;info)) {
+			foreach ($this-&gt;info as $key =&gt; $value) {
+				if (empty($this-&gt;info[$key]) &amp;&amp; ($this-&gt;info[$key] !== 0) &amp;&amp; ($this-&gt;info[$key] !== '0')) {
+					unset($this-&gt;info[$key]);
+				}
+			}
+		}
+
+		// remove meaningless entries from unknown-format files
+		if (empty($this-&gt;info['fileformat'])) {
+			if (isset($this-&gt;info['avdataoffset'])) {
+				unset($this-&gt;info['avdataoffset']);
+			}
+			if (isset($this-&gt;info['avdataend'])) {
+				unset($this-&gt;info['avdataend']);
+			}
+		}
+	}
+
+
+	// return array containing information about all supported formats
+	function GetFileFormatArray() {
+		static $format_info = array();
+		if (empty($format_info)) {
+			$format_info = array(
+
+				// Audio formats
+
+				// AC-3   - audio      - Dolby AC-3 / Dolby Digital
+				'ac3'  =&gt; array(
+							'pattern'   =&gt; '^\x0B\x77',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'ac3',
+							'mime_type' =&gt; 'audio/ac3',
+						),
+
+				// AAC  - audio       - Advanced Audio Coding (AAC) - ADIF format
+				'adif' =&gt; array(
+							'pattern'   =&gt; '^ADIF',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'aac',
+							'option'    =&gt; 'adif',
+							'mime_type' =&gt; 'application/octet-stream',
+							'fail_ape'  =&gt; 'WARNING',
+						),
+
+
+				// AAC  - audio       - Advanced Audio Coding (AAC) - ADTS format (very similar to MP3)
+				'adts' =&gt; array(
+							'pattern'   =&gt; '^\xFF[\xF0-\xF1\xF8-\xF9]',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'aac',
+							'option'    =&gt; 'adts',
+							'mime_type' =&gt; 'application/octet-stream',
+							'fail_ape'  =&gt; 'WARNING',
+						),
+
+
+				// AU   - audio       - NeXT/Sun AUdio (AU)
+				'au'   =&gt; array(
+							'pattern'   =&gt; '^\.snd',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'au',
+							'mime_type' =&gt; 'audio/basic',
+						),
+
+				// AVR  - audio       - Audio Visual Research
+				'avr'  =&gt; array(
+							'pattern'   =&gt; '^2BIT',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'avr',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// BONK - audio       - Bonk v0.9+
+				'bonk' =&gt; array(
+							'pattern'   =&gt; '^\x00(BONK|INFO|META| ID3)',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'bonk',
+							'mime_type' =&gt; 'audio/xmms-bonk',
+						),
+
+				// FLAC - audio       - Free Lossless Audio Codec
+				'flac' =&gt; array(
+							'pattern'   =&gt; '^fLaC',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'flac',
+							'mime_type' =&gt; 'audio/x-flac',
+						),
+
+				// LA   - audio       - Lossless Audio (LA)
+				'la'   =&gt; array(
+							'pattern'   =&gt; '^LA0[2-4]',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'la',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// LPAC - audio       - Lossless Predictive Audio Compression (LPAC)
+				'lpac' =&gt; array(
+							'pattern'   =&gt; '^LPAC',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'lpac',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// MIDI - audio       - MIDI (Musical Instrument Digital Interface)
+				'midi' =&gt; array(
+							'pattern'   =&gt; '^MThd',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'midi',
+							'mime_type' =&gt; 'audio/midi',
+						),
+
+				// MAC  - audio       - Monkey's Audio Compressor
+				'mac'  =&gt; array(
+							'pattern'   =&gt; '^MAC ',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'monkey',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// MOD  - audio       - MODule (assorted sub-formats)
+				'mod'  =&gt; array(
+							'pattern'   =&gt; '^.{1080}(M.K.|[5-9]CHN|[1-3][0-9]CH)',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'mod',
+							'option'    =&gt; 'mod',
+							'mime_type' =&gt; 'audio/mod',
+						),
+
+				// MOD  - audio       - MODule (Impulse Tracker)
+				'it'   =&gt; array(
+							'pattern'   =&gt; '^IMPM',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'mod',
+							'option'    =&gt; 'it',
+							'mime_type' =&gt; 'audio/it',
+						),
+
+				// MOD  - audio       - MODule (eXtended Module, various sub-formats)
+				'xm'   =&gt; array(
+							'pattern'   =&gt; '^Extended Module',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'mod',
+							'option'    =&gt; 'xm',
+							'mime_type' =&gt; 'audio/xm',
+						),
+
+				// MOD  - audio       - MODule (ScreamTracker)
+				's3m'  =&gt; array(
+							'pattern'   =&gt; '^.{44}SCRM',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'mod',
+							'option'    =&gt; 's3m',
+							'mime_type' =&gt; 'audio/s3m',
+						),
+
+				// MPC  - audio       - Musepack / MPEGplus
+				'mpc'  =&gt; array(
+							'pattern'   =&gt; '^(MP\+|[\x00\x01\x10\x11\x40\x41\x50\x51\x80\x81\x90\x91\xC0\xC1\xD0\xD1][\x20-37][\x00\x20\x40\x60\x80\xA0\xC0\xE0])',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'mpc',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// MP3  - audio       - MPEG-audio Layer 3 (very similar to AAC-ADTS)
+				'mp3'  =&gt; array(
+							'pattern'   =&gt; '^\xFF[\xE2-\xE7\xF2-\xF7\xFA-\xFF][\x00-\xEB]',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'mp3',
+							'mime_type' =&gt; 'audio/mpeg',
+						),
+
+				// OFR  - audio       - OptimFROG
+				'ofr'  =&gt; array(
+							'pattern'   =&gt; '^(\*RIFF|OFR)',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'optimfrog',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// RKAU - audio       - RKive AUdio compressor
+				'rkau' =&gt; array(
+							'pattern'   =&gt; '^RKA',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'rkau',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// SHN  - audio       - Shorten
+				'shn'  =&gt; array(
+							'pattern'   =&gt; '^ajkg',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'shorten',
+							'mime_type' =&gt; 'audio/xmms-shn',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+				// TTA  - audio       - TTA Lossless Audio Compressor (<A HREF="http://tta.corecodec.org">http://tta.corecodec.org</A>)
+				'tta'  =&gt; array(
+							'pattern'   =&gt; '^TTA',  // could also be '^TTA(\x01|\x02|\x03|2|1)'
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'tta',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// VOC  - audio       - Creative Voice (VOC)
+				'voc'  =&gt; array(
+							'pattern'   =&gt; '^Creative Voice File',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'voc',
+							'mime_type' =&gt; 'audio/voc',
+						),
+
+				// VQF  - audio       - transform-domain weighted interleave Vector Quantization Format (VQF)
+				'vqf'  =&gt; array(
+							'pattern'   =&gt; '^TWIN',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'vqf',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// WV  - audio        - WavPack (v4.0+)
+				'wv'   =&gt; array(
+							'pattern'   =&gt; '^wvpk',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'wavpack',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+
+				// Audio-Video formats
+
+				// ASF  - audio/video - Advanced Streaming Format, Windows Media Video, Windows Media Audio
+				'asf'  =&gt; array(
+							'pattern'   =&gt; '^\x30\x26\xB2\x75\x8E\x66\xCF\x11\xA6\xD9\x00\xAA\x00\x62\xCE\x6C',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'asf',
+							'mime_type' =&gt; 'video/x-ms-asf',
+							'iconv_req' =&gt; false,
+						),
+
+				// BINK - audio/video - Bink / Smacker
+				'bink' =&gt; array(
+							'pattern'   =&gt; '^(BIK|SMK)',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'bink',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// FLV  - audio/video - FLash Video
+				'flv' =&gt; array(
+							'pattern'   =&gt; '^FLV\x01',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'flv',
+							'mime_type' =&gt; 'video/x-flv',
+						),
+
+				// MKAV - audio/video - Mastroka
+				'matroska' =&gt; array(
+							'pattern'   =&gt; '^\x1A\x45\xDF\xA3',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'matroska',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// MPEG - audio/video - MPEG (Moving Pictures Experts Group)
+				'mpeg' =&gt; array(
+							'pattern'   =&gt; '^\x00\x00\x01(\xBA|\xB3)',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'mpeg',
+							'mime_type' =&gt; 'video/mpeg',
+						),
+
+				// NSV  - audio/video - Nullsoft Streaming Video (NSV)
+				'nsv'  =&gt; array(
+							'pattern'   =&gt; '^NSV[sf]',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'nsv',
+							'mime_type' =&gt; 'application/octet-stream',
+						),
+
+				// Ogg  - audio/video - Ogg (Ogg-Vorbis, Ogg-FLAC, Speex, Ogg-Theora(*), Ogg-Tarkin(*))
+				'ogg'  =&gt; array(
+							'pattern'   =&gt; '^OggS',
+							'group'     =&gt; 'audio',
+							'module'    =&gt; 'ogg',
+							'mime_type' =&gt; 'application/ogg',
+							'fail_id3'  =&gt; 'WARNING',
+							'fail_ape'  =&gt; 'WARNING',
+						),
+
+				// QT   - audio/video - Quicktime
+				'quicktime' =&gt; array(
+							'pattern'   =&gt; '^.{4}(cmov|free|ftyp|mdat|moov|pnot|skip|wide)',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'quicktime',
+							'mime_type' =&gt; 'video/quicktime',
+						),
+
+				// RIFF - audio/video - Resource Interchange File Format (RIFF) / WAV / AVI / CD-audio / SDSS = renamed variant used by SmartSound QuickTracks (www.smartsound.com) / FORM = Audio Interchange File Format (AIFF)
+				'riff' =&gt; array(
+							'pattern'   =&gt; '^(RIFF|SDSS|FORM)',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'riff',
+							'mime_type' =&gt; 'audio/x-wave',
+							'fail_ape'  =&gt; 'WARNING',
+						),
+
+				// Real - audio/video - RealAudio, RealVideo
+				'real' =&gt; array(
+							'pattern'   =&gt; '^(\.RMF|.ra)',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'real',
+							'mime_type' =&gt; 'audio/x-realaudio',
+						),
+
+				// SWF - audio/video - ShockWave Flash
+				'swf' =&gt; array(
+							'pattern'   =&gt; '^(F|C)WS',
+							'group'     =&gt; 'audio-video',
+							'module'    =&gt; 'swf',
+							'mime_type' =&gt; 'application/x-shockwave-flash',
+						),
+
+
+				// Still-Image formats
+
+				// BMP  - still image - Bitmap (Windows, OS/2; uncompressed, RLE8, RLE4)
+				'bmp'  =&gt; array(
+							'pattern'   =&gt; '^BM',
+							'group'     =&gt; 'graphic',
+							'module'    =&gt; 'bmp',
+							'mime_type' =&gt; 'image/bmp',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+				// GIF  - still image - Graphics Interchange Format
+				'gif'  =&gt; array(
+							'pattern'   =&gt; '^GIF',
+							'group'     =&gt; 'graphic',
+							'module'    =&gt; 'gif',
+							'mime_type' =&gt; 'image/gif',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+				// JPEG - still image - Joint Photographic Experts Group (JPEG)
+				'jpg'  =&gt; array(
+							'pattern'   =&gt; '^\xFF\xD8\xFF',
+							'group'     =&gt; 'graphic',
+							'module'    =&gt; 'jpg',
+							'mime_type' =&gt; 'image/jpeg',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+				// PCD  - still image - Kodak Photo CD
+				'pcd'  =&gt; array(
+							'pattern'   =&gt; '^.{2048}PCD_IPI\x00',
+							'group'     =&gt; 'graphic',
+							'module'    =&gt; 'pcd',
+							'mime_type' =&gt; 'image/x-photo-cd',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+
+				// PNG  - still image - Portable Network Graphics (PNG)
+				'png'  =&gt; array(
+							'pattern'   =&gt; '^\x89\x50\x4E\x47\x0D\x0A\x1A\x0A',
+							'group'     =&gt; 'graphic',
+							'module'    =&gt; 'png',
+							'mime_type' =&gt; 'image/png',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+
+				// TIFF  - still image - Tagged Information File Format (TIFF)
+				'tiff' =&gt; array(
+							'pattern'   =&gt; '^(II\x2A\x00|MM\x00\x2A)',
+							'group'     =&gt; 'graphic',
+							'module'    =&gt; 'tiff',
+							'mime_type' =&gt; 'image/tiff',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+
+				// Data formats
+
+				// ISO  - data        - International Standards Organization (ISO) CD-ROM Image
+				'iso'  =&gt; array(
+							'pattern'   =&gt; '^.{32769}CD001',
+							'group'     =&gt; 'misc',
+							'module'    =&gt; 'iso',
+							'mime_type' =&gt; 'application/octet-stream',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+							'iconv_req' =&gt; false,
+						),
+
+				// RAR  - data        - RAR compressed data
+				'rar'  =&gt; array(
+							'pattern'   =&gt; '^Rar\!',
+							'group'     =&gt; 'archive',
+							'module'    =&gt; 'rar',
+							'mime_type' =&gt; 'application/octet-stream',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+				// SZIP - audio       - SZIP compressed data
+				'szip' =&gt; array(
+							'pattern'   =&gt; '^SZ\x0A\x04',
+							'group'     =&gt; 'archive',
+							'module'    =&gt; 'szip',
+							'mime_type' =&gt; 'application/octet-stream',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+				// TAR  - data        - TAR compressed data
+				'tar'  =&gt; array(
+							'pattern'   =&gt; '^.{100}[0-9\x20]{7}\x00[0-9\x20]{7}\x00[0-9\x20]{7}\x00[0-9\x20\x00]{12}[0-9\x20\x00]{12}',
+							'group'     =&gt; 'archive',
+							'module'    =&gt; 'tar',
+							'mime_type' =&gt; 'application/x-tar',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+				// GZIP  - data        - GZIP compressed data
+				'gz'  =&gt; array(
+							'pattern'   =&gt; '^\x1F\x8B\x08',
+							'group'     =&gt; 'archive',
+							'module'    =&gt; 'gzip',
+							'mime_type' =&gt; 'application/x-gzip',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						),
+
+				// ZIP  - data        - ZIP compressed data
+				'zip'  =&gt; array(
+							'pattern'   =&gt; '^PK\x03\x04',
+							'group'     =&gt; 'archive',
+							'module'    =&gt; 'zip',
+							'mime_type' =&gt; 'application/zip',
+							'fail_id3'  =&gt; 'ERROR',
+							'fail_ape'  =&gt; 'ERROR',
+						  )
+			);
+		}
+
+		return $format_info;
+	}
+
+
+
+	function GetFileFormat(&amp;$filedata, $filename='') {
+		// this function will determine the format of a file based on usually
+		// the first 2-4 bytes of the file (8 bytes for PNG, 16 bytes for JPG,
+		// and in the case of ISO CD image, 6 bytes offset 32kb from the start
+		// of the file).
+
+		// Identify file format - loop through $format_info and detect with reg expr
+		foreach ($this-&gt;GetFileFormatArray() as $format_name =&gt; $info) {
+			// Using preg_match() instead of ereg() - much faster
+			// The /s switch on preg_match() forces preg_match() NOT to treat
+			// newline (0x0A) characters as special chars but do a binary match
+			if (preg_match('/'.$info['pattern'].'/s', $filedata)) {
+				$info['include'] = 'module.'.$info['group'].'.'.$info['module'].'.php';
+				return $info;
+			}
+		}
+
+
+		if (preg_match('/\.mp[123a]$/i', $filename)) {
+
+			// Too many mp3 encoders on the market put gabage in front of mpeg files
+			// use assume format on these if format detection failed
+			$GetFileFormatArray = $this-&gt;GetFileFormatArray();
+			$info = $GetFileFormatArray['mp3'];
+			$info['include'] = 'module.'.$info['group'].'.'.$info['module'].'.php';
+			return $info;
+
+		//} elseif (preg_match('/\.tar$/i', $filename)) {
+        //
+		//	// TAR files don't have any useful header to work from
+		//	// TAR  - data        - TAR compressed data
+		//	$info = array(
+		//		'pattern'   =&gt; '^.{512}',
+		//		'group'     =&gt; 'archive',
+		//		'module'    =&gt; 'tar',
+		//		'mime_type' =&gt; 'application/octet-stream',
+		//		'fail_id3'  =&gt; 'ERROR',
+		//		'fail_ape'  =&gt; 'ERROR',
+		//	);
+		//	$info['include'] = 'module.'.$info['group'].'.'.$info['module'].'.php';
+		//	return $info;
+
+		}
+
+		return false;
+	}
+
+
+	// converts array to $encoding charset from $this-&gt;encoding
+	function CharConvert(&amp;$array, $encoding) {
+
+		// identical encoding - end here
+		if ($encoding == $this-&gt;encoding) {
+			return;
+		}
+
+		// loop thru array
+		foreach ($array as $key =&gt; $value) {
+
+			// go recursive
+			if (is_array($value)) {
+				$this-&gt;CharConvert($array[$key], $encoding);
+			}
+
+			// convert string
+			elseif (is_string($value)) {
+				$array[$key] = trim(getid3_lib::iconv_fallback($encoding, $this-&gt;encoding, $value));
+			}
+		}
+	}
+
+
+	function HandleAllTags() {
+
+		// key name =&gt; array (tag name, character encoding)
+		static $tags;
+		if (empty($tags)) {
+			$tags = array(
+				'asf'       =&gt; array('asf'           , 'UTF-16LE'),
+				'midi'      =&gt; array('midi'          , 'ISO-8859-1'),
+				'nsv'       =&gt; array('nsv'           , 'ISO-8859-1'),
+				'ogg'       =&gt; array('vorbiscomment' , 'UTF-8'),
+				'png'       =&gt; array('png'           , 'UTF-8'),
+				'tiff'      =&gt; array('tiff'          , 'ISO-8859-1'),
+				'quicktime' =&gt; array('quicktime'     , 'ISO-8859-1'),
+				'real'      =&gt; array('real'          , 'ISO-8859-1'),
+				'vqf'       =&gt; array('vqf'           , 'ISO-8859-1'),
+				'zip'       =&gt; array('zip'           , 'ISO-8859-1'),
+				'riff'      =&gt; array('riff'          , 'ISO-8859-1'),
+				'lyrics3'   =&gt; array('lyrics3'       , 'ISO-8859-1'),
+				'id3v1'     =&gt; array('id3v1'         , $this-&gt;encoding_id3v1),
+				'id3v2'     =&gt; array('id3v2'         , 'UTF-8'), // not according to the specs (every frame can have a different encoding), but getID3() force-converts all encodings to UTF-8
+				'ape'       =&gt; array('ape'           , 'UTF-8')
+			);
+		}
+
+		// loop thru comments array
+		foreach ($tags as $comment_name =&gt; $tagname_encoding_array) {
+			list($tag_name, $encoding) = $tagname_encoding_array;
+
+			// fill in default encoding type if not already present
+			if (isset($this-&gt;info[$comment_name]) &amp;&amp; !isset($this-&gt;info[$comment_name]['encoding'])) {
+				$this-&gt;info[$comment_name]['encoding'] = $encoding;
+			}
+
+			// copy comments if key name set
+			if (!empty($this-&gt;info[$comment_name]['comments'])) {
+
+				foreach ($this-&gt;info[$comment_name]['comments'] as $tag_key =&gt; $valuearray) {
+					foreach ($valuearray as $key =&gt; $value) {
+						if (strlen(trim($value)) &gt; 0) {
+							$this-&gt;info['tags'][trim($tag_name)][trim($tag_key)][] = $value; // do not trim!! Unicode characters will get mangled if trailing nulls are removed!
+						}
+					}
+				}
+
+				if (!isset($this-&gt;info['tags'][$tag_name])) {
+					// comments are set but contain nothing but empty strings, so skip
+					continue;
+				}
+
+				if ($this-&gt;option_tags_html) {
+					foreach ($this-&gt;info['tags'][$tag_name] as $tag_key =&gt; $valuearray) {
+						foreach ($valuearray as $key =&gt; $value) {
+							if (is_string($value)) {
+								//$this-&gt;info['tags_html'][$tag_name][$tag_key][$key] = getid3_lib::MultiByteCharString2HTML($value, $encoding);
+								$this-&gt;info['tags_html'][$tag_name][$tag_key][$key] = str_replace('&#0;', '', getid3_lib::MultiByteCharString2HTML($value, $encoding));
+							} else {
+								$this-&gt;info['tags_html'][$tag_name][$tag_key][$key] = $value;
+							}
+						}
+					}
+				}
+
+				$this-&gt;CharConvert($this-&gt;info['tags'][$tag_name], $encoding);           // only copy gets converted!
+			}
+
+		}
+		return true;
+	}
+
+
+	function getHashdata($algorithm) {
+		switch ($algorithm) {
+			case 'md5':
+			case 'sha1':
+				break;
+
+			default:
+				return $this-&gt;error('bad algorithm &quot;'.$algorithm.'&quot; in getHashdata()');
+				break;
+		}
+
+		if ((@$this-&gt;info['fileformat'] == 'ogg') &amp;&amp; (@$this-&gt;info['audio']['dataformat'] == 'vorbis')) {
+
+			// We cannot get an identical md5_data value for Ogg files where the comments
+			// span more than 1 Ogg page (compared to the same audio data with smaller
+			// comments) using the normal getID3() method of MD5'ing the data between the
+			// end of the comments and the end of the file (minus any trailing tags),
+			// because the page sequence numbers of the pages that the audio data is on
+			// do not match. Under normal circumstances, where comments are smaller than
+			// the nominal 4-8kB page size, then this is not a problem, but if there are
+			// very large comments, the only way around it is to strip off the comment
+			// tags with vorbiscomment and MD5 that file.
+			// This procedure must be applied to ALL Ogg files, not just the ones with
+			// comments larger than 1 page, because the below method simply MD5's the
+			// whole file with the comments stripped, not just the portion after the
+			// comments block (which is the standard getID3() method.
+
+			// The above-mentioned problem of comments spanning multiple pages and changing
+			// page sequence numbers likely happens for OggSpeex and OggFLAC as well, but
+			// currently vorbiscomment only works on OggVorbis files.
+
+			if ((bool) ini_get('safe_mode')) {
+
+				$this-&gt;info['warning'][] = 'Failed making system call to vorbiscomment.exe - '.$algorithm.'_data is incorrect - error returned: PHP running in Safe Mode (backtick operator not available)';
+				$this-&gt;info[$algorithm.'_data']  = false;
+
+			} else {
+
+				// Prevent user from aborting script
+				$old_abort = ignore_user_abort(true);
+
+				// Create empty file
+				$empty = tempnam('*', 'getID3');
+				touch($empty);
+
+
+				// Use vorbiscomment to make temp file without comments
+				$temp = tempnam('*', 'getID3');
+				$file = $this-&gt;info['filenamepath'];
+
+				if (GETID3_OS_ISWINDOWS) {
+
+					if (file_exists(GETID3_HELPERAPPSDIR.'vorbiscomment.exe')) {
+
+						$commandline = '&quot;'.GETID3_HELPERAPPSDIR.'vorbiscomment.exe&quot; -w -c &quot;'.$empty.'&quot; &quot;'.$file.'&quot; &quot;'.$temp.'&quot;';
+						$VorbisCommentError = `$commandline`;
+
+					} else {
+
+						$VorbisCommentError = 'vorbiscomment.exe not found in '.GETID3_HELPERAPPSDIR;
+
+					}
+
+				} else {
+
+					$commandline = 'vorbiscomment -w -c &quot;'.$empty.'&quot; &quot;'.$file.'&quot; &quot;'.$temp.'&quot; 2&gt;&amp;1';
+					$VorbisCommentError = `$commandline`;
+
+				}
+
+				if (!empty($VorbisCommentError)) {
+
+					$this-&gt;info['warning'][]         = 'Failed making system call to vorbiscomment(.exe) - '.$algorithm.'_data will be incorrect. If vorbiscomment is unavailable, please download from <A HREF="http://www.vorbis.com/download.psp">http://www.vorbis.com/download.psp</A> and put in the getID3() directory. Error returned: '.$VorbisCommentError;
+					$this-&gt;info[$algorithm.'_data']  = false;
+
+				} else {
+
+					// Get hash of newly created file
+					switch ($algorithm) {
+						case 'md5':
+							$this-&gt;info[$algorithm.'_data'] = getid3_lib::md5_file($temp);
+							break;
+
+						case 'sha1':
+							$this-&gt;info[$algorithm.'_data'] = getid3_lib::sha1_file($temp);
+							break;
+					}
+				}
+
+				// Clean up
+				unlink($empty);
+				unlink($temp);
+
+				// Reset abort setting
+				ignore_user_abort($old_abort);
+
+			}
+
+		} else {
+
+			if (!empty($this-&gt;info['avdataoffset']) || (isset($this-&gt;info['avdataend']) &amp;&amp; ($this-&gt;info['avdataend'] &lt; $this-&gt;info['filesize']))) {
+
+				// get hash from part of file
+				$this-&gt;info[$algorithm.'_data'] = getid3_lib::hash_data($this-&gt;info['filenamepath'], $this-&gt;info['avdataoffset'], $this-&gt;info['avdataend'], $algorithm);
+
+			} else {
+
+				// get hash from whole file
+				switch ($algorithm) {
+					case 'md5':
+						$this-&gt;info[$algorithm.'_data'] = getid3_lib::md5_file($this-&gt;info['filenamepath']);
+						break;
+
+					case 'sha1':
+						$this-&gt;info[$algorithm.'_data'] = getid3_lib::sha1_file($this-&gt;info['filenamepath']);
+						break;
+				}
+			}
+
+		}
+		return true;
+	}
+
+
+	function ChannelsBitratePlaytimeCalculations() {
+
+		// set channelmode on audio
+		if (@$this-&gt;info['audio']['channels'] == '1') {
+			$this-&gt;info['audio']['channelmode'] = 'mono';
+		} elseif (@$this-&gt;info['audio']['channels'] == '2') {
+			$this-&gt;info['audio']['channelmode'] = 'stereo';
+		}
+
+		// Calculate combined bitrate - audio + video
+		$CombinedBitrate  = 0;
+		$CombinedBitrate += (isset($this-&gt;info['audio']['bitrate']) ? $this-&gt;info['audio']['bitrate'] : 0);
+		$CombinedBitrate += (isset($this-&gt;info['video']['bitrate']) ? $this-&gt;info['video']['bitrate'] : 0);
+		if (($CombinedBitrate &gt; 0) &amp;&amp; empty($this-&gt;info['bitrate'])) {
+			$this-&gt;info['bitrate'] = $CombinedBitrate;
+		}
+		//if ((isset($this-&gt;info['video']) &amp;&amp; !isset($this-&gt;info['video']['bitrate'])) || (isset($this-&gt;info['audio']) &amp;&amp; !isset($this-&gt;info['audio']['bitrate']))) {
+		//	// for example, VBR MPEG video files cannot determine video bitrate:
+		//	// should not set overall bitrate and playtime from audio bitrate only
+		//	unset($this-&gt;info['bitrate']);
+		//}
+
+		if (!isset($this-&gt;info['playtime_seconds']) &amp;&amp; !empty($this-&gt;info['bitrate'])) {
+			$this-&gt;info['playtime_seconds'] = (($this-&gt;info['avdataend'] - $this-&gt;info['avdataoffset']) * 8) / $this-&gt;info['bitrate'];
+		}
+
+		// Set playtime string
+		if (!empty($this-&gt;info['playtime_seconds']) &amp;&amp; empty($this-&gt;info['playtime_string'])) {
+			$this-&gt;info['playtime_string'] = getid3_lib::PlaytimeString($this-&gt;info['playtime_seconds']);
+		}
+	}
+
+
+	function CalculateCompressionRatioVideo() {
+		if (empty($this-&gt;info['video'])) {
+			return false;
+		}
+		if (empty($this-&gt;info['video']['resolution_x']) || empty($this-&gt;info['video']['resolution_y'])) {
+			return false;
+		}
+		if (empty($this-&gt;info['video']['bits_per_sample'])) {
+			return false;
+		}
+
+		switch ($this-&gt;info['video']['dataformat']) {
+			case 'bmp':
+			case 'gif':
+			case 'jpeg':
+			case 'jpg':
+			case 'png':
+			case 'tiff':
+				$FrameRate = 1;
+				$PlaytimeSeconds = 1;
+				$BitrateCompressed = $this-&gt;info['filesize'] * 8;
+				break;
+
+			default:
+				if (!empty($this-&gt;info['video']['frame_rate'])) {
+					$FrameRate = $this-&gt;info['video']['frame_rate'];
+				} else {
+					return false;
+				}
+				if (!empty($this-&gt;info['playtime_seconds'])) {
+					$PlaytimeSeconds = $this-&gt;info['playtime_seconds'];
+				} else {
+					return false;
+				}
+				if (!empty($this-&gt;info['video']['bitrate'])) {
+					$BitrateCompressed = $this-&gt;info['video']['bitrate'];
+				} else {
+					return false;
+				}
+				break;
+		}
+		$BitrateUncompressed = $this-&gt;info['video']['resolution_x'] * $this-&gt;info['video']['resolution_y'] * $this-&gt;info['video']['bits_per_sample'] * $FrameRate;
+
+		$this-&gt;info['video']['compression_ratio'] = $BitrateCompressed / $BitrateUncompressed;
+		return true;
+	}
+
+
+	function CalculateCompressionRatioAudio() {
+		if (empty($this-&gt;info['audio']['bitrate']) || empty($this-&gt;info['audio']['channels']) || empty($this-&gt;info['audio']['sample_rate'])) {
+			return false;
+		}
+		$this-&gt;info['audio']['compression_ratio'] = $this-&gt;info['audio']['bitrate'] / ($this-&gt;info['audio']['channels'] * $this-&gt;info['audio']['sample_rate'] * (!empty($this-&gt;info['audio']['bits_per_sample']) ? $this-&gt;info['audio']['bits_per_sample'] : 16));
+
+		if (!empty($this-&gt;info['audio']['streams'])) {
+			foreach ($this-&gt;info['audio']['streams'] as $streamnumber =&gt; $streamdata) {
+				if (!empty($streamdata['bitrate']) &amp;&amp; !empty($streamdata['channels']) &amp;&amp; !empty($streamdata['sample_rate'])) {
+					$this-&gt;info['audio']['streams'][$streamnumber]['compression_ratio'] = $streamdata['bitrate'] / ($streamdata['channels'] * $streamdata['sample_rate'] * (!empty($streamdata['bits_per_sample']) ? $streamdata['bits_per_sample'] : 16));
+				}
+			}
+		}
+		return true;
+	}
+
+
+	function CalculateReplayGain() {
+		if (isset($this-&gt;info['replay_gain'])) {
+			$this-&gt;info['replay_gain']['reference_volume'] = 89;
+			if (isset($this-&gt;info['replay_gain']['track']['adjustment'])) {
+				$this-&gt;info['replay_gain']['track']['volume'] = $this-&gt;info['replay_gain']['reference_volume'] - $this-&gt;info['replay_gain']['track']['adjustment'];
+			}
+			if (isset($this-&gt;info['replay_gain']['album']['adjustment'])) {
+				$this-&gt;info['replay_gain']['album']['volume'] = $this-&gt;info['replay_gain']['reference_volume'] - $this-&gt;info['replay_gain']['album']['adjustment'];
+			}
+
+			if (isset($this-&gt;info['replay_gain']['track']['peak'])) {
+				$this-&gt;info['replay_gain']['track']['max_noclip_gain'] = 0 - getid3_lib::RGADamplitude2dB($this-&gt;info['replay_gain']['track']['peak']);
+			}
+			if (isset($this-&gt;info['replay_gain']['album']['peak'])) {
+				$this-&gt;info['replay_gain']['album']['max_noclip_gain'] = 0 - getid3_lib::RGADamplitude2dB($this-&gt;info['replay_gain']['album']['peak']);
+			}
+		}
+		return true;
+	}
+
+	function ProcessAudioStreams() {
+		if (!empty($this-&gt;info['audio']['bitrate']) || !empty($this-&gt;info['audio']['channels']) || !empty($this-&gt;info['audio']['sample_rate'])) {
+			if (!isset($this-&gt;info['audio']['streams'])) {
+				foreach ($this-&gt;info['audio'] as $key =&gt; $value) {
+					if ($key != 'streams') {
+						$this-&gt;info['audio']['streams'][0][$key] = $value;
+					}
+				}
+			}
+		}
+		return true;
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.gzip.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.gzip.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.gzip.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,254 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.archive.gzip.php                                     //
+// written by Mike Mozolin &lt;teddybear&#216;mail*ru&gt;                 //
+// module for analyzing GZIP files                             //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+class getid3_gzip {
+
+	// public: Optional file list - disable for speed.
+	var $option_gzip_parse_contents = true; // decode gzipped files, if possible, and parse recursively (.tar.gz for example)
+
+	function getid3_gzip(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat'] = 'gzip';
+		return $this-&gt;read_gzip($fd, $ThisFileInfo);
+	}
+
+	// Reads the gzip-file
+	function read_gzip($fd, &amp;$ThisFileInfo) {
+
+		$start_length = 10;
+		$unpack_header = 'a1id1/a1id2/a1cmethod/a1flags/a4mtime/a1xflags/a1os';
+		//+---+---+---+---+---+---+---+---+---+---+
+		//|ID1|ID2|CM |FLG|     MTIME     |XFL|OS |
+		//+---+---+---+---+---+---+---+---+---+---+
+		@fseek($fd, 0);
+		$buffer = @fread($fd, $ThisFileInfo['filesize']);
+
+		$arr_members = explode(&quot;\x1F\x8B\x08&quot;, $buffer);
+		while (true) {
+			$is_wrong_members = false;
+			$num_members = intval(count($arr_members));
+			for ($i = 0; $i &lt; $num_members; $i++) {
+				if (strlen($arr_members[$i]) == 0) {
+					continue;
+				}
+				$buf = &quot;\x1F\x8B\x08&quot;.$arr_members[$i];
+
+				$attr = unpack($unpack_header, substr($buf, 0, $start_length));
+				if (!$this-&gt;get_os_type(ord($attr['os']))) {
+					// Merge member with previous if wrong OS type
+					$arr_members[$i - 1] .= $buf;
+					$arr_members[$i] = '';
+					$is_wrong_members = true;
+					continue;
+				}
+			}
+			if (!$is_wrong_members) {
+				break;
+			}
+		}
+
+		$ThisFileInfo['gzip']['files'] = array();
+
+		$fpointer = 0;
+		$idx = 0;
+		for ($i = 0; $i &lt; $num_members; $i++) {
+			if (strlen($arr_members[$i]) == 0) {
+				continue;
+			}
+			$thisThisFileInfo = &amp;$ThisFileInfo['gzip']['member_header'][++$idx];
+
+			$buff = &quot;\x1F\x8B\x08&quot;.$arr_members[$i];
+
+			$attr = unpack($unpack_header, substr($buff, 0, $start_length));
+			$thisThisFileInfo['filemtime']      = getid3_lib::LittleEndian2Int($attr['mtime']);
+			$thisThisFileInfo['raw']['id1']     = ord($attr['cmethod']);
+			$thisThisFileInfo['raw']['id2']     = ord($attr['cmethod']);
+			$thisThisFileInfo['raw']['cmethod'] = ord($attr['cmethod']);
+			$thisThisFileInfo['raw']['os']      = ord($attr['os']);
+			$thisThisFileInfo['raw']['xflags']  = ord($attr['xflags']);
+			$thisThisFileInfo['raw']['flags']   = ord($attr['flags']);
+
+			$thisThisFileInfo['flags']['crc16']    = (bool) ($thisThisFileInfo['raw']['flags'] &amp; 0x02);
+			$thisThisFileInfo['flags']['extra']    = (bool) ($thisThisFileInfo['raw']['flags'] &amp; 0x04);
+			$thisThisFileInfo['flags']['filename'] = (bool) ($thisThisFileInfo['raw']['flags'] &amp; 0x08);
+			$thisThisFileInfo['flags']['comment']  = (bool) ($thisThisFileInfo['raw']['flags'] &amp; 0x10);
+
+			$thisThisFileInfo['compression'] = $this-&gt;get_xflag_type($thisThisFileInfo['raw']['xflags']);
+
+			$thisThisFileInfo['os'] = $this-&gt;get_os_type($thisThisFileInfo['raw']['os']);
+			if (!$thisThisFileInfo['os']) {
+				$ThisFileInfo['error'][] = 'Read error on gzip file';
+				return false;
+			}
+
+			$fpointer = 10;
+			$arr_xsubfield = array();
+			// bit 2 - FLG.FEXTRA
+			//+---+---+=================================+
+			//| XLEN  |...XLEN bytes of &quot;extra field&quot;...|
+			//+---+---+=================================+
+			if ($thisThisFileInfo['flags']['extra']) {
+				$w_xlen = substr($buff, $fpointer, 2);
+				$xlen = getid3_lib::LittleEndian2Int($w_xlen);
+				$fpointer += 2;
+
+				$thisThisFileInfo['raw']['xfield'] = substr($buff, $fpointer, $xlen);
+				// Extra SubFields
+				//+---+---+---+---+==================================+
+				//|SI1|SI2|  LEN  |... LEN bytes of subfield data ...|
+				//+---+---+---+---+==================================+
+				$idx = 0;
+				while (true) {
+					if ($idx &gt;= $xlen) {
+						break;
+					}
+					$si1 = ord(substr($buff, $fpointer + $idx++, 1));
+					$si2 = ord(substr($buff, $fpointer + $idx++, 1));
+					if (($si1 == 0x41) &amp;&amp; ($si2 == 0x70)) {
+						$w_xsublen = substr($buff, $fpointer+$idx, 2);
+						$xsublen = getid3_lib::LittleEndian2Int($w_xsublen);
+						$idx += 2;
+						$arr_xsubfield[] = substr($buff, $fpointer+$idx, $xsublen);
+						$idx += $xsublen;
+					} else {
+						break;
+					}
+				}
+				$fpointer += $xlen;
+			}
+			// bit 3 - FLG.FNAME
+			//+=========================================+
+			//|...original file name, zero-terminated...|
+			//+=========================================+
+			// GZIP files may have only one file, with no filename, so assume original filename is current filename without .gz
+			$thisThisFileInfo['filename'] = eregi_replace('.gz$', '', $ThisFileInfo['filename']);
+			if ($thisThisFileInfo['flags']['filename']) {
+				while (true) {
+					if (ord($buff[$fpointer]) == 0) {
+						$fpointer++;
+						break;
+					}
+					$thisThisFileInfo['filename'] .= $buff[$fpointer];
+					$fpointer++;
+				}
+			}
+			// bit 4 - FLG.FCOMMENT
+			//+===================================+
+			//|...file comment, zero-terminated...|
+			//+===================================+
+			if ($thisThisFileInfo['flags']['comment']) {
+				while (true) {
+					if (ord($buff[$fpointer]) == 0) {
+						$fpointer++;
+						break;
+					}
+					$thisThisFileInfo['comment'] .= $buff[$fpointer];
+					$fpointer++;
+				}
+			}
+			// bit 1 - FLG.FHCRC
+			//+---+---+
+			//| CRC16 |
+			//+---+---+
+			if ($thisThisFileInfo['flags']['crc16']) {
+				$w_crc = substr($buff, $fpointer, 2);
+				$thisThisFileInfo['crc16'] = getid3_lib::LittleEndian2Int($w_crc);
+				$fpointer += 2;
+			}
+			// bit 0 - FLG.FTEXT
+			//if ($thisThisFileInfo['raw']['flags'] &amp; 0x01) {
+			//	Ignored...
+			//}
+			// bits 5, 6, 7 - reserved
+
+			$thisThisFileInfo['crc32']    = getid3_lib::LittleEndian2Int(substr($buff, strlen($buff) - 8, 4));
+			$thisThisFileInfo['filesize'] = getid3_lib::LittleEndian2Int(substr($buff, strlen($buff) - 4));
+
+			$ThisFileInfo['gzip']['files'] = getid3_lib::array_merge_clobber($ThisFileInfo['gzip']['files'], getid3_lib::CreateDeepArray($thisThisFileInfo['filename'], '/', $thisThisFileInfo['filesize']));
+
+			if ($this-&gt;option_gzip_parse_contents) {
+				// Try to inflate GZip
+				$csize = 0;
+				$inflated = '';
+				$chkcrc32 = '';
+				if (function_exists('gzinflate')) {
+					$cdata = substr($buff, $fpointer);
+					$cdata = substr($cdata, 0, strlen($cdata) - 8);
+					$csize = strlen($cdata);
+					$inflated = gzinflate($cdata);
+
+					// Calculate CRC32 for inflated content
+					$thisThisFileInfo['crc32_valid'] = (bool) (sprintf('%u', crc32($inflated)) == $thisThisFileInfo['crc32']);
+
+					// determine format
+					$formattest = substr($inflated, 0, 32774);
+					$newgetID3 = new getID3();
+					$determined_format = $newgetID3-&gt;GetFileFormat($formattest);
+					unset($newgetID3);
+
+	        		// file format is determined
+	        		switch (@$determined_format['module']) {
+	        			case 'tar':
+							// view TAR-file info
+							if (file_exists(GETID3_INCLUDEPATH.$determined_format['include']) &amp;&amp; @include_once(GETID3_INCLUDEPATH.$determined_format['include'])) {
+								getid3_tar::read_tar($inflated, $ThisFileInfo['gzip']['member_header'][$idx]);
+							}
+							break;
+
+	        			case '':
+	        			default:
+	        				// unknown or unhandled format
+	        				break;
+					}
+				}
+			}
+		}
+		return true;
+	}
+
+	// Converts the OS type
+	function get_os_type($key) {
+		static $os_type = array(
+			'0'   =&gt; 'FAT filesystem (MS-DOS, OS/2, NT/Win32)',
+			'1'   =&gt; 'Amiga',
+			'2'   =&gt; 'VMS (or OpenVMS)',
+			'3'   =&gt; 'Unix',
+			'4'   =&gt; 'VM/CMS',
+			'5'   =&gt; 'Atari TOS',
+			'6'   =&gt; 'HPFS filesystem (OS/2, NT)',
+			'7'   =&gt; 'Macintosh',
+			'8'   =&gt; 'Z-System',
+			'9'   =&gt; 'CP/M',
+			'10'  =&gt; 'TOPS-20',
+			'11'  =&gt; 'NTFS filesystem (NT)',
+			'12'  =&gt; 'QDOS',
+			'13'  =&gt; 'Acorn RISCOS',
+			'255' =&gt; 'unknown'
+		);
+		return @$os_type[$key];
+	}
+
+	// Converts the eXtra FLags
+	function get_xflag_type($key) {
+		static $xflag_type = array(
+			'0' =&gt; 'unknown',
+			'2' =&gt; 'maximum compression',
+			'4' =&gt; 'fastest algorithm'
+		);
+		return @$xflag_type[$key];
+	}
+}
+
+?&gt;

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.rar.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.rar.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.rar.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,32 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.archive.rar.php                                      //
+// module for analyzing RAR files                              //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_rar
+{
+
+	function getid3_rar(&amp;$fd, &amp;$ThisFileInfo) {
+
+		$ThisFileInfo['fileformat'] = 'rar';
+
+		$ThisFileInfo['error'][] = 'RAR parsing not enabled in this version of getID3()';
+		return false;
+
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.szip.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.szip.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.szip.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,97 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.archive.szip.php                                     //
+// module for analyzing SZIP compressed files                  //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_szip
+{
+
+	function getid3_szip(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$SZIPHeader = fread($fd, 6);
+		if (substr($SZIPHeader, 0, 4) != 'SZ'.&quot;\x0A\x04&quot;) {
+			$ThisFileInfo['error'][] = 'Expecting &quot;SZ[x0A][x04]&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.substr($SZIPHeader, 0, 4).'&quot;';
+			return false;
+		}
+
+		$ThisFileInfo['fileformat']            = 'szip';
+
+		$ThisFileInfo['szip']['major_version'] = getid3_lib::BigEndian2Int(substr($SZIPHeader, 4, 1));
+		$ThisFileInfo['szip']['minor_version'] = getid3_lib::BigEndian2Int(substr($SZIPHeader, 5, 1));
+
+		while (!feof($fd)) {
+			$NextBlockID = fread($fd, 2);
+			switch ($NextBlockID) {
+				case 'SZ':
+					// Note that szip files can be concatenated, this has the same effect as
+					// concatenating the files. this also means that global header blocks
+					// might be present between directory/data blocks.
+					fseek($fd, 4, SEEK_CUR);
+					break;
+
+				case 'BH':
+					$BHheaderbytes  = getid3_lib::BigEndian2Int(fread($fd, 3));
+					$BHheaderdata   = fread($fd, $BHheaderbytes);
+					$BHheaderoffset = 0;
+					while (strpos($BHheaderdata, &quot;\x00&quot;, $BHheaderoffset) &gt; 0) {
+						//filename as \0 terminated string  (empty string indicates end)
+						//owner as \0 terminated string (empty is same as last file)
+						//group as \0 terminated string (empty is same as last file)
+						//3 byte filelength in this block
+						//2 byte access flags
+						//4 byte creation time (like in unix)
+						//4 byte modification time (like in unix)
+						//4 byte access time (like in unix)
+
+						$BHdataArray['filename'] = substr($BHheaderdata, $BHheaderoffset, strcspn($BHheaderdata, &quot;\x00&quot;));
+						$BHheaderoffset += (strlen($BHdataArray['filename']) + 1);
+
+						$BHdataArray['owner'] = substr($BHheaderdata, $BHheaderoffset, strcspn($BHheaderdata, &quot;\x00&quot;));
+						$BHheaderoffset += (strlen($BHdataArray['owner']) + 1);
+
+						$BHdataArray['group'] = substr($BHheaderdata, $BHheaderoffset, strcspn($BHheaderdata, &quot;\x00&quot;));
+						$BHheaderoffset += (strlen($BHdataArray['group']) + 1);
+
+						$BHdataArray['filelength'] = getid3_lib::BigEndian2Int(substr($BHheaderdata, $BHheaderoffset, 3));
+						$BHheaderoffset += 3;
+
+						$BHdataArray['access_flags'] = getid3_lib::BigEndian2Int(substr($BHheaderdata, $BHheaderoffset, 2));
+						$BHheaderoffset += 2;
+
+						$BHdataArray['creation_time'] = getid3_lib::BigEndian2Int(substr($BHheaderdata, $BHheaderoffset, 4));
+						$BHheaderoffset += 4;
+
+						$BHdataArray['modification_time'] = getid3_lib::BigEndian2Int(substr($BHheaderdata, $BHheaderoffset, 4));
+						$BHheaderoffset += 4;
+
+						$BHdataArray['access_time'] = getid3_lib::BigEndian2Int(substr($BHheaderdata, $BHheaderoffset, 4));
+						$BHheaderoffset += 4;
+
+						$ThisFileInfo['szip']['BH'][] = $BHdataArray;
+					}
+					break;
+
+				default:
+					break 2;
+			}
+		}
+
+		return true;
+
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.tar.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.tar.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.tar.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,181 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.archive.tar.php                                      //
+// written by Mike Mozolin &lt;teddybear&#216;mail*ru&gt;                 //
+// module for analyzing TAR files                              //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+class getid3_tar {
+
+	function getid3_tar(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat'] = 'tar';
+
+		@fseek($fd, 0);
+		$filebuffer = @fread($fd, $ThisFileInfo['filesize']);
+		return $this-&gt;read_tar($filebuffer, $ThisFileInfo);
+	}
+
+	// Reads the tar-file
+	function read_tar(&amp;$filebuffer, &amp;$ThisFileInfo) {
+
+		$header_length = 512;
+		$unpack_header = 'a100fname/a8mode/a8uid/a8gid/a12size/a12mtime/a8chksum/a1typflag/a100lnkname/a6magic/a2ver/a32uname/a32gname/a8devmaj/a8devmin/a155/prefix';
+
+		$null_512k = str_repeat(&quot;\0&quot;, 512); // end-of-file marker
+
+		$ThisFileInfo['tar']['files'] = array();
+
+		while(strlen($filebuffer) != 0) {
+			$buffer = substr($filebuffer, 0, $header_length);
+			$filebuffer = substr($filebuffer, strlen($buffer));
+			// check the block
+			$checksum = 0;
+			for ($i = 0; $i &lt; 148; $i++) {
+				$checksum += ord(substr($buffer, $i, 1));
+			}
+			for ($i = 148; $i &lt; 156; $i++) {
+				$checksum += ord(' ');
+			}
+			for ($i = 156; $i &lt; 512; $i++) {
+				$checksum += ord(substr($buffer, $i, 1));
+			}
+			$attr    = unpack($unpack_header, $buffer);
+			$name    =        trim(@$attr['fname']);
+			$mode    = octdec(trim(@$attr['mode']));
+			$uid     = octdec(trim(@$attr['uid']));
+			$gid     = octdec(trim(@$attr['gid']));
+			$size    = octdec(trim(@$attr['size']));
+			$mtime   = octdec(trim(@$attr['mtime']));
+			$chksum  = octdec(trim(@$attr['chksum']));
+			$typflag =        trim(@$attr['typflag']);
+			$lnkname =        trim(@$attr['lnkname']);
+			$magic   =        trim(@$attr['magic']);
+			$ver     =        trim(@$attr['ver']);
+			$uname   =        trim(@$attr['uname']);
+			$gname   =        trim(@$attr['gname']);
+			$devmaj  = octdec(trim(@$attr['devmaj']));
+			$devmin  = octdec(trim(@$attr['devmin']));
+			$prefix  =        trim(@$attr['prefix']);
+			// EOF Found
+			if (($checksum == 256) &amp;&amp; ($chksum == 0)) {
+				break;
+			}
+			if ($prefix) {
+				$name = $prefix.'/'.$name;
+			}
+			if ((preg_match('#/$#', $name)) &amp;&amp; !$name) {
+				$typeflag = 5;
+			}
+			// If it's the end of the tar-file...
+			if ($buffer == $null_512k) {
+				break;
+			}
+			// Read the next chunk
+			$data = substr($filebuffer, 0, $size);
+			$filebuffer = substr($filebuffer, strlen($data));
+			if (strlen($data) != $size) {
+				$ThisFileInfo['error'][] = 'Read error on tar file';
+				return false;
+			}
+			$diff = $size % 512;
+			if ($diff != 0) {
+				// Padding, throw away
+				$buff = substr($filebuffer, 0, (512 - $diff));
+				$filebuffer = substr($filebuffer, strlen($buff));
+			}
+			// Protect against tar-files with garbage at the end
+			if ($name == '') {
+				break;
+			}
+			$ThisFileInfo['tar']['file_details'][$name] = array (
+				'name'     =&gt; $name,
+				'mode_raw' =&gt; $mode,
+				'mode'     =&gt; getid3_tar::display_perms($mode),
+				'uid'      =&gt; $uid,
+				'gid'      =&gt; $gid,
+				'size'     =&gt; $size,
+				'mtime'    =&gt; $mtime,
+				'chksum'   =&gt; $chksum,
+				'typeflag' =&gt; getid3_tar::get_flag_type($typflag),
+				'linkname' =&gt; $lnkname,
+				'magic'    =&gt; $magic,
+				'version'  =&gt; $ver,
+				'uname'    =&gt; $uname,
+				'gname'    =&gt; $gname,
+				'devmajor' =&gt; $devmaj,
+				'devminor' =&gt; $devmin
+			);
+			$ThisFileInfo['tar']['files'] = getid3_lib::array_merge_clobber($ThisFileInfo['tar']['files'], getid3_lib::CreateDeepArray($ThisFileInfo['tar']['file_details'][$name]['name'], '/', $size));
+		}
+		return true;
+	}
+
+	// Parses the file mode to file permissions
+	function display_perms($mode) {
+		// Determine Type
+		if ($mode &amp; 0x1000)     $type='p'; // FIFO pipe
+		elseif ($mode &amp; 0x2000) $type='c'; // Character special
+		elseif ($mode &amp; 0x4000) $type='d'; // Directory
+		elseif ($mode &amp; 0x6000) $type='b'; // Block special
+		elseif ($mode &amp; 0x8000) $type='-'; // Regular
+		elseif ($mode &amp; 0xA000) $type='l'; // Symbolic Link
+		elseif ($mode &amp; 0xC000) $type='s'; // Socket
+		else                    $type='u'; // UNKNOWN
+
+		// Determine permissions
+		$owner['read']    = (($mode &amp; 00400) ? 'r' : '-');
+		$owner['write']   = (($mode &amp; 00200) ? 'w' : '-');
+		$owner['execute'] = (($mode &amp; 00100) ? 'x' : '-');
+		$group['read']    = (($mode &amp; 00040) ? 'r' : '-');
+		$group['write']   = (($mode &amp; 00020) ? 'w' : '-');
+		$group['execute'] = (($mode &amp; 00010) ? 'x' : '-');
+		$world['read']    = (($mode &amp; 00004) ? 'r' : '-');
+		$world['write']   = (($mode &amp; 00002) ? 'w' : '-');
+		$world['execute'] = (($mode &amp; 00001) ? 'x' : '-');
+
+		// Adjust for SUID, SGID and sticky bit
+		if ($mode &amp; 0x800) $owner['execute'] = ($owner['execute'] == 'x') ? 's' : 'S';
+		if ($mode &amp; 0x400) $group['execute'] = ($group['execute'] == 'x') ? 's' : 'S';
+		if ($mode &amp; 0x200) $world['execute'] = ($world['execute'] == 'x') ? 't' : 'T';
+
+		$s  = sprintf('%1s', $type);
+		$s .= sprintf('%1s%1s%1s',      $owner['read'], $owner['write'], $owner['execute']);
+		$s .= sprintf('%1s%1s%1s',      $group['read'], $group['write'], $group['execute']);
+		$s .= sprintf('%1s%1s%1s'.&quot;\n&quot;, $world['read'], $world['write'], $world['execute']);
+		return $s;
+	}
+
+	// Converts the file type
+	function get_flag_type($typflag) {
+		static $flag_types = array(
+			'0' =&gt; 'LF_NORMAL',
+			'1' =&gt; 'LF_LINK',
+			'2' =&gt; 'LF_SYNLINK',
+			'3' =&gt; 'LF_CHR',
+			'4' =&gt; 'LF_BLK',
+			'5' =&gt; 'LF_DIR',
+			'6' =&gt; 'LF_FIFO',
+			'7' =&gt; 'LF_CONFIG',
+			'D' =&gt; 'LF_DUMPDIR',
+			'K' =&gt; 'LF_LONGLINK',
+			'L' =&gt; 'LF_LONGNAME',
+			'M' =&gt; 'LF_MULTIVOL',
+			'N' =&gt; 'LF_NAMES',
+			'S' =&gt; 'LF_SPARSE',
+			'V' =&gt; 'LF_VOLHDR'
+		);
+		return @$flag_types[$typflag];
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.zip.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.zip.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.archive.zip.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,415 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.archive.zip.php                                      //
+// module for analyzing pkZip files                            //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_zip
+{
+
+	function getid3_zip(&amp;$fd, &amp;$ThisFileInfo) {
+
+		$ThisFileInfo['fileformat']      = 'zip';
+		$ThisFileInfo['zip']['encoding'] = 'ISO-8859-1';
+		$ThisFileInfo['zip']['files']    = array();
+
+		$ThisFileInfo['zip']['compressed_size']   = 0;
+		$ThisFileInfo['zip']['uncompressed_size'] = 0;
+		$ThisFileInfo['zip']['entries_count']     = 0;
+
+		$EOCDsearchData    = '';
+		$EOCDsearchCounter = 0;
+		while ($EOCDsearchCounter++ &lt; 512) {
+
+			fseek($fd, -128 * $EOCDsearchCounter, SEEK_END);
+			$EOCDsearchData = fread($fd, 128).$EOCDsearchData;
+
+			if (strstr($EOCDsearchData, 'PK'.&quot;\x05\x06&quot;)) {
+
+				$EOCDposition = strpos($EOCDsearchData, 'PK'.&quot;\x05\x06&quot;);
+				fseek($fd, (-128 * $EOCDsearchCounter) + $EOCDposition, SEEK_END);
+				$ThisFileInfo['zip']['end_central_directory'] = $this-&gt;ZIPparseEndOfCentralDirectory($fd);
+
+				fseek($fd, $ThisFileInfo['zip']['end_central_directory']['directory_offset'], SEEK_SET);
+				$ThisFileInfo['zip']['entries_count'] = 0;
+				while ($centraldirectoryentry = $this-&gt;ZIPparseCentralDirectory($fd)) {
+					$ThisFileInfo['zip']['central_directory'][] = $centraldirectoryentry;
+					$ThisFileInfo['zip']['entries_count']++;
+					$ThisFileInfo['zip']['compressed_size']   += $centraldirectoryentry['compressed_size'];
+					$ThisFileInfo['zip']['uncompressed_size'] += $centraldirectoryentry['uncompressed_size'];
+
+					if ($centraldirectoryentry['uncompressed_size'] &gt; 0) {
+						$ThisFileInfo['zip']['files'] = getid3_lib::array_merge_clobber($ThisFileInfo['zip']['files'], getid3_lib::CreateDeepArray($centraldirectoryentry['filename'], '/', $centraldirectoryentry['uncompressed_size']));
+					}
+				}
+
+				if ($ThisFileInfo['zip']['entries_count'] == 0) {
+					$ThisFileInfo['error'][] = 'No Central Directory entries found (truncated file?)';
+					return false;
+				}
+
+				if (!empty($ThisFileInfo['zip']['end_central_directory']['comment'])) {
+					$ThisFileInfo['zip']['comments']['comment'][] = $ThisFileInfo['zip']['end_central_directory']['comment'];
+				}
+
+				if (isset($ThisFileInfo['zip']['central_directory'][0]['compression_method'])) {
+					$ThisFileInfo['zip']['compression_method'] = $ThisFileInfo['zip']['central_directory'][0]['compression_method'];
+				}
+				if (isset($ThisFileInfo['zip']['central_directory'][0]['flags']['compression_speed'])) {
+					$ThisFileInfo['zip']['compression_speed']  = $ThisFileInfo['zip']['central_directory'][0]['flags']['compression_speed'];
+				}
+				if (isset($ThisFileInfo['zip']['compression_method']) &amp;&amp; ($ThisFileInfo['zip']['compression_method'] == 'store') &amp;&amp; !isset($ThisFileInfo['zip']['compression_speed'])) {
+					$ThisFileInfo['zip']['compression_speed']  = 'store';
+				}
+
+				return true;
+
+			}
+
+		}
+
+		if ($this-&gt;getZIPentriesFilepointer($fd, $ThisFileInfo)) {
+
+			// central directory couldn't be found and/or parsed
+			// scan through actual file data entries, recover as much as possible from probable trucated file
+			if ($ThisFileInfo['zip']['compressed_size'] &gt; ($ThisFileInfo['filesize'] - 46 - 22)) {
+				$ThisFileInfo['error'][] = 'Warning: Truncated file! - Total compressed file sizes ('.$ThisFileInfo['zip']['compressed_size'].' bytes) is greater than filesize minus Central Directory and End Of Central Directory structures ('.($ThisFileInfo['filesize'] - 46 - 22).' bytes)';
+			}
+			$ThisFileInfo['error'][] = 'Cannot find End Of Central Directory - returned list of files in [zip][entries] array may not be complete';
+			foreach ($ThisFileInfo['zip']['entries'] as $key =&gt; $valuearray) {
+				$ThisFileInfo['zip']['files'][$valuearray['filename']] = $valuearray['uncompressed_size'];
+			}
+			return true;
+
+		} else {
+
+			unset($ThisFileInfo['zip']);
+			$ThisFileInfo['fileformat'] = '';
+			$ThisFileInfo['error'][] = 'Cannot find End Of Central Directory (truncated file?)';
+			return false;
+
+		}
+	}
+
+
+	function getZIPHeaderFilepointerTopDown(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat'] = 'zip';
+
+		$ThisFileInfo['zip']['compressed_size']   = 0;
+		$ThisFileInfo['zip']['uncompressed_size'] = 0;
+		$ThisFileInfo['zip']['entries_count']     = 0;
+
+		rewind($fd);
+		while ($fileentry = $this-&gt;ZIPparseLocalFileHeader($fd)) {
+			$ThisFileInfo['zip']['entries'][] = $fileentry;
+			$ThisFileInfo['zip']['entries_count']++;
+		}
+		if ($ThisFileInfo['zip']['entries_count'] == 0) {
+			$ThisFileInfo['error'][] = 'No Local File Header entries found';
+			return false;
+		}
+
+		$ThisFileInfo['zip']['entries_count']     = 0;
+		while ($centraldirectoryentry = $this-&gt;ZIPparseCentralDirectory($fd)) {
+			$ThisFileInfo['zip']['central_directory'][] = $centraldirectoryentry;
+			$ThisFileInfo['zip']['entries_count']++;
+			$ThisFileInfo['zip']['compressed_size']   += $centraldirectoryentry['compressed_size'];
+			$ThisFileInfo['zip']['uncompressed_size'] += $centraldirectoryentry['uncompressed_size'];
+		}
+		if ($ThisFileInfo['zip']['entries_count'] == 0) {
+			$ThisFileInfo['error'][] = 'No Central Directory entries found (truncated file?)';
+			return false;
+		}
+
+		if ($EOCD = $this-&gt;ZIPparseEndOfCentralDirectory($fd)) {
+			$ThisFileInfo['zip']['end_central_directory'] = $EOCD;
+		} else {
+			$ThisFileInfo['error'][] = 'No End Of Central Directory entry found (truncated file?)';
+			return false;
+		}
+
+		if (!empty($ThisFileInfo['zip']['end_central_directory']['comment'])) {
+			$ThisFileInfo['zip']['comments']['comment'][] = $ThisFileInfo['zip']['end_central_directory']['comment'];
+		}
+
+		return true;
+	}
+
+
+	function getZIPentriesFilepointer(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['zip']['compressed_size']   = 0;
+		$ThisFileInfo['zip']['uncompressed_size'] = 0;
+		$ThisFileInfo['zip']['entries_count']     = 0;
+
+		rewind($fd);
+		while ($fileentry = $this-&gt;ZIPparseLocalFileHeader($fd)) {
+			$ThisFileInfo['zip']['entries'][] = $fileentry;
+			$ThisFileInfo['zip']['entries_count']++;
+			$ThisFileInfo['zip']['compressed_size']   += $fileentry['compressed_size'];
+			$ThisFileInfo['zip']['uncompressed_size'] += $fileentry['uncompressed_size'];
+		}
+		if ($ThisFileInfo['zip']['entries_count'] == 0) {
+			$ThisFileInfo['error'][] = 'No Local File Header entries found';
+			return false;
+		}
+
+		return true;
+	}
+
+
+	function ZIPparseLocalFileHeader(&amp;$fd) {
+		$LocalFileHeader['offset'] = ftell($fd);
+
+		$ZIPlocalFileHeader = fread($fd, 30);
+
+		$LocalFileHeader['raw']['signature']          = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader,  0, 4));
+		if ($LocalFileHeader['raw']['signature'] != 0x04034B50) {
+			// invalid Local File Header Signature
+			fseek($fd, $LocalFileHeader['offset'], SEEK_SET); // seek back to where filepointer originally was so it can be handled properly
+			return false;
+		}
+		$LocalFileHeader['raw']['extract_version']    = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader,  4, 2));
+		$LocalFileHeader['raw']['general_flags']      = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader,  6, 2));
+		$LocalFileHeader['raw']['compression_method'] = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader,  8, 2));
+		$LocalFileHeader['raw']['last_mod_file_time'] = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader, 10, 2));
+		$LocalFileHeader['raw']['last_mod_file_date'] = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader, 12, 2));
+		$LocalFileHeader['raw']['crc_32']             = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader, 14, 4));
+		$LocalFileHeader['raw']['compressed_size']    = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader, 18, 4));
+		$LocalFileHeader['raw']['uncompressed_size']  = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader, 22, 4));
+		$LocalFileHeader['raw']['filename_length']    = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader, 26, 2));
+		$LocalFileHeader['raw']['extra_field_length'] = getid3_lib::LittleEndian2Int(substr($ZIPlocalFileHeader, 28, 2));
+
+		$LocalFileHeader['extract_version']           = sprintf('%1.1f', $LocalFileHeader['raw']['extract_version'] / 10);
+		$LocalFileHeader['host_os']                   = $this-&gt;ZIPversionOSLookup(($LocalFileHeader['raw']['extract_version'] &amp; 0xFF00) &gt;&gt; 8);
+		$LocalFileHeader['compression_method']        = $this-&gt;ZIPcompressionMethodLookup($LocalFileHeader['raw']['compression_method']);
+		$LocalFileHeader['compressed_size']           = $LocalFileHeader['raw']['compressed_size'];
+		$LocalFileHeader['uncompressed_size']         = $LocalFileHeader['raw']['uncompressed_size'];
+		$LocalFileHeader['flags']                     = $this-&gt;ZIPparseGeneralPurposeFlags($LocalFileHeader['raw']['general_flags'], $LocalFileHeader['raw']['compression_method']);
+		$LocalFileHeader['last_modified_timestamp']   = $this-&gt;DOStime2UNIXtime($LocalFileHeader['raw']['last_mod_file_date'], $LocalFileHeader['raw']['last_mod_file_time']);
+
+		$FilenameExtrafieldLength = $LocalFileHeader['raw']['filename_length'] + $LocalFileHeader['raw']['extra_field_length'];
+		if ($FilenameExtrafieldLength &gt; 0) {
+			$ZIPlocalFileHeader .= fread($fd, $FilenameExtrafieldLength);
+
+			if ($LocalFileHeader['raw']['filename_length'] &gt; 0) {
+				$LocalFileHeader['filename']                = substr($ZIPlocalFileHeader, 30, $LocalFileHeader['raw']['filename_length']);
+			}
+			if ($LocalFileHeader['raw']['extra_field_length'] &gt; 0) {
+				$LocalFileHeader['raw']['extra_field_data'] = substr($ZIPlocalFileHeader, 30 + $LocalFileHeader['raw']['filename_length'], $LocalFileHeader['raw']['extra_field_length']);
+			}
+		}
+
+		$LocalFileHeader['data_offset'] = ftell($fd);
+		//$LocalFileHeader['compressed_data'] = fread($fd, $LocalFileHeader['raw']['compressed_size']);
+		fseek($fd, $LocalFileHeader['raw']['compressed_size'], SEEK_CUR);
+
+		if ($LocalFileHeader['flags']['data_descriptor_used']) {
+			$DataDescriptor = fread($fd, 12);
+			$LocalFileHeader['data_descriptor']['crc_32']            = getid3_lib::LittleEndian2Int(substr($DataDescriptor,  0, 4));
+			$LocalFileHeader['data_descriptor']['compressed_size']   = getid3_lib::LittleEndian2Int(substr($DataDescriptor,  4, 4));
+			$LocalFileHeader['data_descriptor']['uncompressed_size'] = getid3_lib::LittleEndian2Int(substr($DataDescriptor,  8, 4));
+		}
+
+		return $LocalFileHeader;
+	}
+
+
+	function ZIPparseCentralDirectory(&amp;$fd) {
+		$CentralDirectory['offset'] = ftell($fd);
+
+		$ZIPcentralDirectory = fread($fd, 46);
+
+		$CentralDirectory['raw']['signature']            = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory,  0, 4));
+		if ($CentralDirectory['raw']['signature'] != 0x02014B50) {
+			// invalid Central Directory Signature
+			fseek($fd, $CentralDirectory['offset'], SEEK_SET); // seek back to where filepointer originally was so it can be handled properly
+			return false;
+		}
+		$CentralDirectory['raw']['create_version']       = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory,  4, 2));
+		$CentralDirectory['raw']['extract_version']      = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory,  6, 2));
+		$CentralDirectory['raw']['general_flags']        = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory,  8, 2));
+		$CentralDirectory['raw']['compression_method']   = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 10, 2));
+		$CentralDirectory['raw']['last_mod_file_time']   = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 12, 2));
+		$CentralDirectory['raw']['last_mod_file_date']   = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 14, 2));
+		$CentralDirectory['raw']['crc_32']               = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 16, 4));
+		$CentralDirectory['raw']['compressed_size']      = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 20, 4));
+		$CentralDirectory['raw']['uncompressed_size']    = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 24, 4));
+		$CentralDirectory['raw']['filename_length']      = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 28, 2));
+		$CentralDirectory['raw']['extra_field_length']   = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 30, 2));
+		$CentralDirectory['raw']['file_comment_length']  = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 32, 2));
+		$CentralDirectory['raw']['disk_number_start']    = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 34, 2));
+		$CentralDirectory['raw']['internal_file_attrib'] = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 36, 2));
+		$CentralDirectory['raw']['external_file_attrib'] = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 38, 4));
+		$CentralDirectory['raw']['local_header_offset']  = getid3_lib::LittleEndian2Int(substr($ZIPcentralDirectory, 42, 4));
+
+		$CentralDirectory['entry_offset']              = $CentralDirectory['raw']['local_header_offset'];
+		$CentralDirectory['create_version']            = sprintf('%1.1f', $CentralDirectory['raw']['create_version'] / 10);
+		$CentralDirectory['extract_version']           = sprintf('%1.1f', $CentralDirectory['raw']['extract_version'] / 10);
+		$CentralDirectory['host_os']                   = $this-&gt;ZIPversionOSLookup(($CentralDirectory['raw']['extract_version'] &amp; 0xFF00) &gt;&gt; 8);
+		$CentralDirectory['compression_method']        = $this-&gt;ZIPcompressionMethodLookup($CentralDirectory['raw']['compression_method']);
+		$CentralDirectory['compressed_size']           = $CentralDirectory['raw']['compressed_size'];
+		$CentralDirectory['uncompressed_size']         = $CentralDirectory['raw']['uncompressed_size'];
+		$CentralDirectory['flags']                     = $this-&gt;ZIPparseGeneralPurposeFlags($CentralDirectory['raw']['general_flags'], $CentralDirectory['raw']['compression_method']);
+		$CentralDirectory['last_modified_timestamp']   = $this-&gt;DOStime2UNIXtime($CentralDirectory['raw']['last_mod_file_date'], $CentralDirectory['raw']['last_mod_file_time']);
+
+		$FilenameExtrafieldCommentLength = $CentralDirectory['raw']['filename_length'] + $CentralDirectory['raw']['extra_field_length'] + $CentralDirectory['raw']['file_comment_length'];
+		if ($FilenameExtrafieldCommentLength &gt; 0) {
+			$FilenameExtrafieldComment = fread($fd, $FilenameExtrafieldCommentLength);
+
+			if ($CentralDirectory['raw']['filename_length'] &gt; 0) {
+				$CentralDirectory['filename']                  = substr($FilenameExtrafieldComment, 0, $CentralDirectory['raw']['filename_length']);
+			}
+			if ($CentralDirectory['raw']['extra_field_length'] &gt; 0) {
+				$CentralDirectory['raw']['extra_field_data']   = substr($FilenameExtrafieldComment, $CentralDirectory['raw']['filename_length'], $CentralDirectory['raw']['extra_field_length']);
+			}
+			if ($CentralDirectory['raw']['file_comment_length'] &gt; 0) {
+				$CentralDirectory['file_comment']              = substr($FilenameExtrafieldComment, $CentralDirectory['raw']['filename_length'] + $CentralDirectory['raw']['extra_field_length'], $CentralDirectory['raw']['file_comment_length']);
+			}
+		}
+
+		return $CentralDirectory;
+	}
+
+	function ZIPparseEndOfCentralDirectory(&amp;$fd) {
+		$EndOfCentralDirectory['offset'] = ftell($fd);
+
+		$ZIPendOfCentralDirectory = fread($fd, 22);
+
+		$EndOfCentralDirectory['signature']                   = getid3_lib::LittleEndian2Int(substr($ZIPendOfCentralDirectory,  0, 4));
+		if ($EndOfCentralDirectory['signature'] != 0x06054B50) {
+			// invalid End Of Central Directory Signature
+			fseek($fd, $EndOfCentralDirectory['offset'], SEEK_SET); // seek back to where filepointer originally was so it can be handled properly
+			return false;
+		}
+		$EndOfCentralDirectory['disk_number_current']         = getid3_lib::LittleEndian2Int(substr($ZIPendOfCentralDirectory,  4, 2));
+		$EndOfCentralDirectory['disk_number_start_directory'] = getid3_lib::LittleEndian2Int(substr($ZIPendOfCentralDirectory,  6, 2));
+		$EndOfCentralDirectory['directory_entries_this_disk'] = getid3_lib::LittleEndian2Int(substr($ZIPendOfCentralDirectory,  8, 2));
+		$EndOfCentralDirectory['directory_entries_total']     = getid3_lib::LittleEndian2Int(substr($ZIPendOfCentralDirectory, 10, 2));
+		$EndOfCentralDirectory['directory_size']              = getid3_lib::LittleEndian2Int(substr($ZIPendOfCentralDirectory, 12, 4));
+		$EndOfCentralDirectory['directory_offset']            = getid3_lib::LittleEndian2Int(substr($ZIPendOfCentralDirectory, 16, 4));
+		$EndOfCentralDirectory['comment_length']              = getid3_lib::LittleEndian2Int(substr($ZIPendOfCentralDirectory, 20, 2));
+
+		if ($EndOfCentralDirectory['comment_length'] &gt; 0) {
+			$EndOfCentralDirectory['comment']                 = fread($fd, $EndOfCentralDirectory['comment_length']);
+		}
+
+		return $EndOfCentralDirectory;
+	}
+
+
+	function ZIPparseGeneralPurposeFlags($flagbytes, $compressionmethod) {
+		$ParsedFlags['encrypted'] = (bool) ($flagbytes &amp; 0x0001);
+
+		switch ($compressionmethod) {
+			case 6:
+				$ParsedFlags['dictionary_size']    = (($flagbytes &amp; 0x0002) ? 8192 : 4096);
+				$ParsedFlags['shannon_fano_trees'] = (($flagbytes &amp; 0x0004) ? 3    : 2);
+				break;
+
+			case 8:
+			case 9:
+				switch (($flagbytes &amp; 0x0006) &gt;&gt; 1) {
+					case 0:
+						$ParsedFlags['compression_speed'] = 'normal';
+						break;
+					case 1:
+						$ParsedFlags['compression_speed'] = 'maximum';
+						break;
+					case 2:
+						$ParsedFlags['compression_speed'] = 'fast';
+						break;
+					case 3:
+						$ParsedFlags['compression_speed'] = 'superfast';
+						break;
+				}
+				break;
+		}
+		$ParsedFlags['data_descriptor_used']       = (bool) ($flagbytes &amp; 0x0008);
+
+		return $ParsedFlags;
+	}
+
+
+	function ZIPversionOSLookup($index) {
+		static $ZIPversionOSLookup = array(
+			0  =&gt; 'MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)',
+			1  =&gt; 'Amiga',
+			2  =&gt; 'OpenVMS',
+			3  =&gt; 'Unix',
+			4  =&gt; 'VM/CMS',
+			5  =&gt; 'Atari ST',
+			6  =&gt; 'OS/2 H.P.F.S.',
+			7  =&gt; 'Macintosh',
+			8  =&gt; 'Z-System',
+			9  =&gt; 'CP/M',
+			10 =&gt; 'Windows NTFS',
+			11 =&gt; 'MVS',
+			12 =&gt; 'VSE',
+			13 =&gt; 'Acorn Risc',
+			14 =&gt; 'VFAT',
+			15 =&gt; 'Alternate MVS',
+			16 =&gt; 'BeOS',
+			17 =&gt; 'Tandem'
+		);
+
+		return (isset($ZIPversionOSLookup[$index]) ? $ZIPversionOSLookup[$index] : '[unknown]');
+	}
+
+	function ZIPcompressionMethodLookup($index) {
+		static $ZIPcompressionMethodLookup = array(
+			0  =&gt; 'store',
+			1  =&gt; 'shrink',
+			2  =&gt; 'reduce-1',
+			3  =&gt; 'reduce-2',
+			4  =&gt; 'reduce-3',
+			5  =&gt; 'reduce-4',
+			6  =&gt; 'implode',
+			7  =&gt; 'tokenize',
+			8  =&gt; 'deflate',
+			9  =&gt; 'deflate64',
+			10 =&gt; 'PKWARE Date Compression Library Imploding'
+		);
+
+		return (isset($ZIPcompressionMethodLookup[$index]) ? $ZIPcompressionMethodLookup[$index] : '[unknown]');
+	}
+
+	function DOStime2UNIXtime($DOSdate, $DOStime) {
+		// wFatDate
+		// Specifies the MS-DOS date. The date is a packed 16-bit value with the following format:
+		// Bits      Contents
+		// 0-4    Day of the month (1-31)
+		// 5-8    Month (1 = January, 2 = February, and so on)
+		// 9-15   Year offset from 1980 (add 1980 to get actual year)
+
+		$UNIXday    =  ($DOSdate &amp; 0x001F);
+		$UNIXmonth  = (($DOSdate &amp; 0x01E0) &gt;&gt; 5);
+		$UNIXyear   = (($DOSdate &amp; 0xFE00) &gt;&gt; 9) + 1980;
+
+		// wFatTime
+		// Specifies the MS-DOS time. The time is a packed 16-bit value with the following format:
+		// Bits   Contents
+		// 0-4    Second divided by 2
+		// 5-10   Minute (0-59)
+		// 11-15  Hour (0-23 on a 24-hour clock)
+
+		$UNIXsecond =  ($DOStime &amp; 0x001F) * 2;
+		$UNIXminute = (($DOStime &amp; 0x07E0) &gt;&gt; 5);
+		$UNIXhour   = (($DOStime &amp; 0xF800) &gt;&gt; 11);
+
+		return mktime($UNIXhour, $UNIXminute, $UNIXsecond, $UNIXmonth, $UNIXday, $UNIXyear);
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.asf.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.asf.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.asf.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,1598 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio-video.asf.php                                  //
+// module for analyzing ASF, WMA and WMV files                 //
+// dependencies: module.audio-video.riff.php                   //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.riff.php', __FILE__, true);
+
+$GUIDarray = getid3_asf::KnownGUIDs();
+foreach ($GUIDarray as $GUIDname =&gt; $hexstringvalue) {
+	// initialize all GUID constants
+	define($GUIDname, getid3_asf::GUIDtoBytestring($hexstringvalue));
+}
+
+
+
+class getid3_asf
+{
+
+	function getid3_asf(&amp;$fd, &amp;$ThisFileInfo) {
+
+		// Shortcuts
+		$thisfile_audio = &amp;$ThisFileInfo['audio'];
+		$thisfile_video = &amp;$ThisFileInfo['video'];
+		$ThisFileInfo['asf'] = array();
+		$thisfile_asf        = &amp;$ThisFileInfo['asf'];
+		$thisfile_asf['comments'] = array();
+		$thisfile_asf_comments    = &amp;$thisfile_asf['comments'];
+		$thisfile_asf['header_object'] = array();
+		$thisfile_asf_headerobject     = &amp;$thisfile_asf['header_object'];
+
+
+		// ASF structure:
+		// * Header Object [required]
+		//   * File Properties Object [required]   (global file attributes)
+		//   * Stream Properties Object [required] (defines media stream &amp; characteristics)
+		//   * Header Extension Object [required]  (additional functionality)
+		//   * Content Description Object          (bibliographic information)
+		//   * Script Command Object               (commands for during playback)
+		//   * Marker Object                       (named jumped points within the file)
+		// * Data Object [required]
+		//   * Data Packets
+		// * Index Object
+
+		// Header Object: (mandatory, one only)
+		// Field Name                   Field Type   Size (bits)
+		// Object ID                    GUID         128             // GUID for header object - GETID3_ASF_Header_Object
+		// Object Size                  QWORD        64              // size of header object, including 30 bytes of Header Object header
+		// Number of Header Objects     DWORD        32              // number of objects in header object
+		// Reserved1                    BYTE         8               // hardcoded: 0x01
+		// Reserved2                    BYTE         8               // hardcoded: 0x02
+
+		$ThisFileInfo['fileformat'] = 'asf';
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$HeaderObjectData = fread($fd, 30);
+
+		$thisfile_asf_headerobject['objectid']      = substr($HeaderObjectData, 0, 16);
+		$thisfile_asf_headerobject['objectid_guid'] = $this-&gt;BytestringToGUID($thisfile_asf_headerobject['objectid']);
+		if ($thisfile_asf_headerobject['objectid'] != GETID3_ASF_Header_Object) {
+			$ThisFileInfo['warning'][] = 'ASF header GUID {'.$this-&gt;BytestringToGUID($thisfile_asf_headerobject['objectid']).'} does not match expected &quot;GETID3_ASF_Header_Object&quot; GUID {'.$this-&gt;BytestringToGUID(GETID3_ASF_Header_Object).'}';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['asf']);
+			return false;
+			break;
+		}
+		$thisfile_asf_headerobject['objectsize']    = getid3_lib::LittleEndian2Int(substr($HeaderObjectData, 16, 8));
+		$thisfile_asf_headerobject['headerobjects'] = getid3_lib::LittleEndian2Int(substr($HeaderObjectData, 24, 4));
+		$thisfile_asf_headerobject['reserved1']     = getid3_lib::LittleEndian2Int(substr($HeaderObjectData, 28, 1));
+		$thisfile_asf_headerobject['reserved2']     = getid3_lib::LittleEndian2Int(substr($HeaderObjectData, 29, 1));
+
+		//$ASFHeaderData  = $HeaderObjectData;
+		$ASFHeaderData = fread($fd, $thisfile_asf_headerobject['objectsize'] - 30);
+		//$offset = 30;
+		$offset = 0;
+
+		for ($HeaderObjectsCounter = 0; $HeaderObjectsCounter &lt; $thisfile_asf_headerobject['headerobjects']; $HeaderObjectsCounter++) {
+			$NextObjectGUID     = substr($ASFHeaderData, $offset, 16);
+			$offset += 16;
+			$NextObjectGUIDtext = $this-&gt;BytestringToGUID($NextObjectGUID);
+			$NextObjectSize = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+			$offset += 8;
+			switch ($NextObjectGUID) {
+
+				case GETID3_ASF_File_Properties_Object:
+					// File Properties Object: (mandatory, one only)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for file properties object - GETID3_ASF_File_Properties_Object
+					// Object Size                  QWORD        64              // size of file properties object, including 104 bytes of File Properties Object header
+					// File ID                      GUID         128             // unique ID - identical to File ID in Data Object
+					// File Size                    QWORD        64              // entire file in bytes. Invalid if Broadcast Flag == 1
+					// Creation Date                QWORD        64              // date &amp; time of file creation. Maybe invalid if Broadcast Flag == 1
+					// Data Packets Count           QWORD        64              // number of data packets in Data Object. Invalid if Broadcast Flag == 1
+					// Play Duration                QWORD        64              // playtime, in 100-nanosecond units. Invalid if Broadcast Flag == 1
+					// Send Duration                QWORD        64              // time needed to send file, in 100-nanosecond units. Players can ignore this value. Invalid if Broadcast Flag == 1
+					// Preroll                      QWORD        64              // time to buffer data before starting to play file, in 1-millisecond units. If &lt;&gt; 0, PlayDuration and PresentationTime have been offset by this amount
+					// Flags                        DWORD        32              //
+					// * Broadcast Flag             bits         1  (0x01)       // file is currently being written, some header values are invalid
+					// * Seekable Flag              bits         1  (0x02)       // is file seekable
+					// * Reserved                   bits         30 (0xFFFFFFFC) // reserved - set to zero
+					// Minimum Data Packet Size     DWORD        32              // in bytes. should be same as Maximum Data Packet Size. Invalid if Broadcast Flag == 1
+					// Maximum Data Packet Size     DWORD        32              // in bytes. should be same as Minimum Data Packet Size. Invalid if Broadcast Flag == 1
+					// Maximum Bitrate              DWORD        32              // maximum instantaneous bitrate in bits per second for entire file, including all data streams and ASF overhead
+
+					// shortcut
+					$thisfile_asf['file_properties_object'] = array();
+					$thisfile_asf_filepropertiesobject      = &amp;$thisfile_asf['file_properties_object'];
+
+					$thisfile_asf_filepropertiesobject['objectid']           = $NextObjectGUID;
+					$thisfile_asf_filepropertiesobject['objectid_guid']      = $NextObjectGUIDtext;
+					$thisfile_asf_filepropertiesobject['objectsize']         = $NextObjectSize;
+					$thisfile_asf_filepropertiesobject['fileid']             = substr($ASFHeaderData, $offset, 16);
+					$offset += 16;
+					$thisfile_asf_filepropertiesobject['fileid_guid']        = $this-&gt;BytestringToGUID($thisfile_asf_filepropertiesobject['fileid']);
+					$thisfile_asf_filepropertiesobject['filesize']           = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+					$offset += 8;
+					$thisfile_asf_filepropertiesobject['creation_date']      = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+					$thisfile_asf_filepropertiesobject['creation_date_unix'] = $this-&gt;FILETIMEtoUNIXtime($thisfile_asf_filepropertiesobject['creation_date']);
+					$offset += 8;
+					$thisfile_asf_filepropertiesobject['data_packets']       = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+					$offset += 8;
+					$thisfile_asf_filepropertiesobject['play_duration']      = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+					$offset += 8;
+					$thisfile_asf_filepropertiesobject['send_duration']      = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+					$offset += 8;
+					$thisfile_asf_filepropertiesobject['preroll']            = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+					$offset += 8;
+					$ThisFileInfo['playtime_seconds'] = ($thisfile_asf_filepropertiesobject['play_duration'] / 10000000) - ($thisfile_asf_filepropertiesobject['preroll'] / 1000);
+					$thisfile_asf_filepropertiesobject['flags_raw']          = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					$thisfile_asf_filepropertiesobject['flags']['broadcast'] = (bool) ($thisfile_asf_filepropertiesobject['flags_raw'] &amp; 0x0001);
+					$thisfile_asf_filepropertiesobject['flags']['seekable']  = (bool) ($thisfile_asf_filepropertiesobject['flags_raw'] &amp; 0x0002);
+
+					$thisfile_asf_filepropertiesobject['min_packet_size']    = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					$thisfile_asf_filepropertiesobject['max_packet_size']    = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					$thisfile_asf_filepropertiesobject['max_bitrate']        = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					$ThisFileInfo['bitrate']                                 = $thisfile_asf_filepropertiesobject['max_bitrate'];
+					break;
+
+				case GETID3_ASF_Stream_Properties_Object:
+					// Stream Properties Object: (mandatory, one per media stream)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for stream properties object - GETID3_ASF_Stream_Properties_Object
+					// Object Size                  QWORD        64              // size of stream properties object, including 78 bytes of Stream Properties Object header
+					// Stream Type                  GUID         128             // GETID3_ASF_Audio_Media, GETID3_ASF_Video_Media or GETID3_ASF_Command_Media
+					// Error Correction Type        GUID         128             // GETID3_ASF_Audio_Spread for audio-only streams, GETID3_ASF_No_Error_Correction for other stream types
+					// Time Offset                  QWORD        64              // 100-nanosecond units. typically zero. added to all timestamps of samples in the stream
+					// Type-Specific Data Length    DWORD        32              // number of bytes for Type-Specific Data field
+					// Error Correction Data Length DWORD        32              // number of bytes for Error Correction Data field
+					// Flags                        WORD         16              //
+					// * Stream Number              bits         7 (0x007F)      // number of this stream.  1 &lt;= valid &lt;= 127
+					// * Reserved                   bits         8 (0x7F80)      // reserved - set to zero
+					// * Encrypted Content Flag     bits         1 (0x8000)      // stream contents encrypted if set
+					// Reserved                     DWORD        32              // reserved - set to zero
+					// Type-Specific Data           BYTESTREAM   variable        // type-specific format data, depending on value of Stream Type
+					// Error Correction Data        BYTESTREAM   variable        // error-correction-specific format data, depending on value of Error Correct Type
+
+					// There is one GETID3_ASF_Stream_Properties_Object for each stream (audio, video) but the
+					// stream number isn't known until halfway through decoding the structure, hence it
+					// it is decoded to a temporary variable and then stuck in the appropriate index later
+
+					$StreamPropertiesObjectData['objectid']           = $NextObjectGUID;
+					$StreamPropertiesObjectData['objectid_guid']      = $NextObjectGUIDtext;
+					$StreamPropertiesObjectData['objectsize']         = $NextObjectSize;
+					$StreamPropertiesObjectData['stream_type']        = substr($ASFHeaderData, $offset, 16);
+					$offset += 16;
+					$StreamPropertiesObjectData['stream_type_guid']   = $this-&gt;BytestringToGUID($StreamPropertiesObjectData['stream_type']);
+					$StreamPropertiesObjectData['error_correct_type'] = substr($ASFHeaderData, $offset, 16);
+					$offset += 16;
+					$StreamPropertiesObjectData['error_correct_guid'] = $this-&gt;BytestringToGUID($StreamPropertiesObjectData['error_correct_type']);
+					$StreamPropertiesObjectData['time_offset']        = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+					$offset += 8;
+					$StreamPropertiesObjectData['type_data_length']   = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					$StreamPropertiesObjectData['error_data_length']  = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					$StreamPropertiesObjectData['flags_raw']          = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					$StreamPropertiesObjectStreamNumber               = $StreamPropertiesObjectData['flags_raw'] &amp; 0x007F;
+					$StreamPropertiesObjectData['flags']['encrypted'] = (bool) ($StreamPropertiesObjectData['flags_raw'] &amp; 0x8000);
+
+					$offset += 4; // reserved - DWORD
+					$StreamPropertiesObjectData['type_specific_data'] = substr($ASFHeaderData, $offset, $StreamPropertiesObjectData['type_data_length']);
+					$offset += $StreamPropertiesObjectData['type_data_length'];
+					$StreamPropertiesObjectData['error_correct_data'] = substr($ASFHeaderData, $offset, $StreamPropertiesObjectData['error_data_length']);
+					$offset += $StreamPropertiesObjectData['error_data_length'];
+
+					switch ($StreamPropertiesObjectData['stream_type']) {
+
+						case GETID3_ASF_Audio_Media:
+							$thisfile_audio['dataformat']   = (!empty($thisfile_audio['dataformat'])   ? $thisfile_audio['dataformat']   : 'asf');
+							$thisfile_audio['bitrate_mode'] = (!empty($thisfile_audio['bitrate_mode']) ? $thisfile_audio['bitrate_mode'] : 'cbr');
+
+							$audiodata = getid3_riff::RIFFparseWAVEFORMATex(substr($StreamPropertiesObjectData['type_specific_data'], 0, 16));
+							unset($audiodata['raw']);
+							$thisfile_audio = getid3_lib::array_merge_noclobber($audiodata, $thisfile_audio);
+							break;
+
+						case GETID3_ASF_Video_Media:
+							$thisfile_video['dataformat']   = (!empty($thisfile_video['dataformat'])   ? $thisfile_video['dataformat']   : 'asf');
+							$thisfile_video['bitrate_mode'] = (!empty($thisfile_video['bitrate_mode']) ? $thisfile_video['bitrate_mode'] : 'cbr');
+							break;
+
+						case GETID3_ASF_Command_Media:
+						default:
+							// do nothing
+							break;
+
+					}
+
+					$thisfile_asf['stream_properties_object'][$StreamPropertiesObjectStreamNumber] = $StreamPropertiesObjectData;
+					unset($StreamPropertiesObjectData); // clear for next stream, if any
+					break;
+
+				case GETID3_ASF_Header_Extension_Object:
+					// Header Extension Object: (mandatory, one only)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Header Extension object - GETID3_ASF_Header_Extension_Object
+					// Object Size                  QWORD        64              // size of Header Extension object, including 46 bytes of Header Extension Object header
+					// Reserved Field 1             GUID         128             // hardcoded: GETID3_ASF_Reserved_1
+					// Reserved Field 2             WORD         16              // hardcoded: 0x00000006
+					// Header Extension Data Size   DWORD        32              // in bytes. valid: 0, or &gt; 24. equals object size minus 46
+					// Header Extension Data        BYTESTREAM   variable        // array of zero or more extended header objects
+
+					// shortcut
+					$thisfile_asf['header_extension_object'] = array();
+					$thisfile_asf_headerextensionobject      = &amp;$thisfile_asf['header_extension_object'];
+
+					$thisfile_asf_headerextensionobject['objectid']            = $NextObjectGUID;
+					$thisfile_asf_headerextensionobject['objectid_guid']       = $NextObjectGUIDtext;
+					$thisfile_asf_headerextensionobject['objectsize']          = $NextObjectSize;
+					$thisfile_asf_headerextensionobject['reserved_1']          = substr($ASFHeaderData, $offset, 16);
+					$offset += 16;
+					$thisfile_asf_headerextensionobject['reserved_1_guid']     = $this-&gt;BytestringToGUID($thisfile_asf_headerextensionobject['reserved_1']);
+					if ($thisfile_asf_headerextensionobject['reserved_1'] != GETID3_ASF_Reserved_1) {
+						$ThisFileInfo['warning'][] = 'header_extension_object.reserved_1 GUID ('.$this-&gt;BytestringToGUID($thisfile_asf_headerextensionobject['reserved_1']).') does not match expected &quot;GETID3_ASF_Reserved_1&quot; GUID ('.$this-&gt;BytestringToGUID(GETID3_ASF_Reserved_1).')';
+						//return false;
+						break;
+					}
+					$thisfile_asf_headerextensionobject['reserved_2']          = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					if ($thisfile_asf_headerextensionobject['reserved_2'] != 6) {
+						$ThisFileInfo['warning'][] = 'header_extension_object.reserved_2 ('.getid3_lib::PrintHexBytes($thisfile_asf_headerextensionobject['reserved_2']).') does not match expected value of &quot;6&quot;';
+						//return false;
+						break;
+					}
+					$thisfile_asf_headerextensionobject['extension_data_size'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					$thisfile_asf_headerextensionobject['extension_data']      =                              substr($ASFHeaderData, $offset, $thisfile_asf_headerextensionobject['extension_data_size']);
+					$offset += $thisfile_asf_headerextensionobject['extension_data_size'];
+					break;
+
+				case GETID3_ASF_Codec_List_Object:
+					// Codec List Object: (optional, one only)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Codec List object - GETID3_ASF_Codec_List_Object
+					// Object Size                  QWORD        64              // size of Codec List object, including 44 bytes of Codec List Object header
+					// Reserved                     GUID         128             // hardcoded: 86D15241-311D-11D0-A3A4-00A0C90348F6
+					// Codec Entries Count          DWORD        32              // number of entries in Codec Entries array
+					// Codec Entries                array of:    variable        //
+					// * Type                       WORD         16              // 0x0001 = Video Codec, 0x0002 = Audio Codec, 0xFFFF = Unknown Codec
+					// * Codec Name Length          WORD         16              // number of Unicode characters stored in the Codec Name field
+					// * Codec Name                 WCHAR        variable        // array of Unicode characters - name of codec used to create the content
+					// * Codec Description Length   WORD         16              // number of Unicode characters stored in the Codec Description field
+					// * Codec Description          WCHAR        variable        // array of Unicode characters - description of format used to create the content
+					// * Codec Information Length   WORD         16              // number of Unicode characters stored in the Codec Information field
+					// * Codec Information          BYTESTREAM   variable        // opaque array of information bytes about the codec used to create the content
+
+					// shortcut
+					$thisfile_asf['codec_list_object'] = array();
+					$thisfile_asf_codeclistobject      = &amp;$thisfile_asf['codec_list_object'];
+
+					$thisfile_asf_codeclistobject['objectid']                  = $NextObjectGUID;
+					$thisfile_asf_codeclistobject['objectid_guid']             = $NextObjectGUIDtext;
+					$thisfile_asf_codeclistobject['objectsize']                = $NextObjectSize;
+					$thisfile_asf_codeclistobject['reserved']                  = substr($ASFHeaderData, $offset, 16);
+					$offset += 16;
+					$thisfile_asf_codeclistobject['reserved_guid']             = $this-&gt;BytestringToGUID($thisfile_asf_codeclistobject['reserved']);
+					if ($thisfile_asf_codeclistobject['reserved'] != $this-&gt;GUIDtoBytestring('86D15241-311D-11D0-A3A4-00A0C90348F6')) {
+						$ThisFileInfo['warning'][] = 'codec_list_object.reserved GUID {'.$this-&gt;BytestringToGUID($thisfile_asf_codeclistobject['reserved']).'} does not match expected &quot;GETID3_ASF_Reserved_1&quot; GUID {86D15241-311D-11D0-A3A4-00A0C90348F6}';
+						//return false;
+						break;
+					}
+					$thisfile_asf_codeclistobject['codec_entries_count'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					for ($CodecEntryCounter = 0; $CodecEntryCounter &lt; $thisfile_asf_codeclistobject['codec_entries_count']; $CodecEntryCounter++) {
+						// shortcut
+						$thisfile_asf_codeclistobject['codec_entries'][$CodecEntryCounter] = array();
+						$thisfile_asf_codeclistobject_codecentries_current = &amp;$thisfile_asf_codeclistobject['codec_entries'][$CodecEntryCounter];
+
+						$thisfile_asf_codeclistobject_codecentries_current['type_raw'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+						$offset += 2;
+						$thisfile_asf_codeclistobject_codecentries_current['type'] = $this-&gt;ASFCodecListObjectTypeLookup($thisfile_asf_codeclistobject_codecentries_current['type_raw']);
+
+						$CodecNameLength = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2)) * 2; // 2 bytes per character
+						$offset += 2;
+						$thisfile_asf_codeclistobject_codecentries_current['name'] = substr($ASFHeaderData, $offset, $CodecNameLength);
+						$offset += $CodecNameLength;
+
+						$CodecDescriptionLength = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2)) * 2; // 2 bytes per character
+						$offset += 2;
+						$thisfile_asf_codeclistobject_codecentries_current['description'] = substr($ASFHeaderData, $offset, $CodecDescriptionLength);
+						$offset += $CodecDescriptionLength;
+
+						$CodecInformationLength = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+						$offset += 2;
+						$thisfile_asf_codeclistobject_codecentries_current['information'] = substr($ASFHeaderData, $offset, $CodecInformationLength);
+						$offset += $CodecInformationLength;
+
+						if ($thisfile_asf_codeclistobject_codecentries_current['type_raw'] == 2) {
+							// audio codec
+							if (strpos($thisfile_asf_codeclistobject_codecentries_current['description'], ',') === false) {
+								$ThisFileInfo['error'][] = '[asf][codec_list_object][codec_entries]['.$CodecEntryCounter.'][description] expected to contain comma-seperated list of parameters: &quot;'.$thisfile_asf_codeclistobject_codecentries_current['description'].'&quot;';
+								return false;
+							}
+							list($AudioCodecBitrate, $AudioCodecFrequency, $AudioCodecChannels) = explode(',', $this-&gt;TrimConvert($thisfile_asf_codeclistobject_codecentries_current['description']));
+							$thisfile_audio['codec'] = $this-&gt;TrimConvert($thisfile_asf_codeclistobject_codecentries_current['name']);
+
+							if (!isset($thisfile_audio['bitrate']) &amp;&amp; strstr($AudioCodecBitrate, 'kbps')) {
+								$thisfile_audio['bitrate'] = (int) (trim(str_replace('kbps', '', $AudioCodecBitrate)) * 1000);
+							}
+							if (!isset($thisfile_video['bitrate']) &amp;&amp; isset($thisfile_audio['bitrate']) &amp;&amp; isset($thisfile_asf['file_properties_object']['max_bitrate']) &amp;&amp; ($thisfile_asf_codeclistobject['codec_entries_count'] &gt; 1)) {
+								$thisfile_video['bitrate'] = $thisfile_asf['file_properties_object']['max_bitrate'] - $thisfile_audio['bitrate'];
+							}
+
+							$AudioCodecFrequency = (int) trim(str_replace('kHz', '', $AudioCodecFrequency));
+							switch ($AudioCodecFrequency) {
+								case 8:
+									$thisfile_audio['sample_rate'] = 8000;
+									break;
+
+								case 11:
+									$thisfile_audio['sample_rate'] = 11025;
+									break;
+
+								case 12:
+									$thisfile_audio['sample_rate'] = 12000;
+									break;
+
+								case 16:
+									$thisfile_audio['sample_rate'] = 16000;
+									break;
+
+								case 22:
+									$thisfile_audio['sample_rate'] = 22050;
+									break;
+
+								case 24:
+									$thisfile_audio['sample_rate'] = 24000;
+									break;
+
+								case 32:
+									$thisfile_audio['sample_rate'] = 32000;
+									break;
+
+								case 44:
+									$thisfile_audio['sample_rate'] = 44100;
+									break;
+
+								case 48:
+									$thisfile_audio['sample_rate'] = 48000;
+									break;
+
+								default:
+									$ThisFileInfo['warning'][] = 'unknown frequency: &quot;'.$AudioCodecFrequency.'&quot; ('.$this-&gt;TrimConvert($thisfile_asf_codeclistobject_codecentries_current['description']).')';
+	//                                return false;
+									break;
+							}
+
+							if (!isset($thisfile_audio['channels'])) {
+								if (strstr($AudioCodecChannels, 'stereo')) {
+									$thisfile_audio['channels'] = 2;
+								} elseif (strstr($AudioCodecChannels, 'mono')) {
+									$thisfile_audio['channels'] = 1;
+								}
+							}
+						}
+					}
+					break;
+
+				case GETID3_ASF_Script_Command_Object:
+					// Script Command Object: (optional, one only)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Script Command object - GETID3_ASF_Script_Command_Object
+					// Object Size                  QWORD        64              // size of Script Command object, including 44 bytes of Script Command Object header
+					// Reserved                     GUID         128             // hardcoded: 4B1ACBE3-100B-11D0-A39B-00A0C90348F6
+					// Commands Count               WORD         16              // number of Commands structures in the Script Commands Objects
+					// Command Types Count          WORD         16              // number of Command Types structures in the Script Commands Objects
+					// Command Types                array of:    variable        //
+					// * Command Type Name Length   WORD         16              // number of Unicode characters for Command Type Name
+					// * Command Type Name          WCHAR        variable        // array of Unicode characters - name of a type of command
+					// Commands                     array of:    variable        //
+					// * Presentation Time          DWORD        32              // presentation time of that command, in milliseconds
+					// * Type Index                 WORD         16              // type of this command, as a zero-based index into the array of Command Types of this object
+					// * Command Name Length        WORD         16              // number of Unicode characters for Command Name
+					// * Command Name               WCHAR        variable        // array of Unicode characters - name of this command
+
+					// shortcut
+					$thisfile_asf['script_command_object'] = array();
+					$thisfile_asf_scriptcommandobject      = &amp;$thisfile_asf['script_command_object'];
+
+					$thisfile_asf_scriptcommandobject['objectid']             = $NextObjectGUID;
+					$thisfile_asf_scriptcommandobject['objectid_guid']        = $NextObjectGUIDtext;
+					$thisfile_asf_scriptcommandobject['objectsize']           = $NextObjectSize;
+					$thisfile_asf_scriptcommandobject['reserved']             = substr($ASFHeaderData, $offset, 16);
+					$offset += 16;
+					$thisfile_asf_scriptcommandobject['reserved_guid']        = $this-&gt;BytestringToGUID($thisfile_asf_scriptcommandobject['reserved']);
+					if ($thisfile_asf_scriptcommandobject['reserved'] != $this-&gt;GUIDtoBytestring('4B1ACBE3-100B-11D0-A39B-00A0C90348F6')) {
+						$ThisFileInfo['warning'][] = 'script_command_object.reserved GUID {'.$this-&gt;BytestringToGUID($thisfile_asf_scriptcommandobject['reserved']).'} does not match expected &quot;GETID3_ASF_Reserved_1&quot; GUID {4B1ACBE3-100B-11D0-A39B-00A0C90348F6}';
+						//return false;
+						break;
+					}
+					$thisfile_asf_scriptcommandobject['commands_count']       = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					$thisfile_asf_scriptcommandobject['command_types_count']  = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					for ($CommandTypesCounter = 0; $CommandTypesCounter &lt; $thisfile_asf_scriptcommandobject['command_types_count']; $CommandTypesCounter++) {
+						$CommandTypeNameLength = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2)) * 2; // 2 bytes per character
+						$offset += 2;
+						$thisfile_asf_scriptcommandobject['command_types'][$CommandTypesCounter]['name'] = substr($ASFHeaderData, $offset, $CommandTypeNameLength);
+						$offset += $CommandTypeNameLength;
+					}
+					for ($CommandsCounter = 0; $CommandsCounter &lt; $thisfile_asf_scriptcommandobject['commands_count']; $CommandsCounter++) {
+						$thisfile_asf_scriptcommandobject['commands'][$CommandsCounter]['presentation_time']  = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+						$offset += 4;
+						$thisfile_asf_scriptcommandobject['commands'][$CommandsCounter]['type_index']         = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+						$offset += 2;
+
+						$CommandTypeNameLength = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2)) * 2; // 2 bytes per character
+						$offset += 2;
+						$thisfile_asf_scriptcommandobject['commands'][$CommandsCounter]['name'] = substr($ASFHeaderData, $offset, $CommandTypeNameLength);
+						$offset += $CommandTypeNameLength;
+					}
+					break;
+
+				case GETID3_ASF_Marker_Object:
+					// Marker Object: (optional, one only)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Marker object - GETID3_ASF_Marker_Object
+					// Object Size                  QWORD        64              // size of Marker object, including 48 bytes of Marker Object header
+					// Reserved                     GUID         128             // hardcoded: 4CFEDB20-75F6-11CF-9C0F-00A0C90349CB
+					// Markers Count                DWORD        32              // number of Marker structures in Marker Object
+					// Reserved                     WORD         16              // hardcoded: 0x0000
+					// Name Length                  WORD         16              // number of bytes in the Name field
+					// Name                         WCHAR        variable        // name of the Marker Object
+					// Markers                      array of:    variable        //
+					// * Offset                     QWORD        64              // byte offset into Data Object
+					// * Presentation Time          QWORD        64              // in 100-nanosecond units
+					// * Entry Length               WORD         16              // length in bytes of (Send Time + Flags + Marker Description Length + Marker Description + Padding)
+					// * Send Time                  DWORD        32              // in milliseconds
+					// * Flags                      DWORD        32              // hardcoded: 0x00000000
+					// * Marker Description Length  DWORD        32              // number of bytes in Marker Description field
+					// * Marker Description         WCHAR        variable        // array of Unicode characters - description of marker entry
+					// * Padding                    BYTESTREAM   variable        // optional padding bytes
+
+					// shortcut
+					$thisfile_asf['marker_object'] = array();
+					$thisfile_asf_markerobject     = &amp;$thisfile_asf['marker_object'];
+
+					$thisfile_asf_markerobject['objectid']             = $NextObjectGUID;
+					$thisfile_asf_markerobject['objectid_guid']        = $NextObjectGUIDtext;
+					$thisfile_asf_markerobject['objectsize']           = $NextObjectSize;
+					$thisfile_asf_markerobject['reserved']             = substr($ASFHeaderData, $offset, 16);
+					$offset += 16;
+					$thisfile_asf_markerobject['reserved_guid']        = $this-&gt;BytestringToGUID($thisfile_asf_markerobject['reserved']);
+					if ($thisfile_asf_markerobject['reserved'] != $this-&gt;GUIDtoBytestring('4CFEDB20-75F6-11CF-9C0F-00A0C90349CB')) {
+						$ThisFileInfo['warning'][] = 'marker_object.reserved GUID {'.$this-&gt;BytestringToGUID($thisfile_asf_markerobject['reserved_1']).'} does not match expected &quot;GETID3_ASF_Reserved_1&quot; GUID {4CFEDB20-75F6-11CF-9C0F-00A0C90349CB}';
+						break;
+					}
+					$thisfile_asf_markerobject['markers_count'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					$thisfile_asf_markerobject['reserved_2'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					if ($thisfile_asf_markerobject['reserved_2'] != 0) {
+						$ThisFileInfo['warning'][] = 'marker_object.reserved_2 ('.getid3_lib::PrintHexBytes($thisfile_asf_markerobject['reserved_2']).') does not match expected value of &quot;0&quot;';
+						break;
+					}
+					$thisfile_asf_markerobject['name_length'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					$thisfile_asf_markerobject['name'] = substr($ASFHeaderData, $offset, $thisfile_asf_markerobject['name_length']);
+					$offset += $thisfile_asf_markerobject['name_length'];
+					for ($MarkersCounter = 0; $MarkersCounter &lt; $thisfile_asf_markerobject['markers_count']; $MarkersCounter++) {
+						$thisfile_asf_markerobject['markers'][$MarkersCounter]['offset']  = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+						$offset += 8;
+						$thisfile_asf_markerobject['markers'][$MarkersCounter]['presentation_time']         = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 8));
+						$offset += 8;
+						$thisfile_asf_markerobject['markers'][$MarkersCounter]['entry_length']              = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+						$offset += 2;
+						$thisfile_asf_markerobject['markers'][$MarkersCounter]['send_time']                 = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+						$offset += 4;
+						$thisfile_asf_markerobject['markers'][$MarkersCounter]['flags']                     = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+						$offset += 4;
+						$thisfile_asf_markerobject['markers'][$MarkersCounter]['marker_description_length'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+						$offset += 4;
+						$thisfile_asf_markerobject['markers'][$MarkersCounter]['marker_description']        = substr($ASFHeaderData, $offset, $thisfile_asf_markerobject['markers'][$MarkersCounter]['marker_description_length']);
+						$offset += $thisfile_asf_markerobject['markers'][$MarkersCounter]['marker_description_length'];
+						$PaddingLength = $thisfile_asf_markerobject['markers'][$MarkersCounter]['entry_length'] - 4 -  4 - 4 - $thisfile_asf_markerobject['markers'][$MarkersCounter]['marker_description_length'];
+						if ($PaddingLength &gt; 0) {
+							$thisfile_asf_markerobject['markers'][$MarkersCounter]['padding']               = substr($ASFHeaderData, $offset, $PaddingLength);
+							$offset += $PaddingLength;
+						}
+					}
+					break;
+
+				case GETID3_ASF_Bitrate_Mutual_Exclusion_Object:
+					// Bitrate Mutual Exclusion Object: (optional)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Bitrate Mutual Exclusion object - GETID3_ASF_Bitrate_Mutual_Exclusion_Object
+					// Object Size                  QWORD        64              // size of Bitrate Mutual Exclusion object, including 42 bytes of Bitrate Mutual Exclusion Object header
+					// Exlusion Type                GUID         128             // nature of mutual exclusion relationship. one of: (GETID3_ASF_Mutex_Bitrate, GETID3_ASF_Mutex_Unknown)
+					// Stream Numbers Count         WORD         16              // number of video streams
+					// Stream Numbers               WORD         variable        // array of mutually exclusive video stream numbers. 1 &lt;= valid &lt;= 127
+
+					// shortcut
+					$thisfile_asf['bitrate_mutual_exclusion_object'] = array();
+					$thisfile_asf_bitratemutualexclusionobject       = &amp;$thisfile_asf['bitrate_mutual_exclusion_object'];
+
+					$thisfile_asf_bitratemutualexclusionobject['objectid']             = $NextObjectGUID;
+					$thisfile_asf_bitratemutualexclusionobject['objectid_guid']        = $NextObjectGUIDtext;
+					$thisfile_asf_bitratemutualexclusionobject['objectsize']           = $NextObjectSize;
+					$thisfile_asf_bitratemutualexclusionobject['reserved']             = substr($ASFHeaderData, $offset, 16);
+					$thisfile_asf_bitratemutualexclusionobject['reserved_guid']        = $this-&gt;BytestringToGUID($thisfile_asf_bitratemutualexclusionobject['reserved']);
+					$offset += 16;
+					if (($thisfile_asf_bitratemutualexclusionobject['reserved'] != GETID3_ASF_Mutex_Bitrate) &amp;&amp; ($thisfile_asf_bitratemutualexclusionobject['reserved'] != GETID3_ASF_Mutex_Unknown)) {
+						$ThisFileInfo['warning'][] = 'bitrate_mutual_exclusion_object.reserved GUID {'.$this-&gt;BytestringToGUID($thisfile_asf_bitratemutualexclusionobject['reserved']).'} does not match expected &quot;GETID3_ASF_Mutex_Bitrate&quot; GUID {'.$this-&gt;BytestringToGUID(GETID3_ASF_Mutex_Bitrate).'} or  &quot;GETID3_ASF_Mutex_Unknown&quot; GUID {'.$this-&gt;BytestringToGUID(GETID3_ASF_Mutex_Unknown).'}';
+						//return false;
+						break;
+					}
+					$thisfile_asf_bitratemutualexclusionobject['stream_numbers_count'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					for ($StreamNumberCounter = 0; $StreamNumberCounter &lt; $thisfile_asf_bitratemutualexclusionobject['stream_numbers_count']; $StreamNumberCounter++) {
+						$thisfile_asf_bitratemutualexclusionobject['stream_numbers'][$StreamNumberCounter] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+						$offset += 2;
+					}
+					break;
+
+				case GETID3_ASF_Error_Correction_Object:
+					// Error Correction Object: (optional, one only)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Error Correction object - GETID3_ASF_Error_Correction_Object
+					// Object Size                  QWORD        64              // size of Error Correction object, including 44 bytes of Error Correction Object header
+					// Error Correction Type        GUID         128             // type of error correction. one of: (GETID3_ASF_No_Error_Correction, GETID3_ASF_Audio_Spread)
+					// Error Correction Data Length DWORD        32              // number of bytes in Error Correction Data field
+					// Error Correction Data        BYTESTREAM   variable        // structure depends on value of Error Correction Type field
+
+					// shortcut
+					$thisfile_asf['error_correction_object'] = array();
+					$thisfile_asf_errorcorrectionobject      = &amp;$thisfile_asf['error_correction_object'];
+
+					$thisfile_asf_errorcorrectionobject['objectid']              = $NextObjectGUID;
+					$thisfile_asf_errorcorrectionobject['objectid_guid']         = $NextObjectGUIDtext;
+					$thisfile_asf_errorcorrectionobject['objectsize']            = $NextObjectSize;
+					$thisfile_asf_errorcorrectionobject['error_correction_type'] = substr($ASFHeaderData, $offset, 16);
+					$offset += 16;
+					$thisfile_asf_errorcorrectionobject['error_correction_guid'] = $this-&gt;BytestringToGUID($thisfile_asf_errorcorrectionobject['error_correction_type']);
+					$thisfile_asf_errorcorrectionobject['error_correction_data_length'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+					$offset += 4;
+					switch ($thisfile_asf_errorcorrectionobject['error_correction_type']) {
+						case GETID3_ASF_No_Error_Correction:
+							// should be no data, but just in case there is, skip to the end of the field
+							$offset += $thisfile_asf_errorcorrectionobject['error_correction_data_length'];
+							break;
+
+						case GETID3_ASF_Audio_Spread:
+							// Field Name                   Field Type   Size (bits)
+							// Span                         BYTE         8               // number of packets over which audio will be spread.
+							// Virtual Packet Length        WORD         16              // size of largest audio payload found in audio stream
+							// Virtual Chunk Length         WORD         16              // size of largest audio payload found in audio stream
+							// Silence Data Length          WORD         16              // number of bytes in Silence Data field
+							// Silence Data                 BYTESTREAM   variable        // hardcoded: 0x00 * (Silence Data Length) bytes
+
+							$thisfile_asf_errorcorrectionobject['span']                  = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 1));
+							$offset += 1;
+							$thisfile_asf_errorcorrectionobject['virtual_packet_length'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+							$offset += 2;
+							$thisfile_asf_errorcorrectionobject['virtual_chunk_length']  = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+							$offset += 2;
+							$thisfile_asf_errorcorrectionobject['silence_data_length']   = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+							$offset += 2;
+							$thisfile_asf_errorcorrectionobject['silence_data']          = substr($ASFHeaderData, $offset, $thisfile_asf_errorcorrectionobject['silence_data_length']);
+							$offset += $thisfile_asf_errorcorrectionobject['silence_data_length'];
+							break;
+
+						default:
+							$ThisFileInfo['warning'][] = 'error_correction_object.error_correction_type GUID {'.$this-&gt;BytestringToGUID($thisfile_asf_errorcorrectionobject['reserved']).'} does not match expected &quot;GETID3_ASF_No_Error_Correction&quot; GUID {'.$this-&gt;BytestringToGUID(GETID3_ASF_No_Error_Correction).'} or  &quot;GETID3_ASF_Audio_Spread&quot; GUID {'.$this-&gt;BytestringToGUID(GETID3_ASF_Audio_Spread).'}';
+							//return false;
+							break;
+					}
+
+					break;
+
+				case GETID3_ASF_Content_Description_Object:
+					// Content Description Object: (optional, one only)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Content Description object - GETID3_ASF_Content_Description_Object
+					// Object Size                  QWORD        64              // size of Content Description object, including 34 bytes of Content Description Object header
+					// Title Length                 WORD         16              // number of bytes in Title field
+					// Author Length                WORD         16              // number of bytes in Author field
+					// Copyright Length             WORD         16              // number of bytes in Copyright field
+					// Description Length           WORD         16              // number of bytes in Description field
+					// Rating Length                WORD         16              // number of bytes in Rating field
+					// Title                        WCHAR        16              // array of Unicode characters - Title
+					// Author                       WCHAR        16              // array of Unicode characters - Author
+					// Copyright                    WCHAR        16              // array of Unicode characters - Copyright
+					// Description                  WCHAR        16              // array of Unicode characters - Description
+					// Rating                       WCHAR        16              // array of Unicode characters - Rating
+
+					// shortcut
+					$thisfile_asf['content_description_object'] = array();
+					$thisfile_asf_contentdescriptionobject      = &amp;$thisfile_asf['content_description_object'];
+
+					$thisfile_asf_contentdescriptionobject['objectid']              = $NextObjectGUID;
+					$thisfile_asf_contentdescriptionobject['objectid_guid']         = $NextObjectGUIDtext;
+					$thisfile_asf_contentdescriptionobject['objectsize']            = $NextObjectSize;
+					$thisfile_asf_contentdescriptionobject['title_length']          = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					$thisfile_asf_contentdescriptionobject['author_length']         = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					$thisfile_asf_contentdescriptionobject['copyright_length']      = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					$thisfile_asf_contentdescriptionobject['description_length']    = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					$thisfile_asf_contentdescriptionobject['rating_length']         = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					$thisfile_asf_contentdescriptionobject['title']                 = substr($ASFHeaderData, $offset, $thisfile_asf_contentdescriptionobject['title_length']);
+					$offset += $thisfile_asf_contentdescriptionobject['title_length'];
+					$thisfile_asf_contentdescriptionobject['author']                = substr($ASFHeaderData, $offset, $thisfile_asf_contentdescriptionobject['author_length']);
+					$offset += $thisfile_asf_contentdescriptionobject['author_length'];
+					$thisfile_asf_contentdescriptionobject['copyright']             = substr($ASFHeaderData, $offset, $thisfile_asf_contentdescriptionobject['copyright_length']);
+					$offset += $thisfile_asf_contentdescriptionobject['copyright_length'];
+					$thisfile_asf_contentdescriptionobject['description']           = substr($ASFHeaderData, $offset, $thisfile_asf_contentdescriptionobject['description_length']);
+					$offset += $thisfile_asf_contentdescriptionobject['description_length'];
+					$thisfile_asf_contentdescriptionobject['rating']                = substr($ASFHeaderData, $offset, $thisfile_asf_contentdescriptionobject['rating_length']);
+					$offset += $thisfile_asf_contentdescriptionobject['rating_length'];
+
+					$ASFcommentKeysToCopy = array('title'=&gt;'title', 'author'=&gt;'artist', 'copyright'=&gt;'copyright', 'description'=&gt;'comment', 'rating'=&gt;'rating');
+					foreach ($ASFcommentKeysToCopy as $keytocopyfrom =&gt; $keytocopyto) {
+						if (!empty($thisfile_asf_contentdescriptionobject[$keytocopyfrom])) {
+							$thisfile_asf_comments[$keytocopyto][] = $this-&gt;TrimTerm($thisfile_asf_contentdescriptionobject[$keytocopyfrom]);
+						}
+					}
+					break;
+
+				case GETID3_ASF_Extended_Content_Description_Object:
+					// Extended Content Description Object: (optional, one only)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Extended Content Description object - GETID3_ASF_Extended_Content_Description_Object
+					// Object Size                  QWORD        64              // size of ExtendedContent Description object, including 26 bytes of Extended Content Description Object header
+					// Content Descriptors Count    WORD         16              // number of entries in Content Descriptors list
+					// Content Descriptors          array of:    variable        //
+					// * Descriptor Name Length     WORD         16              // size in bytes of Descriptor Name field
+					// * Descriptor Name            WCHAR        variable        // array of Unicode characters - Descriptor Name
+					// * Descriptor Value Data Type WORD         16              // Lookup array:
+																					// 0x0000 = Unicode String (variable length)
+																					// 0x0001 = BYTE array     (variable length)
+																					// 0x0002 = BOOL           (DWORD, 32 bits)
+																					// 0x0003 = DWORD          (DWORD, 32 bits)
+																					// 0x0004 = QWORD          (QWORD, 64 bits)
+																					// 0x0005 = WORD           (WORD,  16 bits)
+					// * Descriptor Value Length    WORD         16              // number of bytes stored in Descriptor Value field
+					// * Descriptor Value           variable     variable        // value for Content Descriptor
+
+					// shortcut
+					$thisfile_asf['extended_content_description_object'] = array();
+					$thisfile_asf_extendedcontentdescriptionobject       = &amp;$thisfile_asf['extended_content_description_object'];
+
+					$thisfile_asf_extendedcontentdescriptionobject['objectid']                  = $NextObjectGUID;
+					$thisfile_asf_extendedcontentdescriptionobject['objectid_guid']             = $NextObjectGUIDtext;
+					$thisfile_asf_extendedcontentdescriptionobject['objectsize']                = $NextObjectSize;
+					$thisfile_asf_extendedcontentdescriptionobject['content_descriptors_count'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					for ($ExtendedContentDescriptorsCounter = 0; $ExtendedContentDescriptorsCounter &lt; $thisfile_asf_extendedcontentdescriptionobject['content_descriptors_count']; $ExtendedContentDescriptorsCounter++) {
+						// shortcut
+						$thisfile_asf_extendedcontentdescriptionobject['content_descriptors'][$ExtendedContentDescriptorsCounter] = array();
+						$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current                                  = &amp;$thisfile_asf_extendedcontentdescriptionobject['content_descriptors'][$ExtendedContentDescriptorsCounter];
+
+						$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['base_offset']  = $offset + 30;
+						$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['name_length']  = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+						$offset += 2;
+						$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['name']         = substr($ASFHeaderData, $offset, $thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['name_length']);
+						$offset += $thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['name_length'];
+						$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value_type']   = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+						$offset += 2;
+						$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value_length'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+						$offset += 2;
+						$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']        = substr($ASFHeaderData, $offset, $thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value_length']);
+						$offset += $thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value_length'];
+						switch ($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value_type']) {
+							case 0x0000: // Unicode string
+								break;
+
+							case 0x0001: // BYTE array
+								// do nothing
+								break;
+
+							case 0x0002: // BOOL
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value'] = (bool) getid3_lib::LittleEndian2Int($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']);
+								break;
+
+							case 0x0003: // DWORD
+							case 0x0004: // QWORD
+							case 0x0005: // WORD
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value'] = getid3_lib::LittleEndian2Int($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']);
+								break;
+
+							default:
+								$ThisFileInfo['warning'][] = 'extended_content_description.content_descriptors.'.$ExtendedContentDescriptorsCounter.'.value_type is invalid ('.$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value_type'].')';
+								//return false;
+								break;
+						}
+						switch ($this-&gt;TrimConvert(strtolower($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['name']))) {
+
+							case 'wm/albumartist':
+							case 'artist':
+								$thisfile_asf_comments['artist'] = array($this-&gt;TrimTerm($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']));
+								break;
+
+							case 'wm/albumtitle':
+							case 'album':
+								$thisfile_asf_comments['album']  = array($this-&gt;TrimTerm($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']));
+								break;
+
+							case 'wm/genre':
+							case 'genre':
+								$thisfile_asf_comments['genre'] = array($this-&gt;TrimTerm($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']));
+								break;
+
+							case 'wm/tracknumber':
+							case 'tracknumber':
+								$thisfile_asf_comments['track'] = array(intval($this-&gt;TrimTerm($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value'])));
+								break;
+
+							case 'wm/track':
+								if (empty($thisfile_asf_comments['track'])) {
+									$thisfile_asf_comments['track'] = array(1 + $this-&gt;TrimConvert($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']));
+								}
+								break;
+
+							case 'wm/year':
+							case 'year':
+							case 'date':
+								$thisfile_asf_comments['year'] = array( $this-&gt;TrimTerm($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']));
+								break;
+
+							case 'wm/lyrics':
+							case 'lyrics':
+								$thisfile_asf_comments['lyrics'] = array($this-&gt;TrimTerm($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']));
+								break;
+
+							case 'isvbr':
+								if ($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']) {
+									$thisfile_audio['bitrate_mode'] = 'vbr';
+									$thisfile_video['bitrate_mode'] = 'vbr';
+								}
+								break;
+
+							case 'id3':
+								// id3v2 module might not be loaded
+								if (class_exists('getid3_id3v2')) {
+								    $tempfile         = tempnam('*', 'getID3');
+								    $tempfilehandle   = fopen($tempfile, &quot;wb&quot;);
+									$tempThisfileInfo = array('encoding'=&gt;$ThisFileInfo['encoding']);
+									fwrite($tempfilehandle, $thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']);
+									fclose($tempfilehandle);
+
+									$tempfilehandle = fopen($tempfile, &quot;rb&quot;);
+									$id3 = new getid3_id3v2($tempfilehandle, $tempThisfileInfo);
+									fclose($tempfilehandle);
+									unlink($tempfile);
+
+									$ThisFileInfo['id3v2'] = $tempThisfileInfo['id3v2'];
+								}
+								break;
+
+							case 'wm/encodingtime':
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['encoding_time_unix'] = $this-&gt;FILETIMEtoUNIXtime($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']);
+								$thisfile_asf_comments['encoding_time_unix'] = array($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['encoding_time_unix']);
+								break;
+
+							case 'wm/picture':
+								//typedef struct _WMPicture{
+								//  LPWSTR  pwszMIMEType;
+								//  BYTE  bPictureType;
+								//  LPWSTR  pwszDescription;
+								//  DWORD  dwDataLen;
+								//  BYTE*  pbData;
+								//} WM_PICTURE;
+
+								$wm_picture_offset = 0;
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['image_type_id'] = getid3_lib::LittleEndian2Int(substr($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value'], $wm_picture_offset, 1));
+								$wm_picture_offset += 1;
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['image_type']    = $this-&gt;WMpictureTypeLookup($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['image_type_id']);
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['image_size']    = getid3_lib::LittleEndian2Int(substr($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value'], $wm_picture_offset, 4));
+								$wm_picture_offset += 4;
+
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['image_mime'] = '';
+								do {
+									$next_byte_pair = substr($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value'], $wm_picture_offset, 2);
+									$wm_picture_offset += 2;
+									$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['image_mime'] .= $next_byte_pair;
+								} while ($next_byte_pair !== &quot;\x00\x00&quot;);
+
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['image_description'] = '';
+								do {
+									$next_byte_pair = substr($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value'], $wm_picture_offset, 2);
+									$wm_picture_offset += 2;
+									$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['image_description'] .= $next_byte_pair;
+								} while ($next_byte_pair !== &quot;\x00\x00&quot;);
+
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['dataoffset'] = $wm_picture_offset;
+								$thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['data'] = substr($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value'], $wm_picture_offset);
+								unset($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']);
+
+								break;
+
+							default:
+								switch ($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value_type']) {
+									case 0: // Unicode string
+										if (substr($this-&gt;TrimConvert($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['name']), 0, 3) == 'WM/') {
+											$thisfile_asf_comments[str_replace('wm/', '', strtolower($this-&gt;TrimConvert($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['name'])))] = array($this-&gt;TrimTerm($thisfile_asf_extendedcontentdescriptionobject_contentdescriptor_current['value']));
+										}
+										break;
+
+									case 1:
+										break;
+								}
+								break;
+						}
+
+					}
+					break;
+
+				case GETID3_ASF_Stream_Bitrate_Properties_Object:
+					// Stream Bitrate Properties Object: (optional, one only)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Stream Bitrate Properties object - GETID3_ASF_Stream_Bitrate_Properties_Object
+					// Object Size                  QWORD        64              // size of Extended Content Description object, including 26 bytes of Stream Bitrate Properties Object header
+					// Bitrate Records Count        WORD         16              // number of records in Bitrate Records
+					// Bitrate Records              array of:    variable        //
+					// * Flags                      WORD         16              //
+					// * * Stream Number            bits         7  (0x007F)     // number of this stream
+					// * * Reserved                 bits         9  (0xFF80)     // hardcoded: 0
+					// * Average Bitrate            DWORD        32              // in bits per second
+
+					// shortcut
+					$thisfile_asf['stream_bitrate_properties_object'] = array();
+					$thisfile_asf_streambitratepropertiesobject       = &amp;$thisfile_asf['stream_bitrate_properties_object'];
+
+					$thisfile_asf_streambitrateproperties['objectid']                  = $NextObjectGUID;
+					$thisfile_asf_streambitrateproperties['objectid_guid']             = $NextObjectGUIDtext;
+					$thisfile_asf_streambitrateproperties['objectsize']                = $NextObjectSize;
+					$thisfile_asf_streambitrateproperties['bitrate_records_count']     = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+					$offset += 2;
+					for ($BitrateRecordsCounter = 0; $BitrateRecordsCounter &lt; $thisfile_asf_streambitrateproperties['bitrate_records_count']; $BitrateRecordsCounter++) {
+						$thisfile_asf_streambitrateproperties['bitrate_records'][$BitrateRecordsCounter]['flags_raw'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 2));
+						$offset += 2;
+						$thisfile_asf_streambitrateproperties['bitrate_records'][$BitrateRecordsCounter]['flags']['stream_number'] = $thisfile_asf_streambitrateproperties['bitrate_records'][$BitrateRecordsCounter]['flags_raw'] &amp; 0x007F;
+						$thisfile_asf_streambitrateproperties['bitrate_records'][$BitrateRecordsCounter]['bitrate'] = getid3_lib::LittleEndian2Int(substr($ASFHeaderData, $offset, 4));
+						$offset += 4;
+					}
+					break;
+
+				case GETID3_ASF_Padding_Object:
+					// Padding Object: (optional)
+					// Field Name                   Field Type   Size (bits)
+					// Object ID                    GUID         128             // GUID for Padding object - GETID3_ASF_Padding_Object
+					// Object Size                  QWORD        64              // size of Padding object, including 24 bytes of ASF Padding Object header
+					// Padding Data                 BYTESTREAM   variable        // ignore
+
+					// shortcut
+					$thisfile_asf['padding_object'] = array();
+					$thisfile_asf_paddingobject     = &amp;$thisfile_asf['padding_object'];
+
+					$thisfile_asf_paddingobject['objectid']                  = $NextObjectGUID;
+					$thisfile_asf_paddingobject['objectid_guid']             = $NextObjectGUIDtext;
+					$thisfile_asf_paddingobject['objectsize']                = $NextObjectSize;
+					$thisfile_asf_paddingobject['padding_length']            = $thisfile_asf_paddingobject['objectsize'] - 16 - 8;
+					$thisfile_asf_paddingobject['padding']                   = substr($ASFHeaderData, $offset, $thisfile_asf_paddingobject['padding_length']);
+					break;
+
+				case GETID3_ASF_Extended_Content_Encryption_Object:
+				case GETID3_ASF_Content_Encryption_Object:
+					// WMA DRM - just ignore
+					$offset += ($NextObjectSize - 16 - 8);
+					break;
+
+				default:
+					// Implementations shall ignore any standard or non-standard object that they do not know how to handle.
+					if ($this-&gt;GUIDname($NextObjectGUIDtext)) {
+						$ThisFileInfo['warning'][] = 'unhandled GUID &quot;'.$this-&gt;GUIDname($NextObjectGUIDtext).'&quot; {'.$NextObjectGUIDtext.'} in ASF header at offset '.($offset - 16 - 8);
+					} else {
+						$ThisFileInfo['warning'][] = 'unknown GUID {'.$NextObjectGUIDtext.'} in ASF header at offset '.($offset - 16 - 8);
+					}
+					$offset += ($NextObjectSize - 16 - 8);
+					break;
+			}
+		}
+		if (isset($thisfile_asf_streambitrateproperties['bitrate_records_count'])) {
+			$ASFbitrateAudio = 0;
+			$ASFbitrateVideo = 0;
+			for ($BitrateRecordsCounter = 0; $BitrateRecordsCounter &lt; $thisfile_asf_streambitrateproperties['bitrate_records_count']; $BitrateRecordsCounter++) {
+				if (isset($thisfile_asf_codeclistobject['codec_entries'][$BitrateRecordsCounter])) {
+					switch ($thisfile_asf_codeclistobject['codec_entries'][$BitrateRecordsCounter]['type_raw']) {
+						case 1:
+							$ASFbitrateVideo += $thisfile_asf_streambitrateproperties['bitrate_records'][$BitrateRecordsCounter]['bitrate'];
+							break;
+
+						case 2:
+							$ASFbitrateAudio += $thisfile_asf_streambitrateproperties['bitrate_records'][$BitrateRecordsCounter]['bitrate'];
+							break;
+
+						default:
+							// do nothing
+							break;
+					}
+				}
+			}
+			if ($ASFbitrateAudio &gt; 0) {
+				$thisfile_audio['bitrate']     = $ASFbitrateAudio;
+			}
+			if ($ASFbitrateVideo &gt; 0) {
+				$thisfile_video['bitrate']     = $ASFbitrateVideo;
+			}
+		}
+		if (isset($thisfile_asf['stream_properties_object']) &amp;&amp; is_array($thisfile_asf['stream_properties_object'])) {
+
+			foreach ($thisfile_asf['stream_properties_object'] as $streamnumber =&gt; $streamdata) {
+
+				switch ($streamdata['stream_type']) {
+					case GETID3_ASF_Audio_Media:
+						// Field Name                   Field Type   Size (bits)
+						// Codec ID / Format Tag        WORD         16              // unique ID of audio codec - defined as wFormatTag field of WAVEFORMATEX structure
+						// Number of Channels           WORD         16              // number of channels of audio - defined as nChannels field of WAVEFORMATEX structure
+						// Samples Per Second           DWORD        32              // in Hertz - defined as nSamplesPerSec field of WAVEFORMATEX structure
+						// Average number of Bytes/sec  DWORD        32              // bytes/sec of audio stream  - defined as nAvgBytesPerSec field of WAVEFORMATEX structure
+						// Block Alignment              WORD         16              // block size in bytes of audio codec - defined as nBlockAlign field of WAVEFORMATEX structure
+						// Bits per sample              WORD         16              // bits per sample of mono data. set to zero for variable bitrate codecs. defined as wBitsPerSample field of WAVEFORMATEX structure
+						// Codec Specific Data Size     WORD         16              // size in bytes of Codec Specific Data buffer - defined as cbSize field of WAVEFORMATEX structure
+						// Codec Specific Data          BYTESTREAM   variable        // array of codec-specific data bytes
+
+						// shortcut
+						$thisfile_asf['audio_media'][$streamnumber] = array();
+						$thisfile_asf_audiomedia_currentstream      = &amp;$thisfile_asf['audio_media'][$streamnumber];
+
+						$audiomediaoffset = 0;
+
+						$thisfile_asf_audiomedia_currentstream = getid3_riff::RIFFparseWAVEFORMATex(substr($streamdata['type_specific_data'], $audiomediaoffset, 16));
+						$audiomediaoffset += 16;
+
+						$thisfile_audio['lossless'] = false;
+						switch ($thisfile_asf_audiomedia_currentstream['raw']['wFormatTag']) {
+							case 0x0001: // PCM
+							case 0x0163: // WMA9 Lossless
+								$thisfile_audio['lossless'] = true;
+								break;
+						}
+
+						if (!isset($thisfile_audio['bitrate'])) {
+							$thisfile_audio['bitrate'] = $thisfile_asf_audiomedia_currentstream['bytes_sec'] * 8;
+						}
+						$thisfile_audio['streams'][$streamnumber]                = $thisfile_asf_audiomedia_currentstream;
+						$thisfile_audio['streams'][$streamnumber]['wformattag']  = $thisfile_asf_audiomedia_currentstream['raw']['wFormatTag'];
+						$thisfile_audio['streams'][$streamnumber]['lossless']    = $thisfile_audio['lossless'];
+						$thisfile_audio['streams'][$streamnumber]['bitrate']     = $thisfile_audio['bitrate'];
+						unset($thisfile_audio['streams'][$streamnumber]['raw']);
+
+						$thisfile_asf_audiomedia_currentstream['codec_data_size'] = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $audiomediaoffset, 2));
+						$audiomediaoffset += 2;
+						$thisfile_asf_audiomedia_currentstream['codec_data']      = substr($streamdata['type_specific_data'], $audiomediaoffset, $thisfile_asf_audiomedia_currentstream['codec_data_size']);
+						$audiomediaoffset += $thisfile_asf_audiomedia_currentstream['codec_data_size'];
+
+						break;
+
+					case GETID3_ASF_Video_Media:
+						// Field Name                   Field Type   Size (bits)
+						// Encoded Image Width          DWORD        32              // width of image in pixels
+						// Encoded Image Height         DWORD        32              // height of image in pixels
+						// Reserved Flags               BYTE         8               // hardcoded: 0x02
+						// Format Data Size             WORD         16              // size of Format Data field in bytes
+						// Format Data                  array of:    variable        //
+						// * Format Data Size           DWORD        32              // number of bytes in Format Data field, in bytes - defined as biSize field of BITMAPINFOHEADER structure
+						// * Image Width                LONG         32              // width of encoded image in pixels - defined as biWidth field of BITMAPINFOHEADER structure
+						// * Image Height               LONG         32              // height of encoded image in pixels - defined as biHeight field of BITMAPINFOHEADER structure
+						// * Reserved                   WORD         16              // hardcoded: 0x0001 - defined as biPlanes field of BITMAPINFOHEADER structure
+						// * Bits Per Pixel Count       WORD         16              // bits per pixel - defined as biBitCount field of BITMAPINFOHEADER structure
+						// * Compression ID             FOURCC       32              // fourcc of video codec - defined as biCompression field of BITMAPINFOHEADER structure
+						// * Image Size                 DWORD        32              // image size in bytes - defined as biSizeImage field of BITMAPINFOHEADER structure
+						// * Horizontal Pixels / Meter  DWORD        32              // horizontal resolution of target device in pixels per meter - defined as biXPelsPerMeter field of BITMAPINFOHEADER structure
+						// * Vertical Pixels / Meter    DWORD        32              // vertical resolution of target device in pixels per meter - defined as biYPelsPerMeter field of BITMAPINFOHEADER structure
+						// * Colors Used Count          DWORD        32              // number of color indexes in the color table that are actually used - defined as biClrUsed field of BITMAPINFOHEADER structure
+						// * Important Colors Count     DWORD        32              // number of color index required for displaying bitmap. if zero, all colors are required. defined as biClrImportant field of BITMAPINFOHEADER structure
+						// * Codec Specific Data        BYTESTREAM   variable        // array of codec-specific data bytes
+
+						// shortcut
+						$thisfile_asf['video_media'][$streamnumber] = array();
+						$thisfile_asf_videomedia_currentstream      = &amp;$thisfile_asf['video_media'][$streamnumber];
+
+						$videomediaoffset = 0;
+						$thisfile_asf_videomedia_currentstream['image_width']                     = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['image_height']                    = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['flags']                           = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 1));
+						$videomediaoffset += 1;
+						$thisfile_asf_videomedia_currentstream['format_data_size']                = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 2));
+						$videomediaoffset += 2;
+						$thisfile_asf_videomedia_currentstream['format_data']['format_data_size'] = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['format_data']['image_width']      = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['format_data']['image_height']     = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['format_data']['reserved']         = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 2));
+						$videomediaoffset += 2;
+						$thisfile_asf_videomedia_currentstream['format_data']['bits_per_pixel']   = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 2));
+						$videomediaoffset += 2;
+						$thisfile_asf_videomedia_currentstream['format_data']['codec_fourcc']     = substr($streamdata['type_specific_data'], $videomediaoffset, 4);
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['format_data']['image_size']       = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['format_data']['horizontal_pels']  = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['format_data']['vertical_pels']    = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['format_data']['colors_used']      = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['format_data']['colors_important'] = getid3_lib::LittleEndian2Int(substr($streamdata['type_specific_data'], $videomediaoffset, 4));
+						$videomediaoffset += 4;
+						$thisfile_asf_videomedia_currentstream['format_data']['codec_data']       = substr($streamdata['type_specific_data'], $videomediaoffset);
+
+
+						$thisfile_asf_videomedia_currentstream['format_data']['codec'] = getid3_riff::RIFFfourccLookup($thisfile_asf_videomedia_currentstream['format_data']['codec_fourcc']);
+
+						$thisfile_video['fourcc']          = $thisfile_asf_videomedia_currentstream['format_data']['codec_fourcc'];
+						$thisfile_video['codec']           = $thisfile_asf_videomedia_currentstream['format_data']['codec'];
+						$thisfile_video['resolution_x']    = $thisfile_asf_videomedia_currentstream['image_width'];
+						$thisfile_video['resolution_y']    = $thisfile_asf_videomedia_currentstream['image_height'];
+						$thisfile_video['bits_per_sample'] = $thisfile_asf_videomedia_currentstream['format_data']['bits_per_pixel'];
+						break;
+
+					default:
+						break;
+				}
+			}
+		}
+
+		while (ftell($fd) &lt; $ThisFileInfo['avdataend']) {
+			$NextObjectDataHeader = fread($fd, 24);
+			$offset = 0;
+			$NextObjectGUID = substr($NextObjectDataHeader, 0, 16);
+			$offset += 16;
+			$NextObjectGUIDtext = $this-&gt;BytestringToGUID($NextObjectGUID);
+			$NextObjectSize = getid3_lib::LittleEndian2Int(substr($NextObjectDataHeader, $offset, 8));
+			$offset += 8;
+
+			switch ($NextObjectGUID) {
+				case GETID3_ASF_Data_Object:
+					// Data Object: (mandatory, one only)
+					// Field Name                       Field Type   Size (bits)
+					// Object ID                        GUID         128             // GUID for Data object - GETID3_ASF_Data_Object
+					// Object Size                      QWORD        64              // size of Data object, including 50 bytes of Data Object header. may be 0 if FilePropertiesObject.BroadcastFlag == 1
+					// File ID                          GUID         128             // unique identifier. identical to File ID field in Header Object
+					// Total Data Packets               QWORD        64              // number of Data Packet entries in Data Object. invalid if FilePropertiesObject.BroadcastFlag == 1
+					// Reserved                         WORD         16              // hardcoded: 0x0101
+
+					// shortcut
+					$thisfile_asf['data_object'] = array();
+					$thisfile_asf_dataobject     = &amp;$thisfile_asf['data_object'];
+
+					$DataObjectData = $NextObjectDataHeader.fread($fd, 50 - 24);
+					$offset = 24;
+
+					$thisfile_asf_dataobject['objectid']           = $NextObjectGUID;
+					$thisfile_asf_dataobject['objectid_guid']      = $NextObjectGUIDtext;
+					$thisfile_asf_dataobject['objectsize']         = $NextObjectSize;
+
+					$thisfile_asf_dataobject['fileid']             = substr($DataObjectData, $offset, 16);
+					$offset += 16;
+					$thisfile_asf_dataobject['fileid_guid']        = $this-&gt;BytestringToGUID($thisfile_asf_dataobject['fileid']);
+					$thisfile_asf_dataobject['total_data_packets'] = getid3_lib::LittleEndian2Int(substr($DataObjectData, $offset, 8));
+					$offset += 8;
+					$thisfile_asf_dataobject['reserved']           = getid3_lib::LittleEndian2Int(substr($DataObjectData, $offset, 2));
+					$offset += 2;
+					if ($thisfile_asf_dataobject['reserved'] != 0x0101) {
+						$ThisFileInfo['warning'][] = 'data_object.reserved ('.getid3_lib::PrintHexBytes($thisfile_asf_dataobject['reserved']).') does not match expected value of &quot;0x0101&quot;';
+						//return false;
+						break;
+					}
+
+					// Data Packets                     array of:    variable        //
+					// * Error Correction Flags         BYTE         8               //
+					// * * Error Correction Data Length bits         4               // if Error Correction Length Type == 00, size of Error Correction Data in bytes, else hardcoded: 0000
+					// * * Opaque Data Present          bits         1               //
+					// * * Error Correction Length Type bits         2               // number of bits for size of the error correction data. hardcoded: 00
+					// * * Error Correction Present     bits         1               // If set, use Opaque Data Packet structure, else use Payload structure
+					// * Error Correction Data
+
+					$ThisFileInfo['avdataoffset'] = ftell($fd);
+					fseek($fd, ($thisfile_asf_dataobject['objectsize'] - 50), SEEK_CUR); // skip actual audio/video data
+					$ThisFileInfo['avdataend'] = ftell($fd);
+					break;
+
+				case GETID3_ASF_Simple_Index_Object:
+					// Simple Index Object: (optional, recommended, one per video stream)
+					// Field Name                       Field Type   Size (bits)
+					// Object ID                        GUID         128             // GUID for Simple Index object - GETID3_ASF_Data_Object
+					// Object Size                      QWORD        64              // size of Simple Index object, including 56 bytes of Simple Index Object header
+					// File ID                          GUID         128             // unique identifier. may be zero or identical to File ID field in Data Object and Header Object
+					// Index Entry Time Interval        QWORD        64              // interval between index entries in 100-nanosecond units
+					// Maximum Packet Count             DWORD        32              // maximum packet count for all index entries
+					// Index Entries Count              DWORD        32              // number of Index Entries structures
+					// Index Entries                    array of:    variable        //
+					// * Packet Number                  DWORD        32              // number of the Data Packet associated with this index entry
+					// * Packet Count                   WORD         16              // number of Data Packets to sent at this index entry
+
+					// shortcut
+					$thisfile_asf['simple_index_object'] = array();
+					$thisfile_asf_simpleindexobject      = &amp;$thisfile_asf['simple_index_object'];
+
+					$SimpleIndexObjectData = $NextObjectDataHeader.fread($fd, 56 - 24);
+					$offset = 24;
+
+					$thisfile_asf_simpleindexobject['objectid']                  = $NextObjectGUID;
+					$thisfile_asf_simpleindexobject['objectid_guid']             = $NextObjectGUIDtext;
+					$thisfile_asf_simpleindexobject['objectsize']                = $NextObjectSize;
+
+					$thisfile_asf_simpleindexobject['fileid']                    =                  substr($SimpleIndexObjectData, $offset, 16);
+					$offset += 16;
+					$thisfile_asf_simpleindexobject['fileid_guid']               = $this-&gt;BytestringToGUID($thisfile_asf_simpleindexobject['fileid']);
+					$thisfile_asf_simpleindexobject['index_entry_time_interval'] = getid3_lib::LittleEndian2Int(substr($SimpleIndexObjectData, $offset, 8));
+					$offset += 8;
+					$thisfile_asf_simpleindexobject['maximum_packet_count']      = getid3_lib::LittleEndian2Int(substr($SimpleIndexObjectData, $offset, 4));
+					$offset += 4;
+					$thisfile_asf_simpleindexobject['index_entries_count']       = getid3_lib::LittleEndian2Int(substr($SimpleIndexObjectData, $offset, 4));
+					$offset += 4;
+
+					$IndexEntriesData = $SimpleIndexObjectData.fread($fd, 6 * $thisfile_asf_simpleindexobject['index_entries_count']);
+					for ($IndexEntriesCounter = 0; $IndexEntriesCounter &lt; $thisfile_asf_simpleindexobject['index_entries_count']; $IndexEntriesCounter++) {
+						$thisfile_asf_simpleindexobject['index_entries'][$IndexEntriesCounter]['packet_number'] = getid3_lib::LittleEndian2Int(substr($IndexEntriesData, $offset, 4));
+						$offset += 4;
+						$thisfile_asf_simpleindexobject['index_entries'][$IndexEntriesCounter]['packet_count']  = getid3_lib::LittleEndian2Int(substr($IndexEntriesData, $offset, 4));
+						$offset += 2;
+					}
+
+					break;
+
+				case GETID3_ASF_Index_Object:
+					// 6.2 ASF top-level Index Object (optional but recommended when appropriate, 0 or 1)
+					// Field Name                       Field Type   Size (bits)
+					// Object ID                        GUID         128             // GUID for the Index Object - GETID3_ASF_Index_Object
+					// Object Size                      QWORD        64              // Specifies the size, in bytes, of the Index Object, including at least 34 bytes of Index Object header
+					// Index Entry Time Interval        DWORD        32              // Specifies the time interval between each index entry in ms.
+					// Index Specifiers Count           WORD         16              // Specifies the number of Index Specifiers structures in this Index Object.
+					// Index Blocks Count               DWORD        32              // Specifies the number of Index Blocks structures in this Index Object.
+
+					// Index Entry Time Interval        DWORD        32              // Specifies the time interval between index entries in milliseconds.  This value cannot be 0.
+					// Index Specifiers Count           WORD         16              // Specifies the number of entries in the Index Specifiers list.  Valid values are 1 and greater.
+					// Index Specifiers                 array of:    varies          //
+					// * Stream Number                  WORD         16              // Specifies the stream number that the Index Specifiers refer to. Valid values are between 1 and 127.
+					// * Index Type                     WORD         16              // Specifies Index Type values as follows:
+																					//   1 = Nearest Past Data Packet - indexes point to the data packet whose presentation time is closest to the index entry time.
+																					//   2 = Nearest Past Media Object - indexes point to the closest data packet containing an entire object or first fragment of an object.
+																					//   3 = Nearest Past Cleanpoint. - indexes point to the closest data packet containing an entire object (or first fragment of an object) that has the Cleanpoint Flag set.
+																					//   Nearest Past Cleanpoint is the most common type of index.
+					// Index Entry Count                DWORD        32              // Specifies the number of Index Entries in the block.
+					// * Block Positions                QWORD        varies          // Specifies a list of byte offsets of the beginnings of the blocks relative to the beginning of the first Data Packet (i.e., the beginning of the Data Object + 50 bytes). The number of entries in this list is specified by the value of the Index Specifiers Count field. The order of those byte offsets is tied to the order in which Index Specifiers are listed.
+					// * Index Entries                  array of:    varies          //
+					// * * Offsets                      DWORD        varies          // An offset value of 0xffffffff indicates an invalid offset value
+
+					// shortcut
+					$thisfile_asf['asf_index_object'] = array();
+					$thisfile_asf_asfindexobject      = &amp;$thisfile_asf['asf_index_object'];
+
+					$ASFIndexObjectData = $NextObjectDataHeader.fread($fd, 34 - 24);
+					$offset = 24;
+
+					$thisfile_asf_asfindexobject['objectid']                  = $NextObjectGUID;
+					$thisfile_asf_asfindexobject['objectid_guid']             = $NextObjectGUIDtext;
+					$thisfile_asf_asfindexobject['objectsize']                = $NextObjectSize;
+
+					$thisfile_asf_asfindexobject['entry_time_interval']       = getid3_lib::LittleEndian2Int(substr($ASFIndexObjectData, $offset, 4));
+					$offset += 4;
+					$thisfile_asf_asfindexobject['index_specifiers_count']    = getid3_lib::LittleEndian2Int(substr($ASFIndexObjectData, $offset, 2));
+					$offset += 2;
+					$thisfile_asf_asfindexobject['index_blocks_count']        = getid3_lib::LittleEndian2Int(substr($ASFIndexObjectData, $offset, 4));
+					$offset += 4;
+
+					$ASFIndexObjectData .= fread($fd, 4 * $thisfile_asf_asfindexobject['index_specifiers_count']);
+					for ($IndexSpecifiersCounter = 0; $IndexSpecifiersCounter &lt; $thisfile_asf_asfindexobject['index_specifiers_count']; $IndexSpecifiersCounter++) {
+						$IndexSpecifierStreamNumber = getid3_lib::LittleEndian2Int(substr($ASFIndexObjectData, $offset, 2));
+						$offset += 2;
+						$thisfile_asf_asfindexobject['index_specifiers'][$IndexSpecifiersCounter]['stream_number']   = $IndexSpecifierStreamNumber;
+						$thisfile_asf_asfindexobject['index_specifiers'][$IndexSpecifiersCounter]['index_type']      = getid3_lib::LittleEndian2Int(substr($ASFIndexObjectData, $offset, 2));
+						$offset += 2;
+						$thisfile_asf_asfindexobject['index_specifiers'][$IndexSpecifiersCounter]['index_type_text'] = $this-&gt;ASFIndexObjectIndexTypeLookup($thisfile_asf_asfindexobject['index_specifiers'][$IndexSpecifiersCounter]['index_type']);
+					}
+
+					$ASFIndexObjectData .= fread($fd, 4);
+					$thisfile_asf_asfindexobject['index_entry_count'] = getid3_lib::LittleEndian2Int(substr($ASFIndexObjectData, $offset, 4));
+					$offset += 4;
+
+					$ASFIndexObjectData .= fread($fd, 8 * $thisfile_asf_asfindexobject['index_specifiers_count']);
+					for ($IndexSpecifiersCounter = 0; $IndexSpecifiersCounter &lt; $thisfile_asf_asfindexobject['index_specifiers_count']; $IndexSpecifiersCounter++) {
+						$thisfile_asf_asfindexobject['block_positions'][$IndexSpecifiersCounter] = getid3_lib::LittleEndian2Int(substr($ASFIndexObjectData, $offset, 8));
+						$offset += 8;
+					}
+
+					$ASFIndexObjectData .= fread($fd, 4 * $thisfile_asf_asfindexobject['index_specifiers_count'] * $thisfile_asf_asfindexobject['index_entry_count']);
+					for ($IndexEntryCounter = 0; $IndexEntryCounter &lt; $thisfile_asf_asfindexobject['index_entry_count']; $IndexEntryCounter++) {
+						for ($IndexSpecifiersCounter = 0; $IndexSpecifiersCounter &lt; $thisfile_asf_asfindexobject['index_specifiers_count']; $IndexSpecifiersCounter++) {
+							$thisfile_asf_asfindexobject['offsets'][$IndexSpecifiersCounter][$IndexEntryCounter] = getid3_lib::LittleEndian2Int(substr($ASFIndexObjectData, $offset, 4));
+							$offset += 4;
+						}
+					}
+					break;
+
+
+				default:
+					// Implementations shall ignore any standard or non-standard object that they do not know how to handle.
+					if ($this-&gt;GUIDname($NextObjectGUIDtext)) {
+						$ThisFileInfo['warning'][] = 'unhandled GUID &quot;'.$this-&gt;GUIDname($NextObjectGUIDtext).'&quot; {'.$NextObjectGUIDtext.'} in ASF body at offset '.($offset - 16 - 8);
+					} else {
+						$ThisFileInfo['warning'][] = 'unknown GUID {'.$NextObjectGUIDtext.'} in ASF body at offset '.(ftell($fd) - 16 - 8);
+					}
+					fseek($fd, ($NextObjectSize - 16 - 8), SEEK_CUR);
+					break;
+			}
+		}
+
+		if (isset($thisfile_asf_codeclistobject['codec_entries']) &amp;&amp; is_array($thisfile_asf_codeclistobject['codec_entries'])) {
+			foreach ($thisfile_asf_codeclistobject['codec_entries'] as $streamnumber =&gt; $streamdata) {
+				switch ($streamdata['information']) {
+					case 'WMV1':
+					case 'WMV2':
+					case 'WMV3':
+						$thisfile_video['dataformat'] = 'wmv';
+						$ThisFileInfo['mime_type']    = 'video/x-ms-wmv';
+						break;
+
+					case 'MP42':
+					case 'MP43':
+					case 'MP4S':
+					case 'mp4s':
+						$thisfile_video['dataformat'] = 'asf';
+						$ThisFileInfo['mime_type']    = 'video/x-ms-asf';
+						break;
+
+					default:
+						switch ($streamdata['type_raw']) {
+							case 1:
+								if (strstr($this-&gt;TrimConvert($streamdata['name']), 'Windows Media')) {
+									$thisfile_video['dataformat'] = 'wmv';
+									if ($ThisFileInfo['mime_type'] == 'video/x-ms-asf') {
+										$ThisFileInfo['mime_type'] = 'video/x-ms-wmv';
+									}
+								}
+								break;
+
+							case 2:
+								if (strstr($this-&gt;TrimConvert($streamdata['name']), 'Windows Media')) {
+									$thisfile_audio['dataformat'] = 'wma';
+									if ($ThisFileInfo['mime_type'] == 'video/x-ms-asf') {
+										$ThisFileInfo['mime_type'] = 'audio/x-ms-wma';
+									}
+								}
+								break;
+
+						}
+						break;
+				}
+			}
+		}
+
+		switch ($thisfile_audio['codec']) {
+			case 'MPEG Layer-3':
+				$thisfile_audio['dataformat'] = 'mp3';
+				break;
+
+			default:
+				break;
+		}
+
+		if (isset($thisfile_asf_codeclistobject['codec_entries'])) {
+			foreach ($thisfile_asf_codeclistobject['codec_entries'] as $streamnumber =&gt; $streamdata) {
+				switch ($streamdata['type_raw']) {
+
+					case 1: // video
+						$thisfile_video['encoder'] = $this-&gt;TrimConvert($thisfile_asf_codeclistobject['codec_entries'][$streamnumber]['name']);
+						break;
+
+					case 2: // audio
+						$thisfile_audio['encoder'] = $this-&gt;TrimConvert($thisfile_asf_codeclistobject['codec_entries'][$streamnumber]['name']);
+
+						// AH 2003-10-01
+						$thisfile_audio['encoder_options'] = $this-&gt;TrimConvert($thisfile_asf_codeclistobject['codec_entries'][0]['description']);
+
+						$thisfile_audio['codec']   = $thisfile_audio['encoder'];
+						break;
+
+					default:
+						$ThisFileInfo['warning'][] = 'Unknown streamtype: [codec_list_object][codec_entries]['.$streamnumber.'][type_raw] == '.$streamdata['type_raw'];
+						break;
+
+				}
+			}
+		}
+
+		if (isset($ThisFileInfo['audio'])) {
+			$thisfile_audio['lossless']           = (isset($thisfile_audio['lossless'])           ? $thisfile_audio['lossless']           : false);
+			$thisfile_audio['dataformat']         = (!empty($thisfile_audio['dataformat'])        ? $thisfile_audio['dataformat']         : 'asf');
+		}
+		if (!empty($thisfile_video['dataformat'])) {
+			$thisfile_video['lossless']           = (isset($thisfile_audio['lossless'])           ? $thisfile_audio['lossless']           : false);
+			$thisfile_video['pixel_aspect_ratio'] = (isset($thisfile_audio['pixel_aspect_ratio']) ? $thisfile_audio['pixel_aspect_ratio'] : (float) 1);
+			$thisfile_video['dataformat']         = (!empty($thisfile_video['dataformat'])        ? $thisfile_video['dataformat']         : 'asf');
+		}
+
+		return true;
+	}
+
+	function ASFCodecListObjectTypeLookup($CodecListType) {
+		static $ASFCodecListObjectTypeLookup = array();
+		if (empty($ASFCodecListObjectTypeLookup)) {
+			$ASFCodecListObjectTypeLookup[0x0001] = 'Video Codec';
+			$ASFCodecListObjectTypeLookup[0x0002] = 'Audio Codec';
+			$ASFCodecListObjectTypeLookup[0xFFFF] = 'Unknown Codec';
+		}
+
+		return (isset($ASFCodecListObjectTypeLookup[$CodecListType]) ? $ASFCodecListObjectTypeLookup[$CodecListType] : 'Invalid Codec Type');
+	}
+
+	function KnownGUIDs() {
+		static $GUIDarray = array();
+		if (empty($GUIDarray)) {
+			$GUIDarray['GETID3_ASF_Extended_Stream_Properties_Object']   = '14E6A5CB-C672-4332-8399-A96952065B5A';
+			$GUIDarray['GETID3_ASF_Padding_Object']                      = '1806D474-CADF-4509-A4BA-9AABCB96AAE8';
+			$GUIDarray['GETID3_ASF_Payload_Ext_Syst_Pixel_Aspect_Ratio'] = '1B1EE554-F9EA-4BC8-821A-376B74E4C4B8';
+			$GUIDarray['GETID3_ASF_Script_Command_Object']               = '1EFB1A30-0B62-11D0-A39B-00A0C90348F6';
+			$GUIDarray['GETID3_ASF_No_Error_Correction']                 = '20FB5700-5B55-11CF-A8FD-00805F5C442B';
+			$GUIDarray['GETID3_ASF_Content_Branding_Object']             = '2211B3FA-BD23-11D2-B4B7-00A0C955FC6E';
+			$GUIDarray['GETID3_ASF_Content_Encryption_Object']           = '2211B3FB-BD23-11D2-B4B7-00A0C955FC6E';
+			$GUIDarray['GETID3_ASF_Digital_Signature_Object']            = '2211B3FC-BD23-11D2-B4B7-00A0C955FC6E';
+			$GUIDarray['GETID3_ASF_Extended_Content_Encryption_Object']  = '298AE614-2622-4C17-B935-DAE07EE9289C';
+			$GUIDarray['GETID3_ASF_Simple_Index_Object']                 = '33000890-E5B1-11CF-89F4-00A0C90349CB';
+			$GUIDarray['GETID3_ASF_Degradable_JPEG_Media']               = '35907DE0-E415-11CF-A917-00805F5C442B';
+			$GUIDarray['GETID3_ASF_Payload_Extension_System_Timecode']   = '399595EC-8667-4E2D-8FDB-98814CE76C1E';
+			$GUIDarray['GETID3_ASF_Binary_Media']                        = '3AFB65E2-47EF-40F2-AC2C-70A90D71D343';
+			$GUIDarray['GETID3_ASF_Timecode_Index_Object']               = '3CB73FD0-0C4A-4803-953D-EDF7B6228F0C';
+			$GUIDarray['GETID3_ASF_Metadata_Library_Object']             = '44231C94-9498-49D1-A141-1D134E457054';
+			$GUIDarray['GETID3_ASF_Reserved_3']                          = '4B1ACBE3-100B-11D0-A39B-00A0C90348F6';
+			$GUIDarray['GETID3_ASF_Reserved_4']                          = '4CFEDB20-75F6-11CF-9C0F-00A0C90349CB';
+			$GUIDarray['GETID3_ASF_Command_Media']                       = '59DACFC0-59E6-11D0-A3AC-00A0C90348F6';
+			$GUIDarray['GETID3_ASF_Header_Extension_Object']             = '5FBF03B5-A92E-11CF-8EE3-00C00C205365';
+			$GUIDarray['GETID3_ASF_Media_Object_Index_Parameters_Obj']   = '6B203BAD-3F11-4E84-ACA8-D7613DE2CFA7';
+			$GUIDarray['GETID3_ASF_Header_Object']                       = '75B22630-668E-11CF-A6D9-00AA0062CE6C';
+			$GUIDarray['GETID3_ASF_Content_Description_Object']          = '75B22633-668E-11CF-A6D9-00AA0062CE6C';
+			$GUIDarray['GETID3_ASF_Error_Correction_Object']             = '75B22635-668E-11CF-A6D9-00AA0062CE6C';
+			$GUIDarray['GETID3_ASF_Data_Object']                         = '75B22636-668E-11CF-A6D9-00AA0062CE6C';
+			$GUIDarray['GETID3_ASF_Web_Stream_Media_Subtype']            = '776257D4-C627-41CB-8F81-7AC7FF1C40CC';
+			$GUIDarray['GETID3_ASF_Stream_Bitrate_Properties_Object']    = '7BF875CE-468D-11D1-8D82-006097C9A2B2';
+			$GUIDarray['GETID3_ASF_Language_List_Object']                = '7C4346A9-EFE0-4BFC-B229-393EDE415C85';
+			$GUIDarray['GETID3_ASF_Codec_List_Object']                   = '86D15240-311D-11D0-A3A4-00A0C90348F6';
+			$GUIDarray['GETID3_ASF_Reserved_2']                          = '86D15241-311D-11D0-A3A4-00A0C90348F6';
+			$GUIDarray['GETID3_ASF_File_Properties_Object']              = '8CABDCA1-A947-11CF-8EE4-00C00C205365';
+			$GUIDarray['GETID3_ASF_File_Transfer_Media']                 = '91BD222C-F21C-497A-8B6D-5AA86BFC0185';
+			$GUIDarray['GETID3_ASF_Old_RTP_Extension_Data']              = '96800C63-4C94-11D1-837B-0080C7A37F95';
+			$GUIDarray['GETID3_ASF_Advanced_Mutual_Exclusion_Object']    = 'A08649CF-4775-4670-8A16-6E35357566CD';
+			$GUIDarray['GETID3_ASF_Bandwidth_Sharing_Object']            = 'A69609E6-517B-11D2-B6AF-00C04FD908E9';
+			$GUIDarray['GETID3_ASF_Reserved_1']                          = 'ABD3D211-A9BA-11cf-8EE6-00C00C205365';
+			$GUIDarray['GETID3_ASF_Bandwidth_Sharing_Exclusive']         = 'AF6060AA-5197-11D2-B6AF-00C04FD908E9';
+			$GUIDarray['GETID3_ASF_Bandwidth_Sharing_Partial']           = 'AF6060AB-5197-11D2-B6AF-00C04FD908E9';
+			$GUIDarray['GETID3_ASF_JFIF_Media']                          = 'B61BE100-5B4E-11CF-A8FD-00805F5C442B';
+			$GUIDarray['GETID3_ASF_Stream_Properties_Object']            = 'B7DC0791-A9B7-11CF-8EE6-00C00C205365';
+			$GUIDarray['GETID3_ASF_Video_Media']                         = 'BC19EFC0-5B4D-11CF-A8FD-00805F5C442B';
+			$GUIDarray['GETID3_ASF_Audio_Spread']                        = 'BFC3CD50-618F-11CF-8BB2-00AA00B4E220';
+			$GUIDarray['GETID3_ASF_Metadata_Object']                     = 'C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA';
+			$GUIDarray['GETID3_ASF_Payload_Ext_Syst_Sample_Duration']    = 'C6BD9450-867F-4907-83A3-C77921B733AD';
+			$GUIDarray['GETID3_ASF_Group_Mutual_Exclusion_Object']       = 'D1465A40-5A79-4338-B71B-E36B8FD6C249';
+			$GUIDarray['GETID3_ASF_Extended_Content_Description_Object'] = 'D2D0A440-E307-11D2-97F0-00A0C95EA850';
+			$GUIDarray['GETID3_ASF_Stream_Prioritization_Object']        = 'D4FED15B-88D3-454F-81F0-ED5C45999E24';
+			$GUIDarray['GETID3_ASF_Payload_Ext_System_Content_Type']     = 'D590DC20-07BC-436C-9CF7-F3BBFBF1A4DC';
+			$GUIDarray['GETID3_ASF_Old_File_Properties_Object']          = 'D6E229D0-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_ASF_Header_Object']               = 'D6E229D1-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_ASF_Data_Object']                 = 'D6E229D2-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Index_Object']                        = 'D6E229D3-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Stream_Properties_Object']        = 'D6E229D4-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Content_Description_Object']      = 'D6E229D5-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Script_Command_Object']           = 'D6E229D6-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Marker_Object']                   = 'D6E229D7-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Component_Download_Object']       = 'D6E229D8-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Stream_Group_Object']             = 'D6E229D9-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Scalable_Object']                 = 'D6E229DA-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Prioritization_Object']           = 'D6E229DB-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Bitrate_Mutual_Exclusion_Object']     = 'D6E229DC-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Inter_Media_Dependency_Object']   = 'D6E229DD-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Rating_Object']                   = 'D6E229DE-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Index_Parameters_Object']             = 'D6E229DF-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Color_Table_Object']              = 'D6E229E0-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Language_List_Object']            = 'D6E229E1-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Audio_Media']                     = 'D6E229E2-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Video_Media']                     = 'D6E229E3-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Image_Media']                     = 'D6E229E4-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Timecode_Media']                  = 'D6E229E5-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Text_Media']                      = 'D6E229E6-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_MIDI_Media']                      = 'D6E229E7-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Command_Media']                   = 'D6E229E8-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_No_Error_Concealment']            = 'D6E229EA-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Scrambled_Audio']                 = 'D6E229EB-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_No_Color_Table']                  = 'D6E229EC-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_SMPTE_Time']                      = 'D6E229ED-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_ASCII_Text']                      = 'D6E229EE-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Unicode_Text']                    = 'D6E229EF-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_HTML_Text']                       = 'D6E229F0-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_URL_Command']                     = 'D6E229F1-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Filename_Command']                = 'D6E229F2-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_ACM_Codec']                       = 'D6E229F3-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_VCM_Codec']                       = 'D6E229F4-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_QuickTime_Codec']                 = 'D6E229F5-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_DirectShow_Transform_Filter']     = 'D6E229F6-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_DirectShow_Rendering_Filter']     = 'D6E229F7-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_No_Enhancement']                  = 'D6E229F8-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Unknown_Enhancement_Type']        = 'D6E229F9-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Temporal_Enhancement']            = 'D6E229FA-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Spatial_Enhancement']             = 'D6E229FB-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Quality_Enhancement']             = 'D6E229FC-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Number_of_Channels_Enhancement']  = 'D6E229FD-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Frequency_Response_Enhancement']  = 'D6E229FE-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Media_Object']                    = 'D6E229FF-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Mutex_Language']                      = 'D6E22A00-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Mutex_Bitrate']                       = 'D6E22A01-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Mutex_Unknown']                       = 'D6E22A02-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_ASF_Placeholder_Object']          = 'D6E22A0E-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Old_Data_Unit_Extension_Object']      = 'D6E22A0F-35DA-11D1-9034-00A0C90349BE';
+			$GUIDarray['GETID3_ASF_Web_Stream_Format']                   = 'DA1E6B13-8359-4050-B398-388E965BF00C';
+			$GUIDarray['GETID3_ASF_Payload_Ext_System_File_Name']        = 'E165EC0E-19ED-45D7-B4A7-25CBD1E28E9B';
+			$GUIDarray['GETID3_ASF_Marker_Object']                       = 'F487CD01-A951-11CF-8EE6-00C00C205365';
+			$GUIDarray['GETID3_ASF_Timecode_Index_Parameters_Object']    = 'F55E496D-9797-4B5D-8C8B-604DFE9BFB24';
+			$GUIDarray['GETID3_ASF_Audio_Media']                         = 'F8699E40-5B4D-11CF-A8FD-00805F5C442B';
+			$GUIDarray['GETID3_ASF_Media_Object_Index_Object']           = 'FEB103F8-12AD-4C64-840F-2A1D2F7AD48C';
+			$GUIDarray['GETID3_ASF_Alt_Extended_Content_Encryption_Obj'] = 'FF889EF1-ADEE-40DA-9E71-98704BB928CE';
+		}
+		return $GUIDarray;
+	}
+
+	function GUIDname($GUIDstring) {
+		static $GUIDarray = array();
+		if (empty($GUIDarray)) {
+			$GUIDarray = $this-&gt;KnownGUIDs();
+		}
+		return array_search($GUIDstring, $GUIDarray);
+	}
+
+	function ASFIndexObjectIndexTypeLookup($id) {
+		static $ASFIndexObjectIndexTypeLookup = array();
+		if (empty($ASFIndexObjectIndexTypeLookup)) {
+			$ASFIndexObjectIndexTypeLookup[1] = 'Nearest Past Data Packet';
+			$ASFIndexObjectIndexTypeLookup[2] = 'Nearest Past Media Object';
+			$ASFIndexObjectIndexTypeLookup[3] = 'Nearest Past Cleanpoint';
+		}
+		return (isset($ASFIndexObjectIndexTypeLookup[$id]) ? $ASFIndexObjectIndexTypeLookup[$id] : 'invalid');
+	}
+
+	function GUIDtoBytestring($GUIDstring) {
+		// Microsoft defines these 16-byte (128-bit) GUIDs in the strangest way:
+		// first 4 bytes are in little-endian order
+		// next 2 bytes are appended in little-endian order
+		// next 2 bytes are appended in little-endian order
+		// next 2 bytes are appended in big-endian order
+		// next 6 bytes are appended in big-endian order
+
+		// AaBbCcDd-EeFf-GgHh-IiJj-KkLlMmNnOoPp is stored as this 16-byte string:
+		// $Dd $Cc $Bb $Aa $Ff $Ee $Hh $Gg $Ii $Jj $Kk $Ll $Mm $Nn $Oo $Pp
+
+		$hexbytecharstring  = chr(hexdec(substr($GUIDstring,  6, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring,  4, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring,  2, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring,  0, 2)));
+
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 11, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring,  9, 2)));
+
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 16, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 14, 2)));
+
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 19, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 21, 2)));
+
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 24, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 26, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 28, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 30, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 32, 2)));
+		$hexbytecharstring .= chr(hexdec(substr($GUIDstring, 34, 2)));
+
+		return $hexbytecharstring;
+	}
+
+	function BytestringToGUID($Bytestring) {
+		$GUIDstring  = str_pad(dechex(ord($Bytestring{3})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{2})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{1})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{0})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= '-';
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{5})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{4})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= '-';
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{7})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{6})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= '-';
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{8})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{9})),  2, '0', STR_PAD_LEFT);
+		$GUIDstring .= '-';
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{10})), 2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{11})), 2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{12})), 2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{13})), 2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{14})), 2, '0', STR_PAD_LEFT);
+		$GUIDstring .= str_pad(dechex(ord($Bytestring{15})), 2, '0', STR_PAD_LEFT);
+
+		return strtoupper($GUIDstring);
+	}
+
+	function FILETIMEtoUNIXtime($FILETIME, $round=true) {
+		// FILETIME is a 64-bit unsigned integer representing
+		// the number of 100-nanosecond intervals since January 1, 1601
+		// UNIX timestamp is number of seconds since January 1, 1970
+		// 116444736000000000 = 10000000 * 60 * 60 * 24 * 365 * 369 + 89 leap days
+		if ($round) {
+			return intval(round(($FILETIME - 116444736000000000) / 10000000));
+		}
+		return ($FILETIME - 116444736000000000) / 10000000;
+	}
+
+	function WMpictureTypeLookup($WMpictureType) {
+		static $WMpictureTypeLookup = array();
+		if (empty($WMpictureTypeLookup)) {
+			$WMpictureTypeLookup[0x03] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Front Cover');
+			$WMpictureTypeLookup[0x04] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Back Cover');
+			$WMpictureTypeLookup[0x00] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'User Defined');
+			$WMpictureTypeLookup[0x05] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Leaflet Page');
+			$WMpictureTypeLookup[0x06] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Media Label');
+			$WMpictureTypeLookup[0x07] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Lead Artist');
+			$WMpictureTypeLookup[0x08] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Artist');
+			$WMpictureTypeLookup[0x09] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Conductor');
+			$WMpictureTypeLookup[0x0A] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Band');
+			$WMpictureTypeLookup[0x0B] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Composer');
+			$WMpictureTypeLookup[0x0C] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Lyricist');
+			$WMpictureTypeLookup[0x0D] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Recording Location');
+			$WMpictureTypeLookup[0x0E] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'During Recording');
+			$WMpictureTypeLookup[0x0F] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'During Performance');
+			$WMpictureTypeLookup[0x10] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Video Screen Capture');
+			$WMpictureTypeLookup[0x12] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Illustration');
+			$WMpictureTypeLookup[0x13] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Band Logotype');
+			$WMpictureTypeLookup[0x14] = getid3_lib::iconv_fallback('ISO-8859-1', 'UTF-16LE', 'Publisher Logotype');
+		}
+		return @$WMpictureTypeLookup[$WMpictureType];
+	}
+
+
+	// Remove terminator 00 00 and convert UNICODE to Latin-1
+	function TrimConvert($string) {
+
+		// remove terminator, only if present (it should be, but...)
+		if (substr($string, strlen($string) - 2, 2) == &quot;\x00\x00&quot;) {
+			$string = substr($string, 0, strlen($string) - 2);
+		}
+
+		// convert
+		return trim(getid3_lib::iconv_fallback('UTF-16LE', 'ISO-8859-1', $string), ' ');
+	}
+
+
+	function TrimTerm($string) {
+
+		// remove terminator, only if present (it should be, but...)
+		if (substr($string, -2) == &quot;\x00\x00&quot;) {
+			$string = substr($string, 0, -2);
+		}
+		return $string;
+	}
+
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.bink.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.bink.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.bink.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,70 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.bink.php                                       //
+// module for analyzing Bink or Smacker audio-video files      //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_bink
+{
+
+	function getid3_bink(&amp;$fd, &amp;$ThisFileInfo) {
+
+$ThisFileInfo['error'][] = 'Bink / Smacker files not properly processed by this version of getID3()';
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$fileTypeID = fread($fd, 3);
+		switch ($fileTypeID) {
+			case 'BIK':
+				return $this-&gt;ParseBink($fd, $ThisFileInfo);
+				break;
+
+			case 'SMK':
+				return $this-&gt;ParseSmacker($fd, $ThisFileInfo);
+				break;
+
+			default:
+				$ThisFileInfo['error'][] = 'Expecting &quot;BIK&quot; or &quot;SMK&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$fileTypeID.'&quot;';
+				return false;
+				break;
+		}
+
+		return true;
+
+	}
+
+	function ParseBink(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat']          = 'bink';
+		$ThisFileInfo['video']['dataformat'] = 'bink';
+
+		$fileData = 'BIK'.fread($fd, 13);
+
+		$ThisFileInfo['bink']['data_size']   = getid3_lib::LittleEndian2Int(substr($fileData, 4, 4));
+		$ThisFileInfo['bink']['frame_count'] = getid3_lib::LittleEndian2Int(substr($fileData, 8, 2));
+
+		if (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) != ($ThisFileInfo['bink']['data_size'] + 8)) {
+			$ThisFileInfo['error'][] = 'Probably truncated file: expecting '.$ThisFileInfo['bink']['data_size'].' bytes, found '.($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']);
+		}
+
+		return true;
+	}
+
+	function ParseSmacker(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat']          = 'smacker';
+		$ThisFileInfo['video']['dataformat'] = 'smacker';
+
+		return false;
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.flv.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.flv.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.flv.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,210 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+//                                                             //
+//  FLV module by Seth Kaufman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">seth at whirl-i-gig.com</A>&gt;          //
+//  * version 0.1 (26 June 2005)                               //
+//  minor modifications by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;    //
+//  * version 0.1.1 (15 July 2005)                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio-video.flv.php                                  //
+// module for analyzing Shockwave Flash Video files            //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_flv
+{
+
+	function getid3_flv(&amp;$fd, &amp;$ThisFileInfo, $ReturnAllTagData=false) {
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+		$FLVfileData = fread($fd, $ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']);
+
+		$FLVmagic = substr($FLVfileData, 0, 3);
+		if ($FLVmagic != 'FLV') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;FLV&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$ThisFileInfo['flv']['header']['signature'].'&quot;';
+			unset($ThisFileInfo['flv']);
+			unset($ThisFileInfo['fileformat']);
+			return false;
+		}
+		$ThisFileInfo['flv']['header']['signature'] = $FLVmagic;
+		$ThisFileInfo['flv']['header']['version']   = ord($FLVfileData{3});
+		$ThisFileInfo['fileformat'] = 'flv';
+
+		$TypeFlags = ord($FLVfileData{4});
+		$ThisFileInfo['flv']['header']['hasAudio'] = (bool) ($TypeFlags &amp; 4);
+		$ThisFileInfo['flv']['header']['hasVideo'] = (bool) ($TypeFlags &amp; 1);
+
+		$FrameSizeDataLength = getid3_lib::BigEndian2Int(substr($FLVfileData, 5, 4));
+
+		// FLV tags
+		$CurrentOffset = $FrameSizeDataLength;
+		$FLVdataLength = strlen($FLVfileData);
+
+		$Duration = 0;
+
+		$SoundFormat = null;
+		$VideoFormat = null;
+		while ($CurrentOffset &lt; $FLVdataLength) {
+			// previous tag size
+			$PreviousTagLength = getid3_lib::BigEndian2Int(substr($FLVfileData, $CurrentOffset, 4));
+			$CurrentOffset += 4;
+
+			$TagType = ord(substr($FLVfileData, $CurrentOffset, 1));
+			$DataLength = getid3_lib::BigEndian2Int(substr($FLVfileData, $CurrentOffset + 1, 3));
+			$Timestamp  = getid3_lib::BigEndian2Int(substr($FLVfileData, $CurrentOffset + 4, 3));
+
+			switch ($TagType) {
+				case 8:
+					if (is_null($SoundFormat)) {
+						$SoundInfo = ord(substr($FLVfileData, $CurrentOffset + 11, 1));
+						$SoundFormat = $SoundInfo &amp; 0x07;
+						$ThisFileInfo['flv']['audio']['audioFormat']     = $SoundFormat;
+						$ThisFileInfo['flv']['audio']['audioRate']       = ($SoundInfo &amp; 0x30) / 0x10;
+						$ThisFileInfo['flv']['audio']['audioSampleSize'] = ($SoundInfo &amp; 0x40) / 0x40;
+						$ThisFileInfo['flv']['audio']['audioType']       = ($SoundInfo &amp; 0x80) / 0x80;
+					}
+					break;
+
+				case 9:
+					if (is_null($VideoFormat)) {
+						$VideoInfo = ord(substr($FLVfileData, $CurrentOffset + 11, 1));
+						$VideoFormat = $VideoInfo &amp; 0x07;
+						$ThisFileInfo['flv']['video']['videoCodec'] = $VideoFormat;
+
+						$PictureSizeType = (getid3_lib::BigEndian2Int(substr($FLVfileData, $CurrentOffset + 15, 2))) &gt;&gt; 7;
+						$PictureSizeType = $PictureSizeType &amp; 0x0007;
+						$ThisFileInfo['flv']['header']['videoSizeType'] = $PictureSizeType;
+						switch ($PictureSizeType) {
+							case 0:
+								$PictureSizeEnc = getid3_lib::BigEndian2Int(substr($FLVfileData, $CurrentOffset + 16, 2));
+								$PictureSizeEnc &lt;&lt;= 1;
+								$ThisFileInfo['video']['resolution_x'] = ($PictureSizeEnc &amp; 0xFF00) &gt;&gt; 8;
+								$PictureSizeEnc = getid3_lib::BigEndian2Int(substr($FLVfileData, $CurrentOffset + 17, 2));
+								$PictureSizeEnc &lt;&lt;= 1;
+								$ThisFileInfo['video']['resolution_y'] = ($PictureSizeEnc &amp; 0xFF00) &gt;&gt; 8;
+								break;
+
+							case 1:
+								$PictureSizeEnc = getid3_lib::BigEndian2Int(substr($FLVfileData, $CurrentOffset + 16, 4));
+								$PictureSizeEnc &lt;&lt;= 1;
+								$ThisFileInfo['video']['resolution_x'] = ($PictureSizeEnc &amp; 0xFFFF0000) &gt;&gt; 16;
+
+								$PictureSizeEnc = getid3_lib::BigEndian2Int(substr($FLVfileData, $CurrentOffset + 18, 4));
+								$PictureSizeEnc &lt;&lt;= 1;
+								$ThisFileInfo['video']['resolution_y'] = ($PictureSizeEnc &amp; 0xFFFF0000) &gt;&gt; 16;
+								break;
+
+							case 2:
+								$ThisFileInfo['video']['resolution_x'] = 352;
+								$ThisFileInfo['video']['resolution_y'] = 288;
+								break;
+
+							case 3:
+								$ThisFileInfo['video']['resolution_x'] = 176;
+								$ThisFileInfo['video']['resolution_y'] = 144;
+								break;
+
+							case 4:
+								$ThisFileInfo['video']['resolution_x'] = 128;
+								$ThisFileInfo['video']['resolution_y'] = 96;
+								break;
+
+							case 5:
+								$ThisFileInfo['video']['resolution_x'] = 320;
+								$ThisFileInfo['video']['resolution_y'] = 240;
+								break;
+
+							case 6:
+								$ThisFileInfo['video']['resolution_x'] = 160;
+								$ThisFileInfo['video']['resolution_y'] = 120;
+								break;
+
+							default:
+								$ThisFileInfo['video']['resolution_x'] = 0;
+								$ThisFileInfo['video']['resolution_y'] = 0;
+								break;
+
+						}
+					}
+					break;
+
+				default:
+					// noop
+					break;
+			}
+
+			if ($Timestamp &gt; $Duration) {
+				$Duration = $Timestamp;
+			}
+
+			$CurrentOffset += ($DataLength + 11);
+		}
+
+		$ThisFileInfo['playtime_seconds'] = $Duration / 1000;
+		$ThisFileInfo['bitrate'] = ($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) / $ThisFileInfo['playtime_seconds'];
+
+		if ($ThisFileInfo['flv']['header']['hasAudio']) {
+			$ThisFileInfo['audio']['codec']           =   $this-&gt;FLVaudioFormat($ThisFileInfo['flv']['audio']['audioFormat']);
+			$ThisFileInfo['audio']['sample_rate']     =     $this-&gt;FLVaudioRate($ThisFileInfo['flv']['audio']['audioRate']);
+			$ThisFileInfo['audio']['bits_per_sample'] = $this-&gt;FLVaudioBitDepth($ThisFileInfo['flv']['audio']['audioSampleSize']);
+
+			$ThisFileInfo['audio']['channels']   = $ThisFileInfo['flv']['audio']['audioType'] + 1; // 0=mono,1=stereo
+			$ThisFileInfo['audio']['lossless']   = ($ThisFileInfo['flv']['audio']['audioFormat'] ? false : true); // 0=uncompressed
+			$ThisFileInfo['audio']['dataformat'] = 'flv';
+		}
+		if (@$ThisFileInfo['flv']['header']['hasVideo']) {
+			$ThisFileInfo['video']['codec']      =   $this-&gt;FLVvideoCodec($ThisFileInfo['flv']['video']['videoCodec']);
+			$ThisFileInfo['video']['dataformat'] = 'flv';
+			$ThisFileInfo['video']['lossless']   = false;
+		}
+
+		return true;
+	}
+
+
+	function FLVaudioFormat($id) {
+		$FLVaudioFormat = array(
+			0 =&gt; 'uncompressed',
+			1 =&gt; 'ADPCM',
+			2 =&gt; 'mp3',
+			5 =&gt; 'Nellymoser 8kHz mono',
+			6 =&gt; 'Nellymoser',
+		);
+		return (@$FLVaudioFormat[$id] ? @$FLVaudioFormat[$id] : false);
+	}
+
+	function FLVaudioRate($id) {
+		$FLVaudioRate = array(
+			0 =&gt; 5500,
+			1 =&gt; 11025,
+			2 =&gt; 22050,
+			3 =&gt; 44100,
+		);
+		return (@$FLVaudioRate[$id] ? @$FLVaudioRate[$id] : false);
+	}
+
+	function FLVaudioBitDepth($id) {
+		$FLVaudioBitDepth = array(
+			0 =&gt; 8,
+			1 =&gt; 16,
+		);
+		return (@$FLVaudioBitDepth[$id] ? @$FLVaudioBitDepth[$id] : false);
+	}
+
+	function FLVvideoCodec($id) {
+		$FLVaudioBitDepth = array(
+			2 =&gt; 'Sorenson H.263',
+			3 =&gt; 'Screen video',
+		);
+		return (@$FLVaudioBitDepth[$id] ? @$FLVaudioBitDepth[$id] : false);
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.matroska.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.matroska.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.matroska.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,78 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio-video.matriska.php                             //
+// module for analyzing Matroska containers                    //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_matroska
+{
+
+	function getid3_matroska(&amp;$fd, &amp;$ThisFileInfo) {
+
+		$ThisFileInfo['fileformat'] = 'matroska';
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+		//$ThisFileInfo['matroska']['raw']['a'] = $this-&gt;EBML2Int(fread($fd, 4));
+
+		$ThisFileInfo['error'][] = 'Mastroka parsing not enabled in this version of getID3()';
+		return false;
+
+	}
+
+
+	function EBML2Int($EBMLstring) {
+		// <A HREF="http://matroska.org/specs/">http://matroska.org/specs/</A>
+
+		// Element ID coded with an UTF-8 like system:
+		// 1xxx xxxx                                  - Class A IDs (2^7 -2 possible values) (base 0x8X)
+		// 01xx xxxx  xxxx xxxx                       - Class B IDs (2^14-2 possible values) (base 0x4X 0xXX)
+		// 001x xxxx  xxxx xxxx  xxxx xxxx            - Class C IDs (2^21-2 possible values) (base 0x2X 0xXX 0xXX)
+		// 0001 xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx - Class D IDs (2^28-2 possible values) (base 0x1X 0xXX 0xXX 0xXX)
+		// Values with all x at 0 and 1 are reserved (hence the -2).
+
+		// Data size, in octets, is also coded with an UTF-8 like system :
+		// 1xxx xxxx                                                                              - value 0 to  2^7-2
+		// 01xx xxxx  xxxx xxxx                                                                   - value 0 to 2^14-2
+		// 001x xxxx  xxxx xxxx  xxxx xxxx                                                        - value 0 to 2^21-2
+		// 0001 xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx                                             - value 0 to 2^28-2
+		// 0000 1xxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx                                  - value 0 to 2^35-2
+		// 0000 01xx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx                       - value 0 to 2^42-2
+		// 0000 001x  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx            - value 0 to 2^49-2
+		// 0000 0001  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx - value 0 to 2^56-2
+
+		if (0x80 &amp; ord($EBMLstring{0})) {
+			$EBMLstring{0} = chr(ord($EBMLstring{0}) &amp; 0x7F);
+		} elseif (0x40 &amp; ord($EBMLstring{0})) {
+			$EBMLstring{0} = chr(ord($EBMLstring{0}) &amp; 0x3F);
+		} elseif (0x20 &amp; ord($EBMLstring{0})) {
+			$EBMLstring{0} = chr(ord($EBMLstring{0}) &amp; 0x1F);
+		} elseif (0x10 &amp; ord($EBMLstring{0})) {
+			$EBMLstring{0} = chr(ord($EBMLstring{0}) &amp; 0x0F);
+		} elseif (0x08 &amp; ord($EBMLstring{0})) {
+			$EBMLstring{0} = chr(ord($EBMLstring{0}) &amp; 0x07);
+		} elseif (0x04 &amp; ord($EBMLstring{0})) {
+			$EBMLstring{0} = chr(ord($EBMLstring{0}) &amp; 0x03);
+		} elseif (0x02 &amp; ord($EBMLstring{0})) {
+			$EBMLstring{0} = chr(ord($EBMLstring{0}) &amp; 0x01);
+		} elseif (0x01 &amp; ord($EBMLstring{0})) {
+			$EBMLstring{0} = chr(ord($EBMLstring{0}) &amp; 0x00);
+		} else {
+			return false;
+		}
+		return getid3_lib::BigEndian2Int($EBMLstring);
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.mpeg.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.mpeg.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.mpeg.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,292 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio-video.mpeg.php                                 //
+// module for analyzing MPEG files                             //
+// dependencies: module.audio.mp3.php                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.mp3.php', __FILE__, true);
+
+define('GETID3_MPEG_VIDEO_PICTURE_START',   &quot;\x00\x00\x01\x00&quot;);
+define('GETID3_MPEG_VIDEO_USER_DATA_START', &quot;\x00\x00\x01\xB2&quot;);
+define('GETID3_MPEG_VIDEO_SEQUENCE_HEADER', &quot;\x00\x00\x01\xB3&quot;);
+define('GETID3_MPEG_VIDEO_SEQUENCE_ERROR',  &quot;\x00\x00\x01\xB4&quot;);
+define('GETID3_MPEG_VIDEO_EXTENSION_START', &quot;\x00\x00\x01\xB5&quot;);
+define('GETID3_MPEG_VIDEO_SEQUENCE_END',    &quot;\x00\x00\x01\xB7&quot;);
+define('GETID3_MPEG_VIDEO_GROUP_START',     &quot;\x00\x00\x01\xB8&quot;);
+define('GETID3_MPEG_AUDIO_START',           &quot;\x00\x00\x01\xC0&quot;);
+
+
+class getid3_mpeg
+{
+
+	function getid3_mpeg(&amp;$fd, &amp;$ThisFileInfo) {
+		if ($ThisFileInfo['avdataend'] &lt;= $ThisFileInfo['avdataoffset']) {
+			$ThisFileInfo['error'][] = '&quot;avdataend&quot; ('.$ThisFileInfo['avdataend'].') is unexpectedly less-than-or-equal-to &quot;avdataoffset&quot; ('.$ThisFileInfo['avdataoffset'].')';
+			return false;
+		}
+		$ThisFileInfo['fileformat'] = 'mpeg';
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$MPEGstreamData       = fread($fd, min(100000, $ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']));
+		$MPEGstreamDataLength = strlen($MPEGstreamData);
+
+		$foundVideo = true;
+		$VideoChunkOffset = 0;
+		while (substr($MPEGstreamData, $VideoChunkOffset++, 4) !== GETID3_MPEG_VIDEO_SEQUENCE_HEADER) {
+			if ($VideoChunkOffset &gt;= $MPEGstreamDataLength) {
+				$foundVideo = false;
+				break;
+			}
+		}
+		if ($foundVideo) {
+
+			// Start code                       32 bits
+			// horizontal frame size            12 bits
+			// vertical frame size              12 bits
+			// pixel aspect ratio                4 bits
+			// frame rate                        4 bits
+			// bitrate                          18 bits
+			// marker bit                        1 bit
+			// VBV buffer size                  10 bits
+			// constrained parameter flag        1 bit
+			// intra quant. matrix flag          1 bit
+			// intra quant. matrix values      512 bits (present if matrix flag == 1)
+			// non-intra quant. matrix flag      1 bit
+			// non-intra quant. matrix values  512 bits (present if matrix flag == 1)
+
+			$ThisFileInfo['video']['dataformat'] = 'mpeg';
+
+			$VideoChunkOffset += (strlen(GETID3_MPEG_VIDEO_SEQUENCE_HEADER) - 1);
+
+			$FrameSizeDWORD = getid3_lib::BigEndian2Int(substr($MPEGstreamData, $VideoChunkOffset, 3));
+			$VideoChunkOffset += 3;
+
+			$AspectRatioFrameRateDWORD = getid3_lib::BigEndian2Int(substr($MPEGstreamData, $VideoChunkOffset, 1));
+			$VideoChunkOffset += 1;
+
+			$assortedinformation = getid3_lib::BigEndian2Bin(substr($MPEGstreamData, $VideoChunkOffset, 4));
+			$VideoChunkOffset += 4;
+
+			$ThisFileInfo['mpeg']['video']['raw']['framesize_horizontal'] = ($FrameSizeDWORD &amp; 0xFFF000) &gt;&gt; 12; // 12 bits for horizontal frame size
+			$ThisFileInfo['mpeg']['video']['raw']['framesize_vertical']   = ($FrameSizeDWORD &amp; 0x000FFF);       // 12 bits for vertical frame size
+			$ThisFileInfo['mpeg']['video']['raw']['pixel_aspect_ratio']   = ($AspectRatioFrameRateDWORD &amp; 0xF0) &gt;&gt; 4;
+			$ThisFileInfo['mpeg']['video']['raw']['frame_rate']           = ($AspectRatioFrameRateDWORD &amp; 0x0F);
+
+			$ThisFileInfo['mpeg']['video']['framesize_horizontal'] = $ThisFileInfo['mpeg']['video']['raw']['framesize_horizontal'];
+			$ThisFileInfo['mpeg']['video']['framesize_vertical']   = $ThisFileInfo['mpeg']['video']['raw']['framesize_vertical'];
+
+			$ThisFileInfo['mpeg']['video']['pixel_aspect_ratio']      = $this-&gt;MPEGvideoAspectRatioLookup($ThisFileInfo['mpeg']['video']['raw']['pixel_aspect_ratio']);
+			$ThisFileInfo['mpeg']['video']['pixel_aspect_ratio_text'] = $this-&gt;MPEGvideoAspectRatioTextLookup($ThisFileInfo['mpeg']['video']['raw']['pixel_aspect_ratio']);
+			$ThisFileInfo['mpeg']['video']['frame_rate']              = $this-&gt;MPEGvideoFramerateLookup($ThisFileInfo['mpeg']['video']['raw']['frame_rate']);
+
+			$ThisFileInfo['mpeg']['video']['raw']['bitrate']                =        getid3_lib::Bin2Dec(substr($assortedinformation,  0, 18));
+			$ThisFileInfo['mpeg']['video']['raw']['marker_bit']             = (bool) getid3_lib::Bin2Dec(substr($assortedinformation, 18,  1));
+			$ThisFileInfo['mpeg']['video']['raw']['vbv_buffer_size']        =        getid3_lib::Bin2Dec(substr($assortedinformation, 19, 10));
+			$ThisFileInfo['mpeg']['video']['raw']['constrained_param_flag'] = (bool) getid3_lib::Bin2Dec(substr($assortedinformation, 29,  1));
+			$ThisFileInfo['mpeg']['video']['raw']['intra_quant_flag']       = (bool) getid3_lib::Bin2Dec(substr($assortedinformation, 30,  1));
+			if ($ThisFileInfo['mpeg']['video']['raw']['intra_quant_flag']) {
+
+				// read 512 bits
+				$ThisFileInfo['mpeg']['video']['raw']['intra_quant']          = getid3_lib::BigEndian2Bin(substr($MPEGstreamData, $VideoChunkOffset, 64));
+				$VideoChunkOffset += 64;
+
+				$ThisFileInfo['mpeg']['video']['raw']['non_intra_quant_flag'] = (bool) getid3_lib::Bin2Dec(substr($ThisFileInfo['mpeg']['video']['raw']['intra_quant'], 511,  1));
+				$ThisFileInfo['mpeg']['video']['raw']['intra_quant']          =        getid3_lib::Bin2Dec(substr($assortedinformation, 31,  1)).substr(getid3_lib::BigEndian2Bin(substr($MPEGstreamData, $VideoChunkOffset, 64)), 0, 511);
+
+				if ($ThisFileInfo['mpeg']['video']['raw']['non_intra_quant_flag']) {
+					$ThisFileInfo['mpeg']['video']['raw']['non_intra_quant'] = substr($MPEGstreamData, $VideoChunkOffset, 64);
+					$VideoChunkOffset += 64;
+				}
+
+			} else {
+
+				$ThisFileInfo['mpeg']['video']['raw']['non_intra_quant_flag'] = (bool) getid3_lib::Bin2Dec(substr($assortedinformation, 31,  1));
+				if ($ThisFileInfo['mpeg']['video']['raw']['non_intra_quant_flag']) {
+					$ThisFileInfo['mpeg']['video']['raw']['non_intra_quant'] = substr($MPEGstreamData, $VideoChunkOffset, 64);
+					$VideoChunkOffset += 64;
+				}
+
+			}
+
+			if ($ThisFileInfo['mpeg']['video']['raw']['bitrate'] == 0x3FFFF) { // 18 set bits
+
+				$ThisFileInfo['warning'][] = 'This version of getID3() ['.GETID3_VERSION.'] cannot determine average bitrate of VBR MPEG video files';
+				$ThisFileInfo['mpeg']['video']['bitrate_mode'] = 'vbr';
+
+			} else {
+
+				$ThisFileInfo['mpeg']['video']['bitrate']      = $ThisFileInfo['mpeg']['video']['raw']['bitrate'] * 400;
+				$ThisFileInfo['mpeg']['video']['bitrate_mode'] = 'cbr';
+				$ThisFileInfo['video']['bitrate']              = $ThisFileInfo['mpeg']['video']['bitrate'];
+
+			}
+
+			$ThisFileInfo['video']['resolution_x']       = $ThisFileInfo['mpeg']['video']['framesize_horizontal'];
+			$ThisFileInfo['video']['resolution_y']       = $ThisFileInfo['mpeg']['video']['framesize_vertical'];
+			$ThisFileInfo['video']['frame_rate']         = $ThisFileInfo['mpeg']['video']['frame_rate'];
+			$ThisFileInfo['video']['bitrate_mode']       = $ThisFileInfo['mpeg']['video']['bitrate_mode'];
+			$ThisFileInfo['video']['pixel_aspect_ratio'] = $ThisFileInfo['mpeg']['video']['pixel_aspect_ratio'];
+			$ThisFileInfo['video']['lossless']           = false;
+			$ThisFileInfo['video']['bits_per_sample']    = 24;
+
+		} else {
+
+			$ThisFileInfo['error'][] = 'Could not find start of video block in the first 100,000 bytes (or before end of file) - this might not be an MPEG-video file?';
+
+		}
+
+		//0x000001B3 begins the sequence_header of every MPEG video stream.
+		//But in MPEG-2, this header must immediately be followed by an
+		//extension_start_code (0x000001B5) with a sequence_extension ID (1).
+		//(This extension contains all the additional MPEG-2 stuff.)
+		//MPEG-1 doesn't have this extension, so that's a sure way to tell the
+		//difference between MPEG-1 and MPEG-2 video streams.
+
+		if (substr($MPEGstreamData, $VideoChunkOffset, 4) == GETID3_MPEG_VIDEO_EXTENSION_START) {
+			$ThisFileInfo['video']['codec'] = 'MPEG-2';
+		} else {
+			$ThisFileInfo['video']['codec'] = 'MPEG-1';
+		}
+
+
+		$AudioChunkOffset = 0;
+		while (true) {
+			while (substr($MPEGstreamData, $AudioChunkOffset++, 4) !== GETID3_MPEG_AUDIO_START) {
+				if ($AudioChunkOffset &gt;= $MPEGstreamDataLength) {
+					break 2;
+				}
+			}
+
+			for ($i = 0; $i &lt;= 7; $i++) {
+				// some files have the MPEG-audio header 8 bytes after the end of the $00 $00 $01 $C0 signature, some have it up to 13 bytes (or more?) after
+				// I have no idea why or what the difference is, so this is a stupid hack.
+				// If anybody has any better idea of what's going on, please let me know - <A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>
+
+				$dummy = $ThisFileInfo;
+				if (getid3_mp3::decodeMPEGaudioHeader($fd, ($AudioChunkOffset + 3) + 8 + $i, $dummy, false)) {
+					$ThisFileInfo = $dummy;
+					$ThisFileInfo['audio']['bitrate_mode']    = 'cbr';
+					$ThisFileInfo['audio']['lossless']        = false;
+					break 2;
+
+				}
+			}
+		}
+
+		// Temporary hack to account for interleaving overhead:
+		if (!empty($ThisFileInfo['video']['bitrate']) &amp;&amp; !empty($ThisFileInfo['audio']['bitrate'])) {
+			$ThisFileInfo['playtime_seconds'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / ($ThisFileInfo['video']['bitrate'] + $ThisFileInfo['audio']['bitrate']);
+
+			// Interleaved MPEG audio/video files have a certain amount of overhead that varies
+			// by both video and audio bitrates, and not in any sensible, linear/logarithmic patter
+			// Use interpolated lookup tables to approximately guess how much is overhead, because
+			// playtime is calculated as filesize / total-bitrate
+			$ThisFileInfo['playtime_seconds'] *= $this-&gt;MPEGsystemNonOverheadPercentage($ThisFileInfo['video']['bitrate'], $ThisFileInfo['audio']['bitrate']);
+
+			//switch ($ThisFileInfo['video']['bitrate']) {
+			//	case('5000000'):
+			//		$multiplier = 0.93292642112380355828048824319889;
+			//		break;
+			//	case('5500000'):
+			//		$multiplier = 0.93582895375200989965359777343219;
+			//		break;
+			//	case('6000000'):
+			//		$multiplier = 0.93796247714820932532911373859139;
+			//		break;
+			//	case('7000000'):
+			//		$multiplier = 0.9413264083635103463010117778776;
+			//		break;
+			//	default:
+			//		$multiplier = 1;
+			//		break;
+			//}
+			//$ThisFileInfo['playtime_seconds'] *= $multiplier;
+			//$ThisFileInfo['warning'][] = 'Interleaved MPEG audio/video playtime may be inaccurate. With current hack should be within a few seconds of accurate. Report to <A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A> if off by more than 10 seconds.';
+			if ($ThisFileInfo['video']['bitrate'] &lt; 50000) {
+				$ThisFileInfo['warning'][] = 'Interleaved MPEG audio/video playtime may be slightly inaccurate for video bitrates below 100kbps. Except in extreme low-bitrate situations, error should be less than 1%. Report to <A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A> if greater than this.';
+			}
+		}
+
+		return true;
+	}
+
+
+	function MPEGsystemNonOverheadPercentage($VideoBitrate, $AudioBitrate) {
+		$OverheadPercentage = 0;
+
+		$AudioBitrate = max(min($AudioBitrate / 1000,   384), 32); // limit to range of 32kbps - 384kbps (should be only legal bitrates, but maybe VBR?)
+		$VideoBitrate = max(min($VideoBitrate / 1000, 10000), 10); // limit to range of 10kbps -  10Mbps (beyond that curves flatten anyways, no big loss)
+
+
+		//OMBB[audiobitrate]              = array(video-10kbps,       video-100kbps,      video-1000kbps,     video-10000kbps)
+		$OverheadMultiplierByBitrate[32]  = array(0, 0.9676287944368530, 0.9802276264360310, 0.9844916183244460, 0.9852821845179940);
+		$OverheadMultiplierByBitrate[48]  = array(0, 0.9779100089209830, 0.9787770035359320, 0.9846738664076130, 0.9852683013799960);
+		$OverheadMultiplierByBitrate[56]  = array(0, 0.9731249855367600, 0.9776624308938040, 0.9832606361852130, 0.9843922606633340);
+		$OverheadMultiplierByBitrate[64]  = array(0, 0.9755642683275760, 0.9795256705493390, 0.9836573009193170, 0.9851122539404470);
+		$OverheadMultiplierByBitrate[96]  = array(0, 0.9788025247497290, 0.9798553314148700, 0.9822956869792560, 0.9834815119124690);
+		$OverheadMultiplierByBitrate[128] = array(0, 0.9816940050925480, 0.9821675936072120, 0.9829756927470870, 0.9839763420152050);
+		$OverheadMultiplierByBitrate[160] = array(0, 0.9825894094561180, 0.9820913399073960, 0.9823907143253970, 0.9832821783651570);
+		$OverheadMultiplierByBitrate[192] = array(0, 0.9832038474336260, 0.9825731694317960, 0.9821028622712400, 0.9828262076447620);
+		$OverheadMultiplierByBitrate[224] = array(0, 0.9836516298538770, 0.9824718601823890, 0.9818302180625380, 0.9823735101626480);
+		$OverheadMultiplierByBitrate[256] = array(0, 0.9845863022094920, 0.9837229411967540, 0.9824521662210830, 0.9828645172100790);
+		$OverheadMultiplierByBitrate[320] = array(0, 0.9849565280263180, 0.9837683142805110, 0.9822885275960400, 0.9824424382727190);
+		$OverheadMultiplierByBitrate[384] = array(0, 0.9856094774357600, 0.9844573394432720, 0.9825970399837330, 0.9824673808303890);
+
+		$BitrateToUseMin = 32;
+		$BitrateToUseMax = 32;
+		$previousBitrate = 32;
+		foreach ($OverheadMultiplierByBitrate as $key =&gt; $value) {
+			if ($AudioBitrate &gt;= $previousBitrate) {
+				$BitrateToUseMin = $previousBitrate;
+			}
+			if ($AudioBitrate &lt; $key) {
+				$BitrateToUseMax = $key;
+				break;
+			}
+			$previousBitrate = $key;
+		}
+		$FactorA = ($BitrateToUseMax - $AudioBitrate) / ($BitrateToUseMax - $BitrateToUseMin);
+
+		$VideoBitrateLog10 = log10($VideoBitrate);
+		$VideoFactorMin1 = $OverheadMultiplierByBitrate[$BitrateToUseMin][floor($VideoBitrateLog10)];
+		$VideoFactorMin2 = $OverheadMultiplierByBitrate[$BitrateToUseMax][floor($VideoBitrateLog10)];
+		$VideoFactorMax1 = $OverheadMultiplierByBitrate[$BitrateToUseMin][ceil($VideoBitrateLog10)];
+		$VideoFactorMax2 = $OverheadMultiplierByBitrate[$BitrateToUseMax][ceil($VideoBitrateLog10)];
+		$FactorV = $VideoBitrateLog10 - floor($VideoBitrateLog10);
+
+		$OverheadPercentage  = $VideoFactorMin1 *      $FactorA  *      $FactorV;
+		$OverheadPercentage += $VideoFactorMin2 * (1 - $FactorA) *      $FactorV;
+		$OverheadPercentage += $VideoFactorMax1 *      $FactorA  * (1 - $FactorV);
+		$OverheadPercentage += $VideoFactorMax2 * (1 - $FactorA) * (1 - $FactorV);
+
+		return $OverheadPercentage;
+	}
+
+
+	function MPEGvideoFramerateLookup($rawframerate) {
+		$MPEGvideoFramerateLookup = array(0, 23.976, 24, 25, 29.97, 30, 50, 59.94, 60);
+		return (isset($MPEGvideoFramerateLookup[$rawframerate]) ? (float) $MPEGvideoFramerateLookup[$rawframerate] : (float) 0);
+	}
+
+	function MPEGvideoAspectRatioLookup($rawaspectratio) {
+		$MPEGvideoAspectRatioLookup = array(0, 1, 0.6735, 0.7031, 0.7615, 0.8055, 0.8437, 0.8935, 0.9157, 0.9815, 1.0255, 1.0695, 1.0950, 1.1575, 1.2015, 0);
+		return (isset($MPEGvideoAspectRatioLookup[$rawaspectratio]) ? (float) $MPEGvideoAspectRatioLookup[$rawaspectratio] : (float) 0);
+	}
+
+	function MPEGvideoAspectRatioTextLookup($rawaspectratio) {
+		$MPEGvideoAspectRatioTextLookup = array('forbidden', 'square pixels', '0.6735', '16:9, 625 line, PAL', '0.7615', '0.8055', '16:9, 525 line, NTSC', '0.8935', '4:3, 625 line, PAL, CCIR601', '0.9815', '1.0255', '1.0695', '4:3, 525 line, NTSC, CCIR601', '1.1575', '1.2015', 'reserved');
+		return (isset($MPEGvideoAspectRatioTextLookup[$rawaspectratio]) ? $MPEGvideoAspectRatioTextLookup[$rawaspectratio] : '');
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.nsv.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.nsv.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.nsv.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,224 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.nsv.php                                        //
+// module for analyzing Nullsoft NSV files                     //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_nsv
+{
+
+	function getid3_nsv(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$NSVheader = fread($fd, 4);
+
+		switch ($NSVheader) {
+			case 'NSVs':
+				if ($this-&gt;getNSVsHeaderFilepointer($fd, $ThisFileInfo, 0)) {
+					$ThisFileInfo['fileformat']          = 'nsv';
+					$ThisFileInfo['audio']['dataformat'] = 'nsv';
+					$ThisFileInfo['video']['dataformat'] = 'nsv';
+					$ThisFileInfo['audio']['lossless']   = false;
+					$ThisFileInfo['video']['lossless']   = false;
+				}
+				break;
+
+			case 'NSVf':
+				if ($this-&gt;getNSVfHeaderFilepointer($fd, $ThisFileInfo, 0)) {
+					$ThisFileInfo['fileformat']          = 'nsv';
+					$ThisFileInfo['audio']['dataformat'] = 'nsv';
+					$ThisFileInfo['video']['dataformat'] = 'nsv';
+					$ThisFileInfo['audio']['lossless']   = false;
+					$ThisFileInfo['video']['lossless']   = false;
+					$this-&gt;getNSVsHeaderFilepointer($fd, $ThisFileInfo, $ThisFileInfo['nsv']['NSVf']['header_length']);
+				}
+				break;
+
+			default:
+				$ThisFileInfo['error'][] = 'Expecting &quot;NSVs&quot; or &quot;NSVf&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$NSVheader.'&quot;';
+				return false;
+				break;
+		}
+
+		if (!isset($ThisFileInfo['nsv']['NSVf'])) {
+			$ThisFileInfo['warning'][] = 'NSVf header not present - cannot calculate playtime or bitrate';
+		}
+
+		return true;
+	}
+
+	function getNSVsHeaderFilepointer(&amp;$fd, &amp;$ThisFileInfo, $fileoffset) {
+		fseek($fd, $fileoffset, SEEK_SET);
+		$NSVsheader = fread($fd, 28);
+		$offset = 0;
+
+		$ThisFileInfo['nsv']['NSVs']['identifier']      =                  substr($NSVsheader, $offset, 4);
+		$offset += 4;
+
+		if ($ThisFileInfo['nsv']['NSVs']['identifier'] != 'NSVs') {
+			$ThisFileInfo['error'][] = 'expected &quot;NSVs&quot; at offset ('.$fileoffset.'), found &quot;'.$ThisFileInfo['nsv']['NSVs']['identifier'].'&quot; instead';
+			unset($ThisFileInfo['nsv']['NSVs']);
+			return false;
+		}
+
+		$ThisFileInfo['nsv']['NSVs']['offset']          = $fileoffset;
+
+		$ThisFileInfo['nsv']['NSVs']['video_codec']     =                              substr($NSVsheader, $offset, 4);
+		$offset += 4;
+		$ThisFileInfo['nsv']['NSVs']['audio_codec']     =                              substr($NSVsheader, $offset, 4);
+		$offset += 4;
+		$ThisFileInfo['nsv']['NSVs']['resolution_x']    = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 2));
+		$offset += 2;
+		$ThisFileInfo['nsv']['NSVs']['resolution_y']    = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 2));
+		$offset += 2;
+
+		$ThisFileInfo['nsv']['NSVs']['framerate_index'] = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+		$offset += 1;
+		//$ThisFileInfo['nsv']['NSVs']['unknown1b']       = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+		$offset += 1;
+		//$ThisFileInfo['nsv']['NSVs']['unknown1c']       = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+		$offset += 1;
+		//$ThisFileInfo['nsv']['NSVs']['unknown1d']       = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+		$offset += 1;
+		//$ThisFileInfo['nsv']['NSVs']['unknown2a']       = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+		$offset += 1;
+		//$ThisFileInfo['nsv']['NSVs']['unknown2b']       = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+		$offset += 1;
+		//$ThisFileInfo['nsv']['NSVs']['unknown2c']       = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+		$offset += 1;
+		//$ThisFileInfo['nsv']['NSVs']['unknown2d']       = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+		$offset += 1;
+
+		switch ($ThisFileInfo['nsv']['NSVs']['audio_codec']) {
+			case 'PCM ':
+				$ThisFileInfo['nsv']['NSVs']['bits_channel'] = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+				$offset += 1;
+				$ThisFileInfo['nsv']['NSVs']['channels']     = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 1));
+				$offset += 1;
+				$ThisFileInfo['nsv']['NSVs']['sample_rate']  = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 2));
+				$offset += 2;
+
+				$ThisFileInfo['audio']['sample_rate']        = $ThisFileInfo['nsv']['NSVs']['sample_rate'];
+				break;
+
+			case 'MP3 ':
+			case 'NONE':
+			default:
+				//$ThisFileInfo['nsv']['NSVs']['unknown3']     = getid3_lib::LittleEndian2Int(substr($NSVsheader, $offset, 4));
+				$offset += 4;
+				break;
+		}
+
+		$ThisFileInfo['video']['resolution_x']       = $ThisFileInfo['nsv']['NSVs']['resolution_x'];
+		$ThisFileInfo['video']['resolution_y']       = $ThisFileInfo['nsv']['NSVs']['resolution_y'];
+		$ThisFileInfo['nsv']['NSVs']['frame_rate']   = $this-&gt;NSVframerateLookup($ThisFileInfo['nsv']['NSVs']['framerate_index']);
+		$ThisFileInfo['video']['frame_rate']         = $ThisFileInfo['nsv']['NSVs']['frame_rate'];
+		$ThisFileInfo['video']['bits_per_sample']    = 24;
+		$ThisFileInfo['video']['pixel_aspect_ratio'] = (float) 1;
+
+		return true;
+	}
+
+	function getNSVfHeaderFilepointer(&amp;$fd, &amp;$ThisFileInfo, $fileoffset, $getTOCoffsets=false) {
+		fseek($fd, $fileoffset, SEEK_SET);
+		$NSVfheader = fread($fd, 28);
+		$offset = 0;
+
+		$ThisFileInfo['nsv']['NSVf']['identifier']    =                  substr($NSVfheader, $offset, 4);
+		$offset += 4;
+
+		if ($ThisFileInfo['nsv']['NSVf']['identifier'] != 'NSVf') {
+			$ThisFileInfo['error'][] = 'expected &quot;NSVf&quot; at offset ('.$fileoffset.'), found &quot;'.$ThisFileInfo['nsv']['NSVf']['identifier'].'&quot; instead';
+			unset($ThisFileInfo['nsv']['NSVf']);
+			return false;
+		}
+
+		$ThisFileInfo['nsv']['NSVs']['offset']        = $fileoffset;
+
+		$ThisFileInfo['nsv']['NSVf']['header_length'] = getid3_lib::LittleEndian2Int(substr($NSVfheader, $offset, 4));
+		$offset += 4;
+		$ThisFileInfo['nsv']['NSVf']['file_size']     = getid3_lib::LittleEndian2Int(substr($NSVfheader, $offset, 4));
+		$offset += 4;
+
+		if ($ThisFileInfo['nsv']['NSVf']['file_size'] &gt; $ThisFileInfo['avdataend']) {
+			$ThisFileInfo['warning'][] = 'truncated file - NSVf header indicates '.$ThisFileInfo['nsv']['NSVf']['file_size'].' bytes, file actually '.$ThisFileInfo['avdataend'].' bytes';
+		}
+
+		$ThisFileInfo['nsv']['NSVf']['playtime_ms']   = getid3_lib::LittleEndian2Int(substr($NSVfheader, $offset, 4));
+		$offset += 4;
+		$ThisFileInfo['nsv']['NSVf']['meta_size']     = getid3_lib::LittleEndian2Int(substr($NSVfheader, $offset, 4));
+		$offset += 4;
+		$ThisFileInfo['nsv']['NSVf']['TOC_entries_1'] = getid3_lib::LittleEndian2Int(substr($NSVfheader, $offset, 4));
+		$offset += 4;
+		$ThisFileInfo['nsv']['NSVf']['TOC_entries_2'] = getid3_lib::LittleEndian2Int(substr($NSVfheader, $offset, 4));
+		$offset += 4;
+
+		if ($ThisFileInfo['nsv']['NSVf']['playtime_ms'] == 0) {
+			$ThisFileInfo['error'][] = 'Corrupt NSV file: NSVf.playtime_ms == zero';
+			return false;
+		}
+
+		$NSVfheader .= fread($fd, $ThisFileInfo['nsv']['NSVf']['meta_size'] + (4 * $ThisFileInfo['nsv']['NSVf']['TOC_entries_1']) + (4 * $ThisFileInfo['nsv']['NSVf']['TOC_entries_2']));
+		$NSVfheaderlength = strlen($NSVfheader);
+		$ThisFileInfo['nsv']['NSVf']['metadata']      =                  substr($NSVfheader, $offset, $ThisFileInfo['nsv']['NSVf']['meta_size']);
+		$offset += $ThisFileInfo['nsv']['NSVf']['meta_size'];
+
+		if ($getTOCoffsets) {
+			$TOCcounter = 0;
+			while ($TOCcounter &lt; $ThisFileInfo['nsv']['NSVf']['TOC_entries_1']) {
+				if ($TOCcounter &lt; $ThisFileInfo['nsv']['NSVf']['TOC_entries_1']) {
+					$ThisFileInfo['nsv']['NSVf']['TOC_1'][$TOCcounter] = getid3_lib::LittleEndian2Int(substr($NSVfheader, $offset, 4));
+					$offset += 4;
+					$TOCcounter++;
+				}
+			}
+		}
+
+		if (trim($ThisFileInfo['nsv']['NSVf']['metadata']) != '') {
+			$ThisFileInfo['nsv']['NSVf']['metadata'] = str_replace('`', &quot;\x01&quot;, $ThisFileInfo['nsv']['NSVf']['metadata']);
+			$CommentPairArray = explode(&quot;\x01&quot;.' ', $ThisFileInfo['nsv']['NSVf']['metadata']);
+			foreach ($CommentPairArray as $CommentPair) {
+				if (strstr($CommentPair, '='.&quot;\x01&quot;)) {
+					list($key, $value) = explode('='.&quot;\x01&quot;, $CommentPair, 2);
+					$ThisFileInfo['nsv']['comments'][strtolower($key)][] = trim(str_replace(&quot;\x01&quot;, '', $value));
+				}
+			}
+		}
+
+		$ThisFileInfo['playtime_seconds'] = $ThisFileInfo['nsv']['NSVf']['playtime_ms'] / 1000;
+		$ThisFileInfo['bitrate']          = ($ThisFileInfo['nsv']['NSVf']['file_size'] * 8) / $ThisFileInfo['playtime_seconds'];
+
+		return true;
+	}
+
+
+	function NSVframerateLookup($framerateindex) {
+		if ($framerateindex &lt;= 127) {
+			return (float) $framerateindex;
+		}
+
+		static $NSVframerateLookup = array();
+		if (empty($NSVframerateLookup)) {
+			$NSVframerateLookup[129] = (float) 29.970;
+			$NSVframerateLookup[131] = (float) 23.976;
+			$NSVframerateLookup[133] = (float) 14.985;
+			$NSVframerateLookup[197] = (float) 59.940;
+			$NSVframerateLookup[199] = (float) 47.952;
+		}
+		return (isset($NSVframerateLookup[$framerateindex]) ? $NSVframerateLookup[$framerateindex] : false);
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.quicktime.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.quicktime.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.quicktime.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,1300 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio-video.quicktime.php                            //
+// module for analyzing Quicktime and MP3-in-MP4 files         //
+// dependencies: module.audio.mp3.php                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.mp3.php', __FILE__, true);
+
+class getid3_quicktime
+{
+
+	function getid3_quicktime(&amp;$fd, &amp;$ThisFileInfo, $ReturnAtomData=true, $ParseAllPossibleAtoms=false) {
+
+		$ThisFileInfo['fileformat'] = 'quicktime';
+		$ThisFileInfo['quicktime']['hinting'] = false;
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+		$offset      = 0;
+		$atomcounter = 0;
+
+		while ($offset &lt; $ThisFileInfo['avdataend']) {
+			fseek($fd, $offset, SEEK_SET);
+			$AtomHeader = fread($fd, 8);
+
+			$atomsize = getid3_lib::BigEndian2Int(substr($AtomHeader, 0, 4));
+			$atomname =               substr($AtomHeader, 4, 4);
+			$ThisFileInfo['quicktime'][$atomname]['name']   = $atomname;
+			$ThisFileInfo['quicktime'][$atomname]['size']   = $atomsize;
+			$ThisFileInfo['quicktime'][$atomname]['offset'] = $offset;
+
+			if (($offset + $atomsize) &gt; $ThisFileInfo['avdataend']) {
+				$ThisFileInfo['error'][] = 'Atom at offset '.$offset.' claims to go beyond end-of-file (length: '.$atomsize.' bytes)';
+				return false;
+			}
+
+			if ($atomsize == 0) {
+				// Furthermore, for historical reasons the list of atoms is optionally
+				// terminated by a 32-bit integer set to 0. If you are writing a program
+				// to read user data atoms, you should allow for the terminating 0.
+				break;
+			}
+			switch ($atomname) {
+				case 'mdat': // Media DATa atom
+					// 'mdat' contains the actual data for the audio/video
+					if (($atomsize &gt; 8) &amp;&amp; (!isset($ThisFileInfo['avdataend_tmp']) || ($ThisFileInfo['quicktime'][$atomname]['size'] &gt; ($ThisFileInfo['avdataend_tmp'] - $ThisFileInfo['avdataoffset'])))) {
+
+						$ThisFileInfo['avdataoffset'] = $ThisFileInfo['quicktime'][$atomname]['offset'] + 8;
+						$OldAVDataEnd                 = $ThisFileInfo['avdataend'];
+						$ThisFileInfo['avdataend']    = $ThisFileInfo['quicktime'][$atomname]['offset'] + $ThisFileInfo['quicktime'][$atomname]['size'];
+
+						if (getid3_mp3::MPEGaudioHeaderValid(getid3_mp3::MPEGaudioHeaderDecode(fread($fd, 4)))) {
+							getid3_mp3::getOnlyMPEGaudioInfo($fd, $ThisFileInfo, $ThisFileInfo['avdataoffset'], false);
+							if (isset($ThisFileInfo['mpeg']['audio'])) {
+								$ThisFileInfo['audio']['dataformat']   = 'mp3';
+								$ThisFileInfo['audio']['codec']        = (!empty($ThisFileInfo['mpeg']['audio']['encoder']) ? $ThisFileInfo['mpeg']['audio']['encoder'] : (!empty($ThisFileInfo['mpeg']['audio']['codec']) ? $ThisFileInfo['mpeg']['audio']['codec'] : (!empty($ThisFileInfo['mpeg']['audio']['LAME']) ? 'LAME' :'mp3')));
+								$ThisFileInfo['audio']['sample_rate']  = $ThisFileInfo['mpeg']['audio']['sample_rate'];
+								$ThisFileInfo['audio']['channels']     = $ThisFileInfo['mpeg']['audio']['channels'];
+								$ThisFileInfo['audio']['bitrate']      = $ThisFileInfo['mpeg']['audio']['bitrate'];
+								$ThisFileInfo['audio']['bitrate_mode'] = strtolower($ThisFileInfo['mpeg']['audio']['bitrate_mode']);
+								$ThisFileInfo['bitrate']               = $ThisFileInfo['audio']['bitrate'];
+							}
+						}
+						$ThisFileInfo['avdataend'] = $OldAVDataEnd;
+						unset($OldAVDataEnd);
+
+					}
+					break;
+
+				case 'free': // FREE space atom
+				case 'skip': // SKIP atom
+				case 'wide': // 64-bit expansion placeholder atom
+					// 'free', 'skip' and 'wide' are just padding, contains no useful data at all
+					break;
+
+				default:
+					$atomHierarchy = array();
+					$ThisFileInfo['quicktime'][$atomname] = $this-&gt;QuicktimeParseAtom($atomname, $atomsize, fread($fd, $atomsize), $ThisFileInfo, $offset, $atomHierarchy, $ParseAllPossibleAtoms);
+					break;
+			}
+
+			$offset += $atomsize;
+			$atomcounter++;
+		}
+
+		if (!empty($ThisFileInfo['avdataend_tmp'])) {
+			// this value is assigned to a temp value and then erased because
+			// otherwise any atoms beyond the 'mdat' atom would not get parsed
+			$ThisFileInfo['avdataend'] = $ThisFileInfo['avdataend_tmp'];
+			unset($ThisFileInfo['avdataend_tmp']);
+		}
+
+		if (!isset($ThisFileInfo['bitrate']) &amp;&amp; isset($ThisFileInfo['playtime_seconds'])) {
+			$ThisFileInfo['bitrate'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+		}
+		if (isset($ThisFileInfo['bitrate']) &amp;&amp; !isset($ThisFileInfo['audio']['bitrate']) &amp;&amp; !isset($ThisFileInfo['quicktime']['video'])) {
+			$ThisFileInfo['audio']['bitrate'] = $ThisFileInfo['bitrate'];
+		}
+
+		if (($ThisFileInfo['audio']['dataformat'] == 'mp4') &amp;&amp; empty($ThisFileInfo['video']['resolution_x'])) {
+			$ThisFileInfo['fileformat'] = 'mp4';
+			$ThisFileInfo['mime_type']  = 'audio/mp4';
+			unset($ThisFileInfo['video']['dataformat']);
+		}
+
+		if (!$ReturnAtomData) {
+			unset($ThisFileInfo['quicktime']['moov']);
+		}
+
+		if (empty($ThisFileInfo['audio']['dataformat']) &amp;&amp; !empty($ThisFileInfo['quicktime']['audio'])) {
+			$ThisFileInfo['audio']['dataformat'] = 'quicktime';
+		}
+		if (empty($ThisFileInfo['video']['dataformat']) &amp;&amp; !empty($ThisFileInfo['quicktime']['video'])) {
+			$ThisFileInfo['video']['dataformat'] = 'quicktime';
+		}
+
+		return true;
+	}
+
+	function QuicktimeParseAtom($atomname, $atomsize, $atomdata, &amp;$ThisFileInfo, $baseoffset, &amp;$atomHierarchy, $ParseAllPossibleAtoms) {
+		// <A HREF="http://developer.apple.com/techpubs/quicktime/qtdevdocs/APIREF/INDEX/atomalphaindex.htm">http://developer.apple.com/techpubs/quicktime/qtdevdocs/APIREF/INDEX/atomalphaindex.htm</A>
+
+		array_push($atomHierarchy, $atomname);
+		$atomstructure['hierarchy'] = implode(' ', $atomHierarchy);
+		$atomstructure['name']      = $atomname;
+		$atomstructure['size']      = $atomsize;
+		$atomstructure['offset']    = $baseoffset;
+
+		switch ($atomname) {
+			case 'moov': // MOVie container atom
+			case 'trak': // TRAcK container atom
+			case 'clip': // CLIPping container atom
+			case 'matt': // track MATTe container atom
+			case 'edts': // EDiTS container atom
+			case 'tref': // Track REFerence container atom
+			case 'mdia': // MeDIA container atom
+			case 'minf': // Media INFormation container atom
+			case 'dinf': // Data INFormation container atom
+			case 'udta': // User DaTA container atom
+			case 'stbl': // Sample TaBLe container atom
+			case 'cmov': // Compressed MOVie container atom
+			case 'rmra': // Reference Movie Record Atom
+			case 'rmda': // Reference Movie Descriptor Atom
+			case 'gmhd': // Generic Media info HeaDer atom (seen on QTVR)
+				$atomstructure['subatoms'] = $this-&gt;QuicktimeParseContainerAtom($atomdata, $ThisFileInfo, $baseoffset + 8, $atomHierarchy, $ParseAllPossibleAtoms);
+				break;
+
+
+			case '&#169;cpy':
+			case '&#169;day':
+			case '&#169;dir':
+			case '&#169;ed1':
+			case '&#169;ed2':
+			case '&#169;ed3':
+			case '&#169;ed4':
+			case '&#169;ed5':
+			case '&#169;ed6':
+			case '&#169;ed7':
+			case '&#169;ed8':
+			case '&#169;ed9':
+			case '&#169;fmt':
+			case '&#169;inf':
+			case '&#169;prd':
+			case '&#169;prf':
+			case '&#169;req':
+			case '&#169;src':
+			case '&#169;wrt':
+			case '&#169;nam':
+			case '&#169;cmt':
+			case '&#169;wrn':
+			case '&#169;hst':
+			case '&#169;mak':
+			case '&#169;mod':
+			case '&#169;PRD':
+			case '&#169;swr':
+			case '&#169;aut':
+			case '&#169;ART':
+			case '&#169;trk':
+			case '&#169;alb':
+			case '&#169;com':
+			case '&#169;gen':
+			case '&#169;ope':
+			case '&#169;url':
+			case '&#169;enc':
+				$atomstructure['data_length'] = getid3_lib::BigEndian2Int(substr($atomdata,  0, 2));
+				$atomstructure['language_id'] = getid3_lib::BigEndian2Int(substr($atomdata,  2, 2));
+				$atomstructure['data']        =                           substr($atomdata,  4);
+
+				$atomstructure['language']    = $this-&gt;QuicktimeLanguageLookup($atomstructure['language_id']);
+				if (empty($ThisFileInfo['comments']['language']) || (!in_array($atomstructure['language'], $ThisFileInfo['comments']['language']))) {
+					$ThisFileInfo['comments']['language'][] = $atomstructure['language'];
+				}
+				$this-&gt;CopyToAppropriateCommentsSection($atomname, $atomstructure['data'], $ThisFileInfo);
+				break;
+
+
+			case 'play': // auto-PLAY atom
+				$atomstructure['autoplay']             = (bool) getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+
+				$ThisFileInfo['quicktime']['autoplay'] = $atomstructure['autoplay'];
+				break;
+
+
+			case 'WLOC': // Window LOCation atom
+				$atomstructure['location_x']  = getid3_lib::BigEndian2Int(substr($atomdata,  0, 2));
+				$atomstructure['location_y']  = getid3_lib::BigEndian2Int(substr($atomdata,  2, 2));
+				break;
+
+
+			case 'LOOP': // LOOPing atom
+			case 'SelO': // play SELection Only atom
+			case 'AllF': // play ALL Frames atom
+				$atomstructure['data'] = getid3_lib::BigEndian2Int($atomdata);
+				break;
+
+
+			case 'name': //
+			case 'MCPS': // Media Cleaner PRo
+			case '@PRM': // adobe PReMiere version
+			case '@PRQ': // adobe PRemiere Quicktime version
+				$atomstructure['data'] = $atomdata;
+				break;
+
+
+			case 'cmvd': // Compressed MooV Data atom
+				// Code by ubergeek&#216;ubergeek*tv based on information from
+				// <A HREF="http://developer.apple.com/quicktime/icefloe/dispatch012.html">http://developer.apple.com/quicktime/icefloe/dispatch012.html</A>
+				$atomstructure['unCompressedSize'] = getid3_lib::BigEndian2Int(substr($atomdata, 0, 4));
+
+				$CompressedFileData = substr($atomdata, 4);
+				if ($UncompressedHeader = @gzuncompress($CompressedFileData)) {
+					$atomstructure['subatoms'] = $this-&gt;QuicktimeParseContainerAtom($UncompressedHeader, $ThisFileInfo, 0, $atomHierarchy, $ParseAllPossibleAtoms);
+				} else {
+					$ThisFileInfo['warning'][] = 'Error decompressing compressed MOV atom at offset '.$atomstructure['offset'];
+				}
+				break;
+
+
+			case 'dcom': // Data COMpression atom
+				$atomstructure['compression_id']   = $atomdata;
+				$atomstructure['compression_text'] = $this-&gt;QuicktimeDCOMLookup($atomdata);
+				break;
+
+
+			case 'rdrf': // Reference movie Data ReFerence atom
+				$atomstructure['version']                = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']              = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3));
+				$atomstructure['flags']['internal_data'] = (bool) ($atomstructure['flags_raw'] &amp; 0x000001);
+
+				$atomstructure['reference_type_name']    =                           substr($atomdata,  4, 4);
+				$atomstructure['reference_length']       = getid3_lib::BigEndian2Int(substr($atomdata,  8, 4));
+				switch ($atomstructure['reference_type_name']) {
+					case 'url ':
+						$atomstructure['url']            =       $this-&gt;NoNullString(substr($atomdata, 12));
+						break;
+
+					case 'alis':
+						$atomstructure['file_alias']     =                           substr($atomdata, 12);
+						break;
+
+					case 'rsrc':
+						$atomstructure['resource_alias'] =                           substr($atomdata, 12);
+						break;
+
+					default:
+						$atomstructure['data']           =                           substr($atomdata, 12);
+						break;
+				}
+				break;
+
+
+			case 'rmqu': // Reference Movie QUality atom
+				$atomstructure['movie_quality'] = getid3_lib::BigEndian2Int($atomdata);
+				break;
+
+
+			case 'rmcs': // Reference Movie Cpu Speed atom
+				$atomstructure['version']          = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']        = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['cpu_speed_rating'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 2));
+				break;
+
+
+			case 'rmvc': // Reference Movie Version Check atom
+				$atomstructure['version']            = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']          = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['gestalt_selector']   =                           substr($atomdata,  4, 4);
+				$atomstructure['gestalt_value_mask'] = getid3_lib::BigEndian2Int(substr($atomdata,  8, 4));
+				$atomstructure['gestalt_value']      = getid3_lib::BigEndian2Int(substr($atomdata, 12, 4));
+				$atomstructure['gestalt_check_type'] = getid3_lib::BigEndian2Int(substr($atomdata, 14, 2));
+				break;
+
+
+			case 'rmcd': // Reference Movie Component check atom
+				$atomstructure['version']                = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']              = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['component_type']         =                           substr($atomdata,  4, 4);
+				$atomstructure['component_subtype']      =                           substr($atomdata,  8, 4);
+				$atomstructure['component_manufacturer'] =                           substr($atomdata, 12, 4);
+				$atomstructure['component_flags_raw']    = getid3_lib::BigEndian2Int(substr($atomdata, 16, 4));
+				$atomstructure['component_flags_mask']   = getid3_lib::BigEndian2Int(substr($atomdata, 20, 4));
+				$atomstructure['component_min_version']  = getid3_lib::BigEndian2Int(substr($atomdata, 24, 4));
+				break;
+
+
+			case 'rmdr': // Reference Movie Data Rate atom
+				$atomstructure['version']       = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']     = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['data_rate']     = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+
+				$atomstructure['data_rate_bps'] = $atomstructure['data_rate'] * 10;
+				break;
+
+
+			case 'rmla': // Reference Movie Language Atom
+				$atomstructure['version']     = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']   = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['language_id'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 2));
+
+				$atomstructure['language']    = $this-&gt;QuicktimeLanguageLookup($atomstructure['language_id']);
+				if (empty($ThisFileInfo['comments']['language']) || (!in_array($atomstructure['language'], $ThisFileInfo['comments']['language']))) {
+					$ThisFileInfo['comments']['language'][] = $atomstructure['language'];
+				}
+				break;
+
+
+			case 'rmla': // Reference Movie Language Atom
+				$atomstructure['version']   = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw'] = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['track_id']  = getid3_lib::BigEndian2Int(substr($atomdata,  4, 2));
+				break;
+
+
+			case 'ptv ': // Print To Video - defines a movie's full screen mode
+				// <A HREF="http://developer.apple.com/documentation/QuickTime/APIREF/SOURCESIV/at_ptv-_pg.htm">http://developer.apple.com/documentation/QuickTime/APIREF/SOURCESIV/at_ptv-_pg.htm</A>
+				$atomstructure['display_size_raw']  = getid3_lib::BigEndian2Int(substr($atomdata, 0, 2));
+				$atomstructure['reserved_1']        = getid3_lib::BigEndian2Int(substr($atomdata, 2, 2)); // hardcoded: 0x0000
+				$atomstructure['reserved_2']        = getid3_lib::BigEndian2Int(substr($atomdata, 4, 2)); // hardcoded: 0x0000
+				$atomstructure['slide_show_flag']   = getid3_lib::BigEndian2Int(substr($atomdata, 6, 1));
+				$atomstructure['play_on_open_flag'] = getid3_lib::BigEndian2Int(substr($atomdata, 7, 1));
+
+				$atomstructure['flags']['play_on_open'] = (bool) $atomstructure['play_on_open_flag'];
+				$atomstructure['flags']['slide_show']   = (bool) $atomstructure['slide_show_flag'];
+
+				$ptv_lookup[0] = 'normal';
+				$ptv_lookup[1] = 'double';
+				$ptv_lookup[2] = 'half';
+				$ptv_lookup[3] = 'full';
+				$ptv_lookup[4] = 'current';
+				if (isset($ptv_lookup[$atomstructure['display_size_raw']])) {
+					$atomstructure['display_size'] = $ptv_lookup[$atomstructure['display_size_raw']];
+				} else {
+					$ThisFileInfo['warning'][] = 'unknown &quot;ptv &quot; display constant ('.$atomstructure['display_size_raw'].')';
+				}
+				break;
+
+
+			case 'stsd': // Sample Table Sample Description atom
+				$atomstructure['version']        = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']      = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['number_entries'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+				$stsdEntriesDataOffset = 8;
+				for ($i = 0; $i &lt; $atomstructure['number_entries']; $i++) {
+					$atomstructure['sample_description_table'][$i]['size']             = getid3_lib::BigEndian2Int(substr($atomdata, $stsdEntriesDataOffset, 4));
+					$stsdEntriesDataOffset += 4;
+					$atomstructure['sample_description_table'][$i]['data_format']      =                           substr($atomdata, $stsdEntriesDataOffset, 4);
+					$stsdEntriesDataOffset += 4;
+					$atomstructure['sample_description_table'][$i]['reserved']         = getid3_lib::BigEndian2Int(substr($atomdata, $stsdEntriesDataOffset, 6));
+					$stsdEntriesDataOffset += 6;
+					$atomstructure['sample_description_table'][$i]['reference_index']  = getid3_lib::BigEndian2Int(substr($atomdata, $stsdEntriesDataOffset, 2));
+					$stsdEntriesDataOffset += 2;
+					$atomstructure['sample_description_table'][$i]['data']             =                           substr($atomdata, $stsdEntriesDataOffset, ($atomstructure['sample_description_table'][$i]['size'] - 4 - 4 - 6 - 2));
+					$stsdEntriesDataOffset += ($atomstructure['sample_description_table'][$i]['size'] - 4 - 4 - 6 - 2);
+
+					$atomstructure['sample_description_table'][$i]['encoder_version']  = getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'],  0, 2));
+					$atomstructure['sample_description_table'][$i]['encoder_revision'] = getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'],  2, 2));
+					$atomstructure['sample_description_table'][$i]['encoder_vendor']   =                           substr($atomstructure['sample_description_table'][$i]['data'],  4, 4);
+
+					switch ($atomstructure['sample_description_table'][$i]['encoder_vendor']) {
+
+						case &quot;\x00\x00\x00\x00&quot;:
+							// audio atom
+							$atomstructure['sample_description_table'][$i]['audio_channels']       =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'],  8,  2));
+							$atomstructure['sample_description_table'][$i]['audio_bit_depth']      =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 10,  2));
+							$atomstructure['sample_description_table'][$i]['audio_compression_id'] =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 12,  2));
+							$atomstructure['sample_description_table'][$i]['audio_packet_size']    =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 14,  2));
+							$atomstructure['sample_description_table'][$i]['audio_sample_rate']    = getid3_lib::FixedPoint16_16(substr($atomstructure['sample_description_table'][$i]['data'], 16,  4));
+
+							switch ($atomstructure['sample_description_table'][$i]['data_format']) {
+								case 'mp4v':
+									$ThisFileInfo['fileformat'] = 'mp4';
+									$ThisFileInfo['error'][] = 'This version ('.GETID3_VERSION.') of getID3() does not fully support MPEG-4 audio/video streams';
+									break;
+
+								case 'qtvr':
+									$ThisFileInfo['video']['dataformat'] = 'quicktimevr';
+									break;
+
+								case 'mp4a':
+								default:
+									$ThisFileInfo['quicktime']['audio']['codec']       = $this-&gt;QuicktimeAudioCodecLookup($atomstructure['sample_description_table'][$i]['data_format']);
+									$ThisFileInfo['quicktime']['audio']['sample_rate'] = $atomstructure['sample_description_table'][$i]['audio_sample_rate'];
+									$ThisFileInfo['quicktime']['audio']['channels']    = $atomstructure['sample_description_table'][$i]['audio_channels'];
+									$ThisFileInfo['quicktime']['audio']['bit_depth']   = $atomstructure['sample_description_table'][$i]['audio_bit_depth'];
+									$ThisFileInfo['audio']['codec']                    = $ThisFileInfo['quicktime']['audio']['codec'];
+									$ThisFileInfo['audio']['sample_rate']              = $ThisFileInfo['quicktime']['audio']['sample_rate'];
+									$ThisFileInfo['audio']['channels']                 = $ThisFileInfo['quicktime']['audio']['channels'];
+									$ThisFileInfo['audio']['bits_per_sample']          = $ThisFileInfo['quicktime']['audio']['bit_depth'];
+									switch ($atomstructure['sample_description_table'][$i]['data_format']) {
+										case 'raw ': // PCM
+										case 'alac': // Apple Lossless Audio Codec
+											$ThisFileInfo['audio']['lossless'] = true;
+											break;
+										default:
+											$ThisFileInfo['audio']['lossless'] = false;
+											break;
+									}
+									break;
+							}
+							break;
+
+						default:
+							switch ($atomstructure['sample_description_table'][$i]['data_format']) {
+								case 'mp4s':
+									$ThisFileInfo['fileformat'] = 'mp4';
+									break;
+
+								default:
+									// video atom
+									$atomstructure['sample_description_table'][$i]['video_temporal_quality']  =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'],  8,  4));
+									$atomstructure['sample_description_table'][$i]['video_spatial_quality']   =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 12,  4));
+									$atomstructure['sample_description_table'][$i]['video_frame_width']       =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 16,  2));
+									$atomstructure['sample_description_table'][$i]['video_frame_height']      =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 18,  2));
+									$atomstructure['sample_description_table'][$i]['video_resolution_x']      = getid3_lib::FixedPoint16_16(substr($atomstructure['sample_description_table'][$i]['data'], 20,  4));
+									$atomstructure['sample_description_table'][$i]['video_resolution_y']      = getid3_lib::FixedPoint16_16(substr($atomstructure['sample_description_table'][$i]['data'], 24,  4));
+									$atomstructure['sample_description_table'][$i]['video_data_size']         =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 28,  4));
+									$atomstructure['sample_description_table'][$i]['video_frame_count']       =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 32,  2));
+									$atomstructure['sample_description_table'][$i]['video_encoder_name_len']  =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 34,  1));
+									$atomstructure['sample_description_table'][$i]['video_encoder_name']      =                             substr($atomstructure['sample_description_table'][$i]['data'], 35, $atomstructure['sample_description_table'][$i]['video_encoder_name_len']);
+									$atomstructure['sample_description_table'][$i]['video_pixel_color_depth'] =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 66,  2));
+									$atomstructure['sample_description_table'][$i]['video_color_table_id']    =   getid3_lib::BigEndian2Int(substr($atomstructure['sample_description_table'][$i]['data'], 68,  2));
+
+									$atomstructure['sample_description_table'][$i]['video_pixel_color_type']  = (($atomstructure['sample_description_table'][$i]['video_pixel_color_depth'] &gt; 32) ? 'grayscale' : 'color');
+									$atomstructure['sample_description_table'][$i]['video_pixel_color_name']  = $this-&gt;QuicktimeColorNameLookup($atomstructure['sample_description_table'][$i]['video_pixel_color_depth']);
+
+									if ($atomstructure['sample_description_table'][$i]['video_pixel_color_name'] != 'invalid') {
+										$ThisFileInfo['quicktime']['video']['codec_fourcc']        = $atomstructure['sample_description_table'][$i]['data_format'];
+										$ThisFileInfo['quicktime']['video']['codec_fourcc_lookup'] = $this-&gt;QuicktimeVideoCodecLookup($atomstructure['sample_description_table'][$i]['data_format']);
+										$ThisFileInfo['quicktime']['video']['codec']               = $atomstructure['sample_description_table'][$i]['video_encoder_name'];
+										$ThisFileInfo['quicktime']['video']['color_depth']         = $atomstructure['sample_description_table'][$i]['video_pixel_color_depth'];
+										$ThisFileInfo['quicktime']['video']['color_depth_name']    = $atomstructure['sample_description_table'][$i]['video_pixel_color_name'];
+
+										$ThisFileInfo['video']['codec']           = $ThisFileInfo['quicktime']['video']['codec'];
+										$ThisFileInfo['video']['bits_per_sample'] = $ThisFileInfo['quicktime']['video']['color_depth'];
+									}
+									$ThisFileInfo['video']['lossless']           = false;
+									$ThisFileInfo['video']['pixel_aspect_ratio'] = (float) 1;
+									break;
+							}
+							break;
+					}
+					switch (strtolower($atomstructure['sample_description_table'][$i]['data_format'])) {
+						case 'mp4a':
+							$ThisFileInfo['audio']['dataformat']         = 'mp4';
+							$ThisFileInfo['quicktime']['audio']['codec'] = 'mp4';
+							break;
+
+						case '3ivx':
+						case '3iv1':
+						case '3iv2':
+							$ThisFileInfo['video']['dataformat'] = '3ivx';
+							break;
+
+						case 'xvid':
+							$ThisFileInfo['video']['dataformat'] = 'xvid';
+							break;
+
+						case 'mp4v':
+							$ThisFileInfo['video']['dataformat'] = 'mpeg4';
+							break;
+
+						case 'divx':
+						case 'div1':
+						case 'div2':
+						case 'div3':
+						case 'div4':
+						case 'div5':
+						case 'div6':
+							$TDIVXileInfo['video']['dataformat'] = 'divx';
+							break;
+
+						default:
+							// do nothing
+							break;
+					}
+					unset($atomstructure['sample_description_table'][$i]['data']);
+				}
+				break;
+
+
+			case 'stts': // Sample Table Time-to-Sample atom
+				//if ($ParseAllPossibleAtoms) {
+					$atomstructure['version']        = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+					$atomstructure['flags_raw']      = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+					$atomstructure['number_entries'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+					$sttsEntriesDataOffset = 8;
+					$FrameRateCalculatorArray = array();
+					for ($i = 0; $i &lt; $atomstructure['number_entries']; $i++) {
+						$atomstructure['time_to_sample_table'][$i]['sample_count']    = getid3_lib::BigEndian2Int(substr($atomdata, $sttsEntriesDataOffset, 4));
+						$sttsEntriesDataOffset += 4;
+						$atomstructure['time_to_sample_table'][$i]['sample_duration'] = getid3_lib::BigEndian2Int(substr($atomdata, $sttsEntriesDataOffset, 4));
+						$sttsEntriesDataOffset += 4;
+
+						if (!empty($ThisFileInfo['quicktime']['time_scale'])) {
+							$stts_new_framerate = $ThisFileInfo['quicktime']['time_scale'] / $atomstructure['time_to_sample_table'][$i]['sample_duration'];
+							if ($stts_new_framerate &lt;= 60) {
+								// some atoms have durations of &quot;1&quot; giving a very large framerate, which probably is not right
+								$ThisFileInfo['video']['frame_rate'] = max(@$ThisFileInfo['video']['frame_rate'], $stts_new_framerate);
+							}
+						}
+						//@$FrameRateCalculatorArray[($ThisFileInfo['quicktime']['time_scale'] / $atomstructure['time_to_sample_table'][$i]['sample_duration'])] += $atomstructure['time_to_sample_table'][$i]['sample_count'];
+					}
+					//$sttsFramesTotal  = 0;
+					//$sttsSecondsTotal = 0;
+					//foreach ($FrameRateCalculatorArray as $frames_per_second =&gt; $frame_count) {
+					//	if (($frames_per_second &gt; 60) || ($frames_per_second &lt; 1)) {
+					//		// not video FPS information, probably audio information
+					//		$sttsFramesTotal  = 0;
+					//		$sttsSecondsTotal = 0;
+					//		break;
+					//	}
+					//	$sttsFramesTotal  += $frame_count;
+					//	$sttsSecondsTotal += $frame_count / $frames_per_second;
+					//}
+					//if (($sttsFramesTotal &gt; 0) &amp;&amp; ($sttsSecondsTotal &gt; 0)) {
+					//	if (($sttsFramesTotal / $sttsSecondsTotal) &gt; @$ThisFileInfo['video']['frame_rate']) {
+					//		$ThisFileInfo['video']['frame_rate'] = $sttsFramesTotal / $sttsSecondsTotal;
+					//	}
+					//}
+				//}
+				break;
+
+
+			case 'stss': // Sample Table Sync Sample (key frames) atom
+				if ($ParseAllPossibleAtoms) {
+					$atomstructure['version']        = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+					$atomstructure['flags_raw']      = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+					$atomstructure['number_entries'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+					$stssEntriesDataOffset = 8;
+					for ($i = 0; $i &lt; $atomstructure['number_entries']; $i++) {
+						$atomstructure['time_to_sample_table'][$i] = getid3_lib::BigEndian2Int(substr($atomdata, $stssEntriesDataOffset, 4));
+						$stssEntriesDataOffset += 4;
+					}
+				}
+				break;
+
+
+			case 'stsc': // Sample Table Sample-to-Chunk atom
+				if ($ParseAllPossibleAtoms) {
+					$atomstructure['version']        = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+					$atomstructure['flags_raw']      = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+					$atomstructure['number_entries'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+					$stscEntriesDataOffset = 8;
+					for ($i = 0; $i &lt; $atomstructure['number_entries']; $i++) {
+						$atomstructure['sample_to_chunk_table'][$i]['first_chunk']        = getid3_lib::BigEndian2Int(substr($atomdata, $stscEntriesDataOffset, 4));
+						$stscEntriesDataOffset += 4;
+						$atomstructure['sample_to_chunk_table'][$i]['samples_per_chunk']  = getid3_lib::BigEndian2Int(substr($atomdata, $stscEntriesDataOffset, 4));
+						$stscEntriesDataOffset += 4;
+						$atomstructure['sample_to_chunk_table'][$i]['sample_description'] = getid3_lib::BigEndian2Int(substr($atomdata, $stscEntriesDataOffset, 4));
+						$stscEntriesDataOffset += 4;
+					}
+				}
+				break;
+
+
+			case 'stsz': // Sample Table SiZe atom
+				if ($ParseAllPossibleAtoms) {
+					$atomstructure['version']        = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+					$atomstructure['flags_raw']      = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+					$atomstructure['sample_size']    = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+					$atomstructure['number_entries'] = getid3_lib::BigEndian2Int(substr($atomdata,  8, 4));
+					$stszEntriesDataOffset = 12;
+					if ($atomstructure['sample_size'] == 0) {
+						for ($i = 0; $i &lt; $atomstructure['number_entries']; $i++) {
+							$atomstructure['sample_size_table'][$i] = getid3_lib::BigEndian2Int(substr($atomdata, $stszEntriesDataOffset, 4));
+							$stszEntriesDataOffset += 4;
+						}
+					}
+				}
+				break;
+
+
+			case 'stco': // Sample Table Chunk Offset atom
+				if ($ParseAllPossibleAtoms) {
+					$atomstructure['version']        = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+					$atomstructure['flags_raw']      = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+					$atomstructure['number_entries'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+					$stcoEntriesDataOffset = 8;
+					for ($i = 0; $i &lt; $atomstructure['number_entries']; $i++) {
+						$atomstructure['chunk_offset_table'][$i] = getid3_lib::BigEndian2Int(substr($atomdata, $stcoEntriesDataOffset, 4));
+						$stcoEntriesDataOffset += 4;
+					}
+				}
+				break;
+
+
+			case 'dref': // Data REFerence atom
+				$atomstructure['version']        = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']      = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['number_entries'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+				$drefDataOffset = 8;
+				for ($i = 0; $i &lt; $atomstructure['number_entries']; $i++) {
+					$atomstructure['data_references'][$i]['size']                    = getid3_lib::BigEndian2Int(substr($atomdata, $drefDataOffset, 4));
+					$drefDataOffset += 4;
+					$atomstructure['data_references'][$i]['type']                    =               substr($atomdata, $drefDataOffset, 4);
+					$drefDataOffset += 4;
+					$atomstructure['data_references'][$i]['version']                 = getid3_lib::BigEndian2Int(substr($atomdata,  $drefDataOffset, 1));
+					$drefDataOffset += 1;
+					$atomstructure['data_references'][$i]['flags_raw']               = getid3_lib::BigEndian2Int(substr($atomdata,  $drefDataOffset, 3)); // hardcoded: 0x0000
+					$drefDataOffset += 3;
+					$atomstructure['data_references'][$i]['data']                    =               substr($atomdata, $drefDataOffset, ($atomstructure['data_references'][$i]['size'] - 4 - 4 - 1 - 3));
+					$drefDataOffset += ($atomstructure['data_references'][$i]['size'] - 4 - 4 - 1 - 3);
+
+					$atomstructure['data_references'][$i]['flags']['self_reference'] = (bool) ($atomstructure['data_references'][$i]['flags_raw'] &amp; 0x001);
+				}
+				break;
+
+
+			case 'gmin': // base Media INformation atom
+				$atomstructure['version']                = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']              = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['graphics_mode']          = getid3_lib::BigEndian2Int(substr($atomdata,  4, 2));
+				$atomstructure['opcolor_red']            = getid3_lib::BigEndian2Int(substr($atomdata,  6, 2));
+				$atomstructure['opcolor_green']          = getid3_lib::BigEndian2Int(substr($atomdata,  8, 2));
+				$atomstructure['opcolor_blue']           = getid3_lib::BigEndian2Int(substr($atomdata, 10, 2));
+				$atomstructure['balance']                = getid3_lib::BigEndian2Int(substr($atomdata, 12, 2));
+				$atomstructure['reserved']               = getid3_lib::BigEndian2Int(substr($atomdata, 14, 2));
+				break;
+
+
+			case 'smhd': // Sound Media information HeaDer atom
+				$atomstructure['version']                = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']              = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['balance']                = getid3_lib::BigEndian2Int(substr($atomdata,  4, 2));
+				$atomstructure['reserved']               = getid3_lib::BigEndian2Int(substr($atomdata,  6, 2));
+				break;
+
+
+			case 'vmhd': // Video Media information HeaDer atom
+				$atomstructure['version']                = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']              = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3));
+				$atomstructure['graphics_mode']          = getid3_lib::BigEndian2Int(substr($atomdata,  4, 2));
+				$atomstructure['opcolor_red']            = getid3_lib::BigEndian2Int(substr($atomdata,  6, 2));
+				$atomstructure['opcolor_green']          = getid3_lib::BigEndian2Int(substr($atomdata,  8, 2));
+				$atomstructure['opcolor_blue']           = getid3_lib::BigEndian2Int(substr($atomdata, 10, 2));
+
+				$atomstructure['flags']['no_lean_ahead'] = (bool) ($atomstructure['flags_raw'] &amp; 0x001);
+				break;
+
+
+			case 'hdlr': // HanDLeR reference atom
+				$atomstructure['version']                = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']              = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['component_type']         =                           substr($atomdata,  4, 4);
+				$atomstructure['component_subtype']      =                           substr($atomdata,  8, 4);
+				$atomstructure['component_manufacturer'] =                           substr($atomdata, 12, 4);
+				$atomstructure['component_flags_raw']    = getid3_lib::BigEndian2Int(substr($atomdata, 16, 4));
+				$atomstructure['component_flags_mask']   = getid3_lib::BigEndian2Int(substr($atomdata, 20, 4));
+				$atomstructure['component_name']         =      $this-&gt;Pascal2String(substr($atomdata, 24));
+
+				if (($atomstructure['component_subtype'] == 'STpn') &amp;&amp; ($atomstructure['component_manufacturer'] == 'zzzz')) {
+					$ThisFileInfo['video']['dataformat'] = 'quicktimevr';
+				}
+				break;
+
+
+			case 'mdhd': // MeDia HeaDer atom
+				$atomstructure['version']               = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']             = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['creation_time']         = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+				$atomstructure['modify_time']           = getid3_lib::BigEndian2Int(substr($atomdata,  8, 4));
+				$atomstructure['time_scale']            = getid3_lib::BigEndian2Int(substr($atomdata, 12, 4));
+				$atomstructure['duration']              = getid3_lib::BigEndian2Int(substr($atomdata, 16, 4));
+				$atomstructure['language_id']           = getid3_lib::BigEndian2Int(substr($atomdata, 20, 2));
+				$atomstructure['quality']               = getid3_lib::BigEndian2Int(substr($atomdata, 22, 2));
+
+				if ($atomstructure['time_scale'] == 0) {
+					$ThisFileInfo['error'][] = 'Corrupt Quicktime file: mdhd.time_scale == zero';
+					return false;
+				}
+				$atomstructure['creation_time_unix']    = getid3_lib::DateMac2Unix($atomstructure['creation_time']);
+				$atomstructure['modify_time_unix']      = getid3_lib::DateMac2Unix($atomstructure['modify_time']);
+				$atomstructure['playtime_seconds']      = $atomstructure['duration'] / $atomstructure['time_scale'];
+				$atomstructure['language']              = $this-&gt;QuicktimeLanguageLookup($atomstructure['language_id']);
+				if (empty($ThisFileInfo['comments']['language']) || (!in_array($atomstructure['language'], $ThisFileInfo['comments']['language']))) {
+					$ThisFileInfo['comments']['language'][] = $atomstructure['language'];
+				}
+				break;
+
+
+			case 'pnot': // Preview atom
+				$atomstructure['modification_date']      = getid3_lib::BigEndian2Int(substr($atomdata,  0, 4)); // &quot;standard Macintosh format&quot;
+				$atomstructure['version_number']         = getid3_lib::BigEndian2Int(substr($atomdata,  4, 2)); // hardcoded: 0x00
+				$atomstructure['atom_type']              =               substr($atomdata,  6, 4);        // usually: 'PICT'
+				$atomstructure['atom_index']             = getid3_lib::BigEndian2Int(substr($atomdata, 10, 2)); // usually: 0x01
+
+				$atomstructure['modification_date_unix'] = getid3_lib::DateMac2Unix($atomstructure['modification_date']);
+				break;
+
+
+			case 'crgn': // Clipping ReGioN atom
+				$atomstructure['region_size']   = getid3_lib::BigEndian2Int(substr($atomdata,  0, 2)); // The Region size, Region boundary box,
+				$atomstructure['boundary_box']  = getid3_lib::BigEndian2Int(substr($atomdata,  2, 8)); // and Clipping region data fields
+				$atomstructure['clipping_data'] =               substr($atomdata, 10);           // constitute a QuickDraw region.
+				break;
+
+
+			case 'load': // track LOAD settings atom
+				$atomstructure['preload_start_time'] = getid3_lib::BigEndian2Int(substr($atomdata,  0, 4));
+				$atomstructure['preload_duration']   = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+				$atomstructure['preload_flags_raw']  = getid3_lib::BigEndian2Int(substr($atomdata,  8, 4));
+				$atomstructure['default_hints_raw']  = getid3_lib::BigEndian2Int(substr($atomdata, 12, 4));
+
+				$atomstructure['default_hints']['double_buffer'] = (bool) ($atomstructure['default_hints_raw'] &amp; 0x0020);
+				$atomstructure['default_hints']['high_quality']  = (bool) ($atomstructure['default_hints_raw'] &amp; 0x0100);
+				break;
+
+
+			case 'tmcd': // TiMe CoDe atom
+			case 'chap': // CHAPter list atom
+			case 'sync': // SYNChronization atom
+			case 'scpt': // tranSCriPT atom
+			case 'ssrc': // non-primary SouRCe atom
+				for ($i = 0; $i &lt; (strlen($atomdata) % 4); $i++) {
+					$atomstructure['track_id'][$i] = getid3_lib::BigEndian2Int(substr($atomdata, $i * 4, 4));
+				}
+				break;
+
+
+			case 'elst': // Edit LiST atom
+				$atomstructure['version']        = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']      = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['number_entries'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+				for ($i = 0; $i &lt; $atomstructure['number_entries']; $i++ ) {
+					$atomstructure['edit_list'][$i]['track_duration'] =   getid3_lib::BigEndian2Int(substr($atomdata, 8 + ($i * 12) + 0, 4));
+					$atomstructure['edit_list'][$i]['media_time']     =   getid3_lib::BigEndian2Int(substr($atomdata, 8 + ($i * 12) + 4, 4));
+					$atomstructure['edit_list'][$i]['media_rate']     = getid3_lib::FixedPoint16_16(substr($atomdata, 8 + ($i * 12) + 8, 4));
+				}
+				break;
+
+
+			case 'kmat': // compressed MATte atom
+				$atomstructure['version']        = getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']      = getid3_lib::BigEndian2Int(substr($atomdata,  1, 3)); // hardcoded: 0x0000
+				$atomstructure['matte_data_raw'] =               substr($atomdata,  4);
+				break;
+
+
+			case 'ctab': // Color TABle atom
+				$atomstructure['color_table_seed']   = getid3_lib::BigEndian2Int(substr($atomdata,  0, 4)); // hardcoded: 0x00000000
+				$atomstructure['color_table_flags']  = getid3_lib::BigEndian2Int(substr($atomdata,  4, 2)); // hardcoded: 0x8000
+				$atomstructure['color_table_size']   = getid3_lib::BigEndian2Int(substr($atomdata,  6, 2)) + 1;
+				for ($colortableentry = 0; $colortableentry &lt; $atomstructure['color_table_size']; $colortableentry++) {
+					$atomstructure['color_table'][$colortableentry]['alpha'] = getid3_lib::BigEndian2Int(substr($atomdata, 8 + ($colortableentry * 8) + 0, 2));
+					$atomstructure['color_table'][$colortableentry]['red']   = getid3_lib::BigEndian2Int(substr($atomdata, 8 + ($colortableentry * 8) + 2, 2));
+					$atomstructure['color_table'][$colortableentry]['green'] = getid3_lib::BigEndian2Int(substr($atomdata, 8 + ($colortableentry * 8) + 4, 2));
+					$atomstructure['color_table'][$colortableentry]['blue']  = getid3_lib::BigEndian2Int(substr($atomdata, 8 + ($colortableentry * 8) + 6, 2));
+				}
+				break;
+
+
+			case 'mvhd': // MoVie HeaDer atom
+				$atomstructure['version']            =   getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']          =   getid3_lib::BigEndian2Int(substr($atomdata,  1, 3));
+				$atomstructure['creation_time']      =   getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+				$atomstructure['modify_time']        =   getid3_lib::BigEndian2Int(substr($atomdata,  8, 4));
+				$atomstructure['time_scale']         =   getid3_lib::BigEndian2Int(substr($atomdata, 12, 4));
+				$atomstructure['duration']           =   getid3_lib::BigEndian2Int(substr($atomdata, 16, 4));
+				$atomstructure['preferred_rate']     = getid3_lib::FixedPoint16_16(substr($atomdata, 20, 4));
+				$atomstructure['preferred_volume']   =   getid3_lib::FixedPoint8_8(substr($atomdata, 24, 2));
+				$atomstructure['reserved']           =                             substr($atomdata, 26, 10);
+				$atomstructure['matrix_a']           = getid3_lib::FixedPoint16_16(substr($atomdata, 36, 4));
+				$atomstructure['matrix_b']           = getid3_lib::FixedPoint16_16(substr($atomdata, 40, 4));
+				$atomstructure['matrix_u']           =  getid3_lib::FixedPoint2_30(substr($atomdata, 44, 4));
+				$atomstructure['matrix_c']           = getid3_lib::FixedPoint16_16(substr($atomdata, 48, 4));
+				$atomstructure['matrix_d']           = getid3_lib::FixedPoint16_16(substr($atomdata, 52, 4));
+				$atomstructure['matrix_v']           =  getid3_lib::FixedPoint2_30(substr($atomdata, 56, 4));
+				$atomstructure['matrix_x']           = getid3_lib::FixedPoint16_16(substr($atomdata, 60, 4));
+				$atomstructure['matrix_y']           = getid3_lib::FixedPoint16_16(substr($atomdata, 64, 4));
+				$atomstructure['matrix_w']           =  getid3_lib::FixedPoint2_30(substr($atomdata, 68, 4));
+				$atomstructure['preview_time']       =   getid3_lib::BigEndian2Int(substr($atomdata, 72, 4));
+				$atomstructure['preview_duration']   =   getid3_lib::BigEndian2Int(substr($atomdata, 76, 4));
+				$atomstructure['poster_time']        =   getid3_lib::BigEndian2Int(substr($atomdata, 80, 4));
+				$atomstructure['selection_time']     =   getid3_lib::BigEndian2Int(substr($atomdata, 84, 4));
+				$atomstructure['selection_duration'] =   getid3_lib::BigEndian2Int(substr($atomdata, 88, 4));
+				$atomstructure['current_time']       =   getid3_lib::BigEndian2Int(substr($atomdata, 92, 4));
+				$atomstructure['next_track_id']      =   getid3_lib::BigEndian2Int(substr($atomdata, 96, 4));
+
+				if ($atomstructure['time_scale'] == 0) {
+					$ThisFileInfo['error'][] = 'Corrupt Quicktime file: mvhd.time_scale == zero';
+					return false;
+				}
+				$atomstructure['creation_time_unix']        = getid3_lib::DateMac2Unix($atomstructure['creation_time']);
+				$atomstructure['modify_time_unix']          = getid3_lib::DateMac2Unix($atomstructure['modify_time']);
+				$ThisFileInfo['quicktime']['time_scale']    = $atomstructure['time_scale'];
+				$ThisFileInfo['quicktime']['display_scale'] = $atomstructure['matrix_a'];
+				$ThisFileInfo['playtime_seconds']           = $atomstructure['duration'] / $atomstructure['time_scale'];
+				break;
+
+
+			case 'tkhd': // TracK HeaDer atom
+				$atomstructure['version']             =   getid3_lib::BigEndian2Int(substr($atomdata,  0, 1));
+				$atomstructure['flags_raw']           =   getid3_lib::BigEndian2Int(substr($atomdata,  1, 3));
+				$atomstructure['creation_time']       =   getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+				$atomstructure['modify_time']         =   getid3_lib::BigEndian2Int(substr($atomdata,  8, 4));
+				$atomstructure['trackid']             =   getid3_lib::BigEndian2Int(substr($atomdata, 12, 4));
+				$atomstructure['reserved1']           =   getid3_lib::BigEndian2Int(substr($atomdata, 16, 4));
+				$atomstructure['duration']            =   getid3_lib::BigEndian2Int(substr($atomdata, 20, 4));
+				$atomstructure['reserved2']           =   getid3_lib::BigEndian2Int(substr($atomdata, 24, 8));
+				$atomstructure['layer']               =   getid3_lib::BigEndian2Int(substr($atomdata, 32, 2));
+				$atomstructure['alternate_group']     =   getid3_lib::BigEndian2Int(substr($atomdata, 34, 2));
+				$atomstructure['volume']              =   getid3_lib::FixedPoint8_8(substr($atomdata, 36, 2));
+				$atomstructure['reserved3']           =   getid3_lib::BigEndian2Int(substr($atomdata, 38, 2));
+				$atomstructure['matrix_a']            = getid3_lib::FixedPoint16_16(substr($atomdata, 40, 4));
+				$atomstructure['matrix_b']            = getid3_lib::FixedPoint16_16(substr($atomdata, 44, 4));
+				$atomstructure['matrix_u']            = getid3_lib::FixedPoint16_16(substr($atomdata, 48, 4));
+				$atomstructure['matrix_c']            = getid3_lib::FixedPoint16_16(substr($atomdata, 52, 4));
+				$atomstructure['matrix_v']            = getid3_lib::FixedPoint16_16(substr($atomdata, 56, 4));
+				$atomstructure['matrix_d']            = getid3_lib::FixedPoint16_16(substr($atomdata, 60, 4));
+				$atomstructure['matrix_x']            =  getid3_lib::FixedPoint2_30(substr($atomdata, 64, 4));
+				$atomstructure['matrix_y']            =  getid3_lib::FixedPoint2_30(substr($atomdata, 68, 4));
+				$atomstructure['matrix_w']            =  getid3_lib::FixedPoint2_30(substr($atomdata, 72, 4));
+				$atomstructure['width']               = getid3_lib::FixedPoint16_16(substr($atomdata, 76, 4));
+				$atomstructure['height']              = getid3_lib::FixedPoint16_16(substr($atomdata, 80, 4));
+
+				$atomstructure['flags']['enabled']    = (bool) ($atomstructure['flags_raw'] &amp; 0x0001);
+				$atomstructure['flags']['in_movie']   = (bool) ($atomstructure['flags_raw'] &amp; 0x0002);
+				$atomstructure['flags']['in_preview'] = (bool) ($atomstructure['flags_raw'] &amp; 0x0004);
+				$atomstructure['flags']['in_poster']  = (bool) ($atomstructure['flags_raw'] &amp; 0x0008);
+				$atomstructure['creation_time_unix']  = getid3_lib::DateMac2Unix($atomstructure['creation_time']);
+				$atomstructure['modify_time_unix']    = getid3_lib::DateMac2Unix($atomstructure['modify_time']);
+
+				if (!isset($ThisFileInfo['video']['resolution_x']) || !isset($ThisFileInfo['video']['resolution_y'])) {
+					$ThisFileInfo['video']['resolution_x'] = $atomstructure['width'];
+					$ThisFileInfo['video']['resolution_y'] = $atomstructure['height'];
+				}
+				$ThisFileInfo['video']['resolution_x'] = max($ThisFileInfo['video']['resolution_x'], $atomstructure['width']);
+				$ThisFileInfo['video']['resolution_y'] = max($ThisFileInfo['video']['resolution_y'], $atomstructure['height']);
+				if (!empty($ThisFileInfo['video']['resolution_x']) &amp;&amp; !empty($ThisFileInfo['video']['resolution_y'])) {
+					$ThisFileInfo['quicktime']['video']['resolution_x'] = $ThisFileInfo['video']['resolution_x'];
+					$ThisFileInfo['quicktime']['video']['resolution_y'] = $ThisFileInfo['video']['resolution_y'];
+				} else {
+					unset($ThisFileInfo['video']['resolution_x']);
+					unset($ThisFileInfo['video']['resolution_y']);
+					unset($ThisFileInfo['quicktime']['video']);
+				}
+				break;
+
+
+			case 'meta': // METAdata atom
+				// <A HREF="http://www.geocities.com/xhelmboyx/quicktime/formats/qti-layout.txt">http://www.geocities.com/xhelmboyx/quicktime/formats/qti-layout.txt</A>
+				$NextTagPosition = strpos($atomdata, '&#169;');
+				while ($NextTagPosition &lt; strlen($atomdata)) {
+					$metaItemSize = getid3_lib::BigEndian2Int(substr($atomdata, $NextTagPosition - 4, 4)) - 4;
+					if ($metaItemSize == -4) {
+					    break;
+					}
+					$metaItemRaw  = substr($atomdata, $NextTagPosition, $metaItemSize);
+					$metaItemKey  = substr($metaItemRaw, 0, 4);
+					$metaItemData = substr($metaItemRaw, 20);
+					$NextTagPosition += $metaItemSize + 4;
+
+					$this-&gt;CopyToAppropriateCommentsSection($metaItemKey, $metaItemData, $ThisFileInfo);
+				}
+				break;
+
+			case 'ftyp': // FileTYPe (?) atom (for MP4 it seems)
+				$atomstructure['signature'] =                           substr($atomdata,  0, 4);
+				$atomstructure['unknown_1'] = getid3_lib::BigEndian2Int(substr($atomdata,  4, 4));
+				$atomstructure['fourcc']    =                           substr($atomdata,  8, 4);
+				break;
+
+			case 'mdat': // Media DATa atom
+			case 'free': // FREE space atom
+			case 'skip': // SKIP atom
+			case 'wide': // 64-bit expansion placeholder atom
+				// 'mdat' data is too big to deal with, contains no useful metadata
+				// 'free', 'skip' and 'wide' are just padding, contains no useful data at all
+
+				// When writing QuickTime files, it is sometimes necessary to update an atom's size.
+				// It is impossible to update a 32-bit atom to a 64-bit atom since the 32-bit atom
+				// is only 8 bytes in size, and the 64-bit atom requires 16 bytes. Therefore, QuickTime
+				// puts an 8-byte placeholder atom before any atoms it may have to update the size of.
+				// In this way, if the atom needs to be converted from a 32-bit to a 64-bit atom, the
+				// placeholder atom can be overwritten to obtain the necessary 8 extra bytes.
+				// The placeholder atom has a type of kWideAtomPlaceholderType ( 'wide' ).
+				break;
+
+
+			case 'nsav': // NoSAVe atom
+				// <A HREF="http://developer.apple.com/technotes/tn/tn2038.html">http://developer.apple.com/technotes/tn/tn2038.html</A>
+				$atomstructure['data'] = getid3_lib::BigEndian2Int(substr($atomdata,  0, 4));
+				break;
+
+			case 'ctyp': // Controller TYPe atom (seen on QTVR)
+				// <A HREF="http://homepages.slingshot.co.nz/~helmboy/quicktime/formats/qtm-layout.txt">http://homepages.slingshot.co.nz/~helmboy/quicktime/formats/qtm-layout.txt</A>
+				// some controller names are:
+				//   0x00 + 'std' for linear movie
+				//   'none' for no controls
+				$atomstructure['ctyp'] = substr($atomdata, 0, 4);
+				switch ($atomstructure['ctyp']) {
+					case 'qtvr':
+						$ThisFileInfo['video']['dataformat'] = 'quicktimevr';
+						break;
+				}
+				break;
+
+			case 'pano': // PANOrama track (seen on QTVR)
+				$atomstructure['pano'] = getid3_lib::BigEndian2Int(substr($atomdata,  0, 4));
+				break;
+
+			case 'hint': // HINT track
+			case 'hinf': //
+			case 'hinv': //
+			case 'hnti': //
+				$ThisFileInfo['quicktime']['hinting'] = true;
+				break;
+
+			case 'imgt': // IMaGe Track reference (kQTVRImageTrackRefType) (seen on QTVR)
+				for ($i = 0; $i &lt; ($atomstructure['size'] - 8); $i += 4) {
+					$atomstructure['imgt'][] = getid3_lib::BigEndian2Int(substr($atomdata, $i, 4));
+				}
+				break;
+
+			case 'FXTC': // Something to do with Adobe After Effects (?)
+			case 'PrmA':
+			case 'code':
+			case 'FIEL': // this is NOT &quot;fiel&quot; (Field Ordering) as describe here: <A HREF="http://developer.apple.com/documentation/QuickTime/QTFF/QTFFChap3/chapter_4_section_2.html">http://developer.apple.com/documentation/QuickTime/QTFF/QTFFChap3/chapter_4_section_2.html</A>
+				// Observed-but-not-handled atom types are just listed here
+				// to prevent warnings being generated
+				$atomstructure['data'] = $atomdata;
+				break;
+
+			default:
+				$ThisFileInfo['warning'][] = 'Unknown QuickTime atom type: &quot;'.$atomname.'&quot; at offset '.$baseoffset;
+				$atomstructure['data'] = $atomdata;
+				break;
+		}
+		array_pop($atomHierarchy);
+		return $atomstructure;
+	}
+
+	function QuicktimeParseContainerAtom($atomdata, &amp;$ThisFileInfo, $baseoffset, &amp;$atomHierarchy, $ParseAllPossibleAtoms) {
+		$atomstructure  = false;
+		$subatomoffset  = 0;
+		$subatomcounter = 0;
+		if ((strlen($atomdata) == 4) &amp;&amp; (getid3_lib::BigEndian2Int($atomdata) == 0x00000000)) {
+			return false;
+		}
+		while ($subatomoffset &lt; strlen($atomdata)) {
+			$subatomsize = getid3_lib::BigEndian2Int(substr($atomdata, $subatomoffset + 0, 4));
+			$subatomname =               substr($atomdata, $subatomoffset + 4, 4);
+			$subatomdata =               substr($atomdata, $subatomoffset + 8, $subatomsize - 8);
+			if ($subatomsize == 0) {
+				// Furthermore, for historical reasons the list of atoms is optionally
+				// terminated by a 32-bit integer set to 0. If you are writing a program
+				// to read user data atoms, you should allow for the terminating 0.
+				return $atomstructure;
+			}
+
+			$atomstructure[$subatomcounter] = $this-&gt;QuicktimeParseAtom($subatomname, $subatomsize, $subatomdata, $ThisFileInfo, $baseoffset + $subatomoffset, $atomHierarchy, $ParseAllPossibleAtoms);
+
+			$subatomoffset += $subatomsize;
+			$subatomcounter++;
+		}
+		return $atomstructure;
+	}
+
+
+	function QuicktimeLanguageLookup($languageid) {
+		static $QuicktimeLanguageLookup = array();
+		if (empty($QuicktimeLanguageLookup)) {
+			$QuicktimeLanguageLookup[0]   = 'English';
+			$QuicktimeLanguageLookup[1]   = 'French';
+			$QuicktimeLanguageLookup[2]   = 'German';
+			$QuicktimeLanguageLookup[3]   = 'Italian';
+			$QuicktimeLanguageLookup[4]   = 'Dutch';
+			$QuicktimeLanguageLookup[5]   = 'Swedish';
+			$QuicktimeLanguageLookup[6]   = 'Spanish';
+			$QuicktimeLanguageLookup[7]   = 'Danish';
+			$QuicktimeLanguageLookup[8]   = 'Portuguese';
+			$QuicktimeLanguageLookup[9]   = 'Norwegian';
+			$QuicktimeLanguageLookup[10]  = 'Hebrew';
+			$QuicktimeLanguageLookup[11]  = 'Japanese';
+			$QuicktimeLanguageLookup[12]  = 'Arabic';
+			$QuicktimeLanguageLookup[13]  = 'Finnish';
+			$QuicktimeLanguageLookup[14]  = 'Greek';
+			$QuicktimeLanguageLookup[15]  = 'Icelandic';
+			$QuicktimeLanguageLookup[16]  = 'Maltese';
+			$QuicktimeLanguageLookup[17]  = 'Turkish';
+			$QuicktimeLanguageLookup[18]  = 'Croatian';
+			$QuicktimeLanguageLookup[19]  = 'Chinese (Traditional)';
+			$QuicktimeLanguageLookup[20]  = 'Urdu';
+			$QuicktimeLanguageLookup[21]  = 'Hindi';
+			$QuicktimeLanguageLookup[22]  = 'Thai';
+			$QuicktimeLanguageLookup[23]  = 'Korean';
+			$QuicktimeLanguageLookup[24]  = 'Lithuanian';
+			$QuicktimeLanguageLookup[25]  = 'Polish';
+			$QuicktimeLanguageLookup[26]  = 'Hungarian';
+			$QuicktimeLanguageLookup[27]  = 'Estonian';
+			$QuicktimeLanguageLookup[28]  = 'Lettish';
+			$QuicktimeLanguageLookup[28]  = 'Latvian';
+			$QuicktimeLanguageLookup[29]  = 'Saamisk';
+			$QuicktimeLanguageLookup[29]  = 'Lappish';
+			$QuicktimeLanguageLookup[30]  = 'Faeroese';
+			$QuicktimeLanguageLookup[31]  = 'Farsi';
+			$QuicktimeLanguageLookup[31]  = 'Persian';
+			$QuicktimeLanguageLookup[32]  = 'Russian';
+			$QuicktimeLanguageLookup[33]  = 'Chinese (Simplified)';
+			$QuicktimeLanguageLookup[34]  = 'Flemish';
+			$QuicktimeLanguageLookup[35]  = 'Irish';
+			$QuicktimeLanguageLookup[36]  = 'Albanian';
+			$QuicktimeLanguageLookup[37]  = 'Romanian';
+			$QuicktimeLanguageLookup[38]  = 'Czech';
+			$QuicktimeLanguageLookup[39]  = 'Slovak';
+			$QuicktimeLanguageLookup[40]  = 'Slovenian';
+			$QuicktimeLanguageLookup[41]  = 'Yiddish';
+			$QuicktimeLanguageLookup[42]  = 'Serbian';
+			$QuicktimeLanguageLookup[43]  = 'Macedonian';
+			$QuicktimeLanguageLookup[44]  = 'Bulgarian';
+			$QuicktimeLanguageLookup[45]  = 'Ukrainian';
+			$QuicktimeLanguageLookup[46]  = 'Byelorussian';
+			$QuicktimeLanguageLookup[47]  = 'Uzbek';
+			$QuicktimeLanguageLookup[48]  = 'Kazakh';
+			$QuicktimeLanguageLookup[49]  = 'Azerbaijani';
+			$QuicktimeLanguageLookup[50]  = 'AzerbaijanAr';
+			$QuicktimeLanguageLookup[51]  = 'Armenian';
+			$QuicktimeLanguageLookup[52]  = 'Georgian';
+			$QuicktimeLanguageLookup[53]  = 'Moldavian';
+			$QuicktimeLanguageLookup[54]  = 'Kirghiz';
+			$QuicktimeLanguageLookup[55]  = 'Tajiki';
+			$QuicktimeLanguageLookup[56]  = 'Turkmen';
+			$QuicktimeLanguageLookup[57]  = 'Mongolian';
+			$QuicktimeLanguageLookup[58]  = 'MongolianCyr';
+			$QuicktimeLanguageLookup[59]  = 'Pashto';
+			$QuicktimeLanguageLookup[60]  = 'Kurdish';
+			$QuicktimeLanguageLookup[61]  = 'Kashmiri';
+			$QuicktimeLanguageLookup[62]  = 'Sindhi';
+			$QuicktimeLanguageLookup[63]  = 'Tibetan';
+			$QuicktimeLanguageLookup[64]  = 'Nepali';
+			$QuicktimeLanguageLookup[65]  = 'Sanskrit';
+			$QuicktimeLanguageLookup[66]  = 'Marathi';
+			$QuicktimeLanguageLookup[67]  = 'Bengali';
+			$QuicktimeLanguageLookup[68]  = 'Assamese';
+			$QuicktimeLanguageLookup[69]  = 'Gujarati';
+			$QuicktimeLanguageLookup[70]  = 'Punjabi';
+			$QuicktimeLanguageLookup[71]  = 'Oriya';
+			$QuicktimeLanguageLookup[72]  = 'Malayalam';
+			$QuicktimeLanguageLookup[73]  = 'Kannada';
+			$QuicktimeLanguageLookup[74]  = 'Tamil';
+			$QuicktimeLanguageLookup[75]  = 'Telugu';
+			$QuicktimeLanguageLookup[76]  = 'Sinhalese';
+			$QuicktimeLanguageLookup[77]  = 'Burmese';
+			$QuicktimeLanguageLookup[78]  = 'Khmer';
+			$QuicktimeLanguageLookup[79]  = 'Lao';
+			$QuicktimeLanguageLookup[80]  = 'Vietnamese';
+			$QuicktimeLanguageLookup[81]  = 'Indonesian';
+			$QuicktimeLanguageLookup[82]  = 'Tagalog';
+			$QuicktimeLanguageLookup[83]  = 'MalayRoman';
+			$QuicktimeLanguageLookup[84]  = 'MalayArabic';
+			$QuicktimeLanguageLookup[85]  = 'Amharic';
+			$QuicktimeLanguageLookup[86]  = 'Tigrinya';
+			$QuicktimeLanguageLookup[87]  = 'Galla';
+			$QuicktimeLanguageLookup[87]  = 'Oromo';
+			$QuicktimeLanguageLookup[88]  = 'Somali';
+			$QuicktimeLanguageLookup[89]  = 'Swahili';
+			$QuicktimeLanguageLookup[90]  = 'Ruanda';
+			$QuicktimeLanguageLookup[91]  = 'Rundi';
+			$QuicktimeLanguageLookup[92]  = 'Chewa';
+			$QuicktimeLanguageLookup[93]  = 'Malagasy';
+			$QuicktimeLanguageLookup[94]  = 'Esperanto';
+			$QuicktimeLanguageLookup[128] = 'Welsh';
+			$QuicktimeLanguageLookup[129] = 'Basque';
+			$QuicktimeLanguageLookup[130] = 'Catalan';
+			$QuicktimeLanguageLookup[131] = 'Latin';
+			$QuicktimeLanguageLookup[132] = 'Quechua';
+			$QuicktimeLanguageLookup[133] = 'Guarani';
+			$QuicktimeLanguageLookup[134] = 'Aymara';
+			$QuicktimeLanguageLookup[135] = 'Tatar';
+			$QuicktimeLanguageLookup[136] = 'Uighur';
+			$QuicktimeLanguageLookup[137] = 'Dzongkha';
+			$QuicktimeLanguageLookup[138] = 'JavaneseRom';
+		}
+		return (isset($QuicktimeLanguageLookup[$languageid]) ? $QuicktimeLanguageLookup[$languageid] : 'invalid');
+	}
+
+	function QuicktimeVideoCodecLookup($codecid) {
+		static $QuicktimeVideoCodecLookup = array();
+		if (empty($QuicktimeVideoCodecLookup)) {
+			$QuicktimeVideoCodecLookup['3IVX'] = '3ivx MPEG-4';
+			$QuicktimeVideoCodecLookup['3IV1'] = '3ivx MPEG-4 v1';
+			$QuicktimeVideoCodecLookup['3IV2'] = '3ivx MPEG-4 v2';
+			$QuicktimeVideoCodecLookup['avr '] = 'AVR-JPEG';
+			$QuicktimeVideoCodecLookup['base'] = 'Base';
+			$QuicktimeVideoCodecLookup['WRLE'] = 'BMP';
+			$QuicktimeVideoCodecLookup['cvid'] = 'Cinepak';
+			$QuicktimeVideoCodecLookup['clou'] = 'Cloud';
+			$QuicktimeVideoCodecLookup['cmyk'] = 'CMYK';
+			$QuicktimeVideoCodecLookup['yuv2'] = 'ComponentVideo';
+			$QuicktimeVideoCodecLookup['yuvu'] = 'ComponentVideoSigned';
+			$QuicktimeVideoCodecLookup['yuvs'] = 'ComponentVideoUnsigned';
+			$QuicktimeVideoCodecLookup['dvc '] = 'DVC-NTSC';
+			$QuicktimeVideoCodecLookup['dvcp'] = 'DVC-PAL';
+			$QuicktimeVideoCodecLookup['dvpn'] = 'DVCPro-NTSC';
+			$QuicktimeVideoCodecLookup['dvpp'] = 'DVCPro-PAL';
+			$QuicktimeVideoCodecLookup['fire'] = 'Fire';
+			$QuicktimeVideoCodecLookup['flic'] = 'FLC';
+			$QuicktimeVideoCodecLookup['b48r'] = '48RGB';
+			$QuicktimeVideoCodecLookup['gif '] = 'GIF';
+			$QuicktimeVideoCodecLookup['smc '] = 'Graphics';
+			$QuicktimeVideoCodecLookup['h261'] = 'H261';
+			$QuicktimeVideoCodecLookup['h263'] = 'H263';
+			$QuicktimeVideoCodecLookup['IV41'] = 'Indeo4';
+			$QuicktimeVideoCodecLookup['jpeg'] = 'JPEG';
+			$QuicktimeVideoCodecLookup['PNTG'] = 'MacPaint';
+			$QuicktimeVideoCodecLookup['msvc'] = 'Microsoft Video1';
+			$QuicktimeVideoCodecLookup['mjpa'] = 'Motion JPEG-A';
+			$QuicktimeVideoCodecLookup['mjpb'] = 'Motion JPEG-B';
+			$QuicktimeVideoCodecLookup['myuv'] = 'MPEG YUV420';
+			$QuicktimeVideoCodecLookup['dmb1'] = 'OpenDML JPEG';
+			$QuicktimeVideoCodecLookup['kpcd'] = 'PhotoCD';
+			$QuicktimeVideoCodecLookup['8BPS'] = 'Planar RGB';
+			$QuicktimeVideoCodecLookup['png '] = 'PNG';
+			$QuicktimeVideoCodecLookup['qdrw'] = 'QuickDraw';
+			$QuicktimeVideoCodecLookup['qdgx'] = 'QuickDrawGX';
+			$QuicktimeVideoCodecLookup['raw '] = 'RAW';
+			$QuicktimeVideoCodecLookup['.SGI'] = 'SGI';
+			$QuicktimeVideoCodecLookup['b16g'] = '16Gray';
+			$QuicktimeVideoCodecLookup['b64a'] = '64ARGB';
+			$QuicktimeVideoCodecLookup['SVQ1'] = 'Sorenson Video 1';
+			$QuicktimeVideoCodecLookup['SVQ1'] = 'Sorenson Video 3';
+			$QuicktimeVideoCodecLookup['syv9'] = 'Sorenson YUV9';
+			$QuicktimeVideoCodecLookup['tga '] = 'Targa';
+			$QuicktimeVideoCodecLookup['b32a'] = '32AlphaGray';
+			$QuicktimeVideoCodecLookup['tiff'] = 'TIFF';
+			$QuicktimeVideoCodecLookup['path'] = 'Vector';
+			$QuicktimeVideoCodecLookup['rpza'] = 'Video';
+			$QuicktimeVideoCodecLookup['ripl'] = 'WaterRipple';
+			$QuicktimeVideoCodecLookup['WRAW'] = 'Windows RAW';
+			$QuicktimeVideoCodecLookup['y420'] = 'YUV420';
+		}
+		return (isset($QuicktimeVideoCodecLookup[$codecid]) ? $QuicktimeVideoCodecLookup[$codecid] : '');
+	}
+
+	function QuicktimeAudioCodecLookup($codecid) {
+		static $QuicktimeAudioCodecLookup = array();
+		if (empty($QuicktimeAudioCodecLookup)) {
+			$QuicktimeAudioCodecLookup['.mp3']          = 'Fraunhofer MPEG Layer-III alias';
+			$QuicktimeAudioCodecLookup['aac ']          = 'ISO/IEC 14496-3 AAC';
+			$QuicktimeAudioCodecLookup['agsm']          = 'Apple GSM 10:1';
+			$QuicktimeAudioCodecLookup['alac']          = 'Apple Lossless Audio Codec';
+			$QuicktimeAudioCodecLookup['alaw']          = 'A-law 2:1';
+			$QuicktimeAudioCodecLookup['conv']          = 'Sample Format';
+			$QuicktimeAudioCodecLookup['dvca']          = 'DV';
+			$QuicktimeAudioCodecLookup['dvi ']          = 'DV 4:1';
+			$QuicktimeAudioCodecLookup['eqal']          = 'Frequency Equalizer';
+			$QuicktimeAudioCodecLookup['fl32']          = '32-bit Floating Point';
+			$QuicktimeAudioCodecLookup['fl64']          = '64-bit Floating Point';
+			$QuicktimeAudioCodecLookup['ima4']          = 'Interactive Multimedia Association 4:1';
+			$QuicktimeAudioCodecLookup['in24']          = '24-bit Integer';
+			$QuicktimeAudioCodecLookup['in32']          = '32-bit Integer';
+			$QuicktimeAudioCodecLookup['lpc ']          = 'LPC 23:1';
+			$QuicktimeAudioCodecLookup['MAC3']          = 'Macintosh Audio Compression/Expansion (MACE) 3:1';
+			$QuicktimeAudioCodecLookup['MAC6']          = 'Macintosh Audio Compression/Expansion (MACE) 6:1';
+			$QuicktimeAudioCodecLookup['mixb']          = '8-bit Mixer';
+			$QuicktimeAudioCodecLookup['mixw']          = '16-bit Mixer';
+			$QuicktimeAudioCodecLookup['mp4a']          = 'ISO/IEC 14496-3 AAC';
+			$QuicktimeAudioCodecLookup['MS'.&quot;\x00\x02&quot;] = 'Microsoft ADPCM';
+			$QuicktimeAudioCodecLookup['MS'.&quot;\x00\x11&quot;] = 'DV IMA';
+			$QuicktimeAudioCodecLookup['MS'.&quot;\x00\x55&quot;] = 'Fraunhofer MPEG Layer III';
+			$QuicktimeAudioCodecLookup['NONE']          = 'No Encoding';
+			$QuicktimeAudioCodecLookup['Qclp']          = 'Qualcomm PureVoice';
+			$QuicktimeAudioCodecLookup['QDM2']          = 'QDesign Music 2';
+			$QuicktimeAudioCodecLookup['QDMC']          = 'QDesign Music 1';
+			$QuicktimeAudioCodecLookup['ratb']          = '8-bit Rate';
+			$QuicktimeAudioCodecLookup['ratw']          = '16-bit Rate';
+			$QuicktimeAudioCodecLookup['raw ']          = 'raw PCM';
+			$QuicktimeAudioCodecLookup['sour']          = 'Sound Source';
+			$QuicktimeAudioCodecLookup['sowt']          = 'signed/two\'s complement (Little Endian)';
+			$QuicktimeAudioCodecLookup['str1']          = 'Iomega MPEG layer II';
+			$QuicktimeAudioCodecLookup['str2']          = 'Iomega MPEG *layer II';
+			$QuicktimeAudioCodecLookup['str3']          = 'Iomega MPEG **layer II';
+			$QuicktimeAudioCodecLookup['str4']          = 'Iomega MPEG ***layer II';
+			$QuicktimeAudioCodecLookup['twos']          = 'signed/two\'s complement (Big Endian)';
+			$QuicktimeAudioCodecLookup['ulaw']          = 'mu-law 2:1';
+		}
+		return (isset($QuicktimeAudioCodecLookup[$codecid]) ? $QuicktimeAudioCodecLookup[$codecid] : '');
+	}
+
+	function QuicktimeDCOMLookup($compressionid) {
+		static $QuicktimeDCOMLookup = array();
+		if (empty($QuicktimeDCOMLookup)) {
+			$QuicktimeDCOMLookup['zlib'] = 'ZLib Deflate';
+			$QuicktimeDCOMLookup['adec'] = 'Apple Compression';
+		}
+		return (isset($QuicktimeDCOMLookup[$compressionid]) ? $QuicktimeDCOMLookup[$compressionid] : '');
+	}
+
+	function QuicktimeColorNameLookup($colordepthid) {
+		static $QuicktimeColorNameLookup = array();
+		if (empty($QuicktimeColorNameLookup)) {
+			$QuicktimeColorNameLookup[1]  = '2-color (monochrome)';
+			$QuicktimeColorNameLookup[2]  = '4-color';
+			$QuicktimeColorNameLookup[4]  = '16-color';
+			$QuicktimeColorNameLookup[8]  = '256-color';
+			$QuicktimeColorNameLookup[16] = 'thousands (16-bit color)';
+			$QuicktimeColorNameLookup[24] = 'millions (24-bit color)';
+			$QuicktimeColorNameLookup[32] = 'millions+ (32-bit color)';
+			$QuicktimeColorNameLookup[33] = 'black &amp; white';
+			$QuicktimeColorNameLookup[34] = '4-gray';
+			$QuicktimeColorNameLookup[36] = '16-gray';
+			$QuicktimeColorNameLookup[40] = '256-gray';
+		}
+		return (isset($QuicktimeColorNameLookup[$colordepthid]) ? $QuicktimeColorNameLookup[$colordepthid] : 'invalid');
+	}
+
+	function CopyToAppropriateCommentsSection($keyname, $data, &amp;$ThisFileInfo) {
+		static $handyatomtranslatorarray = array();
+		if (empty($handyatomtranslatorarray)) {
+			$handyatomtranslatorarray['&#169;cpy'] = 'copyright';
+			$handyatomtranslatorarray['&#169;day'] = 'creation_date';
+			$handyatomtranslatorarray['&#169;dir'] = 'director';
+			$handyatomtranslatorarray['&#169;ed1'] = 'edit1';
+			$handyatomtranslatorarray['&#169;ed2'] = 'edit2';
+			$handyatomtranslatorarray['&#169;ed3'] = 'edit3';
+			$handyatomtranslatorarray['&#169;ed4'] = 'edit4';
+			$handyatomtranslatorarray['&#169;ed5'] = 'edit5';
+			$handyatomtranslatorarray['&#169;ed6'] = 'edit6';
+			$handyatomtranslatorarray['&#169;ed7'] = 'edit7';
+			$handyatomtranslatorarray['&#169;ed8'] = 'edit8';
+			$handyatomtranslatorarray['&#169;ed9'] = 'edit9';
+			$handyatomtranslatorarray['&#169;fmt'] = 'format';
+			$handyatomtranslatorarray['&#169;inf'] = 'information';
+			$handyatomtranslatorarray['&#169;prd'] = 'producer';
+			$handyatomtranslatorarray['&#169;prf'] = 'performers';
+			$handyatomtranslatorarray['&#169;req'] = 'system_requirements';
+			$handyatomtranslatorarray['&#169;src'] = 'source_credit';
+			$handyatomtranslatorarray['&#169;wrt'] = 'writer';
+
+			// <A HREF="http://www.geocities.com/xhelmboyx/quicktime/formats/qtm-layout.txt">http://www.geocities.com/xhelmboyx/quicktime/formats/qtm-layout.txt</A>
+			$handyatomtranslatorarray['&#169;nam'] = 'title';
+			$handyatomtranslatorarray['&#169;cmt'] = 'comment';
+			$handyatomtranslatorarray['&#169;wrn'] = 'warning';
+			$handyatomtranslatorarray['&#169;hst'] = 'host_computer';
+			$handyatomtranslatorarray['&#169;mak'] = 'make';
+			$handyatomtranslatorarray['&#169;mod'] = 'model';
+			$handyatomtranslatorarray['&#169;PRD'] = 'product';
+			$handyatomtranslatorarray['&#169;swr'] = 'software';
+			$handyatomtranslatorarray['&#169;aut'] = 'author';
+			$handyatomtranslatorarray['&#169;ART'] = 'artist';
+			$handyatomtranslatorarray['&#169;trk'] = 'track';
+			$handyatomtranslatorarray['&#169;alb'] = 'album';
+			$handyatomtranslatorarray['&#169;com'] = 'comment';
+			$handyatomtranslatorarray['&#169;gen'] = 'genre';
+			$handyatomtranslatorarray['&#169;ope'] = 'composer';
+			$handyatomtranslatorarray['&#169;url'] = 'url';
+			$handyatomtranslatorarray['&#169;enc'] = 'encoder';
+		}
+		if (isset($handyatomtranslatorarray[$keyname])) {
+			$ThisFileInfo['quicktime']['comments'][$handyatomtranslatorarray[$keyname]][] = $data;
+		}
+
+		return true;
+	}
+
+	function NoNullString($nullterminatedstring) {
+		// remove the single null terminator on null terminated strings
+		if (substr($nullterminatedstring, strlen($nullterminatedstring) - 1, 1) === &quot;\x00&quot;) {
+			return substr($nullterminatedstring, 0, strlen($nullterminatedstring) - 1);
+		}
+		return $nullterminatedstring;
+	}
+
+	function Pascal2String($pascalstring) {
+		// Pascal strings have 1 unsigned byte at the beginning saying how many chars (1-255) are in the string
+		return substr($pascalstring, 1);
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.real.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.real.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.real.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,528 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio-video.real.php                                 //
+// module for analyzing Real Audio/Video files                 //
+// dependencies: module.audio-video.riff.php                   //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.riff.php', __FILE__, true);
+
+class getid3_real
+{
+
+	function getid3_real(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat']       = 'real';
+		$ThisFileInfo['bitrate']          = 0;
+		$ThisFileInfo['playtime_seconds'] = 0;
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$ChunkCounter = 0;
+		while (ftell($fd) &lt; $ThisFileInfo['avdataend']) {
+			$ChunkData  = fread($fd, 8);
+			$ChunkName  =                           substr($ChunkData, 0, 4);
+			$ChunkSize  = getid3_lib::BigEndian2Int(substr($ChunkData, 4, 4));
+
+			if ($ChunkName == '.ra'.&quot;\xFD&quot;) {
+				$ChunkData .= fread($fd, $ChunkSize - 8);
+				if ($this-&gt;ParseOldRAheader(substr($ChunkData, 0, 128), $ThisFileInfo['real']['old_ra_header'])) {
+					$ThisFileInfo['audio']['dataformat']      = 'real';
+					$ThisFileInfo['audio']['lossless']        = false;
+					$ThisFileInfo['audio']['sample_rate']     = $ThisFileInfo['real']['old_ra_header']['sample_rate'];
+					$ThisFileInfo['audio']['bits_per_sample'] = $ThisFileInfo['real']['old_ra_header']['bits_per_sample'];
+					$ThisFileInfo['audio']['channels']        = $ThisFileInfo['real']['old_ra_header']['channels'];
+
+					$ThisFileInfo['playtime_seconds']         = 60 * ($ThisFileInfo['real']['old_ra_header']['audio_bytes'] / $ThisFileInfo['real']['old_ra_header']['bytes_per_minute']);
+					$ThisFileInfo['audio']['bitrate']         =  8 * ($ThisFileInfo['real']['old_ra_header']['audio_bytes'] / $ThisFileInfo['playtime_seconds']);
+					$ThisFileInfo['audio']['codec']           = $this-&gt;RealAudioCodecFourCClookup($ThisFileInfo['real']['old_ra_header']['fourcc'], $ThisFileInfo['audio']['bitrate']);
+
+					foreach ($ThisFileInfo['real']['old_ra_header']['comments'] as $key =&gt; $valuearray) {
+						if (strlen(trim($valuearray[0])) &gt; 0) {
+							$ThisFileInfo['real']['comments'][$key][] = trim($valuearray[0]);
+						}
+					}
+					return true;
+				}
+				$ThisFileInfo['error'][] = 'There was a problem parsing this RealAudio file. Please submit it for analysis to <A HREF="http://www.getid3.org/upload/">http://www.getid3.org/upload/</A> or <A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>';
+				unset($ThisFileInfo['bitrate']);
+				unset($ThisFileInfo['playtime_seconds']);
+				return false;
+			}
+
+			// shortcut
+			$ThisFileInfo['real']['chunks'][$ChunkCounter] = array();
+			$thisfile_real_chunks_currentchunk = &amp;$ThisFileInfo['real']['chunks'][$ChunkCounter];
+
+			$thisfile_real_chunks_currentchunk['name']   = $ChunkName;
+			$thisfile_real_chunks_currentchunk['offset'] = ftell($fd) - 8;
+			$thisfile_real_chunks_currentchunk['length'] = $ChunkSize;
+			if (($thisfile_real_chunks_currentchunk['offset'] + $thisfile_real_chunks_currentchunk['length']) &gt; $ThisFileInfo['avdataend']) {
+				$ThisFileInfo['warning'][] = 'Chunk &quot;'.$thisfile_real_chunks_currentchunk['name'].'&quot; at offset '.$thisfile_real_chunks_currentchunk['offset'].' claims to be '.$thisfile_real_chunks_currentchunk['length'].' bytes long, which is beyond end of file';
+				return false;
+			}
+
+			if ($ChunkSize &gt; (GETID3_FREAD_BUFFER_SIZE + 8)) {
+
+				$ChunkData .= fread($fd, GETID3_FREAD_BUFFER_SIZE - 8);
+				fseek($fd, $thisfile_real_chunks_currentchunk['offset'] + $ChunkSize, SEEK_SET);
+
+			} else {
+
+				$ChunkData .= fread($fd, $ChunkSize - 8);
+
+			}
+			$offset = 8;
+
+			switch ($ChunkName) {
+
+				case '.RMF': // RealMedia File Header
+					$thisfile_real_chunks_currentchunk['object_version'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+					$offset += 2;
+					switch ($thisfile_real_chunks_currentchunk['object_version']) {
+
+						case 0:
+							$thisfile_real_chunks_currentchunk['file_version']  = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+							$offset += 4;
+							$thisfile_real_chunks_currentchunk['headers_count'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+							$offset += 4;
+							break;
+
+						default:
+							//$ThisFileInfo['warning'][] = 'Expected .RMF-object_version to be &quot;0&quot;, actual value is &quot;'.$thisfile_real_chunks_currentchunk['object_version'].'&quot; (should not be a problem)';
+							break;
+
+					}
+					break;
+
+
+				case 'PROP': // Properties Header
+					$thisfile_real_chunks_currentchunk['object_version']      = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+					$offset += 2;
+					if ($thisfile_real_chunks_currentchunk['object_version'] == 0) {
+						$thisfile_real_chunks_currentchunk['max_bit_rate']    = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['avg_bit_rate']    = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['max_packet_size'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['avg_packet_size'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['num_packets']     = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['duration']        = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['preroll']         = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['index_offset']    = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['data_offset']     = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['num_streams']     = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+						$offset += 2;
+						$thisfile_real_chunks_currentchunk['flags_raw']       = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+						$offset += 2;
+						$ThisFileInfo['playtime_seconds'] = $thisfile_real_chunks_currentchunk['duration'] / 1000;
+						if ($thisfile_real_chunks_currentchunk['duration'] &gt; 0) {
+							$ThisFileInfo['bitrate'] += $thisfile_real_chunks_currentchunk['avg_bit_rate'];
+						}
+						$thisfile_real_chunks_currentchunk['flags']['save_enabled']   = (bool) ($thisfile_real_chunks_currentchunk['flags_raw'] &amp; 0x0001);
+						$thisfile_real_chunks_currentchunk['flags']['perfect_play']   = (bool) ($thisfile_real_chunks_currentchunk['flags_raw'] &amp; 0x0002);
+						$thisfile_real_chunks_currentchunk['flags']['live_broadcast'] = (bool) ($thisfile_real_chunks_currentchunk['flags_raw'] &amp; 0x0004);
+					}
+					break;
+
+				case 'MDPR': // Media Properties Header
+					$thisfile_real_chunks_currentchunk['object_version']         = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+					$offset += 2;
+					if ($thisfile_real_chunks_currentchunk['object_version'] == 0) {
+						$thisfile_real_chunks_currentchunk['stream_number']      = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+						$offset += 2;
+						$thisfile_real_chunks_currentchunk['max_bit_rate']       = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['avg_bit_rate']       = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['max_packet_size']    = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['avg_packet_size']    = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['start_time']         = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['preroll']            = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['duration']           = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['stream_name_size']   = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 1));
+						$offset += 1;
+						$thisfile_real_chunks_currentchunk['stream_name']        = substr($ChunkData, $offset, $thisfile_real_chunks_currentchunk['stream_name_size']);
+						$offset += $thisfile_real_chunks_currentchunk['stream_name_size'];
+						$thisfile_real_chunks_currentchunk['mime_type_size']     = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 1));
+						$offset += 1;
+						$thisfile_real_chunks_currentchunk['mime_type']          = substr($ChunkData, $offset, $thisfile_real_chunks_currentchunk['mime_type_size']);
+						$offset += $thisfile_real_chunks_currentchunk['mime_type_size'];
+						$thisfile_real_chunks_currentchunk['type_specific_len']  = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['type_specific_data'] = substr($ChunkData, $offset, $thisfile_real_chunks_currentchunk['type_specific_len']);
+						$offset += $thisfile_real_chunks_currentchunk['type_specific_len'];
+
+						// shortcut
+						$thisfile_real_chunks_currentchunk_typespecificdata = &amp;$thisfile_real_chunks_currentchunk['type_specific_data'];
+
+						switch ($thisfile_real_chunks_currentchunk['mime_type']) {
+							case 'video/x-pn-realvideo':
+							case 'video/x-pn-multirate-realvideo':
+								// <A HREF="http://www.freelists.org/archives/matroska-devel/07-2003/msg00010.html">http://www.freelists.org/archives/matroska-devel/07-2003/msg00010.html</A>
+
+								// shortcut
+								$thisfile_real_chunks_currentchunk['video_info'] = array();
+								$thisfile_real_chunks_currentchunk_videoinfo     = &amp;$thisfile_real_chunks_currentchunk['video_info'];
+
+								$thisfile_real_chunks_currentchunk_videoinfo['dwSize']            = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata,  0, 4));
+								$thisfile_real_chunks_currentchunk_videoinfo['fourcc1']           =                           substr($thisfile_real_chunks_currentchunk_typespecificdata,  4, 4);
+								$thisfile_real_chunks_currentchunk_videoinfo['fourcc2']           =                           substr($thisfile_real_chunks_currentchunk_typespecificdata,  8, 4);
+								$thisfile_real_chunks_currentchunk_videoinfo['width']             = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 12, 2));
+								$thisfile_real_chunks_currentchunk_videoinfo['height']            = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 14, 2));
+								$thisfile_real_chunks_currentchunk_videoinfo['bits_per_sample']   = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 16, 2));
+								//$thisfile_real_chunks_currentchunk_videoinfo['unknown1']          = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 18, 2));
+								//$thisfile_real_chunks_currentchunk_videoinfo['unknown2']          = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 20, 2));
+								$thisfile_real_chunks_currentchunk_videoinfo['frames_per_second'] = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 22, 2));
+								//$thisfile_real_chunks_currentchunk_videoinfo['unknown3']          = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 24, 2));
+								//$thisfile_real_chunks_currentchunk_videoinfo['unknown4']          = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 26, 2));
+								//$thisfile_real_chunks_currentchunk_videoinfo['unknown5']          = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 28, 2));
+								//$thisfile_real_chunks_currentchunk_videoinfo['unknown6']          = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 30, 2));
+								//$thisfile_real_chunks_currentchunk_videoinfo['unknown7']          = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 32, 2));
+								//$thisfile_real_chunks_currentchunk_videoinfo['unknown8']          = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 34, 2));
+								//$thisfile_real_chunks_currentchunk_videoinfo['unknown9']          = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 36, 2));
+
+								$thisfile_real_chunks_currentchunk_videoinfo['codec'] = getid3_riff::RIFFfourccLookup($thisfile_real_chunks_currentchunk_videoinfo['fourcc2']);
+
+								$ThisFileInfo['video']['resolution_x']    =         $thisfile_real_chunks_currentchunk_videoinfo['width'];
+								$ThisFileInfo['video']['resolution_y']    =         $thisfile_real_chunks_currentchunk_videoinfo['height'];
+								$ThisFileInfo['video']['frame_rate']      = (float) $thisfile_real_chunks_currentchunk_videoinfo['frames_per_second'];
+								$ThisFileInfo['video']['codec']           =         $thisfile_real_chunks_currentchunk_videoinfo['codec'];
+								$ThisFileInfo['video']['bits_per_sample'] =         $thisfile_real_chunks_currentchunk_videoinfo['bits_per_sample'];
+								break;
+
+							case 'audio/x-pn-realaudio':
+							case 'audio/x-pn-multirate-realaudio':
+								$this-&gt;ParseOldRAheader($thisfile_real_chunks_currentchunk_typespecificdata, $thisfile_real_chunks_currentchunk['parsed_audio_data']);
+
+								$ThisFileInfo['audio']['sample_rate']     = $thisfile_real_chunks_currentchunk['parsed_audio_data']['sample_rate'];
+								$ThisFileInfo['audio']['bits_per_sample'] = $thisfile_real_chunks_currentchunk['parsed_audio_data']['bits_per_sample'];
+								$ThisFileInfo['audio']['channels']        = $thisfile_real_chunks_currentchunk['parsed_audio_data']['channels'];
+								if (!empty($ThisFileInfo['audio']['dataformat'])) {
+									foreach ($ThisFileInfo['audio'] as $key =&gt; $value) {
+										if ($key != 'streams') {
+											$ThisFileInfo['audio']['streams'][$thisfile_real_chunks_currentchunk['stream_number']][$key] = $value;
+										}
+									}
+								}
+								break;
+
+							case 'logical-fileinfo':
+								// shortcut
+								$thisfile_real_chunks_currentchunk['logical_fileinfo'] = array();
+								$thisfile_real_chunks_currentchunk_logicalfileinfo     = &amp;$thisfile_real_chunks_currentchunk['logical_fileinfo'];
+
+								$thisfile_real_chunks_currentchunk_logicalfileinfo_offset = 0;
+								$thisfile_real_chunks_currentchunk_logicalfileinfo['logical_fileinfo_length'] = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, $thisfile_real_chunks_currentchunk_logicalfileinfo_offset, 4));
+								$thisfile_real_chunks_currentchunk_logicalfileinfo_offset += 4;
+
+								//$thisfile_real_chunks_currentchunk_logicalfileinfo['unknown1']                = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, $thisfile_real_chunks_currentchunk_logicalfileinfo_offset, 4));
+								$thisfile_real_chunks_currentchunk_logicalfileinfo_offset += 4;
+
+								$thisfile_real_chunks_currentchunk_logicalfileinfo['num_tags']                = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, $thisfile_real_chunks_currentchunk_logicalfileinfo_offset, 4));
+								$thisfile_real_chunks_currentchunk_logicalfileinfo_offset += 4;
+
+								//$thisfile_real_chunks_currentchunk_logicalfileinfo['unknown2']                = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, $thisfile_real_chunks_currentchunk_logicalfileinfo_offset, 4));
+								$thisfile_real_chunks_currentchunk_logicalfileinfo_offset += 4;
+
+								//$thisfile_real_chunks_currentchunk_logicalfileinfo['d']                       = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, $thisfile_real_chunks_currentchunk_logicalfileinfo_offset, 1));
+
+								//$thisfile_real_chunks_currentchunk_logicalfileinfo['one_type'] = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata,     $thisfile_real_chunks_currentchunk_logicalfileinfo_offset, 4));
+								//$thisfile_real_chunks_currentchunk_logicalfileinfo_thislength  = getid3_lib::BigEndian2Int(substr($thisfile_real_chunks_currentchunk_typespecificdata, 4 + $thisfile_real_chunks_currentchunk_logicalfileinfo_offset, 2));
+								//$thisfile_real_chunks_currentchunk_logicalfileinfo['one']      =                           substr($thisfile_real_chunks_currentchunk_typespecificdata, 6 + $thisfile_real_chunks_currentchunk_logicalfileinfo_offset, $thisfile_real_chunks_currentchunk_logicalfileinfo_thislength);
+								//$thisfile_real_chunks_currentchunk_logicalfileinfo_offset += (6 + $thisfile_real_chunks_currentchunk_logicalfileinfo_thislength);
+
+								break;
+
+						}
+
+
+						if (empty($ThisFileInfo['playtime_seconds'])) {
+							$ThisFileInfo['playtime_seconds'] = max($ThisFileInfo['playtime_seconds'], ($thisfile_real_chunks_currentchunk['duration'] + $thisfile_real_chunks_currentchunk['start_time']) / 1000);
+						}
+						if ($thisfile_real_chunks_currentchunk['duration'] &gt; 0) {
+							switch ($thisfile_real_chunks_currentchunk['mime_type']) {
+								case 'audio/x-pn-realaudio':
+								case 'audio/x-pn-multirate-realaudio':
+									$ThisFileInfo['audio']['bitrate']    = (isset($ThisFileInfo['audio']['bitrate']) ? $ThisFileInfo['audio']['bitrate'] : 0) + $thisfile_real_chunks_currentchunk['avg_bit_rate'];
+									$ThisFileInfo['audio']['codec']      = $this-&gt;RealAudioCodecFourCClookup($thisfile_real_chunks_currentchunk['parsed_audio_data']['fourcc'], $ThisFileInfo['audio']['bitrate']);
+									$ThisFileInfo['audio']['dataformat'] = 'real';
+									$ThisFileInfo['audio']['lossless']   = false;
+									break;
+
+								case 'video/x-pn-realvideo':
+								case 'video/x-pn-multirate-realvideo':
+									$ThisFileInfo['video']['bitrate']            = (isset($ThisFileInfo['video']['bitrate']) ? $ThisFileInfo['video']['bitrate'] : 0) + $thisfile_real_chunks_currentchunk['avg_bit_rate'];
+									$ThisFileInfo['video']['bitrate_mode']       = 'cbr';
+									$ThisFileInfo['video']['dataformat']         = 'real';
+									$ThisFileInfo['video']['lossless']           = false;
+									$ThisFileInfo['video']['pixel_aspect_ratio'] = (float) 1;
+									break;
+
+								case 'audio/x-ralf-mpeg4-generic':
+									$ThisFileInfo['audio']['bitrate']    = (isset($ThisFileInfo['audio']['bitrate']) ? $ThisFileInfo['audio']['bitrate'] : 0) + $thisfile_real_chunks_currentchunk['avg_bit_rate'];
+									$ThisFileInfo['audio']['codec']      = 'RealAudio Lossless';
+									$ThisFileInfo['audio']['dataformat'] = 'real';
+									$ThisFileInfo['audio']['lossless']   = true;
+									break;
+							}
+							$ThisFileInfo['bitrate'] = (isset($ThisFileInfo['video']['bitrate']) ? $ThisFileInfo['video']['bitrate'] : 0) + (isset($ThisFileInfo['audio']['bitrate']) ? $ThisFileInfo['audio']['bitrate'] : 0);
+						}
+					}
+					break;
+
+				case 'CONT': // Content Description Header (text comments)
+					$thisfile_real_chunks_currentchunk['object_version'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+					$offset += 2;
+					if ($thisfile_real_chunks_currentchunk['object_version'] == 0) {
+						$thisfile_real_chunks_currentchunk['title_len'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+						$offset += 2;
+						$thisfile_real_chunks_currentchunk['title'] = (string) substr($ChunkData, $offset, $thisfile_real_chunks_currentchunk['title_len']);
+						$offset += $thisfile_real_chunks_currentchunk['title_len'];
+
+						$thisfile_real_chunks_currentchunk['artist_len'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+						$offset += 2;
+						$thisfile_real_chunks_currentchunk['artist'] = (string) substr($ChunkData, $offset, $thisfile_real_chunks_currentchunk['artist_len']);
+						$offset += $thisfile_real_chunks_currentchunk['artist_len'];
+
+						$thisfile_real_chunks_currentchunk['copyright_len'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+						$offset += 2;
+						$thisfile_real_chunks_currentchunk['copyright'] = (string) substr($ChunkData, $offset, $thisfile_real_chunks_currentchunk['copyright_len']);
+						$offset += $thisfile_real_chunks_currentchunk['copyright_len'];
+
+						$thisfile_real_chunks_currentchunk['comment_len'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+						$offset += 2;
+						$thisfile_real_chunks_currentchunk['comment'] = (string) substr($ChunkData, $offset, $thisfile_real_chunks_currentchunk['comment_len']);
+						$offset += $thisfile_real_chunks_currentchunk['comment_len'];
+
+
+						$commentkeystocopy = array('title'=&gt;'title', 'artist'=&gt;'artist', 'copyright'=&gt;'copyright', 'comment'=&gt;'comment');
+						foreach ($commentkeystocopy as $key =&gt; $val) {
+							if ($thisfile_real_chunks_currentchunk[$key]) {
+								$ThisFileInfo['real']['comments'][$val][] = trim($thisfile_real_chunks_currentchunk[$key]);
+							}
+						}
+
+					}
+					break;
+
+
+				case 'DATA': // Data Chunk Header
+					// do nothing
+					break;
+
+				case 'INDX': // Index Section Header
+					$thisfile_real_chunks_currentchunk['object_version']        = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+					$offset += 2;
+					if ($thisfile_real_chunks_currentchunk['object_version'] == 0) {
+						$thisfile_real_chunks_currentchunk['num_indices']       = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+						$thisfile_real_chunks_currentchunk['stream_number']     = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 2));
+						$offset += 2;
+						$thisfile_real_chunks_currentchunk['next_index_header'] = getid3_lib::BigEndian2Int(substr($ChunkData, $offset, 4));
+						$offset += 4;
+
+						if ($thisfile_real_chunks_currentchunk['next_index_header'] == 0) {
+							// last index chunk found, ignore rest of file
+							break 2;
+						} else {
+							// non-last index chunk, seek to next index chunk (skipping actual index data)
+							fseek($fd, $thisfile_real_chunks_currentchunk['next_index_header'], SEEK_SET);
+						}
+					}
+					break;
+
+				default:
+					$ThisFileInfo['warning'][] = 'Unhandled RealMedia chunk &quot;'.$ChunkName.'&quot; at offset '.$thisfile_real_chunks_currentchunk['offset'];
+					break;
+			}
+			$ChunkCounter++;
+		}
+
+		if (!empty($ThisFileInfo['audio']['streams'])) {
+			$ThisFileInfo['audio']['bitrate'] = 0;
+			foreach ($ThisFileInfo['audio']['streams'] as $key =&gt; $valuearray) {
+				$ThisFileInfo['audio']['bitrate'] += $valuearray['bitrate'];
+			}
+		}
+
+		return true;
+	}
+
+
+	function ParseOldRAheader($OldRAheaderData, &amp;$ParsedArray) {
+		// <A HREF="http://www.freelists.org/archives/matroska-devel/07-2003/msg00010.html">http://www.freelists.org/archives/matroska-devel/07-2003/msg00010.html</A>
+
+		$ParsedArray = array();
+		$ParsedArray['magic'] = substr($OldRAheaderData, 0, 4);
+		if ($ParsedArray['magic'] != '.ra'.&quot;\xFD&quot;) {
+			return false;
+		}
+		$ParsedArray['version1']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData,  4, 2));
+
+		if ($ParsedArray['version1'] &lt; 3) {
+
+			return false;
+
+		} elseif ($ParsedArray['version1'] == 3) {
+
+			$ParsedArray['fourcc1']          = '.ra3';
+			$ParsedArray['bits_per_sample']  = 16;   // hard-coded for old versions?
+			$ParsedArray['sample_rate']      = 8000; // hard-coded for old versions?
+
+			$ParsedArray['header_size']      = getid3_lib::BigEndian2Int(substr($OldRAheaderData,  6, 2));
+			$ParsedArray['channels']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData,  8, 2)); // always 1 (?)
+			//$ParsedArray['unknown1']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 10, 2));
+			//$ParsedArray['unknown2']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 12, 2));
+			//$ParsedArray['unknown3']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 14, 2));
+			$ParsedArray['bytes_per_minute'] = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 16, 2));
+			$ParsedArray['audio_bytes']      = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 18, 4));
+			$ParsedArray['comments_raw']     =                           substr($OldRAheaderData, 22, $ParsedArray['header_size'] - 22 + 1); // not including null terminator
+
+			$commentoffset = 0;
+			$commentlength = getid3_lib::BigEndian2Int(substr($ParsedArray['comments_raw'], $commentoffset++, 1));
+			$ParsedArray['comments']['title'][]     = substr($ParsedArray['comments_raw'], $commentoffset, $commentlength);
+			$commentoffset += $commentlength;
+
+			$commentlength = getid3_lib::BigEndian2Int(substr($ParsedArray['comments_raw'], $commentoffset++, 1));
+			$ParsedArray['comments']['artist'][]    = substr($ParsedArray['comments_raw'], $commentoffset, $commentlength);
+			$commentoffset += $commentlength;
+
+			$commentlength = getid3_lib::BigEndian2Int(substr($ParsedArray['comments_raw'], $commentoffset++, 1));
+			$ParsedArray['comments']['copyright'][] = substr($ParsedArray['comments_raw'], $commentoffset, $commentlength);
+			$commentoffset += $commentlength;
+
+			$commentoffset++; // final null terminator (?)
+			$commentoffset++; // fourcc length (?) should be 4
+			$ParsedArray['fourcc']           =                           substr($OldRAheaderData, 23 + $commentoffset, 4);
+
+		} elseif ($ParsedArray['version1'] &lt;= 5) {
+
+			//$ParsedArray['unknown1']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData,  6, 2));
+			$ParsedArray['fourcc1']          =                           substr($OldRAheaderData,  8, 4);
+			$ParsedArray['file_size']        = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 12, 4));
+			$ParsedArray['version2']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 16, 2));
+			$ParsedArray['header_size']      = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 18, 4));
+			$ParsedArray['codec_flavor_id']  = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 22, 2));
+			$ParsedArray['coded_frame_size'] = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 24, 4));
+			$ParsedArray['audio_bytes']      = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 28, 4));
+			$ParsedArray['bytes_per_minute'] = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 32, 4));
+			//$ParsedArray['unknown5']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 36, 4));
+			$ParsedArray['sub_packet_h']     = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 40, 2));
+			$ParsedArray['frame_size']       = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 42, 2));
+			$ParsedArray['sub_packet_size']  = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 44, 2));
+			//$ParsedArray['unknown6']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 46, 2));
+
+			switch ($ParsedArray['version1']) {
+
+				case 4:
+					$ParsedArray['sample_rate']      = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 48, 2));
+					//$ParsedArray['unknown8']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 50, 2));
+					$ParsedArray['bits_per_sample']  = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 52, 2));
+					$ParsedArray['channels']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 54, 2));
+					$ParsedArray['length_fourcc2']   = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 56, 1));
+					$ParsedArray['fourcc2']          =                           substr($OldRAheaderData, 57, 4);
+					$ParsedArray['length_fourcc3']   = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 61, 1));
+					$ParsedArray['fourcc3']          =                           substr($OldRAheaderData, 62, 4);
+					//$ParsedArray['unknown9']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 66, 1));
+					//$ParsedArray['unknown10']        = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 67, 2));
+					$ParsedArray['comments_raw']     =                           substr($OldRAheaderData, 69, $ParsedArray['header_size'] - 69 + 16);
+
+					$commentoffset = 0;
+					$commentlength = getid3_lib::BigEndian2Int(substr($ParsedArray['comments_raw'], $commentoffset++, 1));
+					$ParsedArray['comments']['title'][]     = substr($ParsedArray['comments_raw'], $commentoffset, $commentlength);
+					$commentoffset += $commentlength;
+
+					$commentlength = getid3_lib::BigEndian2Int(substr($ParsedArray['comments_raw'], $commentoffset++, 1));
+					$ParsedArray['comments']['artist'][]    = substr($ParsedArray['comments_raw'], $commentoffset, $commentlength);
+					$commentoffset += $commentlength;
+
+					$commentlength = getid3_lib::BigEndian2Int(substr($ParsedArray['comments_raw'], $commentoffset++, 1));
+					$ParsedArray['comments']['copyright'][] = substr($ParsedArray['comments_raw'], $commentoffset, $commentlength);
+					$commentoffset += $commentlength;
+					break;
+
+				case 5:
+					$ParsedArray['sample_rate']      = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 48, 4));
+					$ParsedArray['sample_rate2']     = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 52, 4));
+					$ParsedArray['bits_per_sample']  = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 56, 4));
+					$ParsedArray['channels']         = getid3_lib::BigEndian2Int(substr($OldRAheaderData, 60, 2));
+					$ParsedArray['genr']             =                           substr($OldRAheaderData, 62, 4);
+					$ParsedArray['fourcc3']          =                           substr($OldRAheaderData, 66, 4);
+					$ParsedArray['comments']         = array();
+					break;
+			}
+			$ParsedArray['fourcc'] = $ParsedArray['fourcc3'];
+
+		}
+		foreach ($ParsedArray['comments'] as $key =&gt; $value) {
+			if ($ParsedArray['comments'][$key][0] === false) {
+				$ParsedArray['comments'][$key][0] = '';
+			}
+		}
+
+		return true;
+	}
+
+	function RealAudioCodecFourCClookup($fourcc, $bitrate) {
+		static $RealAudioCodecFourCClookup = array();
+		if (empty($RealAudioCodecFourCClookup)) {
+			// <A HREF="http://www.its.msstate.edu/net/real/reports/config/tags.stats">http://www.its.msstate.edu/net/real/reports/config/tags.stats</A>
+			// <A HREF="http://www.freelists.org/archives/matroska-devel/06-2003/fullthread18.html">http://www.freelists.org/archives/matroska-devel/06-2003/fullthread18.html</A>
+
+			$RealAudioCodecFourCClookup['14_4'][8000]  = 'RealAudio v2 (14.4kbps)';
+			$RealAudioCodecFourCClookup['14.4'][8000]  = 'RealAudio v2 (14.4kbps)';
+			$RealAudioCodecFourCClookup['lpcJ'][8000]  = 'RealAudio v2 (14.4kbps)';
+			$RealAudioCodecFourCClookup['28_8'][15200] = 'RealAudio v2 (28.8kbps)';
+			$RealAudioCodecFourCClookup['28.8'][15200] = 'RealAudio v2 (28.8kbps)';
+			$RealAudioCodecFourCClookup['sipr'][4933]  = 'RealAudio v4 (5kbps Voice)';
+			$RealAudioCodecFourCClookup['sipr'][6444]  = 'RealAudio v4 (6.5kbps Voice)';
+			$RealAudioCodecFourCClookup['sipr'][8444]  = 'RealAudio v4 (8.5kbps Voice)';
+			$RealAudioCodecFourCClookup['sipr'][16000] = 'RealAudio v4 (16kbps Wideband)';
+			$RealAudioCodecFourCClookup['dnet'][8000]  = 'RealAudio v3 (8kbps Music)';
+			$RealAudioCodecFourCClookup['dnet'][16000] = 'RealAudio v3 (16kbps Music Low Response)';
+			$RealAudioCodecFourCClookup['dnet'][15963] = 'RealAudio v3 (16kbps Music Mid/High Response)';
+			$RealAudioCodecFourCClookup['dnet'][20000] = 'RealAudio v3 (20kbps Music Stereo)';
+			$RealAudioCodecFourCClookup['dnet'][32000] = 'RealAudio v3 (32kbps Music Mono)';
+			$RealAudioCodecFourCClookup['dnet'][31951] = 'RealAudio v3 (32kbps Music Stereo)';
+			$RealAudioCodecFourCClookup['dnet'][39965] = 'RealAudio v3 (40kbps Music Mono)';
+			$RealAudioCodecFourCClookup['dnet'][40000] = 'RealAudio v3 (40kbps Music Stereo)';
+			$RealAudioCodecFourCClookup['dnet'][79947] = 'RealAudio v3 (80kbps Music Mono)';
+			$RealAudioCodecFourCClookup['dnet'][80000] = 'RealAudio v3 (80kbps Music Stereo)';
+
+			$RealAudioCodecFourCClookup['dnet'][0] = 'RealAudio v3';
+			$RealAudioCodecFourCClookup['sipr'][0] = 'RealAudio v4';
+			$RealAudioCodecFourCClookup['cook'][0] = 'RealAudio G2';
+			$RealAudioCodecFourCClookup['atrc'][0] = 'RealAudio 8';
+		}
+		$roundbitrate = intval(round($bitrate));
+		if (isset($RealAudioCodecFourCClookup[$fourcc][$roundbitrate])) {
+			return $RealAudioCodecFourCClookup[$fourcc][$roundbitrate];
+		} elseif (isset($RealAudioCodecFourCClookup[$fourcc][0])) {
+			return $RealAudioCodecFourCClookup[$fourcc][0];
+		}
+		return $fourcc;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.riff.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.riff.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.riff.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,1995 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio-video.riff.php                                 //
+// module for analyzing RIFF files                             //
+// multiple formats supported by this module:                  //
+//    Wave, AVI, AIFF/AIFC, (MP3,AC3)/RIFF, Wavpack v3, 8SVX   //
+// dependencies: module.audio.mp3.php                          //
+//               module.audio.ac3.php (optional)               //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.mp3.php', __FILE__, true);
+
+class getid3_riff
+{
+
+	function getid3_riff(&amp;$fd, &amp;$ThisFileInfo) {
+
+		// initialize these values to an empty array, otherwise they default to NULL
+		// and you can't append array values to a NULL value
+		$ThisFileInfo['riff'] = array('raw'=&gt;array());
+
+		// Shortcuts
+		$thisfile_riff             = &amp;$ThisFileInfo['riff'];
+		$thisfile_riff_raw         = &amp;$thisfile_riff['raw'];
+		$thisfile_audio            = &amp;$ThisFileInfo['audio'];
+		$thisfile_video            = &amp;$ThisFileInfo['video'];
+		$thisfile_avdataoffset     = &amp;$ThisFileInfo['avdataoffset'];
+		$thisfile_avdataend        = &amp;$ThisFileInfo['avdataend'];
+		$thisfile_audio_dataformat = &amp;$thisfile_audio['dataformat'];
+		$thisfile_riff_audio       = &amp;$thisfile_riff['audio'];
+		$thisfile_riff_video       = &amp;$thisfile_riff['video'];
+
+
+		$Original['avdataoffset'] = $thisfile_avdataoffset;
+		$Original['avdataend']    = $thisfile_avdataend;
+
+		fseek($fd, $thisfile_avdataoffset, SEEK_SET);
+		$RIFFheader = fread($fd, 12);
+		$RIFFsubtype = substr($RIFFheader, 8, 4);
+		switch (substr($RIFFheader, 0, 4)) {
+			case 'FORM':
+				$ThisFileInfo['fileformat']   = 'aiff';
+				$RIFFheaderSize               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($RIFFheader, 4, 4));
+				$thisfile_riff[$RIFFsubtype]  = getid3_riff::ParseRIFF($fd, $thisfile_avdataoffset + 12, $thisfile_avdataoffset + $RIFFheaderSize, $ThisFileInfo);
+				$thisfile_riff['header_size'] = $RIFFheaderSize;
+				break;
+
+			case 'RIFF':
+			case 'SDSS':  // SDSS is identical to RIFF, just renamed. Used by SmartSound QuickTracks (www.smartsound.com)
+			case 'RMP3':  // RMP3 is identical to RIFF, just renamed. Used by [unknown program] when creating RIFF-MP3s
+				if ($RIFFsubtype == 'RMP3') {
+					// RMP3 is identical to WAVE, just renamed. Used by [unknown program] when creating RIFF-MP3s
+					$RIFFsubtype = 'WAVE';
+				}
+
+				$ThisFileInfo['fileformat']   = 'riff';
+				$RIFFheaderSize               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($RIFFheader, 4, 4));
+				$thisfile_riff[$RIFFsubtype]  = getid3_riff::ParseRIFF($fd, $thisfile_avdataoffset + 12, $thisfile_avdataoffset + $RIFFheaderSize, $ThisFileInfo);
+				$thisfile_riff['header_size'] = $RIFFheaderSize;
+				if ($RIFFsubtype == 'WAVE') {
+					$thisfile_riff_WAVE = &amp;$thisfile_riff['WAVE'];
+				}
+				break;
+
+			default:
+				$ThisFileInfo['error'][] = 'Cannot parse RIFF (this is maybe not a RIFF / WAV / AVI file?) - expecting &quot;FORM|RIFF|SDSS|RMP3&quot; found &quot;'.$RIFFsubtype.'&quot; instead';
+				unset($ThisFileInfo['fileformat']);
+				return false;
+				break;
+		}
+
+		$streamindex = 0;
+		switch ($RIFFsubtype) {
+			case 'WAVE':
+				if (empty($thisfile_audio['bitrate_mode'])) {
+					$thisfile_audio['bitrate_mode'] = 'cbr';
+				}
+				if (empty($thisfile_audio_dataformat)) {
+					$thisfile_audio_dataformat = 'wav';
+				}
+
+				if (isset($thisfile_riff_WAVE['data'][0]['offset'])) {
+					$thisfile_avdataoffset = $thisfile_riff_WAVE['data'][0]['offset'] + 8;
+					$thisfile_avdataend    = $thisfile_avdataoffset + $thisfile_riff_WAVE['data'][0]['size'];
+				}
+				if (isset($thisfile_riff_WAVE['fmt '][0]['data'])) {
+
+					$thisfile_riff_audio[$streamindex] = getid3_riff::RIFFparseWAVEFORMATex($thisfile_riff_WAVE['fmt '][0]['data']);
+					$thisfile_audio['wformattag'] = $thisfile_riff_audio[$streamindex]['raw']['wFormatTag'];
+					if (@$thisfile_riff_audio[$streamindex]['bitrate'] == 0) {
+						$ThisFileInfo['error'][] = 'Corrupt RIFF file: bitrate_audio == zero';
+						return false;
+					}
+					$thisfile_riff_raw['fmt '] = $thisfile_riff_audio[$streamindex]['raw'];
+					unset($thisfile_riff_audio[$streamindex]['raw']);
+					$thisfile_audio['streams'][$streamindex] = $thisfile_riff_audio[$streamindex];
+
+					$thisfile_audio = getid3_lib::array_merge_noclobber($thisfile_audio, $thisfile_riff_audio[$streamindex]);
+					if (substr($thisfile_audio['codec'], 0, strlen('unknown: 0x')) == 'unknown: 0x') {
+						$ThisFileInfo['warning'][] = 'Audio codec = '.$thisfile_audio['codec'];
+					}
+					$thisfile_audio['bitrate'] = $thisfile_riff_audio[$streamindex]['bitrate'];
+
+					$ThisFileInfo['playtime_seconds'] = (float) ((($thisfile_avdataend - $thisfile_avdataoffset) * 8) / $thisfile_audio['bitrate']);
+
+					$thisfile_audio['lossless'] = false;
+					if (isset($thisfile_riff_WAVE['data'][0]['offset']) &amp;&amp; isset($thisfile_riff_raw['fmt ']['wFormatTag'])) {
+						switch ($thisfile_riff_raw['fmt ']['wFormatTag']) {
+
+							case 0x0001:  // PCM
+								$thisfile_audio['lossless'] = true;
+								break;
+
+							case 0x2000:  // AC-3
+								$thisfile_audio_dataformat = 'ac3';
+								break;
+
+							default:
+								// do nothing
+								break;
+
+						}
+					}
+					$thisfile_audio['streams'][$streamindex]['wformattag']   = $thisfile_audio['wformattag'];
+					$thisfile_audio['streams'][$streamindex]['bitrate_mode'] = $thisfile_audio['bitrate_mode'];
+					$thisfile_audio['streams'][$streamindex]['lossless']     = $thisfile_audio['lossless'];
+					$thisfile_audio['streams'][$streamindex]['dataformat']   = $thisfile_audio_dataformat;
+				}
+
+				if (isset($thisfile_riff_WAVE['rgad'][0]['data'])) {
+
+					// shortcuts
+					$rgadData = &amp;$thisfile_riff_WAVE['rgad'][0]['data'];
+					$thisfile_riff_raw['rgad']    = array('track'=&gt;array(), 'album'=&gt;array());
+					$thisfile_riff_raw_rgad       = &amp;$thisfile_riff_raw['rgad'];
+					$thisfile_riff_raw_rgad_track = &amp;$thisfile_riff_raw_rgad['track'];
+					$thisfile_riff_raw_rgad_album = &amp;$thisfile_riff_raw_rgad['album'];
+
+					$thisfile_riff_raw_rgad['fPeakAmplitude']      =               getid3_lib::LittleEndian2Float(substr($rgadData, 0, 4));
+					$thisfile_riff_raw_rgad['nRadioRgAdjust']      = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($rgadData, 4, 2));
+					$thisfile_riff_raw_rgad['nAudiophileRgAdjust'] = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($rgadData, 6, 2));
+
+					$nRadioRgAdjustBitstring      = str_pad(getid3_lib::Dec2Bin($thisfile_riff_raw_rgad['nRadioRgAdjust']), 16, '0', STR_PAD_LEFT);
+					$nAudiophileRgAdjustBitstring = str_pad(getid3_lib::Dec2Bin($thisfile_riff_raw_rgad['nAudiophileRgAdjust']), 16, '0', STR_PAD_LEFT);
+					$thisfile_riff_raw_rgad_track['name']       = getid3_lib::Bin2Dec(substr($nRadioRgAdjustBitstring, 0, 3));
+					$thisfile_riff_raw_rgad_track['originator'] = getid3_lib::Bin2Dec(substr($nRadioRgAdjustBitstring, 3, 3));
+					$thisfile_riff_raw_rgad_track['signbit']    = getid3_lib::Bin2Dec(substr($nRadioRgAdjustBitstring, 6, 1));
+					$thisfile_riff_raw_rgad_track['adjustment'] = getid3_lib::Bin2Dec(substr($nRadioRgAdjustBitstring, 7, 9));
+					$thisfile_riff_raw_rgad_album['name']       = getid3_lib::Bin2Dec(substr($nAudiophileRgAdjustBitstring, 0, 3));
+					$thisfile_riff_raw_rgad_album['originator'] = getid3_lib::Bin2Dec(substr($nAudiophileRgAdjustBitstring, 3, 3));
+					$thisfile_riff_raw_rgad_album['signbit']    = getid3_lib::Bin2Dec(substr($nAudiophileRgAdjustBitstring, 6, 1));
+					$thisfile_riff_raw_rgad_album['adjustment'] = getid3_lib::Bin2Dec(substr($nAudiophileRgAdjustBitstring, 7, 9));
+
+					$thisfile_riff['rgad']['peakamplitude'] = $thisfile_riff_raw_rgad['fPeakAmplitude'];
+					if (($thisfile_riff_raw_rgad_track['name'] != 0) &amp;&amp; ($thisfile_riff_raw_rgad_track['originator'] != 0)) {
+						$thisfile_riff['rgad']['track']['name']            = getid3_lib::RGADnameLookup($thisfile_riff_raw_rgad_track['name']);
+						$thisfile_riff['rgad']['track']['originator']      = getid3_lib::RGADoriginatorLookup($thisfile_riff_raw_rgad_track['originator']);
+						$thisfile_riff['rgad']['track']['adjustment']      = getid3_lib::RGADadjustmentLookup($thisfile_riff_raw_rgad_track['adjustment'], $thisfile_riff_raw_rgad_track['signbit']);
+					}
+					if (($thisfile_riff_raw_rgad_album['name'] != 0) &amp;&amp; ($thisfile_riff_raw_rgad_album['originator'] != 0)) {
+						$thisfile_riff['rgad']['album']['name']       = getid3_lib::RGADnameLookup($thisfile_riff_raw_rgad_album['name']);
+						$thisfile_riff['rgad']['album']['originator'] = getid3_lib::RGADoriginatorLookup($thisfile_riff_raw_rgad_album['originator']);
+						$thisfile_riff['rgad']['album']['adjustment'] = getid3_lib::RGADadjustmentLookup($thisfile_riff_raw_rgad_album['adjustment'], $thisfile_riff_raw_rgad_album['signbit']);
+					}
+				}
+
+				if (isset($thisfile_riff_WAVE['fact'][0]['data'])) {
+					$thisfile_riff_raw['fact']['NumberOfSamples'] = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($thisfile_riff_WAVE['fact'][0]['data'], 0, 4));
+
+					// This should be a good way of calculating exact playtime,
+					// but some sample files have had incorrect number of samples,
+					// so cannot use this method
+
+					// if (!empty($thisfile_riff_raw['fmt ']['nSamplesPerSec'])) {
+					//     $ThisFileInfo['playtime_seconds'] = (float) $thisfile_riff_raw['fact']['NumberOfSamples'] / $thisfile_riff_raw['fmt ']['nSamplesPerSec'];
+					// }
+				}
+				if (!empty($thisfile_riff_raw['fmt ']['nAvgBytesPerSec'])) {
+					$thisfile_audio['bitrate'] = getid3_lib::CastAsInt($thisfile_riff_raw['fmt ']['nAvgBytesPerSec'] * 8);
+				}
+
+				if (isset($thisfile_riff_WAVE['bext'][0]['data'])) {
+					// shortcut
+					$thisfile_riff_WAVE_bext_0 = &amp;$thisfile_riff_WAVE['bext'][0];
+
+					$thisfile_riff_WAVE_bext_0['title']          =                         trim(substr($thisfile_riff_WAVE_bext_0['data'],   0, 256));
+					$thisfile_riff_WAVE_bext_0['author']         =                         trim(substr($thisfile_riff_WAVE_bext_0['data'], 256,  32));
+					$thisfile_riff_WAVE_bext_0['reference']      =                         trim(substr($thisfile_riff_WAVE_bext_0['data'], 288,  32));
+					$thisfile_riff_WAVE_bext_0['origin_date']    =                              substr($thisfile_riff_WAVE_bext_0['data'], 320,  10);
+					$thisfile_riff_WAVE_bext_0['origin_time']    =                              substr($thisfile_riff_WAVE_bext_0['data'], 330,   8);
+					$thisfile_riff_WAVE_bext_0['time_reference'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_bext_0['data'], 338,   8));
+					$thisfile_riff_WAVE_bext_0['bwf_version']    = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_bext_0['data'], 346,   1));
+					$thisfile_riff_WAVE_bext_0['reserved']       = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_bext_0['data'], 347, 254));
+					$thisfile_riff_WAVE_bext_0['coding_history'] =         explode(&quot;\r\n&quot;, trim(substr($thisfile_riff_WAVE_bext_0['data'], 601)));
+
+					$thisfile_riff_WAVE_bext_0['origin_date_unix'] = mktime(
+																				substr($thisfile_riff_WAVE_bext_0['origin_time'], 0, 2),
+																				substr($thisfile_riff_WAVE_bext_0['origin_time'], 3, 2),
+																				substr($thisfile_riff_WAVE_bext_0['origin_time'], 6, 2),
+																				substr($thisfile_riff_WAVE_bext_0['origin_date'], 5, 2),
+																				substr($thisfile_riff_WAVE_bext_0['origin_date'], 8, 2),
+																				substr($thisfile_riff_WAVE_bext_0['origin_date'], 0, 4));
+
+					$thisfile_riff['comments']['author'][] = $thisfile_riff_WAVE_bext_0['author'];
+					$thisfile_riff['comments']['title'][]  = $thisfile_riff_WAVE_bext_0['title'];
+				}
+
+				if (isset($thisfile_riff_WAVE['MEXT'][0]['data'])) {
+					// shortcut
+					$thisfile_riff_WAVE_MEXT_0 = &amp;$thisfile_riff_WAVE['MEXT'][0];
+
+					$thisfile_riff_WAVE_MEXT_0['raw']['sound_information']      = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_MEXT_0['data'], 0, 2));
+					$thisfile_riff_WAVE_MEXT_0['flags']['homogenous']           = (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['sound_information'] &amp; 0x0001);
+					if ($thisfile_riff_WAVE_MEXT_0['flags']['homogenous']) {
+						$thisfile_riff_WAVE_MEXT_0['flags']['padding']          = ($thisfile_riff_WAVE_MEXT_0['raw']['sound_information'] &amp; 0x0002) ? false : true;
+						$thisfile_riff_WAVE_MEXT_0['flags']['22_or_44']         =        (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['sound_information'] &amp; 0x0004);
+						$thisfile_riff_WAVE_MEXT_0['flags']['free_format']      =        (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['sound_information'] &amp; 0x0008);
+
+						$thisfile_riff_WAVE_MEXT_0['nominal_frame_size']        = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_MEXT_0['data'], 2, 2));
+					}
+					$thisfile_riff_WAVE_MEXT_0['anciliary_data_length']         = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_MEXT_0['data'], 6, 2));
+					$thisfile_riff_WAVE_MEXT_0['raw']['anciliary_data_def']     = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_MEXT_0['data'], 8, 2));
+					$thisfile_riff_WAVE_MEXT_0['flags']['anciliary_data_left']  = (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['anciliary_data_def'] &amp; 0x0001);
+					$thisfile_riff_WAVE_MEXT_0['flags']['anciliary_data_free']  = (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['anciliary_data_def'] &amp; 0x0002);
+					$thisfile_riff_WAVE_MEXT_0['flags']['anciliary_data_right'] = (bool) ($thisfile_riff_WAVE_MEXT_0['raw']['anciliary_data_def'] &amp; 0x0004);
+				}
+
+				if (isset($thisfile_riff_WAVE['cart'][0]['data'])) {
+					// shortcut
+					$thisfile_riff_WAVE_cart_0 = &amp;$thisfile_riff_WAVE['cart'][0];
+
+					$thisfile_riff_WAVE_cart_0['version']              =                  substr($thisfile_riff_WAVE_cart_0['data'],    0,    4);
+					$thisfile_riff_WAVE_cart_0['title']                =             trim(substr($thisfile_riff_WAVE_cart_0['data'],    4,   64));
+					$thisfile_riff_WAVE_cart_0['artist']               =             trim(substr($thisfile_riff_WAVE_cart_0['data'],   68,   64));
+					$thisfile_riff_WAVE_cart_0['cut_id']               =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  132,   64));
+					$thisfile_riff_WAVE_cart_0['client_id']            =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  196,   64));
+					$thisfile_riff_WAVE_cart_0['category']             =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  260,   64));
+					$thisfile_riff_WAVE_cart_0['classification']       =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  324,   64));
+					$thisfile_riff_WAVE_cart_0['out_cue']              =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  388,   64));
+					$thisfile_riff_WAVE_cart_0['start_date']           =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  452,   10));
+					$thisfile_riff_WAVE_cart_0['start_time']           =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  462,    8));
+					$thisfile_riff_WAVE_cart_0['end_date']             =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  470,   10));
+					$thisfile_riff_WAVE_cart_0['end_time']             =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  480,    8));
+					$thisfile_riff_WAVE_cart_0['producer_app_id']      =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  488,   64));
+					$thisfile_riff_WAVE_cart_0['producer_app_version'] =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  552,   64));
+					$thisfile_riff_WAVE_cart_0['user_defined_text']    =             trim(substr($thisfile_riff_WAVE_cart_0['data'],  616,   64));
+					$thisfile_riff_WAVE_cart_0['zero_db_reference']    = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_cart_0['data'],  680,    4), true);
+					for ($i = 0; $i &lt; 8; $i++) {
+						$thisfile_riff_WAVE_cart_0['post_time'][$i]['usage_fourcc'] =                  substr($thisfile_riff_WAVE_cart_0['data'], 684 + ($i * 8), 4);
+						$thisfile_riff_WAVE_cart_0['post_time'][$i]['timer_value']  = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE_cart_0['data'], 684 + ($i * 8) + 4, 4));
+					}
+					$thisfile_riff_WAVE_cart_0['url']              =                 trim(substr($thisfile_riff_WAVE_cart_0['data'],  748, 1024));
+					$thisfile_riff_WAVE_cart_0['tag_text']         = explode(&quot;\r\n&quot;, trim(substr($thisfile_riff_WAVE_cart_0['data'], 1772)));
+
+					$thisfile_riff['comments']['artist'][] = $thisfile_riff_WAVE_cart_0['artist'];
+					$thisfile_riff['comments']['title'][]  = $thisfile_riff_WAVE_cart_0['title'];
+				}
+
+				if (!isset($thisfile_audio['bitrate']) &amp;&amp; isset($thisfile_riff_audio[$streamindex]['bitrate'])) {
+					$thisfile_audio['bitrate'] = $thisfile_riff_audio[$streamindex]['bitrate'];
+					$ThisFileInfo['playtime_seconds'] = (float) ((($thisfile_avdataend - $thisfile_avdataoffset) * 8) / $thisfile_audio['bitrate']);
+				}
+
+				if (!empty($ThisFileInfo['wavpack'])) {
+					$thisfile_audio_dataformat = 'wavpack';
+					$thisfile_audio['bitrate_mode'] = 'vbr';
+					$thisfile_audio['encoder']      = 'WavPack v'.$ThisFileInfo['wavpack']['version'];
+
+					// Reset to the way it was - RIFF parsing will have messed this up
+					$thisfile_avdataend        = $Original['avdataend'];
+					$thisfile_audio['bitrate'] = (($thisfile_avdataend - $thisfile_avdataoffset) * 8) / $ThisFileInfo['playtime_seconds'];
+
+					fseek($fd, $thisfile_avdataoffset - 44, SEEK_SET);
+					$RIFFdata = fread($fd, 44);
+					$OrignalRIFFheaderSize = getid3_lib::LittleEndian2Int(substr($RIFFdata,  4, 4)) +  8;
+					$OrignalRIFFdataSize   = getid3_lib::LittleEndian2Int(substr($RIFFdata, 40, 4)) + 44;
+
+					if ($OrignalRIFFheaderSize &gt; $OrignalRIFFdataSize) {
+						$thisfile_avdataend -= ($OrignalRIFFheaderSize - $OrignalRIFFdataSize);
+						fseek($fd, $thisfile_avdataend, SEEK_SET);
+						$RIFFdata .= fread($fd, $OrignalRIFFheaderSize - $OrignalRIFFdataSize);
+					}
+
+					// move the data chunk after all other chunks (if any)
+					// so that the RIFF parser doesn't see EOF when trying
+					// to skip over the data chunk
+					$RIFFdata = substr($RIFFdata, 0, 36).substr($RIFFdata, 44).substr($RIFFdata, 36, 8);
+					getid3_riff::ParseRIFFdata($RIFFdata, $ThisFileInfo);
+				}
+
+				if (isset($thisfile_riff_raw['fmt ']['wFormatTag'])) {
+					switch ($thisfile_riff_raw['fmt ']['wFormatTag']) {
+						case 0x08AE: // ClearJump LiteWave
+							$thisfile_audio['bitrate_mode'] = 'vbr';
+							$thisfile_audio_dataformat   = 'litewave';
+
+							//typedef struct tagSLwFormat {
+							//  WORD    m_wCompFormat;     // low byte defines compression method, high byte is compression flags
+							//  DWORD   m_dwScale;         // scale factor for lossy compression
+							//  DWORD   m_dwBlockSize;     // number of samples in encoded blocks
+							//  WORD    m_wQuality;        // alias for the scale factor
+							//  WORD    m_wMarkDistance;   // distance between marks in bytes
+							//  WORD    m_wReserved;
+							//
+							//  //following paramters are ignored if CF_FILESRC is not set
+							//  DWORD   m_dwOrgSize;       // original file size in bytes
+							//  WORD    m_bFactExists;     // indicates if 'fact' chunk exists in the original file
+							//  DWORD   m_dwRiffChunkSize; // riff chunk size in the original file
+							//
+							//  PCMWAVEFORMAT m_OrgWf;     // original wave format
+							// }SLwFormat, *PSLwFormat;
+
+							// shortcut
+							$thisfile_riff['litewave']['raw'] = array();
+							$thisfile_riff_litewave     = &amp;$thisfile_riff['litewave'];
+							$thisfile_riff_litewave_raw = &amp;$thisfile_riff_litewave['raw'];
+
+							$thisfile_riff_litewave_raw['compression_method'] = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 18, 1));
+							$thisfile_riff_litewave_raw['compression_flags']  = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 19, 1));
+							$thisfile_riff_litewave_raw['m_dwScale']          = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 20, 4));
+							$thisfile_riff_litewave_raw['m_dwBlockSize']      = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 24, 4));
+							$thisfile_riff_litewave_raw['m_wQuality']         = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 28, 2));
+							$thisfile_riff_litewave_raw['m_wMarkDistance']    = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 30, 2));
+							$thisfile_riff_litewave_raw['m_wReserved']        = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 32, 2));
+							$thisfile_riff_litewave_raw['m_dwOrgSize']        = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 34, 4));
+							$thisfile_riff_litewave_raw['m_bFactExists']      = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 38, 2));
+							$thisfile_riff_litewave_raw['m_dwRiffChunkSize']  = getid3_lib::LittleEndian2Int(substr($thisfile_riff_WAVE['fmt '][0]['data'], 40, 4));
+
+							//$thisfile_riff_litewave['quality_factor'] = intval(round((2000 - $thisfile_riff_litewave_raw['m_dwScale']) / 20));
+							$thisfile_riff_litewave['quality_factor'] = $thisfile_riff_litewave_raw['m_wQuality'];
+
+							$thisfile_riff_litewave['flags']['raw_source']    = ($thisfile_riff_litewave_raw['compression_flags'] &amp; 0x01) ? false : true;
+							$thisfile_riff_litewave['flags']['vbr_blocksize'] = ($thisfile_riff_litewave_raw['compression_flags'] &amp; 0x02) ? false : true;
+							$thisfile_riff_litewave['flags']['seekpoints']    =        (bool) ($thisfile_riff_litewave_raw['compression_flags'] &amp; 0x04);
+
+							$thisfile_audio['lossless']        = (($thisfile_riff_litewave_raw['m_wQuality'] == 100) ? true : false);
+							$thisfile_audio['encoder_options'] = '-q'.$thisfile_riff_litewave['quality_factor'];
+							break;
+
+						default:
+							break;
+					}
+				}
+				if ($thisfile_avdataend &gt; $ThisFileInfo['filesize']) {
+					switch (@$thisfile_audio_dataformat) {
+						case 'wavpack': // WavPack
+						case 'lpac':    // LPAC
+						case 'ofr':     // OptimFROG
+						case 'ofs':     // OptimFROG DualStream
+							// lossless compressed audio formats that keep original RIFF headers - skip warning
+							break;
+
+						case 'litewave':
+							if (($thisfile_avdataend - $ThisFileInfo['filesize']) == 1) {
+								// LiteWave appears to incorrectly *not* pad actual output file
+								// to nearest WORD boundary so may appear to be short by one
+								// byte, in which case - skip warning
+							} else {
+								// Short by more than one byte, throw warning
+								$ThisFileInfo['warning'][] = 'Probably truncated file - expecting '.$thisfile_riff[$RIFFsubtype]['data'][0]['size'].' bytes of data, only found '.($ThisFileInfo['filesize'] - $thisfile_avdataoffset).' (short by '.($thisfile_riff[$RIFFsubtype]['data'][0]['size'] - ($ThisFileInfo['filesize'] - $thisfile_avdataoffset)).' bytes)';
+								$thisfile_avdataend = $ThisFileInfo['filesize'];
+							}
+							break;
+
+						default:
+							if ((($thisfile_avdataend - $ThisFileInfo['filesize']) == 1) &amp;&amp; (($thisfile_riff[$RIFFsubtype]['data'][0]['size'] % 2) == 0) &amp;&amp; ((($ThisFileInfo['filesize'] - $thisfile_avdataoffset) % 2) == 1)) {
+								// output file appears to be incorrectly *not* padded to nearest WORD boundary
+								// Output less severe warning
+								$ThisFileInfo['warning'][] = 'File should probably be padded to nearest WORD boundary, but it is not (expecting '.$thisfile_riff[$RIFFsubtype]['data'][0]['size'].' bytes of data, only found '.($ThisFileInfo['filesize'] - $thisfile_avdataoffset).' therefore short by '.($thisfile_riff[$RIFFsubtype]['data'][0]['size'] - ($ThisFileInfo['filesize'] - $thisfile_avdataoffset)).' bytes)';
+								$thisfile_avdataend = $ThisFileInfo['filesize'];
+								break;
+							}
+							// Short by more than one byte, throw warning
+							$ThisFileInfo['warning'][] = 'Probably truncated file - expecting '.$thisfile_riff[$RIFFsubtype]['data'][0]['size'].' bytes of data, only found '.($ThisFileInfo['filesize'] - $thisfile_avdataoffset).' (short by '.($thisfile_riff[$RIFFsubtype]['data'][0]['size'] - ($ThisFileInfo['filesize'] - $thisfile_avdataoffset)).' bytes)';
+							$thisfile_avdataend = $ThisFileInfo['filesize'];
+							break;
+					}
+				}
+				if (!empty($ThisFileInfo['mpeg']['audio']['LAME']['audio_bytes'])) {
+					if ((($thisfile_avdataend - $thisfile_avdataoffset) - $ThisFileInfo['mpeg']['audio']['LAME']['audio_bytes']) == 1) {
+						$thisfile_avdataend--;
+						$ThisFileInfo['warning'][] = 'Extra null byte at end of MP3 data assumed to be RIFF padding and therefore ignored';
+					}
+				}
+				if (@$thisfile_audio_dataformat == 'ac3') {
+					unset($thisfile_audio['bits_per_sample']);
+					if (!empty($ThisFileInfo['ac3']['bitrate']) &amp;&amp; ($ThisFileInfo['ac3']['bitrate'] != $thisfile_audio['bitrate'])) {
+						$thisfile_audio['bitrate'] = $ThisFileInfo['ac3']['bitrate'];
+					}
+				}
+				break;
+
+			case 'AVI ':
+				$thisfile_video['bitrate_mode'] = 'vbr'; // maybe not, but probably
+				$thisfile_video['dataformat']   = 'avi';
+				$ThisFileInfo['mime_type']      = 'video/avi';
+
+				if (isset($thisfile_riff[$RIFFsubtype]['movi']['offset'])) {
+					$thisfile_avdataoffset = $thisfile_riff[$RIFFsubtype]['movi']['offset'] + 8;
+					$thisfile_avdataend    = $thisfile_avdataoffset + $thisfile_riff[$RIFFsubtype]['movi']['size'];
+					if ($thisfile_avdataend &gt; $ThisFileInfo['filesize']) {
+						$ThisFileInfo['warning'][] = 'Probably truncated file - expecting '.$thisfile_riff[$RIFFsubtype]['movi']['size'].' bytes of data, only found '.($ThisFileInfo['filesize'] - $thisfile_avdataoffset).' (short by '.($thisfile_riff[$RIFFsubtype]['movi']['size'] - ($ThisFileInfo['filesize'] - $thisfile_avdataoffset)).' bytes)';
+						$thisfile_avdataend = $ThisFileInfo['filesize'];
+					}
+				}
+
+				if (isset($thisfile_riff['AVI ']['hdrl']['avih'][$streamindex]['data'])) {
+					$avihData = $thisfile_riff['AVI ']['hdrl']['avih'][$streamindex]['data'];
+
+					// shortcut
+					$thisfile_riff_raw['avih'] = array();
+					$thisfile_riff_raw_avih = &amp;$thisfile_riff_raw['avih'];
+
+					$thisfile_riff_raw_avih['dwMicroSecPerFrame']    = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData,  0, 4)); // frame display rate (or 0L)
+					if ($thisfile_riff_raw_avih['dwMicroSecPerFrame'] == 0) {
+						$ThisFileInfo['error'][] = 'Corrupt RIFF file: avih.dwMicroSecPerFrame == zero';
+						return false;
+					}
+					$thisfile_riff_raw_avih['dwMaxBytesPerSec']      = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData,  4, 4)); // max. transfer rate
+					$thisfile_riff_raw_avih['dwPaddingGranularity']  = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData,  8, 4)); // pad to multiples of this size; normally 2K.
+					$thisfile_riff_raw_avih['dwFlags']               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 12, 4)); // the ever-present flags
+					$thisfile_riff_raw_avih['dwTotalFrames']         = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 16, 4)); // # frames in file
+					$thisfile_riff_raw_avih['dwInitialFrames']       = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 20, 4));
+					$thisfile_riff_raw_avih['dwStreams']             = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 24, 4));
+					$thisfile_riff_raw_avih['dwSuggestedBufferSize'] = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 28, 4));
+					$thisfile_riff_raw_avih['dwWidth']               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 32, 4));
+					$thisfile_riff_raw_avih['dwHeight']              = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 36, 4));
+					$thisfile_riff_raw_avih['dwScale']               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 40, 4));
+					$thisfile_riff_raw_avih['dwRate']                = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 44, 4));
+					$thisfile_riff_raw_avih['dwStart']               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 48, 4));
+					$thisfile_riff_raw_avih['dwLength']              = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($avihData, 52, 4));
+
+					$thisfile_riff_raw_avih['flags']['hasindex']     = (bool) ($thisfile_riff_raw_avih['dwFlags'] &amp; 0x00000010);
+					$thisfile_riff_raw_avih['flags']['mustuseindex'] = (bool) ($thisfile_riff_raw_avih['dwFlags'] &amp; 0x00000020);
+					$thisfile_riff_raw_avih['flags']['interleaved']  = (bool) ($thisfile_riff_raw_avih['dwFlags'] &amp; 0x00000100);
+					$thisfile_riff_raw_avih['flags']['trustcktype']  = (bool) ($thisfile_riff_raw_avih['dwFlags'] &amp; 0x00000800);
+					$thisfile_riff_raw_avih['flags']['capturedfile'] = (bool) ($thisfile_riff_raw_avih['dwFlags'] &amp; 0x00010000);
+					$thisfile_riff_raw_avih['flags']['copyrighted']  = (bool) ($thisfile_riff_raw_avih['dwFlags'] &amp; 0x00020010);
+
+					// shortcut
+					$thisfile_riff_video[$streamindex] = array();
+					$thisfile_riff_video_current = &amp;$thisfile_riff_video[$streamindex];
+
+					if ($thisfile_riff_raw_avih['dwWidth'] &gt; 0) {
+						$thisfile_riff_video_current['frame_width'] = $thisfile_riff_raw_avih['dwWidth'];
+						$thisfile_video['resolution_x']             = $thisfile_riff_video_current['frame_width'];
+					}
+					if ($thisfile_riff_raw_avih['dwHeight'] &gt; 0) {
+						$thisfile_riff_video_current['frame_height'] = $thisfile_riff_raw_avih['dwHeight'];
+						$thisfile_video['resolution_y']              = $thisfile_riff_video_current['frame_height'];
+					}
+					if ($thisfile_riff_raw_avih['dwTotalFrames'] &gt; 0) {
+						$thisfile_riff_video_current['total_frames'] = $thisfile_riff_raw_avih['dwTotalFrames'];
+						$thisfile_video['total_frames']              = $thisfile_riff_video_current['total_frames'];
+					}
+
+					$thisfile_riff_video_current['frame_rate'] = round(1000000 / $thisfile_riff_raw_avih['dwMicroSecPerFrame'], 3);
+					$thisfile_video['frame_rate'] = $thisfile_riff_video_current['frame_rate'];
+				}
+				if (isset($thisfile_riff['AVI ']['hdrl']['strl']['strh'][0]['data'])) {
+					if (is_array($thisfile_riff['AVI ']['hdrl']['strl']['strh'])) {
+						for ($i = 0; $i &lt; count($thisfile_riff['AVI ']['hdrl']['strl']['strh']); $i++) {
+							if (isset($thisfile_riff['AVI ']['hdrl']['strl']['strh'][$i]['data'])) {
+								$strhData = $thisfile_riff['AVI ']['hdrl']['strl']['strh'][$i]['data'];
+								$strhfccType = substr($strhData,  0, 4);
+
+								if (isset($thisfile_riff['AVI ']['hdrl']['strl']['strf'][$i]['data'])) {
+									$strfData = $thisfile_riff['AVI ']['hdrl']['strl']['strf'][$i]['data'];
+
+									// shortcut
+									$thisfile_riff_raw_strf_strhfccType_streamindex = &amp;$thisfile_riff_raw['strf'][$strhfccType][$streamindex];
+
+									switch ($strhfccType) {
+										case 'auds':
+											$thisfile_audio['bitrate_mode'] = 'cbr';
+											$thisfile_audio_dataformat      = 'wav';
+											if (isset($thisfile_riff_audio) &amp;&amp; is_array($thisfile_riff_audio)) {
+												$streamindex = count($thisfile_riff_audio);
+											}
+
+											$thisfile_riff_audio[$streamindex] = getid3_riff::RIFFparseWAVEFORMATex($strfData);
+											$thisfile_audio['wformattag'] = $thisfile_riff_audio[$streamindex]['raw']['wFormatTag'];
+
+											// shortcut
+											$thisfile_audio['streams'][$streamindex] = $thisfile_riff_audio[$streamindex];
+											$thisfile_audio_streams_currentstream = &amp;$thisfile_audio['streams'][$streamindex];
+
+											if ($thisfile_audio_streams_currentstream['bits_per_sample'] == 0) {
+												unset($thisfile_audio_streams_currentstream['bits_per_sample']);
+											}
+											$thisfile_audio_streams_currentstream['wformattag'] = $thisfile_audio_streams_currentstream['raw']['wFormatTag'];
+											unset($thisfile_audio_streams_currentstream['raw']);
+
+											// shortcut
+											$thisfile_riff_raw['strf'][$strhfccType][$streamindex] = $thisfile_riff_audio[$streamindex]['raw'];
+
+											unset($thisfile_riff_audio[$streamindex]['raw']);
+											$thisfile_audio = getid3_lib::array_merge_noclobber($thisfile_audio, $thisfile_riff_audio[$streamindex]);
+
+											$thisfile_audio['lossless'] = false;
+											switch ($thisfile_riff_raw_strf_strhfccType_streamindex['wFormatTag']) {
+												case 0x0001:  // PCM
+													$thisfile_audio_dataformat  = 'wav';
+													$thisfile_audio['lossless'] = true;
+													break;
+
+												case 0x0050: // MPEG Layer 2 or Layer 1
+													$thisfile_audio_dataformat = 'mp2'; // Assume Layer-2
+													break;
+
+												case 0x0055: // MPEG Layer 3
+													$thisfile_audio_dataformat = 'mp3';
+													break;
+
+												case 0x00FF: // AAC
+													$thisfile_audio_dataformat = 'aac';
+													break;
+
+												case 0x0161: // Windows Media v7 / v8 / v9
+												case 0x0162: // Windows Media Professional v9
+												case 0x0163: // Windows Media Lossess v9
+													$thisfile_audio_dataformat = 'wma';
+													break;
+
+												case 0x2000: // AC-3
+													$thisfile_audio_dataformat = 'ac3';
+													break;
+
+												case 0x2001: // DTS
+													$thisfile_audio_dataformat = 'dts';
+													break;
+
+												default:
+													$thisfile_audio_dataformat = 'wav';
+													break;
+											}
+											$thisfile_audio_streams_currentstream['dataformat']   = $thisfile_audio_dataformat;
+											$thisfile_audio_streams_currentstream['lossless']     = $thisfile_audio['lossless'];
+											$thisfile_audio_streams_currentstream['bitrate_mode'] = $thisfile_audio['bitrate_mode'];
+											break;
+
+
+										case 'iavs':
+										case 'vids':
+											// shortcut
+											$thisfile_riff_raw['strh'][$i]                  = array();
+											$thisfile_riff_raw_strh_current                 = &amp;$thisfile_riff_raw['strh'][$i];
+
+											$thisfile_riff_raw_strh_current['fccType']               =                  substr($strhData,  0, 4);  // same as $strhfccType;
+											$thisfile_riff_raw_strh_current['fccHandler']            =                  substr($strhData,  4, 4);
+											$thisfile_riff_raw_strh_current['dwFlags']               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData,  8, 4)); // Contains AVITF_* flags
+											$thisfile_riff_raw_strh_current['wPriority']             = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 12, 2));
+											$thisfile_riff_raw_strh_current['wLanguage']             = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 14, 2));
+											$thisfile_riff_raw_strh_current['dwInitialFrames']       = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 16, 4));
+											$thisfile_riff_raw_strh_current['dwScale']               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 20, 4));
+											$thisfile_riff_raw_strh_current['dwRate']                = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 24, 4));
+											$thisfile_riff_raw_strh_current['dwStart']               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 28, 4));
+											$thisfile_riff_raw_strh_current['dwLength']              = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 32, 4));
+											$thisfile_riff_raw_strh_current['dwSuggestedBufferSize'] = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 36, 4));
+											$thisfile_riff_raw_strh_current['dwQuality']             = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 40, 4));
+											$thisfile_riff_raw_strh_current['dwSampleSize']          = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 44, 4));
+											$thisfile_riff_raw_strh_current['rcFrame']               = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strhData, 48, 4));
+
+											$thisfile_riff_video_current['codec'] = getid3_riff::RIFFfourccLookup($thisfile_riff_raw_strh_current['fccHandler']);
+											$thisfile_video['fourcc']             = $thisfile_riff_raw_strh_current['fccHandler'];
+											if (!$thisfile_riff_video_current['codec'] &amp;&amp; isset($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc']) &amp;&amp; getid3_riff::RIFFfourccLookup($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc'])) {
+												$thisfile_riff_video_current['codec'] = getid3_riff::RIFFfourccLookup($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc']);
+												$thisfile_video['fourcc']             = $thisfile_riff_raw_strf_strhfccType_streamindex['fourcc'];
+											}
+											$thisfile_video['codec']              = $thisfile_riff_video_current['codec'];
+											$thisfile_video['pixel_aspect_ratio'] = (float) 1;
+											switch ($thisfile_riff_raw_strh_current['fccHandler']) {
+												case 'HFYU': // Huffman Lossless Codec
+												case 'IRAW': // Intel YUV Uncompressed
+												case 'YUY2': // Uncompressed YUV 4:2:2
+													$thisfile_video['lossless'] = true;
+													break;
+
+												default:
+													$thisfile_video['lossless'] = false;
+													break;
+											}
+
+											switch ($strhfccType) {
+												case 'vids':
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biSize']          = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData,  0, 4)); // number of bytes required by the BITMAPINFOHEADER structure
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biWidth']         = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData,  4, 4)); // width of the bitmap in pixels
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biHeight']        = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData,  8, 4)); // height of the bitmap in pixels. If biHeight is positive, the bitmap is a 'bottom-up' DIB and its origin is the lower left corner. If biHeight is negative, the bitmap is a 'top-down' DIB and its origin is the upper left corner
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biPlanes']        = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData, 12, 2)); // number of color planes on the target device. In most cases this value must be set to 1
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biBitCount']      = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData, 14, 2)); // Specifies the number of bits per pixels
+													$thisfile_riff_raw_strf_strhfccType_streamindex['fourcc']          =                                 substr($strfData, 16, 4);  //
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biSizeImage']     = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData, 20, 4)); // size of the bitmap data section of the image (the actual pixel data, excluding BITMAPINFOHEADER and RGBQUAD structures)
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biXPelsPerMeter'] = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData, 24, 4)); // horizontal resolution, in pixels per metre, of the target device
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biYPelsPerMeter'] = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData, 28, 4)); // vertical resolution, in pixels per metre, of the target device
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biClrUsed']       = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData, 32, 4)); // actual number of color indices in the color table used by the bitmap. If this value is zero, the bitmap uses the maximum number of colors corresponding to the value of the biBitCount member for the compression mode specified by biCompression
+													$thisfile_riff_raw_strf_strhfccType_streamindex['biClrImportant']  = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($strfData, 36, 4)); // number of color indices that are considered important for displaying the bitmap. If this value is zero, all colors are important
+
+													$thisfile_video['bits_per_sample'] = $thisfile_riff_raw_strf_strhfccType_streamindex['biBitCount'];
+
+													if ($thisfile_riff_video_current['codec'] == 'DV') {
+														$thisfile_riff_video_current['dv_type'] = 2;
+													}
+													break;
+
+												case 'iavs':
+													$thisfile_riff_video_current['dv_type'] = 1;
+													break;
+											}
+											break;
+
+										default:
+											$ThisFileInfo['warning'][] = 'Unhandled fccType for stream ('.$i.'): &quot;'.$strhfccType.'&quot;';
+											break;
+
+									}
+								}
+							}
+
+							if (isset($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc']) &amp;&amp; getid3_riff::RIFFfourccLookup($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc'])) {
+
+								$thisfile_riff_video_current['codec'] = getid3_riff::RIFFfourccLookup($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc']);
+								$thisfile_video['codec']              = $thisfile_riff_video_current['codec'];
+								$thisfile_video['fourcc']             = $thisfile_riff_raw_strf_strhfccType_streamindex['fourcc'];
+
+								switch ($thisfile_riff_raw_strf_strhfccType_streamindex['fourcc']) {
+									case 'HFYU': // Huffman Lossless Codec
+									case 'IRAW': // Intel YUV Uncompressed
+									case 'YUY2': // Uncompressed YUV 4:2:2
+										$thisfile_video['lossless']        = true;
+										$thisfile_video['bits_per_sample'] = 24;
+										break;
+
+									default:
+										$thisfile_video['lossless']        = false;
+										$thisfile_video['bits_per_sample'] = 24;
+										break;
+								}
+
+							}
+						}
+					}
+				}
+				break;
+
+			case 'CDDA':
+				$thisfile_audio['bitrate_mode'] = 'cbr';
+				$thisfile_audio_dataformat      = 'cda';
+				$thisfile_audio['lossless']     = true;
+				unset($ThisFileInfo['mime_type']);
+
+				$thisfile_avdataoffset = 44;
+
+				if (isset($thisfile_riff['CDDA']['fmt '][0]['data'])) {
+					// shortcut
+					$thisfile_riff_CDDA_fmt_0 = &amp;$thisfile_riff['CDDA']['fmt '][0];
+
+					$thisfile_riff_CDDA_fmt_0['unknown1']           = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($thisfile_riff_CDDA_fmt_0['data'],  0, 2));
+					$thisfile_riff_CDDA_fmt_0['track_num']          = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($thisfile_riff_CDDA_fmt_0['data'],  2, 2));
+					$thisfile_riff_CDDA_fmt_0['disc_id']            = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($thisfile_riff_CDDA_fmt_0['data'],  4, 4));
+					$thisfile_riff_CDDA_fmt_0['start_offset_frame'] = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($thisfile_riff_CDDA_fmt_0['data'],  8, 4));
+					$thisfile_riff_CDDA_fmt_0['playtime_frames']    = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($thisfile_riff_CDDA_fmt_0['data'], 12, 4));
+					$thisfile_riff_CDDA_fmt_0['unknown6']           = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($thisfile_riff_CDDA_fmt_0['data'], 16, 4));
+					$thisfile_riff_CDDA_fmt_0['unknown7']           = getid3_riff::EitherEndian2Int($ThisFileInfo, substr($thisfile_riff_CDDA_fmt_0['data'], 20, 4));
+
+					$thisfile_riff_CDDA_fmt_0['start_offset_seconds'] = (float) $thisfile_riff_CDDA_fmt_0['start_offset_frame'] / 75;
+					$thisfile_riff_CDDA_fmt_0['playtime_seconds']     = (float) $thisfile_riff_CDDA_fmt_0['playtime_frames'] / 75;
+					$ThisFileInfo['comments']['track']                = $thisfile_riff_CDDA_fmt_0['track_num'];
+					$ThisFileInfo['playtime_seconds']                 = $thisfile_riff_CDDA_fmt_0['playtime_seconds'];
+
+					// hardcoded data for CD-audio
+					$thisfile_audio['sample_rate']     = 44100;
+					$thisfile_audio['channels']        = 2;
+					$thisfile_audio['bits_per_sample'] = 16;
+					$thisfile_audio['bitrate']         = $thisfile_audio['sample_rate'] * $thisfile_audio['channels'] * $thisfile_audio['bits_per_sample'];
+					$thisfile_audio['bitrate_mode']    = 'cbr';
+				}
+				break;
+
+
+			case 'AIFF':
+			case 'AIFC':
+				$thisfile_audio['bitrate_mode'] = 'cbr';
+				$thisfile_audio_dataformat      = 'aiff';
+				$thisfile_audio['lossless']     = true;
+				$ThisFileInfo['mime_type']      = 'audio/x-aiff';
+
+				if (isset($thisfile_riff[$RIFFsubtype]['SSND'][0]['offset'])) {
+					$thisfile_avdataoffset = $thisfile_riff[$RIFFsubtype]['SSND'][0]['offset'] + 8;
+					$thisfile_avdataend    = $thisfile_avdataoffset + $thisfile_riff[$RIFFsubtype]['SSND'][0]['size'];
+					if ($thisfile_avdataend &gt; $ThisFileInfo['filesize']) {
+						if (($thisfile_avdataend == ($ThisFileInfo['filesize'] + 1)) &amp;&amp; (($ThisFileInfo['filesize'] % 2) == 1)) {
+							// structures rounded to 2-byte boundary, but dumb encoders
+							// forget to pad end of file to make this actually work
+						} else {
+							$ThisFileInfo['warning'][] = 'Probable truncated AIFF file: expecting '.$thisfile_riff[$RIFFsubtype]['SSND'][0]['size'].' bytes of audio data, only '.($ThisFileInfo['filesize'] - $thisfile_avdataoffset).' bytes found';
+						}
+						$thisfile_avdataend = $ThisFileInfo['filesize'];
+					}
+				}
+
+				if (isset($thisfile_riff[$RIFFsubtype]['COMM'][0]['data'])) {
+
+					// shortcut
+					$thisfile_riff_RIFFsubtype_COMM_0_data = &amp;$thisfile_riff[$RIFFsubtype]['COMM'][0]['data'];
+
+					$thisfile_riff_audio['channels']         =         getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_COMM_0_data,  0,  2), true);
+					$thisfile_riff_audio['total_samples']    =         getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_COMM_0_data,  2,  4), false);
+					$thisfile_riff_audio['bits_per_sample']  =         getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_COMM_0_data,  6,  2), true);
+					$thisfile_riff_audio['sample_rate']      = (int) getid3_lib::BigEndian2Float(substr($thisfile_riff_RIFFsubtype_COMM_0_data,  8, 10));
+
+					if ($thisfile_riff[$RIFFsubtype]['COMM'][0]['size'] &gt; 18) {
+						$thisfile_riff_audio['codec_fourcc'] =                                   substr($thisfile_riff_RIFFsubtype_COMM_0_data, 18,  4);
+						$CodecNameSize                       =         getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_COMM_0_data, 22,  1), false);
+						$thisfile_riff_audio['codec_name']   =                                   substr($thisfile_riff_RIFFsubtype_COMM_0_data, 23,  $CodecNameSize);
+						switch ($thisfile_riff_audio['codec_name']) {
+							case 'NONE':
+								$thisfile_audio['codec']    = 'Pulse Code Modulation (PCM)';
+								$thisfile_audio['lossless'] = true;
+								break;
+
+							case '':
+								switch ($thisfile_riff_audio['codec_fourcc']) {
+									// <A HREF="http://developer.apple.com/qa/snd/snd07.html">http://developer.apple.com/qa/snd/snd07.html</A>
+									case 'sowt':
+										$thisfile_riff_audio['codec_name'] = 'Two\'s Compliment Little-Endian PCM';
+										$thisfile_audio['lossless'] = true;
+										break;
+
+									case 'twos':
+										$thisfile_riff_audio['codec_name'] = 'Two\'s Compliment Big-Endian PCM';
+										$thisfile_audio['lossless'] = true;
+										break;
+
+									default:
+										break;
+								}
+								break;
+
+							default:
+								$thisfile_audio['codec']    = $thisfile_riff_audio['codec_name'];
+								$thisfile_audio['lossless'] = false;
+								break;
+						}
+					}
+
+					$thisfile_audio['channels']        = $thisfile_riff_audio['channels'];
+					if ($thisfile_riff_audio['bits_per_sample'] &gt; 0) {
+						$thisfile_audio['bits_per_sample'] = $thisfile_riff_audio['bits_per_sample'];
+					}
+					$thisfile_audio['sample_rate']     = $thisfile_riff_audio['sample_rate'];
+					if ($thisfile_audio['sample_rate'] == 0) {
+						$ThisFileInfo['error'][] = 'Corrupted AIFF file: sample_rate == zero';
+						return false;
+					}
+					$ThisFileInfo['playtime_seconds'] = $thisfile_riff_audio['total_samples'] / $thisfile_audio['sample_rate'];
+				}
+
+				if (isset($thisfile_riff[$RIFFsubtype]['COMT'])) {
+					$offset = 0;
+					$CommentCount                                           = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, 2), false);
+					$offset += 2;
+					for ($i = 0; $i &lt; $CommentCount; $i++) {
+						$ThisFileInfo['comments_raw'][$i]['timestamp']      = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, 4), false);
+						$offset += 4;
+						$ThisFileInfo['comments_raw'][$i]['marker_id']      = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, 2), true);
+						$offset += 2;
+						$CommentLength                                      = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, 2), false);
+						$offset += 2;
+						$ThisFileInfo['comments_raw'][$i]['comment']        =                           substr($thisfile_riff[$RIFFsubtype]['COMT'][0]['data'], $offset, $CommentLength);
+						$offset += $CommentLength;
+
+						$ThisFileInfo['comments_raw'][$i]['timestamp_unix'] = getid3_lib::DateMac2Unix($ThisFileInfo['comments_raw'][$i]['timestamp']);
+						$thisfile_riff['comments']['comment'][] = $ThisFileInfo['comments_raw'][$i]['comment'];
+					}
+				}
+
+				$CommentsChunkNames = array('NAME'=&gt;'title', 'author'=&gt;'artist', '(c) '=&gt;'copyright', 'ANNO'=&gt;'comment');
+				foreach ($CommentsChunkNames as $key =&gt; $value) {
+					if (isset($thisfile_riff[$RIFFsubtype][$key][0]['data'])) {
+						$thisfile_riff['comments'][$value][] = $thisfile_riff[$RIFFsubtype][$key][0]['data'];
+					}
+				}
+				break;
+
+			case '8SVX':
+				$thisfile_audio['bitrate_mode']    = 'cbr';
+				$thisfile_audio_dataformat         = '8svx';
+				$thisfile_audio['bits_per_sample'] = 8;
+				$thisfile_audio['channels']        = 1; // overridden below, if need be
+				$ThisFileInfo['mime_type']                = 'audio/x-aiff';
+
+				if (isset($thisfile_riff[$RIFFsubtype]['BODY'][0]['offset'])) {
+					$thisfile_avdataoffset = $thisfile_riff[$RIFFsubtype]['BODY'][0]['offset'] + 8;
+					$thisfile_avdataend    = $thisfile_avdataoffset + $thisfile_riff[$RIFFsubtype]['BODY'][0]['size'];
+					if ($thisfile_avdataend &gt; $ThisFileInfo['filesize']) {
+						$ThisFileInfo['warning'][] = 'Probable truncated AIFF file: expecting '.$thisfile_riff[$RIFFsubtype]['BODY'][0]['size'].' bytes of audio data, only '.($ThisFileInfo['filesize'] - $thisfile_avdataoffset).' bytes found';
+					}
+				}
+
+				if (isset($thisfile_riff[$RIFFsubtype]['VHDR'][0]['offset'])) {
+					// shortcut
+					$thisfile_riff_RIFFsubtype_VHDR_0 = &amp;$thisfile_riff[$RIFFsubtype]['VHDR'][0];
+
+					$thisfile_riff_RIFFsubtype_VHDR_0['oneShotHiSamples']  =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'],  0, 4));
+					$thisfile_riff_RIFFsubtype_VHDR_0['repeatHiSamples']   =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'],  4, 4));
+					$thisfile_riff_RIFFsubtype_VHDR_0['samplesPerHiCycle'] =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'],  8, 4));
+					$thisfile_riff_RIFFsubtype_VHDR_0['samplesPerSec']     =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 12, 2));
+					$thisfile_riff_RIFFsubtype_VHDR_0['ctOctave']          =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 14, 1));
+					$thisfile_riff_RIFFsubtype_VHDR_0['sCompression']      =   getid3_lib::BigEndian2Int(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 15, 1));
+					$thisfile_riff_RIFFsubtype_VHDR_0['Volume']            = getid3_lib::FixedPoint16_16(substr($thisfile_riff_RIFFsubtype_VHDR_0['data'], 16, 4));
+
+					$thisfile_audio['sample_rate'] = $thisfile_riff_RIFFsubtype_VHDR_0['samplesPerSec'];
+
+					switch ($thisfile_riff_RIFFsubtype_VHDR_0['sCompression']) {
+						case 0:
+							$thisfile_audio['codec']    = 'Pulse Code Modulation (PCM)';
+							$thisfile_audio['lossless'] = true;
+							$ActualBitsPerSample               = 8;
+							break;
+
+						case 1:
+							$thisfile_audio['codec']    = 'Fibonacci-delta encoding';
+							$thisfile_audio['lossless'] = false;
+							$ActualBitsPerSample               = 4;
+							break;
+
+						default:
+							$ThisFileInfo['warning'][] = 'Unexpected sCompression value in 8SVX.VHDR chunk - expecting 0 or 1, found &quot;'.sCompression.'&quot;';
+							break;
+					}
+				}
+
+				if (isset($thisfile_riff[$RIFFsubtype]['CHAN'][0]['data'])) {
+					$ChannelsIndex = getid3_lib::BigEndian2Int(substr($thisfile_riff[$RIFFsubtype]['CHAN'][0]['data'], 0, 4));
+					switch ($ChannelsIndex) {
+						case 6: // Stereo
+							$thisfile_audio['channels'] = 2;
+							break;
+
+						case 2: // Left channel only
+						case 4: // Right channel only
+							$thisfile_audio['channels'] = 1;
+							break;
+
+						default:
+							$ThisFileInfo['warning'][] = 'Unexpected value in 8SVX.CHAN chunk - expecting 2 or 4 or 6, found &quot;'.$ChannelsIndex.'&quot;';
+							break;
+					}
+
+				}
+
+				$CommentsChunkNames = array('NAME'=&gt;'title', 'author'=&gt;'artist', '(c) '=&gt;'copyright', 'ANNO'=&gt;'comment');
+				foreach ($CommentsChunkNames as $key =&gt; $value) {
+					if (isset($thisfile_riff[$RIFFsubtype][$key][0]['data'])) {
+						$thisfile_riff['comments'][$value][] = $thisfile_riff[$RIFFsubtype][$key][0]['data'];
+					}
+				}
+
+				$thisfile_audio['bitrate'] = $thisfile_audio['sample_rate'] * $ActualBitsPerSample * $thisfile_audio['channels'];
+				if (!empty($thisfile_audio['bitrate'])) {
+					$ThisFileInfo['playtime_seconds'] = ($thisfile_avdataend - $thisfile_avdataoffset) / ($thisfile_audio['bitrate'] / 8);
+				}
+				break;
+
+
+			case 'CDXA':
+				$ThisFileInfo['mime_type']      = 'video/mpeg';
+				if (!empty($thisfile_riff['CDXA']['data'][0]['size'])) {
+					$GETID3_ERRORARRAY = &amp;$ThisFileInfo['warning'];
+					if (getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.mpeg.php', __FILE__, false)) {
+						$dummy = $ThisFileInfo;
+						$dummy['error'] = array();
+						$mpeg_scanner = new getid3_mpeg($fd, $dummy);
+						if (empty($dummy['error'])) {
+							$ThisFileInfo['audio']   = $dummy['audio'];
+							$ThisFileInfo['video']   = $dummy['video'];
+							$ThisFileInfo['mpeg']    = $dummy['mpeg'];
+							$ThisFileInfo['warning'] = $dummy['warning'];
+						}
+					}
+				}
+				break;
+
+
+			default:
+				$ThisFileInfo['error'][] = 'Unknown RIFF type: expecting one of (WAVE|RMP3|AVI |CDDA|AIFF|AIFC|8SVX|CDXA), found &quot;'.$RIFFsubtype.'&quot; instead';
+				unset($ThisFileInfo['fileformat']);
+				break;
+		}
+
+		if (isset($thisfile_riff_WAVE['DISP']) &amp;&amp; is_array($thisfile_riff_WAVE['DISP'])) {
+			$thisfile_riff['comments']['title'][] = trim(substr($thisfile_riff_WAVE['DISP'][count($thisfile_riff_WAVE['DISP']) - 1]['data'], 4));
+		}
+		if (isset($thisfile_riff_WAVE['INFO']) &amp;&amp; is_array($thisfile_riff_WAVE['INFO'])) {
+			$this-&gt;RIFFcommentsParse($thisfile_riff_WAVE['INFO'], $thisfile_riff['comments']);
+		}
+
+		if (empty($thisfile_audio['encoder']) &amp;&amp; !empty($ThisFileInfo['mpeg']['audio']['LAME']['short_version'])) {
+			$thisfile_audio['encoder'] = $ThisFileInfo['mpeg']['audio']['LAME']['short_version'];
+		}
+
+		if (!isset($ThisFileInfo['playtime_seconds'])) {
+			$ThisFileInfo['playtime_seconds'] = 0;
+		}
+		if (isset($thisfile_riff_raw['avih']['dwTotalFrames']) &amp;&amp; isset($thisfile_riff_raw['avih']['dwMicroSecPerFrame'])) {
+			$ThisFileInfo['playtime_seconds'] = $thisfile_riff_raw['avih']['dwTotalFrames'] * ($thisfile_riff_raw['avih']['dwMicroSecPerFrame'] / 1000000);
+		}
+
+		if ($ThisFileInfo['playtime_seconds'] &gt; 0) {
+			if (isset($thisfile_riff_audio) &amp;&amp; isset($thisfile_riff_video)) {
+
+				if (!isset($ThisFileInfo['bitrate'])) {
+					$ThisFileInfo['bitrate'] = ((($thisfile_avdataend - $thisfile_avdataoffset) / $ThisFileInfo['playtime_seconds']) * 8);
+				}
+
+			} elseif (isset($thisfile_riff_audio) &amp;&amp; !isset($thisfile_riff_video)) {
+
+				if (!isset($thisfile_audio['bitrate'])) {
+					$thisfile_audio['bitrate'] = ((($thisfile_avdataend - $thisfile_avdataoffset) / $ThisFileInfo['playtime_seconds']) * 8);
+				}
+
+			} elseif (!isset($thisfile_riff_audio) &amp;&amp; isset($thisfile_riff_video)) {
+
+				if (!isset($thisfile_video['bitrate'])) {
+					$thisfile_video['bitrate'] = ((($thisfile_avdataend - $thisfile_avdataoffset) / $ThisFileInfo['playtime_seconds']) * 8);
+				}
+
+			}
+		}
+
+
+		if (isset($thisfile_riff_video) &amp;&amp; isset($thisfile_audio['bitrate']) &amp;&amp; ($thisfile_audio['bitrate'] &gt; 0) &amp;&amp; ($ThisFileInfo['playtime_seconds'] &gt; 0)) {
+
+			$ThisFileInfo['bitrate'] = ((($thisfile_avdataend - $thisfile_avdataoffset) / $ThisFileInfo['playtime_seconds']) * 8);
+			$thisfile_audio['bitrate'] = 0;
+			$thisfile_video['bitrate'] = $ThisFileInfo['bitrate'];
+			foreach ($thisfile_riff_audio as $channelnumber =&gt; $audioinfoarray) {
+				$thisfile_video['bitrate'] -= $audioinfoarray['bitrate'];
+				$thisfile_audio['bitrate'] += $audioinfoarray['bitrate'];
+			}
+			if ($thisfile_video['bitrate'] &lt;= 0) {
+				unset($thisfile_video['bitrate']);
+			}
+			if ($thisfile_audio['bitrate'] &lt;= 0) {
+				unset($thisfile_audio['bitrate']);
+			}
+		}
+
+		if (isset($ThisFileInfo['mpeg']['audio'])) {
+			$thisfile_audio_dataformat      = 'mp'.$ThisFileInfo['mpeg']['audio']['layer'];
+			$thisfile_audio['sample_rate']  = $ThisFileInfo['mpeg']['audio']['sample_rate'];
+			$thisfile_audio['channels']     = $ThisFileInfo['mpeg']['audio']['channels'];
+			$thisfile_audio['bitrate']      = $ThisFileInfo['mpeg']['audio']['bitrate'];
+			$thisfile_audio['bitrate_mode'] = strtolower($ThisFileInfo['mpeg']['audio']['bitrate_mode']);
+			if (!empty($ThisFileInfo['mpeg']['audio']['codec'])) {
+				$thisfile_audio['codec'] = $ThisFileInfo['mpeg']['audio']['codec'].' '.$thisfile_audio['codec'];
+			}
+			if (!empty($thisfile_audio['streams'])) {
+				foreach ($thisfile_audio['streams'] as $streamnumber =&gt; $streamdata) {
+					if ($streamdata['dataformat'] == $thisfile_audio_dataformat) {
+						$thisfile_audio['streams'][$streamnumber]['sample_rate']  = $thisfile_audio['sample_rate'];
+						$thisfile_audio['streams'][$streamnumber]['channels']     = $thisfile_audio['channels'];
+						$thisfile_audio['streams'][$streamnumber]['bitrate']      = $thisfile_audio['bitrate'];
+						$thisfile_audio['streams'][$streamnumber]['bitrate_mode'] = $thisfile_audio['bitrate_mode'];
+						$thisfile_audio['streams'][$streamnumber]['codec']        = $thisfile_audio['codec'];
+					}
+				}
+			}
+			$thisfile_audio['encoder_options'] = getid3_mp3::GuessEncoderOptions($ThisFileInfo);
+		}
+
+
+		if (!empty($thisfile_riff_raw['fmt ']['wBitsPerSample']) &amp;&amp; ($thisfile_riff_raw['fmt ']['wBitsPerSample'] &gt; 0)) {
+			switch ($thisfile_audio_dataformat) {
+				case 'ac3':
+					// ignore bits_per_sample
+					break;
+
+				default:
+					$thisfile_audio['bits_per_sample'] = $thisfile_riff_raw['fmt ']['wBitsPerSample'];
+					break;
+			}
+		}
+
+
+		if (empty($thisfile_riff_raw)) {
+			unset($thisfile_riff['raw']);
+		}
+		if (empty($thisfile_riff_audio)) {
+			unset($thisfile_riff['audio']);
+		}
+		if (empty($thisfile_riff_video)) {
+			unset($thisfile_riff['video']);
+		}
+
+		return true;
+	}
+
+
+	function RIFFcommentsParse(&amp;$RIFFinfoArray, &amp;$CommentsTargetArray) {
+		$RIFFinfoKeyLookup = array(
+			'IARL'=&gt;'archivallocation',
+			'IART'=&gt;'artist',
+			'ICDS'=&gt;'costumedesigner',
+			'ICMS'=&gt;'commissionedby',
+			'ICMT'=&gt;'comment',
+			'ICNT'=&gt;'country',
+			'ICOP'=&gt;'copyright',
+			'ICRD'=&gt;'creationdate',
+			'IDIM'=&gt;'dimensions',
+			'IDIT'=&gt;'digitizationdate',
+			'IDPI'=&gt;'resolution',
+			'IDST'=&gt;'distributor',
+			'IEDT'=&gt;'editor',
+			'IENG'=&gt;'engineers',
+			'IFRM'=&gt;'accountofparts',
+			'IGNR'=&gt;'genre',
+			'IKEY'=&gt;'keywords',
+			'ILGT'=&gt;'lightness',
+			'ILNG'=&gt;'language',
+			'IMED'=&gt;'orignalmedium',
+			'IMUS'=&gt;'composer',
+			'INAM'=&gt;'title',
+			'IPDS'=&gt;'productiondesigner',
+			'IPLT'=&gt;'palette',
+			'IPRD'=&gt;'product',
+			'IPRO'=&gt;'producer',
+			'IPRT'=&gt;'part',
+			'IRTD'=&gt;'rating',
+			'ISBJ'=&gt;'subject',
+			'ISFT'=&gt;'software',
+			'ISGN'=&gt;'secondarygenre',
+			'ISHP'=&gt;'sharpness',
+			'ISRC'=&gt;'sourcesupplier',
+			'ISRF'=&gt;'digitizationsource',
+			'ISTD'=&gt;'productionstudio',
+			'ISTR'=&gt;'starring',
+			'ITCH'=&gt;'encoded_by',
+			'IWEB'=&gt;'url',
+			'IWRI'=&gt;'writer'
+		);
+		foreach ($RIFFinfoKeyLookup as $key =&gt; $value) {
+			if (isset($RIFFinfoArray[$key])) {
+				foreach ($RIFFinfoArray[$key] as $commentid =&gt; $commentdata) {
+					if (trim($commentdata['data']) != '') {
+						@$CommentsTargetArray[$value][] = trim($commentdata['data']);
+					}
+				}
+			}
+		}
+		return true;
+	}
+
+	function ParseRIFF(&amp;$fd, $startoffset, $maxoffset, &amp;$ThisFileInfo) {
+
+		$maxoffset = min($maxoffset, $ThisFileInfo['avdataend']);
+
+		$RIFFchunk = false;
+
+		fseek($fd, $startoffset, SEEK_SET);
+
+		while (ftell($fd) &lt; $maxoffset) {
+			$chunkname = fread($fd, 4);
+			if (strlen($chunkname) &lt; 4) {
+				$ThisFileInfo['error'][] = 'Expecting chunk name at offset '.(ftell($fd) - 4).' but found nothing. Aborting RIFF parsing.';
+				break;
+			}
+
+			$chunksize = getid3_riff::EitherEndian2Int($ThisFileInfo, fread($fd, 4));
+			if ($chunksize == 0) {
+				$ThisFileInfo['error'][] = 'Chunk size at offset '.(ftell($fd) - 4).' is zero. Aborting RIFF parsing.';
+				break;
+			}
+			if (($chunksize % 2) != 0) {
+				// all structures are packed on word boundaries
+				$chunksize++;
+			}
+
+			switch ($chunkname) {
+				case 'LIST':
+					$listname = fread($fd, 4);
+					switch ($listname) {
+						case 'movi':
+						case 'rec ':
+							$RIFFchunk[$listname]['offset'] = ftell($fd) - 4;
+							$RIFFchunk[$listname]['size']   = $chunksize;
+
+							static $ParsedAudioStream = false;
+							if ($ParsedAudioStream) {
+
+								// skip over
+
+							} else {
+
+								$WhereWeWere = ftell($fd);
+								$AudioChunkHeader = fread($fd, 12);
+								$AudioChunkStreamNum  =                              substr($AudioChunkHeader, 0, 2);
+								$AudioChunkStreamType =                              substr($AudioChunkHeader, 2, 2);
+								$AudioChunkSize       = getid3_lib::LittleEndian2Int(substr($AudioChunkHeader, 4, 4));
+
+								if ($AudioChunkStreamType == 'wb') {
+									$FirstFourBytes = substr($AudioChunkHeader, 8, 4);
+									if (preg_match('/^\xFF[\xE2-\xE7\xF2-\xF7\xFA-\xFF][\x00-\xEB]/s', $FirstFourBytes)) {
+
+										// MP3
+										if (getid3_mp3::MPEGaudioHeaderBytesValid($FirstFourBytes)) {
+											$dummy = $ThisFileInfo;
+											$dummy['avdataoffset'] = ftell($fd) - 4;
+											$dummy['avdataend']    = ftell($fd) + $AudioChunkSize;
+											getid3_mp3::getOnlyMPEGaudioInfo($fd, $dummy, $dummy['avdataoffset'], false);
+											if (isset($dummy['mpeg']['audio'])) {
+												$ThisFileInfo = $dummy;
+												$ThisFileInfo['audio']['dataformat']   = 'mp'.$ThisFileInfo['mpeg']['audio']['layer'];
+												$ThisFileInfo['audio']['sample_rate']  = $ThisFileInfo['mpeg']['audio']['sample_rate'];
+												$ThisFileInfo['audio']['channels']     = $ThisFileInfo['mpeg']['audio']['channels'];
+												$ThisFileInfo['audio']['bitrate']      = $ThisFileInfo['mpeg']['audio']['bitrate'];
+												$ThisFileInfo['bitrate']               = $ThisFileInfo['audio']['bitrate'];
+												$ThisFileInfo['audio']['bitrate_mode'] = strtolower($ThisFileInfo['mpeg']['audio']['bitrate_mode']);
+											}
+										}
+
+									} elseif (preg_match('/^\x0B\x77/s', $FirstFourBytes)) {
+
+										// AC3
+										$GETID3_ERRORARRAY = &amp;$ThisFileInfo['warning'];
+										if (getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.ac3.php', __FILE__, false)) {
+
+											$dummy = $ThisFileInfo;
+											$dummy['avdataoffset'] = ftell($fd) - 4;
+											$dummy['avdataend']    = ftell($fd) + $AudioChunkSize;
+											$dummy['error']        = array();
+											$ac3_tag = new getid3_ac3($fd, $dummy);
+											if (empty($dummy['error'])) {
+												$ThisFileInfo['audio']   = $dummy['audio'];
+												$ThisFileInfo['ac3']     = $dummy['ac3'];
+												$ThisFileInfo['warning'] = $dummy['warning'];
+											}
+
+										}
+
+									}
+
+								}
+
+								$ParsedAudioStream = true;
+								fseek($fd, $WhereWeWere, SEEK_SET);
+
+							}
+							fseek($fd, $chunksize - 4, SEEK_CUR);
+							break;
+
+						default:
+							if (!isset($RIFFchunk[$listname])) {
+								$RIFFchunk[$listname] = array();
+							}
+							$LISTchunkParent    = $listname;
+							$LISTchunkMaxOffset = ftell($fd) - 4 + $chunksize;
+							if ($parsedChunk = getid3_riff::ParseRIFF($fd, ftell($fd), ftell($fd) + $chunksize - 4, $ThisFileInfo)) {
+								$RIFFchunk[$listname] = array_merge_recursive($RIFFchunk[$listname], $parsedChunk);
+							}
+							break;
+					}
+					break;
+
+				default:
+					$thisindex = 0;
+					if (isset($RIFFchunk[$chunkname]) &amp;&amp; is_array($RIFFchunk[$chunkname])) {
+						$thisindex = count($RIFFchunk[$chunkname]);
+					}
+					$RIFFchunk[$chunkname][$thisindex]['offset'] = ftell($fd) - 8;
+					$RIFFchunk[$chunkname][$thisindex]['size']   = $chunksize;
+					switch ($chunkname) {
+						case 'data':
+							$ThisFileInfo['avdataoffset'] = ftell($fd);
+							$ThisFileInfo['avdataend']    = $ThisFileInfo['avdataoffset'] + $chunksize;
+
+							$RIFFdataChunkContentsTest = fread($fd, 36);
+
+							if ((strlen($RIFFdataChunkContentsTest) &gt; 0) &amp;&amp; preg_match('/^\xFF[\xE2-\xE7\xF2-\xF7\xFA-\xFF][\x00-\xEB]/s', substr($RIFFdataChunkContentsTest, 0, 4))) {
+
+								// Probably is MP3 data
+								if (getid3_mp3::MPEGaudioHeaderBytesValid(substr($RIFFdataChunkContentsTest, 0, 4))) {
+									getid3_mp3::getOnlyMPEGaudioInfo($fd, $ThisFileInfo, $RIFFchunk[$chunkname][$thisindex]['offset'], false);
+								}
+
+							} elseif ((strlen($RIFFdataChunkContentsTest) &gt; 0) &amp;&amp; (substr($RIFFdataChunkContentsTest, 0, 2) == &quot;\x0B\x77&quot;)) {
+
+								// This is probably AC-3 data
+								$GETID3_ERRORARRAY = &amp;$ThisFileInfo['warning'];
+								if (getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.ac3.php', __FILE__, false)) {
+
+									$dummy = $ThisFileInfo;
+									$dummy['avdataoffset'] = $RIFFchunk[$chunkname][$thisindex]['offset'];
+									$dummy['avdataend']    = $dummy['avdataoffset'] + $RIFFchunk[$chunkname][$thisindex]['size'];
+									$dummy['error']        = array();
+
+									$ac3_tag = new getid3_ac3($fd, $dummy);
+									if (empty($dummy['error'])) {
+										$ThisFileInfo['audio']   = $dummy['audio'];
+										$ThisFileInfo['ac3']     = $dummy['ac3'];
+										$ThisFileInfo['warning'] = $dummy['warning'];
+									}
+
+								}
+
+							} elseif ((strlen($RIFFdataChunkContentsTest) &gt; 0) &amp;&amp; (substr($RIFFdataChunkContentsTest, 8, 2) == &quot;\x77\x0B&quot;)) {
+
+								// Dolby Digital WAV
+								// AC-3 content, but not encoded in same format as normal AC-3 file
+								// For one thing, byte order is swapped
+
+								$GETID3_ERRORARRAY = &amp;$ThisFileInfo['warning'];
+								if (getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.ac3.php', __FILE__, false)) {
+
+									// ok to use tmpfile here - only 56 bytes
+									if ($fd_temp = tmpfile()) {
+
+										for ($i = 0; $i &lt; 28; $i += 2) {
+											// swap byte order
+											fwrite($fd_temp, substr($RIFFdataChunkContentsTest, 8 + $i + 1, 1));
+											fwrite($fd_temp, substr($RIFFdataChunkContentsTest, 8 + $i + 0, 1));
+										}
+
+										$dummy = $ThisFileInfo;
+										$dummy['avdataoffset'] = 0;
+										$dummy['avdataend']    = 20;
+										$dummy['error']        = array();
+										$ac3_tag = new getid3_ac3($fd_temp, $dummy);
+										fclose($fd_temp);
+										if (empty($dummy['error'])) {
+											$ThisFileInfo['audio']   = $dummy['audio'];
+											$ThisFileInfo['ac3']     = $dummy['ac3'];
+											$ThisFileInfo['warning'] = $dummy['warning'];
+										} else {
+											$ThisFileInfo['error'][] = 'Errors parsing DolbyDigital WAV: '.explode(';', $dummy['error']);
+										}
+
+									} else {
+
+										$ThisFileInfo['error'][] = 'Could not create temporary file to analyze DolbyDigital WAV';
+
+									}
+
+								}
+
+							} elseif ((strlen($RIFFdataChunkContentsTest) &gt; 0) &amp;&amp; (substr($RIFFdataChunkContentsTest, 0, 4) == 'wvpk')) {
+
+								// This is WavPack data
+								$ThisFileInfo['wavpack']['offset'] = $RIFFchunk[$chunkname][$thisindex]['offset'];
+								$ThisFileInfo['wavpack']['size']   = getid3_lib::LittleEndian2Int(substr($RIFFdataChunkContentsTest, 4, 4));
+								getid3_riff::RIFFparseWavPackHeader(substr($RIFFdataChunkContentsTest, 8, 28), $ThisFileInfo);
+
+							} else {
+
+								// This is some other kind of data (quite possibly just PCM)
+								// do nothing special, just skip it
+
+							}
+							fseek($fd, $RIFFchunk[$chunkname][$thisindex]['offset'] + 8 + $chunksize, SEEK_SET);
+							break;
+
+						case 'bext':
+						case 'cart':
+						case 'fmt ':
+						case 'MEXT':
+						case 'DISP':
+							// always read data in
+							$RIFFchunk[$chunkname][$thisindex]['data'] = fread($fd, $chunksize);
+							break;
+
+						default:
+							if (!empty($LISTchunkParent) &amp;&amp; (($RIFFchunk[$chunkname][$thisindex]['offset'] + $RIFFchunk[$chunkname][$thisindex]['size']) &lt;= $LISTchunkMaxOffset)) {
+								$RIFFchunk[$LISTchunkParent][$chunkname][$thisindex]['offset'] = $RIFFchunk[$chunkname][$thisindex]['offset'];
+								$RIFFchunk[$LISTchunkParent][$chunkname][$thisindex]['size']   = $RIFFchunk[$chunkname][$thisindex]['size'];
+								unset($RIFFchunk[$chunkname][$thisindex]['offset']);
+								unset($RIFFchunk[$chunkname][$thisindex]['size']);
+								if (isset($RIFFchunk[$chunkname][$thisindex]) &amp;&amp; empty($RIFFchunk[$chunkname][$thisindex])) {
+									unset($RIFFchunk[$chunkname][$thisindex]);
+								}
+								if (isset($RIFFchunk[$chunkname]) &amp;&amp; empty($RIFFchunk[$chunkname])) {
+									unset($RIFFchunk[$chunkname]);
+								}
+								$RIFFchunk[$LISTchunkParent][$chunkname][$thisindex]['data'] = fread($fd, $chunksize);
+							} elseif ($chunksize &lt; 2048) {
+								// only read data in if smaller than 2kB
+								$RIFFchunk[$chunkname][$thisindex]['data'] = fread($fd, $chunksize);
+							} else {
+								fseek($fd, $chunksize, SEEK_CUR);
+							}
+							break;
+					}
+					break;
+
+			}
+
+		}
+
+		return $RIFFchunk;
+	}
+
+
+	function ParseRIFFdata(&amp;$RIFFdata, &amp;$ThisFileInfo) {
+		if ($RIFFdata) {
+
+		    $tempfile = tempnam('*', 'getID3');
+            $fp_temp  = fopen($tempfile, &quot;wb&quot;);
+			$RIFFdataLength = strlen($RIFFdata);
+			$NewLengthString = getid3_lib::LittleEndian2String($RIFFdataLength, 4);
+			for ($i = 0; $i &lt; 4; $i++) {
+				$RIFFdata{$i + 4} = $NewLengthString{$i};
+			}
+			fwrite($fp_temp, $RIFFdata);
+			fclose($fp_temp);
+
+			$fp_temp  = fopen($tempfile, &quot;rb&quot;);
+			$dummy = array('filesize'=&gt;$RIFFdataLength, 'filenamepath'=&gt;$ThisFileInfo['filenamepath'], 'tags'=&gt;$ThisFileInfo['tags'], 'avdataoffset'=&gt;0, 'avdataend'=&gt;$RIFFdataLength, 'warning'=&gt;$ThisFileInfo['warning'], 'error'=&gt;$ThisFileInfo['error'], 'comments'=&gt;$ThisFileInfo['comments'], 'audio'=&gt;(isset($ThisFileInfo['audio']) ? $ThisFileInfo['audio'] : array()), 'video'=&gt;(isset($ThisFileInfo['video']) ? $ThisFileInfo['video'] : array()));
+			$riff = new getid3_riff($fp_temp, $dummy);
+			$ThisFileInfo['riff']     = $dummy['riff'];
+			$ThisFileInfo['warning']  = $dummy['warning'];
+			$ThisFileInfo['error']    = $dummy['error'];
+			$ThisFileInfo['tags']     = $dummy['tags'];
+			$ThisFileInfo['comments'] = $dummy['comments'];
+			fclose($fp_temp);
+			unlink($tempfile);
+			return true;
+		}
+		return false;
+	}
+
+
+	function RIFFparseWAVEFORMATex($WaveFormatExData) {
+		// shortcut
+		$WaveFormatEx['raw'] = array();
+		$WaveFormatEx_raw    = &amp;$WaveFormatEx['raw'];
+
+		$WaveFormatEx_raw['wFormatTag']      = getid3_lib::LittleEndian2Int(substr($WaveFormatExData,  0, 2));
+		$WaveFormatEx_raw['nChannels']       = getid3_lib::LittleEndian2Int(substr($WaveFormatExData,  2, 2));
+		$WaveFormatEx_raw['nSamplesPerSec']  = getid3_lib::LittleEndian2Int(substr($WaveFormatExData,  4, 4));
+		$WaveFormatEx_raw['nAvgBytesPerSec'] = getid3_lib::LittleEndian2Int(substr($WaveFormatExData,  8, 4));
+		$WaveFormatEx_raw['nBlockAlign']     = getid3_lib::LittleEndian2Int(substr($WaveFormatExData, 12, 2));
+		$WaveFormatEx_raw['wBitsPerSample']  = getid3_lib::LittleEndian2Int(substr($WaveFormatExData, 14, 2));
+		if (strlen($WaveFormatExData) &gt; 16) {
+			$WaveFormatEx_raw['cbSize']      = getid3_lib::LittleEndian2Int(substr($WaveFormatExData, 16, 2));
+		}
+
+		$WaveFormatEx['codec']           = getid3_riff::RIFFwFormatTagLookup($WaveFormatEx_raw['wFormatTag']);
+		$WaveFormatEx['channels']        = $WaveFormatEx_raw['nChannels'];
+		$WaveFormatEx['sample_rate']     = $WaveFormatEx_raw['nSamplesPerSec'];
+		$WaveFormatEx['bitrate']         = $WaveFormatEx_raw['nAvgBytesPerSec'] * 8;
+		$WaveFormatEx['bits_per_sample'] = $WaveFormatEx_raw['wBitsPerSample'];
+
+		return $WaveFormatEx;
+	}
+
+
+	function RIFFparseWavPackHeader($WavPackChunkData, &amp;$ThisFileInfo) {
+		// typedef struct {
+		//     char ckID [4];
+		//     long ckSize;
+		//     short version;
+		//     short bits;                // added for version 2.00
+		//     short flags, shift;        // added for version 3.00
+		//     long total_samples, crc, crc2;
+		//     char extension [4], extra_bc, extras [3];
+		// } WavpackHeader;
+
+		// shortcut
+		$ThisFileInfo['wavpack'] = array();
+		$thisfile_wavpack        = &amp;$ThisFileInfo['wavpack'];
+
+		$thisfile_wavpack['version']           = getid3_lib::LittleEndian2Int(substr($WavPackChunkData,  0, 2));
+		if ($thisfile_wavpack['version'] &gt;= 2) {
+			$thisfile_wavpack['bits']          = getid3_lib::LittleEndian2Int(substr($WavPackChunkData,  2, 2));
+		}
+		if ($thisfile_wavpack['version'] &gt;= 3) {
+			$thisfile_wavpack['flags_raw']     = getid3_lib::LittleEndian2Int(substr($WavPackChunkData,  4, 2));
+			$thisfile_wavpack['shift']         = getid3_lib::LittleEndian2Int(substr($WavPackChunkData,  6, 2));
+			$thisfile_wavpack['total_samples'] = getid3_lib::LittleEndian2Int(substr($WavPackChunkData,  8, 4));
+			$thisfile_wavpack['crc1']          = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 12, 4));
+			$thisfile_wavpack['crc2']          = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 16, 4));
+			$thisfile_wavpack['extension']     =                              substr($WavPackChunkData, 20, 4);
+			$thisfile_wavpack['extra_bc']      = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 24, 1));
+			for ($i = 0; $i &lt;= 2; $i++) {
+				$thisfile_wavpack['extras'][]  = getid3_lib::LittleEndian2Int(substr($WavPackChunkData, 25 + $i, 1));
+			}
+
+			// shortcut
+			$thisfile_wavpack['flags'] = array();
+			$thisfile_wavpack_flags = &amp;$thisfile_wavpack['flags'];
+
+			$thisfile_wavpack_flags['mono']                 = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000001);
+			$thisfile_wavpack_flags['fast_mode']            = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000002);
+			$thisfile_wavpack_flags['raw_mode']             = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000004);
+			$thisfile_wavpack_flags['calc_noise']           = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000008);
+			$thisfile_wavpack_flags['high_quality']         = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000010);
+			$thisfile_wavpack_flags['3_byte_samples']       = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000020);
+			$thisfile_wavpack_flags['over_20_bits']         = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000040);
+			$thisfile_wavpack_flags['use_wvc']              = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000080);
+			$thisfile_wavpack_flags['noiseshaping']         = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000100);
+			$thisfile_wavpack_flags['very_fast_mode']       = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000200);
+			$thisfile_wavpack_flags['new_high_quality']     = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000400);
+			$thisfile_wavpack_flags['cancel_extreme']       = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x000800);
+			$thisfile_wavpack_flags['cross_decorrelation']  = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x001000);
+			$thisfile_wavpack_flags['new_decorrelation']    = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x002000);
+			$thisfile_wavpack_flags['joint_stereo']         = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x004000);
+			$thisfile_wavpack_flags['extra_decorrelation']  = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x008000);
+			$thisfile_wavpack_flags['override_noiseshape']  = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x010000);
+			$thisfile_wavpack_flags['override_jointstereo'] = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x020000);
+			$thisfile_wavpack_flags['copy_source_filetime'] = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x040000);
+			$thisfile_wavpack_flags['create_exe']           = (bool) ($thisfile_wavpack['flags_raw'] &amp; 0x080000);
+		}
+
+		return true;
+	}
+
+	function RIFFwFormatTagLookup($wFormatTag) {
+
+		$begin = __LINE__;
+
+		/** This is not a comment!
+
+			0x0000	Microsoft Unknown Wave Format
+			0x0001	Pulse Code Modulation (PCM)
+			0x0002	Microsoft ADPCM
+			0x0003	IEEE Float
+			0x0004	Compaq Computer VSELP
+			0x0005	IBM CVSD
+			0x0006	Microsoft A-Law
+			0x0007	Microsoft mu-Law
+			0x0008	Microsoft DTS
+			0x0010	OKI ADPCM
+			0x0011	Intel DVI/IMA ADPCM
+			0x0012	Videologic MediaSpace ADPCM
+			0x0013	Sierra Semiconductor ADPCM
+			0x0014	Antex Electronics G.723 ADPCM
+			0x0015	DSP Solutions DigiSTD
+			0x0016	DSP Solutions DigiFIX
+			0x0017	Dialogic OKI ADPCM
+			0x0018	MediaVision ADPCM
+			0x0019	Hewlett-Packard CU
+			0x0020	Yamaha ADPCM
+			0x0021	Speech Compression Sonarc
+			0x0022	DSP Group TrueSpeech
+			0x0023	Echo Speech EchoSC1
+			0x0024	Audiofile AF36
+			0x0025	Audio Processing Technology APTX
+			0x0026	AudioFile AF10
+			0x0027	Prosody 1612
+			0x0028	LRC
+			0x0030	Dolby AC2
+			0x0031	Microsoft GSM 6.10
+			0x0032	MSNAudio
+			0x0033	Antex Electronics ADPCME
+			0x0034	Control Resources VQLPC
+			0x0035	DSP Solutions DigiREAL
+			0x0036	DSP Solutions DigiADPCM
+			0x0037	Control Resources CR10
+			0x0038	Natural MicroSystems VBXADPCM
+			0x0039	Crystal Semiconductor IMA ADPCM
+			0x003A	EchoSC3
+			0x003B	Rockwell ADPCM
+			0x003C	Rockwell Digit LK
+			0x003D	Xebec
+			0x0040	Antex Electronics G.721 ADPCM
+			0x0041	G.728 CELP
+			0x0042	MSG723
+			0x0050	MPEG Layer-2 or Layer-1
+			0x0052	RT24
+			0x0053	PAC
+			0x0055	MPEG Layer-3
+			0x0059	Lucent G.723
+			0x0060	Cirrus
+			0x0061	ESPCM
+			0x0062	Voxware
+			0x0063	Canopus Atrac
+			0x0064	G.726 ADPCM
+			0x0065	G.722 ADPCM
+			0x0066	DSAT
+			0x0067	DSAT Display
+			0x0069	Voxware Byte Aligned
+			0x0070	Voxware AC8
+			0x0071	Voxware AC10
+			0x0072	Voxware AC16
+			0x0073	Voxware AC20
+			0x0074	Voxware MetaVoice
+			0x0075	Voxware MetaSound
+			0x0076	Voxware RT29HW
+			0x0077	Voxware VR12
+			0x0078	Voxware VR18
+			0x0079	Voxware TQ40
+			0x0080	Softsound
+			0x0081	Voxware TQ60
+			0x0082	MSRT24
+			0x0083	G.729A
+			0x0084	MVI MV12
+			0x0085	DF G.726
+			0x0086	DF GSM610
+			0x0088	ISIAudio
+			0x0089	Onlive
+			0x0091	SBC24
+			0x0092	Dolby AC3 SPDIF
+			0x0093	MediaSonic G.723
+			0x0094	Aculab PLC    Prosody 8kbps
+			0x0097	ZyXEL ADPCM
+			0x0098	Philips LPCBB
+			0x0099	Packed
+			0x00FF	AAC
+			0x0100	Rhetorex ADPCM
+			0x0101	IBM mu-law
+			0x0102	IBM A-law
+			0x0103	IBM AVC Adaptive Differential Pulse Code Modulation (ADPCM)
+			0x0111	Vivo G.723
+			0x0112	Vivo Siren
+			0x0123	Digital G.723
+			0x0125	Sanyo LD ADPCM
+			0x0130	Sipro Lab Telecom ACELP NET
+			0x0131	Sipro Lab Telecom ACELP 4800
+			0x0132	Sipro Lab Telecom ACELP 8V3
+			0x0133	Sipro Lab Telecom G.729
+			0x0134	Sipro Lab Telecom G.729A
+			0x0135	Sipro Lab Telecom Kelvin
+			0x0140	Windows Media Video V8
+			0x0150	Qualcomm PureVoice
+			0x0151	Qualcomm HalfRate
+			0x0155	Ring Zero Systems TUB GSM
+			0x0160	Microsoft Audio 1
+			0x0161	Windows Media Audio V7 / V8 / V9
+			0x0162	Windows Media Audio Professional V9
+			0x0163	Windows Media Audio Lossless V9
+			0x0200	Creative Labs ADPCM
+			0x0202	Creative Labs Fastspeech8
+			0x0203	Creative Labs Fastspeech10
+			0x0210	UHER Informatic GmbH ADPCM
+			0x0220	Quarterdeck
+			0x0230	I-link Worldwide VC
+			0x0240	Aureal RAW Sport
+			0x0250	Interactive Products HSX
+			0x0251	Interactive Products RPELP
+			0x0260	Consistent Software CS2
+			0x0270	Sony SCX
+			0x0300	Fujitsu FM Towns Snd
+			0x0400	BTV Digital
+			0x0401	Intel Music Coder
+			0x0450	QDesign Music
+			0x0680	VME VMPCM
+			0x0681	AT&amp;T Labs TPC
+			0x08AE	ClearJump LiteWave
+			0x1000	Olivetti GSM
+			0x1001	Olivetti ADPCM
+			0x1002	Olivetti CELP
+			0x1003	Olivetti SBC
+			0x1004	Olivetti OPR
+			0x1100	Lernout &amp; Hauspie Codec (0x1100)
+			0x1101	Lernout &amp; Hauspie CELP Codec (0x1101)
+			0x1102	Lernout &amp; Hauspie SBC Codec (0x1102)
+			0x1103	Lernout &amp; Hauspie SBC Codec (0x1103)
+			0x1104	Lernout &amp; Hauspie SBC Codec (0x1104)
+			0x1400	Norris
+			0x1401	AT&amp;T ISIAudio
+			0x1500	Soundspace Music Compression
+			0x181C	VoxWare RT24 Speech
+			0x1FC4	NCT Soft ALF2CD (www.nctsoft.com)
+			0x2000	Dolby AC3
+			0x2001	Dolby DTS
+			0x2002	WAVE_FORMAT_14_4
+			0x2003	WAVE_FORMAT_28_8
+			0x2004	WAVE_FORMAT_COOK
+			0x2005	WAVE_FORMAT_DNET
+			0x674F	Ogg Vorbis 1
+			0x6750	Ogg Vorbis 2
+			0x6751	Ogg Vorbis 3
+			0x676F	Ogg Vorbis 1+
+			0x6770	Ogg Vorbis 2+
+			0x6771	Ogg Vorbis 3+
+			0x7A21	GSM-AMR (CBR, no SID)
+			0x7A22	GSM-AMR (VBR, including SID)
+			0xFFFE	WAVE_FORMAT_EXTENSIBLE
+			0xFFFF	WAVE_FORMAT_DEVELOPMENT
+
+		*/
+
+		return getid3_lib::EmbeddedLookup('0x'.str_pad(strtoupper(dechex($wFormatTag)), 4, '0', STR_PAD_LEFT), $begin, __LINE__, __FILE__, 'riff-wFormatTag');
+
+	}
+
+
+	function RIFFfourccLookup($fourcc) {
+
+		$begin = __LINE__;
+
+		/** This is not a comment!
+
+			swot	<A HREF="http://developer.apple.com/qa/snd/snd07.html">http://developer.apple.com/qa/snd/snd07.html</A>
+			____	No Codec (____)
+			_BIT	BI_BITFIELDS (Raw RGB)
+			_JPG	JPEG compressed
+			_PNG	PNG compressed W3C/ISO/IEC (RFC-2083)
+			_RAW	Full Frames (Uncompressed)
+			_RGB	Raw RGB Bitmap
+			_RL4	RLE 4bpp RGB
+			_RL8	RLE 8bpp RGB
+			3IV1	3ivx MPEG-4 v1
+			3IV2	3ivx MPEG-4 v2
+			3IVX	3ivx MPEG-4
+			AASC	Autodesk Animator
+			ABYR	Kensington ?ABYR?
+			AEMI	Array Microsystems VideoONE MPEG1-I Capture
+			AFLC	Autodesk Animator FLC
+			AFLI	Autodesk Animator FLI
+			AMPG	Array Microsystems VideoONE MPEG
+			ANIM	Intel RDX (ANIM)
+			AP41	AngelPotion Definitive
+			ASV1	Asus Video v1
+			ASV2	Asus Video v2
+			ASVX	Asus Video 2.0 (audio)
+			AUR2	AuraVision Aura 2 Codec - YUV 4:2:2
+			AURA	AuraVision Aura 1 Codec - YUV 4:1:1
+			AVDJ	Independent JPEG Group\'s codec (AVDJ)
+			AVRN	Independent JPEG Group\'s codec (AVRN)
+			AYUV	4:4:4 YUV (AYUV)
+			AZPR	Quicktime Apple Video (AZPR)
+			BGR 	Raw RGB32
+			BLZ0	Blizzard DivX MPEG-4
+			BTVC	Conexant Composite Video
+			BINK	RAD Game Tools Bink Video
+			BT20	Conexant Prosumer Video
+			BTCV	Conexant Composite Video Codec
+			BW10	Data Translation Broadway MPEG Capture
+			CC12	Intel YUV12
+			CDVC	Canopus DV
+			CFCC	Digital Processing Systems DPS Perception
+			CGDI	Microsoft Office 97 Camcorder Video
+			CHAM	Winnov Caviara Champagne
+			CJPG	Creative WebCam JPEG
+			CLJR	Cirrus Logic YUV 4:1:1
+			CMYK	Common Data Format in Printing (Colorgraph)
+			CPLA	Weitek 4:2:0 YUV Planar
+			CRAM	Microsoft Video 1 (CRAM)
+			cvid	Radius Cinepak
+			CVID	Radius Cinepak
+			CWLT	Microsoft Color WLT DIB
+			CYUV	Creative Labs YUV
+			CYUY	ATI YUV
+			D261	H.261
+			D263	H.263
+			DIB 	Device Independent Bitmap
+			DIV1	FFmpeg OpenDivX
+			DIV2	Microsoft MPEG-4 v1/v2
+			DIV3	DivX ;-) MPEG-4 v3.x Low-Motion
+			DIV4	DivX ;-) MPEG-4 v3.x Fast-Motion
+			DIV5	DivX MPEG-4 v5.x
+			DIV6	DivX ;-) (MS MPEG-4 v3.x)
+			DIVX	DivX MPEG-4 v4 (OpenDivX / Project Mayo)
+			divx	DivX MPEG-4
+			DMB1	Matrox Rainbow Runner hardware MJPEG
+			DMB2	Paradigm MJPEG
+			DSVD	?DSVD?
+			DUCK	Duck TrueMotion 1.0
+			DPS0	DPS/Leitch Reality Motion JPEG
+			DPSC	DPS/Leitch PAR Motion JPEG
+			DV25	Matrox DVCPRO codec
+			DV50	Matrox DVCPRO50 codec
+			DVC 	IEC 61834 and SMPTE 314M (DVC/DV Video)
+			DVCP	IEC 61834 and SMPTE 314M (DVC/DV Video)
+			DVHD	IEC Standard DV 1125 lines @ 30fps / 1250 lines @ 25fps
+			DVMA	Darim Vision DVMPEG (dummy for MPEG compressor) (www.darvision.com)
+			DVSL	IEC Standard DV compressed in SD (SDL)
+			DVAN	?DVAN?
+			DVE2	InSoft DVE-2 Videoconferencing
+			dvsd	IEC 61834 and SMPTE 314M DVC/DV Video
+			DVSD	IEC 61834 and SMPTE 314M DVC/DV Video
+			DVX1	Lucent DVX1000SP Video Decoder
+			DVX2	Lucent DVX2000S Video Decoder
+			DVX3	Lucent DVX3000S Video Decoder
+			DX50	DivX v5
+			DXT1	Microsoft DirectX Compressed Texture (DXT1)
+			DXT2	Microsoft DirectX Compressed Texture (DXT2)
+			DXT3	Microsoft DirectX Compressed Texture (DXT3)
+			DXT4	Microsoft DirectX Compressed Texture (DXT4)
+			DXT5	Microsoft DirectX Compressed Texture (DXT5)
+			DXTC	Microsoft DirectX Compressed Texture (DXTC)
+			DXTn	Microsoft DirectX Compressed Texture (DXTn)
+			EM2V	Etymonix MPEG-2 I-frame (www.etymonix.com)
+			EKQ0	Elsa ?EKQ0?
+			ELK0	Elsa ?ELK0?
+			ESCP	Eidos Escape
+			ETV1	eTreppid Video ETV1
+			ETV2	eTreppid Video ETV2
+			ETVC	eTreppid Video ETVC
+			FLIC	Autodesk FLI/FLC Animation
+			FRWT	Darim Vision Forward Motion JPEG (www.darvision.com)
+			FRWU	Darim Vision Forward Uncompressed (www.darvision.com)
+			FLJP	D-Vision Field Encoded Motion JPEG
+			FRWA	SoftLab-Nsk Forward Motion JPEG w/ alpha channel
+			FRWD	SoftLab-Nsk Forward Motion JPEG
+			FVF1	Iterated Systems Fractal Video Frame
+			GLZW	Motion LZW (<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">gabest at freemail.hu</A>)
+			GPEG	Motion JPEG (<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">gabest at freemail.hu</A>)
+			GWLT	Microsoft Greyscale WLT DIB
+			H260	Intel ITU H.260 Videoconferencing
+			H261	Intel ITU H.261 Videoconferencing
+			H262	Intel ITU H.262 Videoconferencing
+			H263	Intel ITU H.263 Videoconferencing
+			H264	Intel ITU H.264 Videoconferencing
+			H265	Intel ITU H.265 Videoconferencing
+			H266	Intel ITU H.266 Videoconferencing
+			H267	Intel ITU H.267 Videoconferencing
+			H268	Intel ITU H.268 Videoconferencing
+			H269	Intel ITU H.269 Videoconferencing
+			HFYU	Huffman Lossless Codec
+			HMCR	Rendition Motion Compensation Format (HMCR)
+			HMRR	Rendition Motion Compensation Format (HMRR)
+			I263	FFmpeg I263 decoder
+			IF09	Indeo YVU9 (&quot;YVU9 with additional delta-frame info after the U plane&quot;)
+			IUYV	Interlaced version of UYVY (www.leadtools.com)
+			IY41	Interlaced version of Y41P (www.leadtools.com)
+			IYU1	12 bit format used in mode 2 of the IEEE 1394 Digital Camera 1.04 spec    IEEE standard
+			IYU2	24 bit format used in mode 2 of the IEEE 1394 Digital Camera 1.04 spec    IEEE standard
+			IYUV	Planar YUV format (8-bpp Y plane, followed by 8-bpp 2&#215;2 U and V planes)
+			i263	Intel ITU H.263 Videoconferencing (i263)
+			I420	Intel Indeo 4
+			IAN 	Intel Indeo 4 (RDX)
+			ICLB	InSoft CellB Videoconferencing
+			IGOR	Power DVD
+			IJPG	Intergraph JPEG
+			ILVC	Intel Layered Video
+			ILVR	ITU-T H.263+
+			IPDV	I-O Data Device Giga AVI DV Codec
+			IR21	Intel Indeo 2.1
+			IRAW	Intel YUV Uncompressed
+			IV30	Intel Indeo 3.0
+			IV31	Intel Indeo 3.1
+			IV32	Ligos Indeo 3.2
+			IV33	Ligos Indeo 3.3
+			IV34	Ligos Indeo 3.4
+			IV35	Ligos Indeo 3.5
+			IV36	Ligos Indeo 3.6
+			IV37	Ligos Indeo 3.7
+			IV38	Ligos Indeo 3.8
+			IV39	Ligos Indeo 3.9
+			IV40	Ligos Indeo Interactive 4.0
+			IV41	Ligos Indeo Interactive 4.1
+			IV42	Ligos Indeo Interactive 4.2
+			IV43	Ligos Indeo Interactive 4.3
+			IV44	Ligos Indeo Interactive 4.4
+			IV45	Ligos Indeo Interactive 4.5
+			IV46	Ligos Indeo Interactive 4.6
+			IV47	Ligos Indeo Interactive 4.7
+			IV48	Ligos Indeo Interactive 4.8
+			IV49	Ligos Indeo Interactive 4.9
+			IV50	Ligos Indeo Interactive 5.0
+			JBYR	Kensington ?JBYR?
+			JPEG	Still Image JPEG DIB
+			JPGL	Pegasus Lossless Motion JPEG
+			KMVC	Team17 Software Karl Morton\'s Video Codec
+			LSVM	Vianet Lighting Strike Vmail (Streaming) (www.vianet.com)
+			LEAD	LEAD Video Codec
+			Ljpg	LEAD MJPEG Codec
+			MDVD	Alex MicroDVD Video (hacked MS MPEG-4) (www.tiasoft.de)
+			MJPA	Morgan Motion JPEG (MJPA) (www.morgan-multimedia.com)
+			MJPB	Morgan Motion JPEG (MJPB) (www.morgan-multimedia.com)
+			MMES	Matrox MPEG-2 I-frame
+			MP2v	Microsoft S-Mpeg 4 version 1 (MP2v)
+			MP42	Microsoft S-Mpeg 4 version 2 (MP42)
+			MP43	Microsoft S-Mpeg 4 version 3 (MP43)
+			MP4S	Microsoft S-Mpeg 4 version 3 (MP4S)
+			MP4V	FFmpeg MPEG-4
+			MPG1	FFmpeg MPEG 1/2
+			MPG2	FFmpeg MPEG 1/2
+			MPG3	FFmpeg DivX ;-) (MS MPEG-4 v3)
+			MPG4	Microsoft MPEG-4
+			MPGI	Sigma Designs MPEG
+			MPNG	PNG images decoder
+			MSS1	Microsoft Windows Screen Video
+			MSZH	LCL (Lossless Codec Library) (www.geocities.co.jp/Playtown-Denei/2837/LRC.htm)
+			M261	Microsoft H.261
+			M263	Microsoft H.263
+			M4S2	Microsoft Fully Compliant MPEG-4 v2 simple profile (M4S2)
+			m4s2	Microsoft Fully Compliant MPEG-4 v2 simple profile (m4s2)
+			MC12	ATI Motion Compensation Format (MC12)
+			MCAM	ATI Motion Compensation Format (MCAM)
+			MJ2C	Morgan Multimedia Motion JPEG2000
+			mJPG	IBM Motion JPEG w/ Huffman Tables
+			MJPG	Microsoft Motion JPEG DIB
+			MP42	Microsoft MPEG-4 (low-motion)
+			MP43	Microsoft MPEG-4 (fast-motion)
+			MP4S	Microsoft MPEG-4 (MP4S)
+			mp4s	Microsoft MPEG-4 (mp4s)
+			MPEG	Chromatic Research MPEG-1 Video I-Frame
+			MPG4	Microsoft MPEG-4 Video High Speed Compressor
+			MPGI	Sigma Designs MPEG
+			MRCA	FAST Multimedia Martin Regen Codec
+			MRLE	Microsoft Run Length Encoding
+			MSVC	Microsoft Video 1
+			MTX1	Matrox ?MTX1?
+			MTX2	Matrox ?MTX2?
+			MTX3	Matrox ?MTX3?
+			MTX4	Matrox ?MTX4?
+			MTX5	Matrox ?MTX5?
+			MTX6	Matrox ?MTX6?
+			MTX7	Matrox ?MTX7?
+			MTX8	Matrox ?MTX8?
+			MTX9	Matrox ?MTX9?
+			MV12	Motion Pixels Codec (old)
+			MWV1	Aware Motion Wavelets
+			nAVI	SMR Codec (hack of Microsoft MPEG-4) (IRC #shadowrealm)
+			NT00	NewTek LightWave HDTV YUV w/ Alpha (www.newtek.com)
+			NUV1	NuppelVideo
+			NTN1	Nogatech Video Compression 1
+			NVS0	nVidia GeForce Texture (NVS0)
+			NVS1	nVidia GeForce Texture (NVS1)
+			NVS2	nVidia GeForce Texture (NVS2)
+			NVS3	nVidia GeForce Texture (NVS3)
+			NVS4	nVidia GeForce Texture (NVS4)
+			NVS5	nVidia GeForce Texture (NVS5)
+			NVT0	nVidia GeForce Texture (NVT0)
+			NVT1	nVidia GeForce Texture (NVT1)
+			NVT2	nVidia GeForce Texture (NVT2)
+			NVT3	nVidia GeForce Texture (NVT3)
+			NVT4	nVidia GeForce Texture (NVT4)
+			NVT5	nVidia GeForce Texture (NVT5)
+			PIXL	MiroXL, Pinnacle PCTV
+			PDVC	I-O Data Device Digital Video Capture DV codec
+			PGVV	Radius Video Vision
+			PHMO	IBM Photomotion
+			PIM1	MPEG Realtime (Pinnacle Cards)
+			PIM2	Pegasus Imaging ?PIM2?
+			PIMJ	Pegasus Imaging Lossless JPEG
+			PVEZ	Horizons Technology PowerEZ
+			PVMM	PacketVideo Corporation MPEG-4
+			PVW2	Pegasus Imaging Wavelet Compression
+			Q1.0	Q-Team\'s QPEG 1.0 (www.q-team.de)
+			Q1.1	Q-Team\'s QPEG 1.1 (www.q-team.de)
+			QPEG	Q-Team QPEG 1.0
+			qpeq	Q-Team QPEG 1.1
+			RGB 	Raw BGR32
+			RGBA	Raw RGB w/ Alpha
+			RMP4	REALmagic MPEG-4 (unauthorized XVID copy) (www.sigmadesigns.com)
+			ROQV	Id RoQ File Video Decoder
+			RPZA	Quicktime Apple Video (RPZA)
+			RUD0	Rududu video codec (<A HREF="http://rududu.ifrance.com/rududu/">http://rududu.ifrance.com/rududu/</A>)
+			RV10	RealVideo 1.0 (aka RealVideo 5.0)
+			RV13	RealVideo 1.0 (RV13)
+			RV20	RealVideo G2
+			RV30	RealVideo 8
+			RV40	RealVideo 9
+			RGBT	Raw RGB w/ Transparency
+			RLE 	Microsoft Run Length Encoder
+			RLE4	Run Length Encoded (4bpp, 16-color)
+			RLE8	Run Length Encoded (8bpp, 256-color)
+			RT21	Intel Indeo RealTime Video 2.1
+			rv20	RealVideo G2
+			rv30	RealVideo 8
+			RVX 	Intel RDX (RVX )
+			SMC 	Apple Graphics (SMC )
+			SP54	Logitech Sunplus Sp54 Codec for Mustek GSmart Mini 2
+			SPIG	Radius Spigot
+			SVQ3	Sorenson Video 3 (Apple Quicktime 5)
+			s422	Tekram VideoCap C210 YUV 4:2:2
+			SDCC	Sun Communication Digital Camera Codec
+			SFMC	CrystalNet Surface Fitting Method
+			SMSC	Radius SMSC
+			SMSD	Radius SMSD
+			smsv	WorldConnect Wavelet Video
+			SPIG	Radius Spigot
+			SPLC	Splash Studios ACM Audio Codec (www.splashstudios.net)
+			SQZ2	Microsoft VXTreme Video Codec V2
+			STVA	ST Microelectronics CMOS Imager Data (Bayer)
+			STVB	ST Microelectronics CMOS Imager Data (Nudged Bayer)
+			STVC	ST Microelectronics CMOS Imager Data (Bunched)
+			STVX	ST Microelectronics CMOS Imager Data (Extended CODEC Data Format)
+			STVY	ST Microelectronics CMOS Imager Data (Extended CODEC Data Format with Correction Data)
+			SV10	Sorenson Video R1
+			SVQ1	Sorenson Video
+			T420	Toshiba YUV 4:2:0
+			TM2A	Duck TrueMotion Archiver 2.0 (www.duck.com)
+			TVJP	Pinnacle/Truevision Targa 2000 board (TVJP)
+			TVMJ	Pinnacle/Truevision Targa 2000 board (TVMJ)
+			TY0N	Tecomac Low-Bit Rate Codec (www.tecomac.com)
+			TY2C	Trident Decompression Driver
+			TLMS	TeraLogic Motion Intraframe Codec (TLMS)
+			TLST	TeraLogic Motion Intraframe Codec (TLST)
+			TM20	Duck TrueMotion 2.0
+			TM2X	Duck TrueMotion 2X
+			TMIC	TeraLogic Motion Intraframe Codec (TMIC)
+			TMOT	Horizons Technology TrueMotion S
+			tmot	Horizons TrueMotion Video Compression
+			TR20	Duck TrueMotion RealTime 2.0
+			TSCC	TechSmith Screen Capture Codec
+			TV10	Tecomac Low-Bit Rate Codec
+			TY2N	Trident ?TY2N?
+			U263	UB Video H.263/H.263+/H.263++ Decoder
+			UMP4	UB Video MPEG 4 (www.ubvideo.com)
+			UYNV	Nvidia UYVY packed 4:2:2
+			UYVP	Evans &amp; Sutherland YCbCr 4:2:2 extended precision
+			UCOD	eMajix.com ClearVideo
+			ULTI	IBM Ultimotion
+			UYVY	UYVY packed 4:2:2
+			V261	Lucent VX2000S
+			VIFP	VFAPI Reader Codec (www.yks.ne.jp/~hori/)
+			VIV1	FFmpeg H263+ decoder
+			VIV2	Vivo H.263
+			VQC2	Vector-quantised codec 2 (research) <A HREF="http://eprints.ecs.soton.ac.uk/archive/00001310/01/VTC97-js.pdf">http://eprints.ecs.soton.ac.uk/archive/00001310/01/VTC97-js.pdf</A>)
+			VTLP	Alaris VideoGramPiX
+			VYU9	ATI YUV (VYU9)
+			VYUY	ATI YUV (VYUY)
+			V261	Lucent VX2000S
+			V422	Vitec Multimedia 24-bit YUV 4:2:2 Format
+			V655	Vitec Multimedia 16-bit YUV 4:2:2 Format
+			VCR1	ATI Video Codec 1
+			VCR2	ATI Video Codec 2
+			VCR3	ATI VCR 3.0
+			VCR4	ATI VCR 4.0
+			VCR5	ATI VCR 5.0
+			VCR6	ATI VCR 6.0
+			VCR7	ATI VCR 7.0
+			VCR8	ATI VCR 8.0
+			VCR9	ATI VCR 9.0
+			VDCT	Vitec Multimedia Video Maker Pro DIB
+			VDOM	VDOnet VDOWave
+			VDOW	VDOnet VDOLive (H.263)
+			VDTZ	Darim Vison VideoTizer YUV
+			VGPX	Alaris VideoGramPiX
+			VIDS	Vitec Multimedia YUV 4:2:2 CCIR 601 for V422
+			VIVO	Vivo H.263 v2.00
+			vivo	Vivo H.263
+			VIXL	Miro/Pinnacle Video XL
+			VLV1	VideoLogic/PURE Digital Videologic Capture
+			VP30	On2 VP3.0
+			VP31	On2 VP3.1
+			VX1K	Lucent VX1000S Video Codec
+			VX2K	Lucent VX2000S Video Codec
+			VXSP	Lucent VX1000SP Video Codec
+			WBVC	Winbond W9960
+			WHAM	Microsoft Video 1 (WHAM)
+			WINX	Winnov Software Compression
+			WJPG	AverMedia Winbond JPEG
+			WMV1	Windows Media Video V7
+			WMV2	Windows Media Video V8
+			WMV3	Windows Media Video V9
+			WNV1	Winnov Hardware Compression
+			XYZP	Extended PAL format XYZ palette (www.riff.org)
+			x263	Xirlink H.263
+			XLV0	NetXL Video Decoder
+			XMPG	Xing MPEG (I-Frame only)
+			XVID	XviD MPEG-4 (www.xvid.org)
+			XXAN	?XXAN?
+			YU92	Intel YUV (YU92)
+			YUNV	Nvidia Uncompressed YUV 4:2:2
+			YUVP	Extended PAL format YUV palette (www.riff.org)
+			Y211	YUV 2:1:1 Packed
+			Y411	YUV 4:1:1 Packed
+			Y41B	Weitek YUV 4:1:1 Planar
+			Y41P	Brooktree PC1 YUV 4:1:1 Packed
+			Y41T	Brooktree PC1 YUV 4:1:1 with transparency
+			Y42B	Weitek YUV 4:2:2 Planar
+			Y42T	Brooktree UYUV 4:2:2 with transparency
+			Y422	ADS Technologies Copy of UYVY used in Pyro WebCam firewire camera
+			Y800	Simple, single Y plane for monochrome images
+			Y8  	Grayscale video
+			YC12	Intel YUV 12 codec
+			YUV8	Winnov Caviar YUV8
+			YUV9	Intel YUV9
+			YUY2	Uncompressed YUV 4:2:2
+			YUYV	Canopus YUV
+			YV12	YVU12 Planar
+			YVU9	Intel YVU9 Planar (8-bpp Y plane, followed by 8-bpp 4x4 U and V planes)
+			YVYU	YVYU 4:2:2 Packed
+			ZLIB	Lossless Codec Library zlib compression (www.geocities.co.jp/Playtown-Denei/2837/LRC.htm)
+			ZPEG	Metheus Video Zipper
+
+		*/
+
+		return getid3_lib::EmbeddedLookup($fourcc, $begin, __LINE__, __FILE__, 'riff-fourcc');
+	}
+
+
+	function EitherEndian2Int(&amp;$ThisFileInfo, $byteword, $signed=false) {
+		if ($ThisFileInfo['fileformat'] == 'riff') {
+			return getid3_lib::LittleEndian2Int($byteword, $signed);
+		}
+		return getid3_lib::BigEndian2Int($byteword, false, $signed);
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.swf.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.swf.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio-video.swf.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,153 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio-video.swf.php                                  //
+// module for analyzing Shockwave Flash files                  //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_swf
+{
+
+	function getid3_swf(&amp;$fd, &amp;$ThisFileInfo, $ReturnAllTagData=false) {
+		$ThisFileInfo['fileformat']          = 'swf';
+		$ThisFileInfo['video']['dataformat'] = 'swf';
+
+		// <A HREF="http://www.openswf.org/spec/SWFfileformat.html">http://www.openswf.org/spec/SWFfileformat.html</A>
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+//echo 'reading '.($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']).' bytes&lt;br&gt;';
+		$SWFfileData = fread($fd, $ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']); // 8 + 2 + 2 + max(9) bytes NOT including Frame_Size RECT data
+
+		$ThisFileInfo['swf']['header']['signature']  = substr($SWFfileData, 0, 3);
+		switch ($ThisFileInfo['swf']['header']['signature']) {
+			case 'FWS':
+				$ThisFileInfo['swf']['header']['compressed'] = false;
+				break;
+
+			case 'CWS':
+				$ThisFileInfo['swf']['header']['compressed'] = true;
+				break;
+
+			default:
+				$ThisFileInfo['error'][] = 'Expecting &quot;FWS&quot; or &quot;CWS&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$ThisFileInfo['swf']['header']['signature'].'&quot;';
+				unset($ThisFileInfo['swf']);
+				unset($ThisFileInfo['fileformat']);
+				return false;
+				break;
+		}
+		$ThisFileInfo['swf']['header']['version'] = getid3_lib::LittleEndian2Int(substr($SWFfileData, 3, 1));
+		$ThisFileInfo['swf']['header']['length']  = getid3_lib::LittleEndian2Int(substr($SWFfileData, 4, 4));
+
+//echo '1&lt;br&gt;';
+		if ($ThisFileInfo['swf']['header']['compressed']) {
+
+//echo '2&lt;br&gt;';
+//			$foo = substr($SWFfileData, 8, 4096);
+//			echo '['.strlen($foo).']&lt;br&gt;';
+//			$fee = gzuncompress($foo);
+//			echo '('.strlen($fee).')&lt;br&gt;';
+//return false;
+//echo '&lt;br&gt;time: '.time().'&lt;br&gt;';
+//return false;
+			if ($UncompressedFileData = gzuncompress(substr($SWFfileData, 8))) {
+
+//echo '3&lt;br&gt;';
+				$SWFfileData = substr($SWFfileData, 0, 8).$UncompressedFileData;
+
+			} else {
+
+//echo '4&lt;br&gt;';
+				$ThisFileInfo['error'][] = 'Error decompressing compressed SWF data';
+				return false;
+
+			}
+
+		}
+
+		$FrameSizeBitsPerValue = (ord(substr($SWFfileData, 8, 1)) &amp; 0xF8) &gt;&gt; 3;
+		$FrameSizeDataLength   = ceil((5 + (4 * $FrameSizeBitsPerValue)) / 8);
+		$FrameSizeDataString   = str_pad(decbin(ord(substr($SWFfileData, 8, 1)) &amp; 0x07), 3, '0', STR_PAD_LEFT);
+		for ($i = 1; $i &lt; $FrameSizeDataLength; $i++) {
+			$FrameSizeDataString .= str_pad(decbin(ord(substr($SWFfileData, 8 + $i, 1))), 8, '0', STR_PAD_LEFT);
+		}
+		list($X1, $X2, $Y1, $Y2) = explode(&quot;\n&quot;, wordwrap($FrameSizeDataString, $FrameSizeBitsPerValue, &quot;\n&quot;, 1));
+		$ThisFileInfo['swf']['header']['frame_width']  = getid3_lib::Bin2Dec($X2);
+		$ThisFileInfo['swf']['header']['frame_height'] = getid3_lib::Bin2Dec($Y2);
+
+		// <A HREF="http://www-lehre.informatik.uni-osnabrueck.de/~fbstark/diplom/docs/swf/Flash_Uncovered.htm">http://www-lehre.informatik.uni-osnabrueck.de/~fbstark/diplom/docs/swf/Flash_Uncovered.htm</A>
+		// Next in the header is the frame rate, which is kind of weird.
+		// It is supposed to be stored as a 16bit integer, but the first byte
+		// (or last depending on how you look at it) is completely ignored.
+		// Example: 0x000C  -&gt;  0x0C  -&gt;  12     So the frame rate is 12 fps.
+
+		// Byte at (8 + $FrameSizeDataLength) is always zero and ignored
+		$ThisFileInfo['swf']['header']['frame_rate']  = getid3_lib::LittleEndian2Int(substr($SWFfileData,  9 + $FrameSizeDataLength, 1));
+		$ThisFileInfo['swf']['header']['frame_count'] = getid3_lib::LittleEndian2Int(substr($SWFfileData, 10 + $FrameSizeDataLength, 2));
+
+		$ThisFileInfo['video']['frame_rate']         = $ThisFileInfo['swf']['header']['frame_rate'];
+		$ThisFileInfo['video']['resolution_x']       = intval(round($ThisFileInfo['swf']['header']['frame_width']  / 20));
+		$ThisFileInfo['video']['resolution_y']       = intval(round($ThisFileInfo['swf']['header']['frame_height'] / 20));
+		$ThisFileInfo['video']['pixel_aspect_ratio'] = (float) 1;
+
+		if (($ThisFileInfo['swf']['header']['frame_count'] &gt; 0) &amp;&amp; ($ThisFileInfo['swf']['header']['frame_rate'] &gt; 0)) {
+			$ThisFileInfo['playtime_seconds'] = $ThisFileInfo['swf']['header']['frame_count'] / $ThisFileInfo['swf']['header']['frame_rate'];
+		}
+
+
+		// SWF tags
+
+		$CurrentOffset = 12 + $FrameSizeDataLength;
+		$SWFdataLength = strlen($SWFfileData);
+
+		while ($CurrentOffset &lt; $SWFdataLength) {
+
+			$TagIDTagLength = getid3_lib::LittleEndian2Int(substr($SWFfileData, $CurrentOffset, 2));
+			$TagID     = ($TagIDTagLength &amp; 0xFFFC) &gt;&gt; 6;
+			$TagLength = ($TagIDTagLength &amp; 0x003F);
+			$CurrentOffset += 2;
+			if ($TagLength == 0x3F) {
+				$TagLength = getid3_lib::LittleEndian2Int(substr($SWFfileData, $CurrentOffset, 4));
+				$CurrentOffset += 4;
+			}
+
+			unset($TagData);
+			$TagData['offset'] = $CurrentOffset;
+			$TagData['size']   = $TagLength;
+			$TagData['id']     = $TagID;
+			$TagData['data']   = substr($SWFfileData, $CurrentOffset, $TagLength);
+			switch ($TagID) {
+				case 0: // end of movie
+					break 2;
+
+				case 9: // Set background color
+					//$ThisFileInfo['swf']['tags'][] = $TagData;
+					$ThisFileInfo['swf']['bgcolor'] = strtoupper(str_pad(dechex(getid3_lib::BigEndian2Int($TagData['data'])), 6, '0', STR_PAD_LEFT));
+					break;
+
+				default:
+					if ($ReturnAllTagData) {
+						$ThisFileInfo['swf']['tags'][] = $TagData;
+					}
+					break;
+			}
+
+			$CurrentOffset += $TagLength;
+		}
+
+		return true;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.aac.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.aac.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.aac.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,538 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.aac.php                                        //
+// module for analyzing AAC Audio files                        //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_aac
+{
+
+	// new combined constructor
+	function getid3_aac(&amp;$fd, &amp;$ThisFileInfo, $option) {
+
+		if ($option === 'adif') {
+			$this-&gt;getAACADIFheaderFilepointer($fd, $ThisFileInfo);
+		}
+		elseif ($option === 'adts') {
+			$this-&gt;getAACADTSheaderFilepointer($fd, $ThisFileInfo);
+		}
+	}
+
+
+
+	function getAACADIFheaderFilepointer(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat']          = 'aac';
+		$ThisFileInfo['audio']['dataformat'] = 'aac';
+		$ThisFileInfo['audio']['lossless']   = false;
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$AACheader = fread($fd, 1024);
+		$offset    = 0;
+
+		if (substr($AACheader, 0, 4) == 'ADIF') {
+
+			// <A HREF="http://faac.sourceforge.net/wiki/index.php?page=ADIF">http://faac.sourceforge.net/wiki/index.php?page=ADIF</A>
+
+			// <A HREF="http://libmpeg.org/mpeg4/doc/w2203tfs.pdf">http://libmpeg.org/mpeg4/doc/w2203tfs.pdf</A>
+			// adif_header() {
+			//     adif_id                                32
+			//     copyright_id_present                    1
+			//     if( copyright_id_present )
+			//         copyright_id                       72
+			//     original_copy                           1
+			//     home                                    1
+			//     bitstream_type                          1
+			//     bitrate                                23
+			//     num_program_config_elements             4
+			//     for (i = 0; i &lt; num_program_config_elements + 1; i++ ) {
+			//         if( bitstream_type == '0' )
+			//             adif_buffer_fullness           20
+			//         program_config_element()
+			//     }
+			// }
+
+			$AACheaderBitstream = getid3_lib::BigEndian2Bin($AACheader);
+			$bitoffset          = 0;
+
+			$ThisFileInfo['aac']['header_type']                   = 'ADIF';
+			$bitoffset += 32;
+			$ThisFileInfo['aac']['header']['mpeg_version']        = 4;
+
+			$ThisFileInfo['aac']['header']['copyright']           = (bool) (substr($AACheaderBitstream, $bitoffset, 1) == '1');
+			$bitoffset += 1;
+			if ($ThisFileInfo['aac']['header']['copyright']) {
+				$ThisFileInfo['aac']['header']['copyright_id']    = getid3_lib::Bin2String(substr($AACheaderBitstream, $bitoffset, 72));
+				$bitoffset += 72;
+			}
+			$ThisFileInfo['aac']['header']['original_copy']       = (bool) (substr($AACheaderBitstream, $bitoffset, 1) == '1');
+			$bitoffset += 1;
+			$ThisFileInfo['aac']['header']['home']                = (bool) (substr($AACheaderBitstream, $bitoffset, 1) == '1');
+			$bitoffset += 1;
+			$ThisFileInfo['aac']['header']['is_vbr']              = (bool) (substr($AACheaderBitstream, $bitoffset, 1) == '1');
+			$bitoffset += 1;
+			if ($ThisFileInfo['aac']['header']['is_vbr']) {
+				$ThisFileInfo['audio']['bitrate_mode']            = 'vbr';
+				$ThisFileInfo['aac']['header']['bitrate_max']     = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 23));
+				$bitoffset += 23;
+			} else {
+				$ThisFileInfo['audio']['bitrate_mode']            = 'cbr';
+				$ThisFileInfo['aac']['header']['bitrate']         = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 23));
+				$bitoffset += 23;
+				$ThisFileInfo['audio']['bitrate']                 = $ThisFileInfo['aac']['header']['bitrate'];
+			}
+			if ($ThisFileInfo['audio']['bitrate'] == 0) {
+				$ThisFileInfo['error'][] = 'Corrupt AAC file: bitrate_audio == zero';
+				return false;
+			}
+			$ThisFileInfo['aac']['header']['num_program_configs'] = 1 + getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+			$bitoffset += 4;
+
+			for ($i = 0; $i &lt; $ThisFileInfo['aac']['header']['num_program_configs']; $i++) {
+				// <A HREF="http://www.audiocoding.com/wiki/index.php?page=program_config_element">http://www.audiocoding.com/wiki/index.php?page=program_config_element</A>
+
+				// buffer_fullness                       20
+
+				// element_instance_tag                   4
+				// object_type                            2
+				// sampling_frequency_index               4
+				// num_front_channel_elements             4
+				// num_side_channel_elements              4
+				// num_back_channel_elements              4
+				// num_lfe_channel_elements               2
+				// num_assoc_data_elements                3
+				// num_valid_cc_elements                  4
+				// mono_mixdown_present                   1
+				// mono_mixdown_element_number            4   if mono_mixdown_present == 1
+				// stereo_mixdown_present                 1
+				// stereo_mixdown_element_number          4   if stereo_mixdown_present == 1
+				// matrix_mixdown_idx_present             1
+				// matrix_mixdown_idx                     2   if matrix_mixdown_idx_present == 1
+				// pseudo_surround_enable                 1   if matrix_mixdown_idx_present == 1
+				// for (i = 0; i &lt; num_front_channel_elements; i++) {
+				//     front_element_is_cpe[i]            1
+				//     front_element_tag_select[i]        4
+				// }
+				// for (i = 0; i &lt; num_side_channel_elements; i++) {
+				//     side_element_is_cpe[i]             1
+				//     side_element_tag_select[i]         4
+				// }
+				// for (i = 0; i &lt; num_back_channel_elements; i++) {
+				//     back_element_is_cpe[i]             1
+				//     back_element_tag_select[i]         4
+				// }
+				// for (i = 0; i &lt; num_lfe_channel_elements; i++) {
+				//     lfe_element_tag_select[i]          4
+				// }
+				// for (i = 0; i &lt; num_assoc_data_elements; i++) {
+				//     assoc_data_element_tag_select[i]   4
+				// }
+				// for (i = 0; i &lt; num_valid_cc_elements; i++) {
+				//     cc_element_is_ind_sw[i]            1
+				//     valid_cc_element_tag_select[i]     4
+				// }
+				// byte_alignment()                       VAR
+				// comment_field_bytes                    8
+				// for (i = 0; i &lt; comment_field_bytes; i++) {
+				//     comment_field_data[i]              8
+				// }
+
+				if (!$ThisFileInfo['aac']['header']['is_vbr']) {
+					$ThisFileInfo['aac']['program_configs'][$i]['buffer_fullness']        = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 20));
+					$bitoffset += 20;
+				}
+				$ThisFileInfo['aac']['program_configs'][$i]['element_instance_tag']       = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+				$bitoffset += 4;
+				$ThisFileInfo['aac']['program_configs'][$i]['object_type']                = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 2));
+				$bitoffset += 2;
+				$ThisFileInfo['aac']['program_configs'][$i]['sampling_frequency_index']   = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+				$bitoffset += 4;
+				$ThisFileInfo['aac']['program_configs'][$i]['num_front_channel_elements'] = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+				$bitoffset += 4;
+				$ThisFileInfo['aac']['program_configs'][$i]['num_side_channel_elements']  = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+				$bitoffset += 4;
+				$ThisFileInfo['aac']['program_configs'][$i]['num_back_channel_elements']  = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+				$bitoffset += 4;
+				$ThisFileInfo['aac']['program_configs'][$i]['num_lfe_channel_elements']   = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 2));
+				$bitoffset += 2;
+				$ThisFileInfo['aac']['program_configs'][$i]['num_assoc_data_elements']    = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 3));
+				$bitoffset += 3;
+				$ThisFileInfo['aac']['program_configs'][$i]['num_valid_cc_elements']      = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+				$bitoffset += 4;
+				$ThisFileInfo['aac']['program_configs'][$i]['mono_mixdown_present']       = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+				$bitoffset += 1;
+				if ($ThisFileInfo['aac']['program_configs'][$i]['mono_mixdown_present']) {
+					$ThisFileInfo['aac']['program_configs'][$i]['mono_mixdown_element_number']    = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+					$bitoffset += 4;
+				}
+				$ThisFileInfo['aac']['program_configs'][$i]['stereo_mixdown_present']             = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+				$bitoffset += 1;
+				if ($ThisFileInfo['aac']['program_configs'][$i]['stereo_mixdown_present']) {
+					$ThisFileInfo['aac']['program_configs'][$i]['stereo_mixdown_element_number']  = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+					$bitoffset += 4;
+				}
+				$ThisFileInfo['aac']['program_configs'][$i]['matrix_mixdown_idx_present']         = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+				$bitoffset += 1;
+				if ($ThisFileInfo['aac']['program_configs'][$i]['matrix_mixdown_idx_present']) {
+					$ThisFileInfo['aac']['program_configs'][$i]['matrix_mixdown_idx']             = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 2));
+					$bitoffset += 2;
+					$ThisFileInfo['aac']['program_configs'][$i]['pseudo_surround_enable']         = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+					$bitoffset += 1;
+				}
+				for ($j = 0; $j &lt; $ThisFileInfo['aac']['program_configs'][$i]['num_front_channel_elements']; $j++) {
+					$ThisFileInfo['aac']['program_configs'][$i]['front_element_is_cpe'][$j]     = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+					$bitoffset += 1;
+					$ThisFileInfo['aac']['program_configs'][$i]['front_element_tag_select'][$j] = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+					$bitoffset += 4;
+				}
+				for ($j = 0; $j &lt; $ThisFileInfo['aac']['program_configs'][$i]['num_side_channel_elements']; $j++) {
+					$ThisFileInfo['aac']['program_configs'][$i]['side_element_is_cpe'][$j]     = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+					$bitoffset += 1;
+					$ThisFileInfo['aac']['program_configs'][$i]['side_element_tag_select'][$j] = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+					$bitoffset += 4;
+				}
+				for ($j = 0; $j &lt; $ThisFileInfo['aac']['program_configs'][$i]['num_back_channel_elements']; $j++) {
+					$ThisFileInfo['aac']['program_configs'][$i]['back_element_is_cpe'][$j]     = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+					$bitoffset += 1;
+					$ThisFileInfo['aac']['program_configs'][$i]['back_element_tag_select'][$j] = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+					$bitoffset += 4;
+				}
+				for ($j = 0; $j &lt; $ThisFileInfo['aac']['program_configs'][$i]['num_lfe_channel_elements']; $j++) {
+					$ThisFileInfo['aac']['program_configs'][$i]['lfe_element_tag_select'][$j] = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+					$bitoffset += 4;
+				}
+				for ($j = 0; $j &lt; $ThisFileInfo['aac']['program_configs'][$i]['num_assoc_data_elements']; $j++) {
+					$ThisFileInfo['aac']['program_configs'][$i]['assoc_data_element_tag_select'][$j] = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+					$bitoffset += 4;
+				}
+				for ($j = 0; $j &lt; $ThisFileInfo['aac']['program_configs'][$i]['num_valid_cc_elements']; $j++) {
+					$ThisFileInfo['aac']['program_configs'][$i]['cc_element_is_ind_sw'][$j]          = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+					$bitoffset += 1;
+					$ThisFileInfo['aac']['program_configs'][$i]['valid_cc_element_tag_select'][$j]   = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+					$bitoffset += 4;
+				}
+
+				$bitoffset = ceil($bitoffset / 8) * 8;
+
+				$ThisFileInfo['aac']['program_configs'][$i]['comment_field_bytes'] = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 8));
+				$bitoffset += 8;
+				$ThisFileInfo['aac']['program_configs'][$i]['comment_field']       = getid3_lib::Bin2String(substr($AACheaderBitstream, $bitoffset, 8 * $ThisFileInfo['aac']['program_configs'][$i]['comment_field_bytes']));
+				$bitoffset += 8 * $ThisFileInfo['aac']['program_configs'][$i]['comment_field_bytes'];
+
+
+				$ThisFileInfo['aac']['header']['profile_text']                      = $this-&gt;AACprofileLookup($ThisFileInfo['aac']['program_configs'][$i]['object_type'], $ThisFileInfo['aac']['header']['mpeg_version']);
+				$ThisFileInfo['aac']['program_configs'][$i]['sampling_frequency']   = $this-&gt;AACsampleRateLookup($ThisFileInfo['aac']['program_configs'][$i]['sampling_frequency_index']);
+				$ThisFileInfo['audio']['sample_rate']                               = $ThisFileInfo['aac']['program_configs'][$i]['sampling_frequency'];
+				$ThisFileInfo['audio']['channels']                                  = $this-&gt;AACchannelCountCalculate($ThisFileInfo['aac']['program_configs'][$i]);
+				if ($ThisFileInfo['aac']['program_configs'][$i]['comment_field']) {
+					$ThisFileInfo['aac']['comments'][]                          = $ThisFileInfo['aac']['program_configs'][$i]['comment_field'];
+				}
+			}
+			$ThisFileInfo['playtime_seconds'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['audio']['bitrate'];
+
+			$ThisFileInfo['audio']['encoder_options'] = $ThisFileInfo['aac']['header_type'].' '.$ThisFileInfo['aac']['header']['profile_text'];
+
+
+
+			return true;
+
+		} else {
+
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['aac']);
+			$ThisFileInfo['error'][] = 'AAC-ADIF synch not found at offset '.$ThisFileInfo['avdataoffset'].' (expected &quot;ADIF&quot;, found &quot;'.substr($AACheader, 0, 4).'&quot; instead)';
+			return false;
+
+		}
+
+	}
+
+
+	function getAACADTSheaderFilepointer(&amp;$fd, &amp;$ThisFileInfo, $MaxFramesToScan=1000000, $ReturnExtendedInfo=false) {
+		// based loosely on code from AACfile by Jurgen Faul  &lt;jfaul&#216;gmx.de&gt;
+		// <A HREF="http://jfaul.de/atl">http://jfaul.de/atl</A>  or  <A HREF="http://j-faul.virtualave.net/atl/atl.html">http://j-faul.virtualave.net/atl/atl.html</A>
+
+
+		// <A HREF="http://faac.sourceforge.net/wiki/index.php?page=ADTS">http://faac.sourceforge.net/wiki/index.php?page=ADTS</A>
+
+		// * ADTS Fixed Header: these don't change from frame to frame
+		// syncword                                       12    always: '111111111111'
+		// ID                                              1    0: MPEG-4, 1: MPEG-2
+		// layer                                           2    always: '00'
+		// protection_absent                               1
+		// profile                                         2
+		// sampling_frequency_index                        4
+		// private_bit                                     1
+		// channel_configuration                           3
+		// original/copy                                   1
+		// home                                            1
+		// emphasis                                        2    only if ID == 0 (ie MPEG-4)
+
+		// * ADTS Variable Header: these can change from frame to frame
+		// copyright_identification_bit                    1
+		// copyright_identification_start                  1
+		// aac_frame_length                               13    length of the frame including header (in bytes)
+		// adts_buffer_fullness                           11    0x7FF indicates VBR
+		// no_raw_data_blocks_in_frame                     2
+
+		// * ADTS Error check
+		// crc_check                                      16    only if protection_absent == 0
+
+		$byteoffset  = 0;
+		$framenumber = 0;
+
+		// Init bit pattern array
+		static $decbin = array();
+
+		// Populate $bindec
+		for ($i = 0; $i &lt; 256; $i++) {
+			$decbin[chr($i)] = str_pad(decbin($i), 8, '0', STR_PAD_LEFT);
+		}
+
+		// used to calculate bitrate below
+		static $BitrateCache = array();
+
+
+		while (true) {
+			// breaks out when end-of-file encountered, or invalid data found,
+			// or MaxFramesToScan frames have been scanned
+
+			fseek($fd, $byteoffset, SEEK_SET);
+
+			// First get substring
+			$substring = fread($fd, 10);
+			$substringlength = strlen($substring);
+			if ($substringlength != 10) {
+				$ThisFileInfo['error'][] = 'Failed to read 10 bytes at offset '.(ftell($fd) - $substringlength).' (only read '.$substringlength.' bytes)';
+				return false;
+			}
+
+			// Initialise $AACheaderBitstream
+			$AACheaderBitstream = '';
+
+			// Loop thru substring chars
+			for ($i = 0; $i &lt; 10; $i++) {
+				$AACheaderBitstream .= $decbin[$substring{$i}];
+			}
+
+			$bitoffset = 0;
+
+			$synctest = bindec(substr($AACheaderBitstream, $bitoffset, 12));
+
+			$bitoffset += 12;
+			if ($synctest != 0x0FFF) {
+				$ThisFileInfo['error'][] = 'Synch pattern (0x0FFF) not found at offset '.(ftell($fd) - 10).' (found 0x0'.strtoupper(dechex($synctest)).' instead)';
+				if ($ThisFileInfo['fileformat'] == 'aac') {
+					return true;
+				}
+				return false;
+			}
+
+			// Gather info for first frame only - this takes time to do 1000 times!
+			if ($framenumber &gt; 0) {
+
+				if (!$AACheaderBitstream[$bitoffset]) {
+
+					// MPEG-4
+					$bitoffset += 20;
+
+				} else {
+
+					// MPEG-2
+					$bitoffset += 18;
+
+				}
+
+			} else {
+
+				$ThisFileInfo['aac']['header_type']                      = 'ADTS';
+				$ThisFileInfo['aac']['header']['synch']                  = $synctest;
+				$ThisFileInfo['fileformat']                              = 'aac';
+				$ThisFileInfo['audio']['dataformat']                     = 'aac';
+
+				$ThisFileInfo['aac']['header']['mpeg_version']           = ((substr($AACheaderBitstream, $bitoffset, 1) == '0') ? 4 : 2);
+				$bitoffset += 1;
+				$ThisFileInfo['aac']['header']['layer']                  = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 2));
+				$bitoffset += 2;
+				if ($ThisFileInfo['aac']['header']['layer'] != 0) {
+					$ThisFileInfo['error'][] = 'Layer error - expected 0x00, found 0x'.dechex($ThisFileInfo['aac']['header']['layer']).' instead';
+					return false;
+				}
+				$ThisFileInfo['aac']['header']['crc_present']            = ((substr($AACheaderBitstream, $bitoffset, 1) == '0') ? true : false);
+				$bitoffset += 1;
+				$ThisFileInfo['aac']['header']['profile_id']             = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 2));
+				$bitoffset += 2;
+				$ThisFileInfo['aac']['header']['profile_text']           = $this-&gt;AACprofileLookup($ThisFileInfo['aac']['header']['profile_id'], $ThisFileInfo['aac']['header']['mpeg_version']);
+
+				$ThisFileInfo['aac']['header']['sample_frequency_index'] = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 4));
+				$bitoffset += 4;
+				$ThisFileInfo['aac']['header']['sample_frequency']       = $this-&gt;AACsampleRateLookup($ThisFileInfo['aac']['header']['sample_frequency_index']);
+				if ($ThisFileInfo['aac']['header']['sample_frequency'] == 0) {
+					$ThisFileInfo['error'][] = 'Corrupt AAC file: sample_frequency == zero';
+					return false;
+				}
+				$ThisFileInfo['audio']['sample_rate']                    = $ThisFileInfo['aac']['header']['sample_frequency'];
+
+				$ThisFileInfo['aac']['header']['private']                = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+				$bitoffset += 1;
+				$ThisFileInfo['aac']['header']['channel_configuration']  = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 3));
+				$bitoffset += 3;
+				$ThisFileInfo['audio']['channels']                       = $ThisFileInfo['aac']['header']['channel_configuration'];
+				$ThisFileInfo['aac']['header']['original']               = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+				$bitoffset += 1;
+				$ThisFileInfo['aac']['header']['home']                   = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+				$bitoffset += 1;
+
+				if ($ThisFileInfo['aac']['header']['mpeg_version'] == 4) {
+					$ThisFileInfo['aac']['header']['emphasis']           = getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 2));
+					$bitoffset += 2;
+				}
+
+				if ($ReturnExtendedInfo) {
+
+					$ThisFileInfo['aac'][$framenumber]['copyright_id_bit']   = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+					$bitoffset += 1;
+					$ThisFileInfo['aac'][$framenumber]['copyright_id_start'] = (bool) getid3_lib::Bin2Dec(substr($AACheaderBitstream, $bitoffset, 1));
+					$bitoffset += 1;
+
+				} else {
+
+					$bitoffset += 2;
+
+				}
+
+			}
+
+			$FrameLength = bindec(substr($AACheaderBitstream, $bitoffset, 13));
+
+			if (!isset($BitrateCache[$FrameLength])) {
+				$BitrateCache[$FrameLength] = ($ThisFileInfo['aac']['header']['sample_frequency'] / 1024) * $FrameLength * 8;
+			}
+			@$ThisFileInfo['aac']['bitrate_distribution'][$BitrateCache[$FrameLength]]++;
+
+			$ThisFileInfo['aac'][$framenumber]['aac_frame_length']     = $FrameLength;
+			$bitoffset += 13;
+			$ThisFileInfo['aac'][$framenumber]['adts_buffer_fullness'] = bindec(substr($AACheaderBitstream, $bitoffset, 11));
+			$bitoffset += 11;
+			if ($ThisFileInfo['aac'][$framenumber]['adts_buffer_fullness'] == 0x07FF) {
+				$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+			} else {
+				$ThisFileInfo['audio']['bitrate_mode'] = 'cbr';
+			}
+			$ThisFileInfo['aac'][$framenumber]['num_raw_data_blocks']  = bindec(substr($AACheaderBitstream, $bitoffset, 2));
+			$bitoffset += 2;
+
+			if ($ThisFileInfo['aac']['header']['crc_present']) {
+				//$ThisFileInfo['aac'][$framenumber]['crc']              = bindec(substr($AACheaderBitstream, $bitoffset, 16));
+				$bitoffset += 16;
+			}
+
+			if (!$ReturnExtendedInfo) {
+				unset($ThisFileInfo['aac'][$framenumber]);
+			}
+
+			$byteoffset += $FrameLength;
+			if ((++$framenumber &lt; $MaxFramesToScan) &amp;&amp; (($byteoffset + 10) &lt; $ThisFileInfo['avdataend'])) {
+
+				// keep scanning
+
+			} else {
+
+				$ThisFileInfo['aac']['frames']    = $framenumber;
+				$ThisFileInfo['playtime_seconds'] = ($ThisFileInfo['avdataend'] / $byteoffset) * (($framenumber * 1024) / $ThisFileInfo['aac']['header']['sample_frequency']);  // (1 / % of file scanned) * (samples / (samples/sec)) = seconds
+				if ($ThisFileInfo['playtime_seconds'] == 0) {
+					$ThisFileInfo['error'][] = 'Corrupt AAC file: playtime_seconds == zero';
+					return false;
+				}
+				$ThisFileInfo['audio']['bitrate']    = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+				ksort($ThisFileInfo['aac']['bitrate_distribution']);
+
+				$ThisFileInfo['audio']['encoder_options'] = $ThisFileInfo['aac']['header_type'].' '.$ThisFileInfo['aac']['header']['profile_text'];
+
+				return true;
+
+			}
+		}
+		// should never get here.
+	}
+
+	function AACsampleRateLookup($samplerateid) {
+		static $AACsampleRateLookup = array();
+		if (empty($AACsampleRateLookup)) {
+			$AACsampleRateLookup[0]  = 96000;
+			$AACsampleRateLookup[1]  = 88200;
+			$AACsampleRateLookup[2]  = 64000;
+			$AACsampleRateLookup[3]  = 48000;
+			$AACsampleRateLookup[4]  = 44100;
+			$AACsampleRateLookup[5]  = 32000;
+			$AACsampleRateLookup[6]  = 24000;
+			$AACsampleRateLookup[7]  = 22050;
+			$AACsampleRateLookup[8]  = 16000;
+			$AACsampleRateLookup[9]  = 12000;
+			$AACsampleRateLookup[10] = 11025;
+			$AACsampleRateLookup[11] = 8000;
+			$AACsampleRateLookup[12] = 0;
+			$AACsampleRateLookup[13] = 0;
+			$AACsampleRateLookup[14] = 0;
+			$AACsampleRateLookup[15] = 0;
+		}
+		return (isset($AACsampleRateLookup[$samplerateid]) ? $AACsampleRateLookup[$samplerateid] : 'invalid');
+	}
+
+	function AACprofileLookup($profileid, $mpegversion) {
+		static $AACprofileLookup = array();
+		if (empty($AACprofileLookup)) {
+			$AACprofileLookup[2][0]  = 'Main profile';
+			$AACprofileLookup[2][1]  = 'Low Complexity profile (LC)';
+			$AACprofileLookup[2][2]  = 'Scalable Sample Rate profile (SSR)';
+			$AACprofileLookup[2][3]  = '(reserved)';
+			$AACprofileLookup[4][0]  = 'AAC_MAIN';
+			$AACprofileLookup[4][1]  = 'AAC_LC';
+			$AACprofileLookup[4][2]  = 'AAC_SSR';
+			$AACprofileLookup[4][3]  = 'AAC_LTP';
+		}
+		return (isset($AACprofileLookup[$mpegversion][$profileid]) ? $AACprofileLookup[$mpegversion][$profileid] : 'invalid');
+	}
+
+	function AACchannelCountCalculate($program_configs) {
+		$channels = 0;
+		for ($i = 0; $i &lt; $program_configs['num_front_channel_elements']; $i++) {
+			$channels++;
+			if ($program_configs['front_element_is_cpe'][$i]) {
+				// each front element is channel pair (CPE = Channel Pair Element)
+				$channels++;
+			}
+		}
+		for ($i = 0; $i &lt; $program_configs['num_side_channel_elements']; $i++) {
+			$channels++;
+			if ($program_configs['side_element_is_cpe'][$i]) {
+				// each side element is channel pair (CPE = Channel Pair Element)
+				$channels++;
+			}
+		}
+		for ($i = 0; $i &lt; $program_configs['num_back_channel_elements']; $i++) {
+			$channels++;
+			if ($program_configs['back_element_is_cpe'][$i]) {
+				// each back element is channel pair (CPE = Channel Pair Element)
+				$channels++;
+			}
+		}
+		for ($i = 0; $i &lt; $program_configs['num_lfe_channel_elements']; $i++) {
+			$channels++;
+		}
+		return $channels;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.ac3.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.ac3.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.ac3.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,497 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.ac3.php                                        //
+// module for analyzing AC-3 (aka Dolby Digital) audio files   //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_ac3
+{
+
+	function getid3_ac3(&amp;$fd, &amp;$ThisFileInfo) {
+
+		///AH
+		$ThisFileInfo['ac3']['raw']['bsi'] = array();
+		$thisfile_ac3                      = &amp;$ThisFileInfo['ac3'];
+		$thisfile_ac3_raw                  = &amp;$thisfile_ac3['raw'];
+		$thisfile_ac3_raw_bsi              = &amp;$thisfile_ac3_raw['bsi'];
+
+
+		// <A HREF="http://www.atsc.org/standards/a_52a.pdf">http://www.atsc.org/standards/a_52a.pdf</A>
+
+		$ThisFileInfo['fileformat']            = 'ac3';
+		$ThisFileInfo['audio']['dataformat']   = 'ac3';
+		$ThisFileInfo['audio']['bitrate_mode'] = 'cbr';
+		$ThisFileInfo['audio']['lossless']     = false;
+
+		// An AC-3 serial coded audio bit stream is made up of a sequence of synchronization frames
+		// Each synchronization frame contains 6 coded audio blocks (AB), each of which represent 256
+		// new audio samples per channel. A synchronization information (SI) header at the beginning
+		// of each frame contains information needed to acquire and maintain synchronization. A
+		// bit stream information (BSI) header follows SI, and contains parameters describing the coded
+		// audio service. The coded audio blocks may be followed by an auxiliary data (Aux) field. At the
+		// end of each frame is an error check field that includes a CRC word for error detection. An
+		// additional CRC word is located in the SI header, the use of which, by a decoder, is optional.
+		//
+		// syncinfo() | bsi() | AB0 | AB1 | AB2 | AB3 | AB4 | AB5 | Aux | CRC
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$AC3header['syncinfo'] = fread($fd, 5);
+		$thisfile_ac3_raw['synchinfo']['synchword'] = substr($AC3header['syncinfo'], 0, 2);
+
+		if ($thisfile_ac3_raw['synchinfo']['synchword'] != &quot;\x0B\x77&quot;) {
+
+			$ThisFileInfo['error'][] = 'Expecting &quot;\x0B\x77&quot; at offset '.$ThisFileInfo['avdataoffset'].', found \x'.strtoupper(dechex($AC3header['syncinfo']{0})).'\x'.strtoupper(dechex($AC3header['syncinfo']{1})).' instead';
+			unset($thisfile_ac3);
+			return false;
+
+		} else {
+
+			// syncinfo() {
+			// 	 syncword    16
+			// 	 crc1        16
+			// 	 fscod        2
+			// 	 frmsizecod   6
+			// } /* end of syncinfo */
+
+			$thisfile_ac3_raw['synchinfo']['crc1']       = getid3_lib::LittleEndian2Int(substr($AC3header['syncinfo'], 2, 2));
+			$ac3_synchinfo_fscod_frmsizecod                        = getid3_lib::LittleEndian2Int(substr($AC3header['syncinfo'], 4, 1));
+			$thisfile_ac3_raw['synchinfo']['fscod']      = ($ac3_synchinfo_fscod_frmsizecod &amp; 0xC0) &gt;&gt; 6;
+			$thisfile_ac3_raw['synchinfo']['frmsizecod'] = ($ac3_synchinfo_fscod_frmsizecod &amp; 0x3F);
+
+			$thisfile_ac3['sample_rate'] = $this-&gt;AC3sampleRateCodeLookup($thisfile_ac3_raw['synchinfo']['fscod']);
+			if ($thisfile_ac3_raw['synchinfo']['fscod'] &lt;= 3) {
+				$ThisFileInfo['audio']['sample_rate'] = $thisfile_ac3['sample_rate'];
+			}
+
+			$thisfile_ac3['frame_length'] = $this-&gt;AC3frameSizeLookup($thisfile_ac3_raw['synchinfo']['frmsizecod'], $thisfile_ac3_raw['synchinfo']['fscod']);
+			$thisfile_ac3['bitrate']      = $this-&gt;AC3bitrateLookup($thisfile_ac3_raw['synchinfo']['frmsizecod']);
+			$ThisFileInfo['audio']['bitrate'] = $thisfile_ac3['bitrate'];
+
+			$AC3header['bsi'] = getid3_lib::BigEndian2Bin(fread($fd, 15));
+			$ac3_bsi_offset = 0;
+
+			$thisfile_ac3_raw_bsi['bsid'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 5));
+			$ac3_bsi_offset += 5;
+			if ($thisfile_ac3_raw_bsi['bsid'] &gt; 8) {
+				// Decoders which can decode version 8 will thus be able to decode version numbers less than 8.
+				// If this standard is extended by the addition of additional elements or features, a value of bsid greater than 8 will be used.
+				// Decoders built to this version of the standard will not be able to decode versions with bsid greater than 8.
+				$ThisFileInfo['error'][] = 'Bit stream identification is version '.$thisfile_ac3_raw_bsi['bsid'].', but getID3() only understands up to version 8';
+				unset($thisfile_ac3);
+				return false;
+			}
+
+			$thisfile_ac3_raw_bsi['bsmod'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 3));
+			$ac3_bsi_offset += 3;
+			$thisfile_ac3_raw_bsi['acmod'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 3));
+			$ac3_bsi_offset += 3;
+
+			$thisfile_ac3['service_type'] = $this-&gt;AC3serviceTypeLookup($thisfile_ac3_raw_bsi['bsmod'], $thisfile_ac3_raw_bsi['acmod']);
+			$ac3_coding_mode = $this-&gt;AC3audioCodingModeLookup($thisfile_ac3_raw_bsi['acmod']);
+			foreach($ac3_coding_mode as $key =&gt; $value) {
+				$thisfile_ac3[$key] = $value;
+			}
+			switch ($thisfile_ac3_raw_bsi['acmod']) {
+				case 0:
+				case 1:
+					$ThisFileInfo['audio']['channelmode'] = 'mono';
+					break;
+				case 3:
+				case 4:
+					$ThisFileInfo['audio']['channelmode'] = 'stereo';
+					break;
+				default:
+					$ThisFileInfo['audio']['channelmode'] = 'surround';
+					break;
+			}
+			$ThisFileInfo['audio']['channels'] = $thisfile_ac3['num_channels'];
+
+			if ($thisfile_ac3_raw_bsi['acmod'] &amp; 0x01) {
+				// If the lsb of acmod is a 1, center channel is in use and cmixlev follows in the bit stream.
+				$thisfile_ac3_raw_bsi['cmixlev'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 2));
+				$ac3_bsi_offset += 2;
+				$thisfile_ac3['center_mix_level'] = $this-&gt;AC3centerMixLevelLookup($thisfile_ac3_raw_bsi['cmixlev']);
+			}
+
+			if ($thisfile_ac3_raw_bsi['acmod'] &amp; 0x04) {
+				// If the msb of acmod is a 1, surround channels are in use and surmixlev follows in the bit stream.
+				$thisfile_ac3_raw_bsi['surmixlev'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 2));
+				$ac3_bsi_offset += 2;
+				$thisfile_ac3['surround_mix_level'] = $this-&gt;AC3surroundMixLevelLookup($thisfile_ac3_raw_bsi['surmixlev']);
+			}
+
+			if ($thisfile_ac3_raw_bsi['acmod'] == 0x02) {
+				// When operating in the two channel mode, this 2-bit code indicates whether or not the program has been encoded in Dolby Surround.
+				$thisfile_ac3_raw_bsi['dsurmod'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 2));
+				$ac3_bsi_offset += 2;
+				$thisfile_ac3['dolby_surround_mode'] = $this-&gt;AC3dolbySurroundModeLookup($thisfile_ac3_raw_bsi['dsurmod']);
+			}
+
+			$thisfile_ac3_raw_bsi['lfeon'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+			$ac3_bsi_offset += 1;
+			$thisfile_ac3['lfe_enabled'] = $thisfile_ac3_raw_bsi['lfeon'];
+			if ($thisfile_ac3_raw_bsi['lfeon']) {
+				//$ThisFileInfo['audio']['channels']++;
+				$ThisFileInfo['audio']['channels'] .= '.1';
+			}
+
+			$thisfile_ac3['channels_enabled'] = $this-&gt;AC3channelsEnabledLookup($thisfile_ac3_raw_bsi['acmod'], $thisfile_ac3_raw_bsi['lfeon']);
+
+			// This indicates how far the average dialogue level is below digital 100 percent. Valid values are 1&#150;31.
+			// The value of 0 is reserved. The values of 1 to 31 are interpreted as -1 dB to -31 dB with respect to digital 100 percent.
+			$thisfile_ac3_raw_bsi['dialnorm'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 5));
+			$ac3_bsi_offset += 5;
+			$thisfile_ac3['dialogue_normalization'] = '-'.$thisfile_ac3_raw_bsi['dialnorm'].'dB';
+
+			$thisfile_ac3_raw_bsi['compre_flag'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+			$ac3_bsi_offset += 1;
+			if ($thisfile_ac3_raw_bsi['compre_flag']) {
+				$thisfile_ac3_raw_bsi['compr'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 8));
+				$ac3_bsi_offset += 8;
+				$thisfile_ac3['heavy_compression'] = $this-&gt;AC3heavyCompression($thisfile_ac3_raw_bsi['compr']);
+			}
+
+			$thisfile_ac3_raw_bsi['langcode_flag'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+			$ac3_bsi_offset += 1;
+			if ($thisfile_ac3_raw_bsi['langcode_flag']) {
+				$thisfile_ac3_raw_bsi['langcod'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 8));
+				$ac3_bsi_offset += 8;
+			}
+
+			$thisfile_ac3_raw_bsi['audprodie'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+			$ac3_bsi_offset += 1;
+			if ($thisfile_ac3_raw_bsi['audprodie']) {
+				$thisfile_ac3_raw_bsi['mixlevel'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 5));
+				$ac3_bsi_offset += 5;
+				$thisfile_ac3_raw_bsi['roomtyp']  = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 2));
+				$ac3_bsi_offset += 2;
+
+				$thisfile_ac3['mixing_level'] = (80 + $thisfile_ac3_raw_bsi['mixlevel']).'dB';
+				$thisfile_ac3['room_type']    = $this-&gt;AC3roomTypeLookup($thisfile_ac3_raw_bsi['roomtyp']);
+			}
+
+			if ($thisfile_ac3_raw_bsi['acmod'] == 0x00) {
+				// If acmod is 0, then two completely independent program channels (dual mono)
+				// are encoded into the bit stream, and are referenced as Ch1, Ch2. In this case,
+				// a number of additional items are present in BSI or audblk to fully describe Ch2.
+
+
+				// This indicates how far the average dialogue level is below digital 100 percent. Valid values are 1&#150;31.
+				// The value of 0 is reserved. The values of 1 to 31 are interpreted as -1 dB to -31 dB with respect to digital 100 percent.
+				$thisfile_ac3_raw_bsi['dialnorm2'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 5));
+				$ac3_bsi_offset += 5;
+				$thisfile_ac3['dialogue_normalization2'] = '-'.$thisfile_ac3_raw_bsi['dialnorm2'].'dB';
+
+				$thisfile_ac3_raw_bsi['compre_flag2'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+				$ac3_bsi_offset += 1;
+				if ($thisfile_ac3_raw_bsi['compre_flag2']) {
+					$thisfile_ac3_raw_bsi['compr2'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 8));
+					$ac3_bsi_offset += 8;
+					$thisfile_ac3['heavy_compression2'] = $this-&gt;AC3heavyCompression($thisfile_ac3_raw_bsi['compr2']);
+				}
+
+				$thisfile_ac3_raw_bsi['langcode_flag2'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+				$ac3_bsi_offset += 1;
+				if ($thisfile_ac3_raw_bsi['langcode_flag2']) {
+					$thisfile_ac3_raw_bsi['langcod2'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 8));
+					$ac3_bsi_offset += 8;
+				}
+
+				$thisfile_ac3_raw_bsi['audprodie2'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+				$ac3_bsi_offset += 1;
+				if ($thisfile_ac3_raw_bsi['audprodie2']) {
+					$thisfile_ac3_raw_bsi['mixlevel2'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 5));
+					$ac3_bsi_offset += 5;
+					$thisfile_ac3_raw_bsi['roomtyp2']  = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 2));
+					$ac3_bsi_offset += 2;
+
+					$thisfile_ac3['mixing_level2'] = (80 + $thisfile_ac3_raw_bsi['mixlevel2']).'dB';
+					$thisfile_ac3['room_type2']    = $this-&gt;AC3roomTypeLookup($thisfile_ac3_raw_bsi['roomtyp2']);
+				}
+
+			}
+
+			$thisfile_ac3_raw_bsi['copyright'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+			$ac3_bsi_offset += 1;
+
+			$thisfile_ac3_raw_bsi['original']  = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+			$ac3_bsi_offset += 1;
+
+			$thisfile_ac3_raw_bsi['timecode1_flag'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+			$ac3_bsi_offset += 1;
+			if ($thisfile_ac3_raw_bsi['timecode1_flag']) {
+				$thisfile_ac3_raw_bsi['timecode1'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 14));
+				$ac3_bsi_offset += 14;
+			}
+
+			$thisfile_ac3_raw_bsi['timecode2_flag'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+			$ac3_bsi_offset += 1;
+			if ($thisfile_ac3_raw_bsi['timecode2_flag']) {
+				$thisfile_ac3_raw_bsi['timecode2'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 14));
+				$ac3_bsi_offset += 14;
+			}
+
+			$thisfile_ac3_raw_bsi['addbsi_flag'] = (bool) bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 1));
+			$ac3_bsi_offset += 1;
+			if ($thisfile_ac3_raw_bsi['addbsi_flag']) {
+				$thisfile_ac3_raw_bsi['addbsi_length'] = bindec(substr($AC3header['bsi'], $ac3_bsi_offset, 6));
+				$ac3_bsi_offset += 6;
+
+				$AC3header['bsi'] .= getid3_lib::BigEndian2Bin(fread($fd, $thisfile_ac3_raw_bsi['addbsi_length']));
+
+				$thisfile_ac3_raw_bsi['addbsi_data'] = substr($AC3header['bsi'], $ac3_bsi_offset, $thisfile_ac3_raw_bsi['addbsi_length'] * 8);
+				$ac3_bsi_offset += $thisfile_ac3_raw_bsi['addbsi_length'] * 8;
+			}
+
+		}
+
+		return true;
+	}
+
+
+	function AC3sampleRateCodeLookup($fscod) {
+		static $AC3sampleRateCodeLookup = array(
+			0 =&gt; 48000,
+			1 =&gt; 44100,
+			2 =&gt; 32000,
+			3 =&gt; 'reserved' // If the reserved code is indicated, the decoder should not attempt to decode audio and should mute.
+		);
+		return (isset($AC3sampleRateCodeLookup[$fscod]) ? $AC3sampleRateCodeLookup[$fscod] : false);
+	}
+
+	function AC3serviceTypeLookup($bsmod, $acmod) {
+		static $AC3serviceTypeLookup = array();
+		if (empty($AC3serviceTypeLookup)) {
+			for ($i = 0; $i &lt;= 7; $i++) {
+				$AC3serviceTypeLookup[0][$i] = 'main audio service: complete main (CM)';
+				$AC3serviceTypeLookup[1][$i] = 'main audio service: music and effects (ME)';
+				$AC3serviceTypeLookup[2][$i] = 'associated service: visually impaired (VI)';
+				$AC3serviceTypeLookup[3][$i] = 'associated service: hearing impaired (HI)';
+				$AC3serviceTypeLookup[4][$i] = 'associated service: dialogue (D)';
+				$AC3serviceTypeLookup[5][$i] = 'associated service: commentary (C)';
+				$AC3serviceTypeLookup[6][$i] = 'associated service: emergency (E)';
+			}
+
+			$AC3serviceTypeLookup[7][1]      = 'associated service: voice over (VO)';
+			for ($i = 2; $i &lt;= 7; $i++) {
+				$AC3serviceTypeLookup[7][$i] = 'main audio service: karaoke';
+			}
+		}
+		return (isset($AC3serviceTypeLookup[$bsmod][$acmod]) ? $AC3serviceTypeLookup[$bsmod][$acmod] : false);
+	}
+
+	function AC3audioCodingModeLookup($acmod) {
+		static $AC3audioCodingModeLookup = array();
+		if (empty($AC3audioCodingModeLookup)) {
+			// array(channel configuration, # channels (not incl LFE), channel order)
+			$AC3audioCodingModeLookup = array (
+				0 =&gt; array('channel_config'=&gt;'1+1', 'num_channels'=&gt;2, 'channel_order'=&gt;'Ch1,Ch2'),
+				1 =&gt; array('channel_config'=&gt;'1/0', 'num_channels'=&gt;1, 'channel_order'=&gt;'C'),
+				2 =&gt; array('channel_config'=&gt;'2/0', 'num_channels'=&gt;2, 'channel_order'=&gt;'L,R'),
+				3 =&gt; array('channel_config'=&gt;'3/0', 'num_channels'=&gt;3, 'channel_order'=&gt;'L,C,R'),
+				4 =&gt; array('channel_config'=&gt;'2/1', 'num_channels'=&gt;3, 'channel_order'=&gt;'L,R,S'),
+				5 =&gt; array('channel_config'=&gt;'3/1', 'num_channels'=&gt;4, 'channel_order'=&gt;'L,C,R,S'),
+				6 =&gt; array('channel_config'=&gt;'2/2', 'num_channels'=&gt;4, 'channel_order'=&gt;'L,R,SL,SR'),
+				7 =&gt; array('channel_config'=&gt;'3/2', 'num_channels'=&gt;5, 'channel_order'=&gt;'L,C,R,SL,SR')
+			);
+		}
+		return (isset($AC3audioCodingModeLookup[$acmod]) ? $AC3audioCodingModeLookup[$acmod] : false);
+	}
+
+	function AC3centerMixLevelLookup($cmixlev) {
+		static $AC3centerMixLevelLookup;
+		if (empty($AC3centerMixLevelLookup)) {
+			$AC3centerMixLevelLookup = array(
+				0 =&gt; pow(2, -3.0 / 6), // 0.707 (&#150;3.0 dB)
+				1 =&gt; pow(2, -4.5 / 6), // 0.595 (&#150;4.5 dB)
+				2 =&gt; pow(2, -6.0 / 6), // 0.500 (&#150;6.0 dB)
+				3 =&gt; 'reserved'
+			);
+		}
+		return (isset($AC3centerMixLevelLookup[$cmixlev]) ? $AC3centerMixLevelLookup[$cmixlev] : false);
+	}
+
+	function AC3surroundMixLevelLookup($surmixlev) {
+		static $AC3surroundMixLevelLookup;
+		if (empty($AC3surroundMixLevelLookup)) {
+			$AC3surroundMixLevelLookup = array(
+				0 =&gt; pow(2, -3.0 / 6),
+				1 =&gt; pow(2, -6.0 / 6),
+				2 =&gt; 0,
+				3 =&gt; 'reserved'
+			);
+		}
+		return (isset($AC3surroundMixLevelLookup[$surmixlev]) ? $AC3surroundMixLevelLookup[$surmixlev] : false);
+	}
+
+	function AC3dolbySurroundModeLookup($dsurmod) {
+		static $AC3dolbySurroundModeLookup = array(
+			0 =&gt; 'not indicated',
+			1 =&gt; 'Not Dolby Surround encoded',
+			2 =&gt; 'Dolby Surround encoded',
+			3 =&gt; 'reserved'
+		);
+		return (isset($AC3dolbySurroundModeLookup[$dsurmod]) ? $AC3dolbySurroundModeLookup[$dsurmod] : false);
+	}
+
+	function AC3channelsEnabledLookup($acmod, $lfeon) {
+		$AC3channelsEnabledLookup = array(
+			'ch1'=&gt;(bool) ($acmod == 0),
+			'ch2'=&gt;(bool) ($acmod == 0),
+			'left'=&gt;(bool) ($acmod &gt; 1),
+			'right'=&gt;(bool) ($acmod &gt; 1),
+			'center'=&gt;(bool) ($acmod &amp; 0x01),
+			'surround_mono'=&gt;false,
+			'surround_left'=&gt;false,
+			'surround_right'=&gt;false,
+			'lfe'=&gt;$lfeon);
+		switch ($acmod) {
+			case 4:
+			case 5:
+				$AC3channelsEnabledLookup['surround_mono']  = true;
+				break;
+			case 6:
+			case 7:
+				$AC3channelsEnabledLookup['surround_left']  = true;
+				$AC3channelsEnabledLookup['surround_right'] = true;
+				break;
+		}
+		return $AC3channelsEnabledLookup;
+	}
+
+	function AC3heavyCompression($compre) {
+		// The first four bits indicate gain changes in 6.02dB increments which can be
+		// implemented with an arithmetic shift operation. The following four bits
+		// indicate linear gain changes, and require a 5-bit multiply.
+		// We will represent the two 4-bit fields of compr as follows:
+		//   X0 X1 X2 X3 . Y4 Y5 Y6 Y7
+		// The meaning of the X values is most simply described by considering X to represent a 4-bit
+		// signed integer with values from &#150;8 to +7. The gain indicated by X is then (X + 1) * 6.02 dB. The
+		// following table shows this in detail.
+
+		// Meaning of 4 msb of compr
+		//  7    +48.16 dB
+		//  6    +42.14 dB
+		//  5    +36.12 dB
+		//  4    +30.10 dB
+		//  3    +24.08 dB
+		//  2    +18.06 dB
+		//  1    +12.04 dB
+		//  0     +6.02 dB
+		// -1         0 dB
+		// -2     &#150;6.02 dB
+		// -3    &#150;12.04 dB
+		// -4    &#150;18.06 dB
+		// -5    &#150;24.08 dB
+		// -6    &#150;30.10 dB
+		// -7    &#150;36.12 dB
+		// -8    &#150;42.14 dB
+
+		$fourbit = str_pad(decbin(($compre &amp; 0xF0) &gt;&gt; 4), 4, '0', STR_PAD_LEFT);
+		if ($fourbit{0} == '1') {
+			$log_gain = -8 + bindec(substr($fourbit, 1));
+		} else {
+			$log_gain = bindec(substr($fourbit, 1));
+		}
+		$log_gain = ($log_gain + 1) * getid3_lib::RGADamplitude2dB(2);
+
+		// The value of Y is a linear representation of a gain change of up to &#150;6 dB. Y is considered to
+		// be an unsigned fractional integer, with a leading value of 1, or: 0.1 Y4 Y5 Y6 Y7 (base 2). Y can
+		// represent values between 0.111112 (or 31/32) and 0.100002 (or 1/2). Thus, Y can represent gain
+		// changes from &#150;0.28 dB to &#150;6.02 dB.
+
+		$lin_gain = (16 + ($compre &amp; 0x0F)) / 32;
+
+		// The combination of X and Y values allows compr to indicate gain changes from
+		//  48.16 &#150; 0.28 = +47.89 dB, to
+		// &#150;42.14 &#150; 6.02 = &#150;48.16 dB.
+
+		return $log_gain - $lin_gain;
+	}
+
+	function AC3roomTypeLookup($roomtyp) {
+		static $AC3roomTypeLookup = array(
+			0 =&gt; 'not indicated',
+			1 =&gt; 'large room, X curve monitor',
+			2 =&gt; 'small room, flat monitor',
+			3 =&gt; 'reserved'
+		);
+		return (isset($AC3roomTypeLookup[$roomtyp]) ? $AC3roomTypeLookup[$roomtyp] : false);
+	}
+
+	function AC3frameSizeLookup($frmsizecod, $fscod) {
+		$padding     = (bool) ($frmsizecod % 2);
+		$framesizeid =   floor($frmsizecod / 2);
+
+		static $AC3frameSizeLookup = array();
+		if (empty($AC3frameSizeLookup)) {
+			$AC3frameSizeLookup = array (
+				0  =&gt; array(128, 138, 192),
+				1  =&gt; array(40, 160, 174, 240),
+				2  =&gt; array(48, 192, 208, 288),
+				3  =&gt; array(56, 224, 242, 336),
+				4  =&gt; array(64, 256, 278, 384),
+				5  =&gt; array(80, 320, 348, 480),
+				6  =&gt; array(96, 384, 416, 576),
+				7  =&gt; array(112, 448, 486, 672),
+				8  =&gt; array(128, 512, 556, 768),
+				9  =&gt; array(160, 640, 696, 960),
+				10 =&gt; array(192, 768, 834, 1152),
+				11 =&gt; array(224, 896, 974, 1344),
+				12 =&gt; array(256, 1024, 1114, 1536),
+				13 =&gt; array(320, 1280, 1392, 1920),
+				14 =&gt; array(384, 1536, 1670, 2304),
+				15 =&gt; array(448, 1792, 1950, 2688),
+				16 =&gt; array(512, 2048, 2228, 3072),
+				17 =&gt; array(576, 2304, 2506, 3456),
+				18 =&gt; array(640, 2560, 2786, 3840)
+			);
+		}
+		if (($fscod == 1) &amp;&amp; $padding) {
+			// frame lengths are padded by 1 word (16 bits) at 44100
+			$AC3frameSizeLookup[$frmsizecod] += 2;
+		}
+		return (isset($AC3frameSizeLookup[$framesizeid][$fscod]) ? $AC3frameSizeLookup[$framesizeid][$fscod] : false);
+	}
+
+	function AC3bitrateLookup($frmsizecod) {
+		$framesizeid =   floor($frmsizecod / 2);
+
+		static $AC3bitrateLookup = array(
+			0  =&gt; 32000,
+			1  =&gt; 40000,
+			2  =&gt; 48000,
+			3  =&gt; 56000,
+			4  =&gt; 64000,
+			5  =&gt; 80000,
+			6  =&gt; 96000,
+			7  =&gt; 112000,
+			8  =&gt; 128000,
+			9  =&gt; 160000,
+			10 =&gt; 192000,
+			11 =&gt; 224000,
+			12 =&gt; 256000,
+			13 =&gt; 320000,
+			14 =&gt; 384000,
+			15 =&gt; 448000,
+			16 =&gt; 512000,
+			17 =&gt; 576000,
+			18 =&gt; 640000
+		);
+		return (isset($AC3bitrateLookup[$framesizeid]) ? $AC3bitrateLookup[$framesizeid] : false);
+	}
+
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.au.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.au.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.au.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,163 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.au.php                                         //
+// module for analyzing AU files                               //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_au
+{
+
+	function getid3_au(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$AUheader  = fread($fd, 8);
+
+		if (substr($AUheader, 0, 4) != '.snd') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;.snd&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.substr($AUheader, 0, 4).'&quot;';
+			return false;
+		}
+
+		// shortcut
+		$ThisFileInfo['au'] = array();
+		$thisfile_au        = &amp;$ThisFileInfo['au'];
+
+		$ThisFileInfo['fileformat']            = 'au';
+		$ThisFileInfo['audio']['dataformat']   = 'au';
+		$ThisFileInfo['audio']['bitrate_mode'] = 'cbr';
+		$thisfile_au['encoding']               = 'ISO-8859-1';
+
+		$thisfile_au['header_length']   = getid3_lib::BigEndian2Int(substr($AUheader,  4, 4));
+		$AUheader .= fread($fd, $thisfile_au['header_length'] - 8);
+		$ThisFileInfo['avdataoffset'] += $thisfile_au['header_length'];
+
+		$thisfile_au['data_size']             = getid3_lib::BigEndian2Int(substr($AUheader,  8, 4));
+		$thisfile_au['data_format_id']        = getid3_lib::BigEndian2Int(substr($AUheader, 12, 4));
+		$thisfile_au['sample_rate']           = getid3_lib::BigEndian2Int(substr($AUheader, 16, 4));
+		$thisfile_au['channels']              = getid3_lib::BigEndian2Int(substr($AUheader, 20, 4));
+		$thisfile_au['comments']['comment'][] =                      trim(substr($AUheader, 24));
+
+		$thisfile_au['data_format'] = $this-&gt;AUdataFormatNameLookup($thisfile_au['data_format_id']);
+		$thisfile_au['used_bits_per_sample'] = $this-&gt;AUdataFormatUsedBitsPerSampleLookup($thisfile_au['data_format_id']);
+		if ($thisfile_au['bits_per_sample'] = $this-&gt;AUdataFormatBitsPerSampleLookup($thisfile_au['data_format_id'])) {
+			$ThisFileInfo['audio']['bits_per_sample'] = $thisfile_au['bits_per_sample'];
+		} else {
+			unset($thisfile_au['bits_per_sample']);
+		}
+
+		$ThisFileInfo['audio']['sample_rate']  = $thisfile_au['sample_rate'];
+		$ThisFileInfo['audio']['channels']     = $thisfile_au['channels'];
+
+		if (($ThisFileInfo['avdataoffset'] + $thisfile_au['data_size']) &gt; $ThisFileInfo['avdataend']) {
+			$ThisFileInfo['warning'][] = 'Possible truncated file - expecting &quot;'.$thisfile_au['data_size'].'&quot; bytes of audio data, only found '.($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']).' bytes&quot;';
+		}
+
+		$ThisFileInfo['playtime_seconds'] = $thisfile_au['data_size'] / ($thisfile_au['sample_rate'] * $thisfile_au['channels'] * ($thisfile_au['used_bits_per_sample'] / 8));
+		$ThisFileInfo['audio']['bitrate'] = ($thisfile_au['data_size'] * 8) / $ThisFileInfo['playtime_seconds'];
+
+		return true;
+	}
+
+	function AUdataFormatNameLookup($id) {
+		static $AUdataFormatNameLookup = array(
+			0  =&gt; 'unspecified format',
+			1  =&gt; '8-bit mu-law',
+			2  =&gt; '8-bit linear',
+			3  =&gt; '16-bit linear',
+			4  =&gt; '24-bit linear',
+			5  =&gt; '32-bit linear',
+			6  =&gt; 'floating-point',
+			7  =&gt; 'double-precision float',
+			8  =&gt; 'fragmented sampled data',
+			9  =&gt; 'SUN_FORMAT_NESTED',
+			10 =&gt; 'DSP program',
+			11 =&gt; '8-bit fixed-point',
+			12 =&gt; '16-bit fixed-point',
+			13 =&gt; '24-bit fixed-point',
+			14 =&gt; '32-bit fixed-point',
+
+			16 =&gt; 'non-audio display data',
+			17 =&gt; 'SND_FORMAT_MULAW_SQUELCH',
+			18 =&gt; '16-bit linear with emphasis',
+			19 =&gt; '16-bit linear with compression',
+			20 =&gt; '16-bit linear with emphasis + compression',
+			21 =&gt; 'Music Kit DSP commands',
+			22 =&gt; 'SND_FORMAT_DSP_COMMANDS_SAMPLES',
+			23 =&gt; 'CCITT g.721 4-bit ADPCM',
+			24 =&gt; 'CCITT g.722 ADPCM',
+			25 =&gt; 'CCITT g.723 3-bit ADPCM',
+			26 =&gt; 'CCITT g.723 5-bit ADPCM',
+			27 =&gt; 'A-Law 8-bit'
+		);
+		return (isset($AUdataFormatNameLookup[$id]) ? $AUdataFormatNameLookup[$id] : false);
+	}
+
+	function AUdataFormatBitsPerSampleLookup($id) {
+		static $AUdataFormatBitsPerSampleLookup = array(
+			1  =&gt; 8,
+			2  =&gt; 8,
+			3  =&gt; 16,
+			4  =&gt; 24,
+			5  =&gt; 32,
+			6  =&gt; 32,
+			7  =&gt; 64,
+
+			11 =&gt; 8,
+			12 =&gt; 16,
+			13 =&gt; 24,
+			14 =&gt; 32,
+
+			18 =&gt; 16,
+			19 =&gt; 16,
+			20 =&gt; 16,
+
+			23 =&gt; 16,
+
+			25 =&gt; 16,
+			26 =&gt; 16,
+			27 =&gt; 8
+		);
+		return (isset($AUdataFormatBitsPerSampleLookup[$id]) ? $AUdataFormatBitsPerSampleLookup[$id] : false);
+	}
+
+	function AUdataFormatUsedBitsPerSampleLookup($id) {
+		static $AUdataFormatUsedBitsPerSampleLookup = array(
+			1  =&gt; 8,
+			2  =&gt; 8,
+			3  =&gt; 16,
+			4  =&gt; 24,
+			5  =&gt; 32,
+			6  =&gt; 32,
+			7  =&gt; 64,
+
+			11 =&gt; 8,
+			12 =&gt; 16,
+			13 =&gt; 24,
+			14 =&gt; 32,
+
+			18 =&gt; 16,
+			19 =&gt; 16,
+			20 =&gt; 16,
+
+			23 =&gt; 4,
+
+			25 =&gt; 3,
+			26 =&gt; 5,
+			27 =&gt; 8,
+		);
+		return (isset($AUdataFormatUsedBitsPerSampleLookup[$id]) ? $AUdataFormatUsedBitsPerSampleLookup[$id] : false);
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.avr.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.avr.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.avr.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,125 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.avr.php                                        //
+// module for analyzing AVR Audio files                        //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_avr
+{
+
+	function getid3_avr(&amp;$fd, &amp;$ThisFileInfo) {
+
+		// <A HREF="http://cui.unige.ch/OSG/info/AudioFormats/ap11.html">http://cui.unige.ch/OSG/info/AudioFormats/ap11.html</A>
+		// <A HREF="http://www.btinternet.com/~AnthonyJ/Atari/programming/avr_format.html">http://www.btinternet.com/~AnthonyJ/Atari/programming/avr_format.html</A>
+		// offset    type    length    name        comments
+		// ---------------------------------------------------------------------
+		// 0    char    4    ID        format ID == &quot;2BIT&quot;
+		// 4    char    8    name        sample name (unused space filled with 0)
+		// 12    short    1    mono/stereo    0=mono, -1 (0xFFFF)=stereo
+		//                     With stereo, samples are alternated,
+		//                     the first voice is the left :
+		//                     (LRLRLRLRLRLRLRLRLR...)
+		// 14    short    1    resolution    8, 12 or 16 (bits)
+		// 16    short    1    signed or not    0=unsigned, -1 (0xFFFF)=signed
+		// 18    short    1    loop or not    0=no loop, -1 (0xFFFF)=loop on
+		// 20    short    1    MIDI note    0xFFnn, where 0 &lt;= nn &lt;= 127
+		//                     0xFFFF means &quot;no MIDI note defined&quot;
+		// 22    byte    1    Replay speed    Frequence in the Replay software
+		//                     0=5.485 Khz, 1=8.084 Khz, 2=10.971 Khz,
+		//                     3=16.168 Khz, 4=21.942 Khz, 5=32.336 Khz
+		//                     6=43.885 Khz, 7=47.261 Khz
+		//                     -1 (0xFF)=no defined Frequence
+		// 23    byte    3    sample rate    in Hertz
+		// 26    long    1    size in bytes (2 * bytes in stereo)
+		// 30    long    1    loop begin    0 for no loop
+		// 34    long    1    loop size    equal to 'size' for no loop
+		// 38  short   2   Reserved, MIDI keyboard split */
+		// 40  short   2   Reserved, sample compression */
+		// 42  short   2   Reserved */
+		// 44  char   20;  Additional filename space, used if (name[7] != 0)
+		// 64    byte    64    user data
+		// 128    bytes    ?    sample data    (12 bits samples are coded on 16 bits:
+		//                     0000 xxxx xxxx xxxx)
+		// ---------------------------------------------------------------------
+
+		// Note that all values are in motorola (big-endian) format, and that long is
+		// assumed to be 4 bytes, and short 2 bytes.
+		// When reading the samples, you should handle both signed and unsigned data,
+		// and be prepared to convert 16-&gt;8 bit, or mono-&gt;stereo if needed. To convert
+		// 8-bit data between signed/unsigned just add 127 to the sample values.
+		// Simularly for 16-bit data you should add 32769
+
+		$ThisFileInfo['fileformat'] = 'avr';
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$AVRheader = fread($fd, 128);
+
+		$ThisFileInfo['avr']['raw']['magic']    =               substr($AVRheader,  0,  4);
+		if ($ThisFileInfo['avr']['raw']['magic'] != '2BIT') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;2BIT&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$ThisFileInfo['avr']['raw']['magic'].'&quot;';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['avr']);
+			return false;
+		}
+		$ThisFileInfo['avdataoffset'] += 128;
+
+		$ThisFileInfo['avr']['sample_name']        =         rtrim(substr($AVRheader,  4,  8));
+		$ThisFileInfo['avr']['raw']['mono']        = getid3_lib::BigEndian2Int(substr($AVRheader, 12,  2));
+		$ThisFileInfo['avr']['bits_per_sample']    = getid3_lib::BigEndian2Int(substr($AVRheader, 14,  2));
+		$ThisFileInfo['avr']['raw']['signed']      = getid3_lib::BigEndian2Int(substr($AVRheader, 16,  2));
+		$ThisFileInfo['avr']['raw']['loop']        = getid3_lib::BigEndian2Int(substr($AVRheader, 18,  2));
+		$ThisFileInfo['avr']['raw']['midi']        = getid3_lib::BigEndian2Int(substr($AVRheader, 20,  2));
+		$ThisFileInfo['avr']['raw']['replay_freq'] = getid3_lib::BigEndian2Int(substr($AVRheader, 22,  1));
+		$ThisFileInfo['avr']['sample_rate']        = getid3_lib::BigEndian2Int(substr($AVRheader, 23,  3));
+		$ThisFileInfo['avr']['sample_length']      = getid3_lib::BigEndian2Int(substr($AVRheader, 26,  4));
+		$ThisFileInfo['avr']['loop_start']         = getid3_lib::BigEndian2Int(substr($AVRheader, 30,  4));
+		$ThisFileInfo['avr']['loop_end']           = getid3_lib::BigEndian2Int(substr($AVRheader, 34,  4));
+		$ThisFileInfo['avr']['midi_split']         = getid3_lib::BigEndian2Int(substr($AVRheader, 38,  2));
+		$ThisFileInfo['avr']['sample_compression'] = getid3_lib::BigEndian2Int(substr($AVRheader, 40,  2));
+		$ThisFileInfo['avr']['reserved']           = getid3_lib::BigEndian2Int(substr($AVRheader, 42,  2));
+		$ThisFileInfo['avr']['sample_name_extra']  =         rtrim(substr($AVRheader, 44, 20));
+		$ThisFileInfo['avr']['comment']            =         rtrim(substr($AVRheader, 64, 64));
+
+		$ThisFileInfo['avr']['flags']['stereo'] = (($ThisFileInfo['avr']['raw']['mono']   == 0) ? false : true);
+		$ThisFileInfo['avr']['flags']['signed'] = (($ThisFileInfo['avr']['raw']['signed'] == 0) ? false : true);
+		$ThisFileInfo['avr']['flags']['loop']   = (($ThisFileInfo['avr']['raw']['loop']   == 0) ? false : true);
+
+		$ThisFileInfo['avr']['midi_notes'] = array();
+		if (($ThisFileInfo['avr']['raw']['midi'] &amp; 0xFF00) != 0xFF00) {
+			$ThisFileInfo['avr']['midi_notes'][] = ($ThisFileInfo['avr']['raw']['midi'] &amp; 0xFF00) &gt;&gt; 8;
+		}
+		if (($ThisFileInfo['avr']['raw']['midi'] &amp; 0x00FF) != 0x00FF) {
+			$ThisFileInfo['avr']['midi_notes'][] = ($ThisFileInfo['avr']['raw']['midi'] &amp; 0x00FF);
+		}
+
+		if (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) != ($ThisFileInfo['avr']['sample_length'] * (($ThisFileInfo['avr']['bits_per_sample'] == 8) ? 1 : 2))) {
+			$ThisFileInfo['warning'][] = 'Probable truncated file: expecting '.($ThisFileInfo['avr']['sample_length'] * (($ThisFileInfo['avr']['bits_per_sample'] == 8) ? 1 : 2)).' bytes of audio data, found '.($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']);
+		}
+
+		$ThisFileInfo['audio']['dataformat']      = 'avr';
+		$ThisFileInfo['audio']['lossless']        = true;
+		$ThisFileInfo['audio']['bitrate_mode']    = 'cbr';
+		$ThisFileInfo['audio']['bits_per_sample'] = $ThisFileInfo['avr']['bits_per_sample'];
+		$ThisFileInfo['audio']['sample_rate']     = $ThisFileInfo['avr']['sample_rate'];
+		$ThisFileInfo['audio']['channels']        = ($ThisFileInfo['avr']['flags']['stereo'] ? 2 : 1);
+		$ThisFileInfo['playtime_seconds']         = ($ThisFileInfo['avr']['sample_length'] / $ThisFileInfo['audio']['channels']) / $ThisFileInfo['avr']['sample_rate'];
+		$ThisFileInfo['audio']['bitrate']         = ($ThisFileInfo['avr']['sample_length'] * (($ThisFileInfo['avr']['bits_per_sample'] == 8) ? 8 : 16)) / $ThisFileInfo['playtime_seconds'];
+
+
+		return true;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.bonk.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.bonk.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.bonk.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,213 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.la.php                                         //
+// module for analyzing BONK audio files                       //
+// dependencies: module.tag.id3v2.php (optional)               //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_bonk
+{
+	function getid3_bonk(&amp;$fd, &amp;$ThisFileInfo) {
+
+		// shortcut
+		$ThisFileInfo['bonk'] = array();
+		$thisfile_bonk        = &amp;$ThisFileInfo['bonk'];
+
+		$thisfile_bonk['dataoffset']      = $ThisFileInfo['avdataoffset'];
+		$thisfile_bonk['dataend']         = $ThisFileInfo['avdataend'];
+
+		// scan-from-end method, for v0.6 and higher
+		fseek($fd, $thisfile_bonk['dataend'] - 8, SEEK_SET);
+		$PossibleBonkTag = fread($fd, 8);
+		while ($this-&gt;BonkIsValidTagName(substr($PossibleBonkTag, 4, 4), true)) {
+			$BonkTagSize = getid3_lib::LittleEndian2Int(substr($PossibleBonkTag, 0, 4));
+			fseek($fd, 0 - $BonkTagSize, SEEK_CUR);
+			$BonkTagOffset = ftell($fd);
+			$TagHeaderTest = fread($fd, 5);
+			if (($TagHeaderTest{0} != &quot;\x00&quot;) || (substr($PossibleBonkTag, 4, 4) != strtolower(substr($PossibleBonkTag, 4, 4)))) {
+				$ThisFileInfo['error'][] = 'Expecting &quot;&#216;'.strtoupper(substr($PossibleBonkTag, 4, 4)).'&quot; at offset '.$BonkTagOffset.', found &quot;'.$TagHeaderTest.'&quot;';
+				return false;
+			}
+			$BonkTagName = substr($TagHeaderTest, 1, 4);
+
+			$thisfile_bonk[$BonkTagName]['size']   = $BonkTagSize;
+			$thisfile_bonk[$BonkTagName]['offset'] = $BonkTagOffset;
+			$this-&gt;HandleBonkTags($fd, $BonkTagName, $ThisFileInfo);
+			$NextTagEndOffset = $BonkTagOffset - 8;
+			if ($NextTagEndOffset &lt; $thisfile_bonk['dataoffset']) {
+				if (empty($ThisFileInfo['audio']['encoder'])) {
+					$ThisFileInfo['audio']['encoder'] = 'Extended BONK v0.9+';
+				}
+				return true;
+			}
+			fseek($fd, $NextTagEndOffset, SEEK_SET);
+			$PossibleBonkTag = fread($fd, 8);
+		}
+
+		// seek-from-beginning method for v0.4 and v0.5
+		if (empty($thisfile_bonk['BONK'])) {
+			fseek($fd, $thisfile_bonk['dataoffset'], SEEK_SET);
+			do {
+				$TagHeaderTest = fread($fd, 5);
+				switch ($TagHeaderTest) {
+					case &quot;\x00&quot;.'BONK':
+						if (empty($ThisFileInfo['audio']['encoder'])) {
+							$ThisFileInfo['audio']['encoder'] = 'BONK v0.4';
+						}
+						break;
+
+					case &quot;\x00&quot;.'INFO':
+						$ThisFileInfo['audio']['encoder'] = 'Extended BONK v0.5';
+						break;
+
+					default:
+						break 2;
+				}
+				$BonkTagName = substr($TagHeaderTest, 1, 4);
+				$thisfile_bonk[$BonkTagName]['size']   = $thisfile_bonk['dataend'] - $thisfile_bonk['dataoffset'];
+				$thisfile_bonk[$BonkTagName]['offset'] = $thisfile_bonk['dataoffset'];
+				$this-&gt;HandleBonkTags($fd, $BonkTagName, $ThisFileInfo);
+
+			} while (true);
+		}
+
+		// parse META block for v0.6 - v0.8
+		if (empty($thisfile_bonk['INFO']) &amp;&amp; isset($thisfile_bonk['META']['tags']['info'])) {
+			fseek($fd, $thisfile_bonk['META']['tags']['info'], SEEK_SET);
+			$TagHeaderTest = fread($fd, 5);
+			if ($TagHeaderTest == &quot;\x00&quot;.'INFO') {
+				$ThisFileInfo['audio']['encoder'] = 'Extended BONK v0.6 - v0.8';
+
+				$BonkTagName = substr($TagHeaderTest, 1, 4);
+				$thisfile_bonk[$BonkTagName]['size']   = $thisfile_bonk['dataend'] - $thisfile_bonk['dataoffset'];
+				$thisfile_bonk[$BonkTagName]['offset'] = $thisfile_bonk['dataoffset'];
+				$this-&gt;HandleBonkTags($fd, $BonkTagName, $ThisFileInfo);
+			}
+		}
+
+		if (empty($ThisFileInfo['audio']['encoder'])) {
+			$ThisFileInfo['audio']['encoder'] = 'Extended BONK v0.9+';
+		}
+		if (empty($thisfile_bonk['BONK'])) {
+			unset($ThisFileInfo['bonk']);
+		}
+		return true;
+
+	}
+
+	function HandleBonkTags(&amp;$fd, &amp;$BonkTagName, &amp;$ThisFileInfo) {
+
+		switch ($BonkTagName) {
+			case 'BONK':
+				// shortcut
+				$thisfile_bonk_BONK = &amp;$ThisFileInfo['bonk']['BONK'];
+
+				$BonkData = &quot;\x00&quot;.'BONK'.fread($fd, 17);
+				$thisfile_bonk_BONK['version']            =        getid3_lib::LittleEndian2Int(substr($BonkData,  5, 1));
+				$thisfile_bonk_BONK['number_samples']     =        getid3_lib::LittleEndian2Int(substr($BonkData,  6, 4));
+				$thisfile_bonk_BONK['sample_rate']        =        getid3_lib::LittleEndian2Int(substr($BonkData, 10, 4));
+
+				$thisfile_bonk_BONK['channels']           =        getid3_lib::LittleEndian2Int(substr($BonkData, 14, 1));
+				$thisfile_bonk_BONK['lossless']           = (bool) getid3_lib::LittleEndian2Int(substr($BonkData, 15, 1));
+				$thisfile_bonk_BONK['joint_stereo']       = (bool) getid3_lib::LittleEndian2Int(substr($BonkData, 16, 1));
+				$thisfile_bonk_BONK['number_taps']        =        getid3_lib::LittleEndian2Int(substr($BonkData, 17, 2));
+				$thisfile_bonk_BONK['downsampling_ratio'] =        getid3_lib::LittleEndian2Int(substr($BonkData, 19, 1));
+				$thisfile_bonk_BONK['samples_per_packet'] =        getid3_lib::LittleEndian2Int(substr($BonkData, 20, 2));
+
+				$ThisFileInfo['avdataoffset'] = $thisfile_bonk_BONK['offset'] + 5 + 17;
+				$ThisFileInfo['avdataend']    = $thisfile_bonk_BONK['offset'] + $thisfile_bonk_BONK['size'];
+
+				$ThisFileInfo['fileformat']               = 'bonk';
+				$ThisFileInfo['audio']['dataformat']      = 'bonk';
+				$ThisFileInfo['audio']['bitrate_mode']    = 'vbr'; // assumed
+				$ThisFileInfo['audio']['channels']        = $thisfile_bonk_BONK['channels'];
+				$ThisFileInfo['audio']['sample_rate']     = $thisfile_bonk_BONK['sample_rate'];
+				$ThisFileInfo['audio']['channelmode']     = ($thisfile_bonk_BONK['joint_stereo'] ? 'joint stereo' : 'stereo');
+				$ThisFileInfo['audio']['lossless']        = $thisfile_bonk_BONK['lossless'];
+				$ThisFileInfo['audio']['codec']           = 'bonk';
+
+				$ThisFileInfo['playtime_seconds'] = $thisfile_bonk_BONK['number_samples'] / ($thisfile_bonk_BONK['sample_rate'] * $thisfile_bonk_BONK['channels']);
+				if ($ThisFileInfo['playtime_seconds'] &gt; 0) {
+					$ThisFileInfo['audio']['bitrate'] = (($ThisFileInfo['bonk']['dataend'] - $ThisFileInfo['bonk']['dataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+				}
+				break;
+
+			case 'INFO':
+				// shortcut
+				$thisfile_bonk_INFO = &amp;$ThisFileInfo['bonk']['INFO'];
+
+				$thisfile_bonk_INFO['version'] = getid3_lib::LittleEndian2Int(fread($fd, 1));
+				$thisfile_bonk_INFO['entries_count'] = 0;
+				$NextInfoDataPair = fread($fd, 5);
+				if (!$this-&gt;BonkIsValidTagName(substr($NextInfoDataPair, 1, 4))) {
+					while (!feof($fd)) {
+						//$CurrentSeekInfo['offset']  = getid3_lib::LittleEndian2Int(substr($NextInfoDataPair, 0, 4));
+						//$CurrentSeekInfo['nextbit'] = getid3_lib::LittleEndian2Int(substr($NextInfoDataPair, 4, 1));
+						//$thisfile_bonk_INFO[] = $CurrentSeekInfo;
+
+						$NextInfoDataPair = fread($fd, 5);
+						if ($this-&gt;BonkIsValidTagName(substr($NextInfoDataPair, 1, 4))) {
+							fseek($fd, -5, SEEK_CUR);
+							break;
+						}
+						$thisfile_bonk_INFO['entries_count']++;
+					}
+				}
+				break;
+
+			case 'META':
+				$BonkData = &quot;\x00&quot;.'META'.fread($fd, $ThisFileInfo['bonk']['META']['size'] - 5);
+				$ThisFileInfo['bonk']['META']['version'] = getid3_lib::LittleEndian2Int(substr($BonkData,  5, 1));
+
+				$MetaTagEntries = floor(((strlen($BonkData) - 8) - 6) / 8); // BonkData - xxxxmeta - &#216;META
+				$offset = 6;
+				for ($i = 0; $i &lt; $MetaTagEntries; $i++) {
+					$MetaEntryTagName   =                  substr($BonkData, $offset, 4);
+					$offset += 4;
+					$MetaEntryTagOffset = getid3_lib::LittleEndian2Int(substr($BonkData, $offset, 4));
+					$offset += 4;
+					$ThisFileInfo['bonk']['META']['tags'][$MetaEntryTagName] = $MetaEntryTagOffset;
+				}
+				break;
+
+			case ' ID3':
+				$ThisFileInfo['audio']['encoder'] = 'Extended BONK v0.9+';
+
+				// ID3v2 checking is optional
+				if (class_exists('getid3_id3v2')) {
+					$ThisFileInfo['bonk'][' ID3']['valid'] = new getid3_id3v2($fd, $ThisFileInfo, $ThisFileInfo['bonk'][' ID3']['offset'] + 2);
+				}
+				break;
+
+			default:
+				$ThisFileInfo['warning'][] = 'Unexpected Bonk tag &quot;'.$BonkTagName.'&quot; at offset '.$ThisFileInfo['bonk'][$BonkTagName]['offset'];
+				break;
+
+		}
+	}
+
+	function BonkIsValidTagName($PossibleBonkTag, $ignorecase=false) {
+		static $BonkIsValidTagName = array('BONK', 'INFO', ' ID3', 'META');
+		foreach ($BonkIsValidTagName as $validtagname) {
+			if ($validtagname == $PossibleBonkTag) {
+				return true;
+			} elseif ($ignorecase &amp;&amp; (strtolower($validtagname) == strtolower($PossibleBonkTag))) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.flac.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.flac.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.flac.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,309 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.flac.php                                       //
+// module for analyzing FLAC and OggFLAC audio files           //
+// dependencies: module.audio.ogg.php                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.ogg.php', __FILE__, true);
+
+class getid3_flac
+{
+
+	function getid3_flac(&amp;$fd, &amp;$ThisFileInfo) {
+		// <A HREF="http://flac.sourceforge.net/format.html">http://flac.sourceforge.net/format.html</A>
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$StreamMarker = fread($fd, 4);
+		if ($StreamMarker != 'fLaC') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;fLaC&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$StreamMarker.'&quot;';
+			return false;
+		}
+		$ThisFileInfo['fileformat']            = 'flac';
+		$ThisFileInfo['audio']['dataformat']   = 'flac';
+		$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+		$ThisFileInfo['audio']['lossless']     = true;
+
+		return getid3_flac::FLACparseMETAdata($fd, $ThisFileInfo);
+	}
+
+
+	function FLACparseMETAdata(&amp;$fd, &amp;$ThisFileInfo) {
+
+		do {
+			$METAdataBlockOffset          = ftell($fd);
+			$METAdataBlockHeader          = fread($fd, 4);
+			$METAdataLastBlockFlag        = (bool) (getid3_lib::BigEndian2Int(substr($METAdataBlockHeader, 0, 1)) &amp; 0x80);
+			$METAdataBlockType            = getid3_lib::BigEndian2Int(substr($METAdataBlockHeader, 0, 1)) &amp; 0x7F;
+			$METAdataBlockLength          = getid3_lib::BigEndian2Int(substr($METAdataBlockHeader, 1, 3));
+			$METAdataBlockTypeText        = getid3_flac::FLACmetaBlockTypeLookup($METAdataBlockType);
+
+			if ($METAdataBlockLength &lt;= 0) {
+				$ThisFileInfo['error'][] = 'corrupt or invalid METADATA_BLOCK_HEADER.BLOCK_TYPE ('.$METAdataBlockType.') at offset '.$METAdataBlockOffset;
+				break;
+			}
+
+			$ThisFileInfo['flac'][$METAdataBlockTypeText]['raw'] = array();
+			$ThisFileInfo_flac_METAdataBlockTypeText_raw = &amp;$ThisFileInfo['flac'][$METAdataBlockTypeText]['raw'];
+
+			$ThisFileInfo_flac_METAdataBlockTypeText_raw['offset']          = $METAdataBlockOffset;
+			$ThisFileInfo_flac_METAdataBlockTypeText_raw['last_meta_block'] = $METAdataLastBlockFlag;
+			$ThisFileInfo_flac_METAdataBlockTypeText_raw['block_type']      = $METAdataBlockType;
+			$ThisFileInfo_flac_METAdataBlockTypeText_raw['block_type_text'] = $METAdataBlockTypeText;
+			$ThisFileInfo_flac_METAdataBlockTypeText_raw['block_length']    = $METAdataBlockLength;
+			$ThisFileInfo_flac_METAdataBlockTypeText_raw['block_data']      = fread($fd, $METAdataBlockLength);
+			$ThisFileInfo['avdataoffset'] = ftell($fd);
+
+			switch ($METAdataBlockTypeText) {
+
+				case 'STREAMINFO':
+					if (!getid3_flac::FLACparseSTREAMINFO($ThisFileInfo_flac_METAdataBlockTypeText_raw['block_data'], $ThisFileInfo)) {
+						return false;
+					}
+					break;
+
+				case 'PADDING':
+					// ignore
+					break;
+
+				case 'APPLICATION':
+					if (!getid3_flac::FLACparseAPPLICATION($ThisFileInfo_flac_METAdataBlockTypeText_raw['block_data'], $ThisFileInfo)) {
+						return false;
+					}
+					break;
+
+				case 'SEEKTABLE':
+					if (!getid3_flac::FLACparseSEEKTABLE($ThisFileInfo_flac_METAdataBlockTypeText_raw['block_data'], $ThisFileInfo)) {
+						return false;
+					}
+					break;
+
+				case 'VORBIS_COMMENT':
+					$OldOffset = ftell($fd);
+					fseek($fd, 0 - $METAdataBlockLength, SEEK_CUR);
+					getid3_ogg::ParseVorbisCommentsFilepointer($fd, $ThisFileInfo);
+					fseek($fd, $OldOffset, SEEK_SET);
+					break;
+
+				case 'CUESHEET':
+					if (!getid3_flac::FLACparseCUESHEET($ThisFileInfo_flac_METAdataBlockTypeText_raw['block_data'], $ThisFileInfo)) {
+						return false;
+					}
+					break;
+
+				default:
+					$ThisFileInfo['warning'][] = 'Unhandled METADATA_BLOCK_HEADER.BLOCK_TYPE ('.$METAdataBlockType.') at offset '.$METAdataBlockOffset;
+					break;
+			}
+
+		} while ($METAdataLastBlockFlag === false);
+
+
+		if (isset($ThisFileInfo['flac']['STREAMINFO'])) {
+			$ThisFileInfo['flac']['compressed_audio_bytes']   = $ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset'];
+			$ThisFileInfo['flac']['uncompressed_audio_bytes'] = $ThisFileInfo['flac']['STREAMINFO']['samples_stream'] * $ThisFileInfo['flac']['STREAMINFO']['channels'] * ($ThisFileInfo['flac']['STREAMINFO']['bits_per_sample'] / 8);
+			if ($ThisFileInfo['flac']['uncompressed_audio_bytes'] == 0) {
+				$ThisFileInfo['error'][] = 'Corrupt FLAC file: uncompressed_audio_bytes == zero';
+				return false;
+			}
+			$ThisFileInfo['flac']['compression_ratio']        = $ThisFileInfo['flac']['compressed_audio_bytes'] / $ThisFileInfo['flac']['uncompressed_audio_bytes'];
+		}
+
+		// set md5_data_source - built into flac 0.5+
+		if (isset($ThisFileInfo['flac']['STREAMINFO']['audio_signature'])) {
+
+			if ($ThisFileInfo['flac']['STREAMINFO']['audio_signature'] === str_repeat(&quot;\x00&quot;, 16)) {
+
+				$ThisFileInfo['warning'][] = 'FLAC STREAMINFO.audio_signature is null (known issue with libOggFLAC)';
+
+			} else {
+
+				$ThisFileInfo['md5_data_source'] = '';
+				$md5 = $ThisFileInfo['flac']['STREAMINFO']['audio_signature'];
+				for ($i = 0; $i &lt; strlen($md5); $i++) {
+					$ThisFileInfo['md5_data_source'] .= str_pad(dechex(ord($md5{$i})), 2, '00', STR_PAD_LEFT);
+				}
+				if (!preg_match('/^[0-9a-f]{32}$/', $ThisFileInfo['md5_data_source'])) {
+					unset($ThisFileInfo['md5_data_source']);
+				}
+
+			}
+
+		}
+
+		$ThisFileInfo['audio']['bits_per_sample'] = $ThisFileInfo['flac']['STREAMINFO']['bits_per_sample'];
+		if ($ThisFileInfo['audio']['bits_per_sample'] == 8) {
+			// special case
+			// must invert sign bit on all data bytes before MD5'ing to match FLAC's calculated value
+			// MD5sum calculates on unsigned bytes, but FLAC calculated MD5 on 8-bit audio data as signed
+			$ThisFileInfo['warning'][] = 'FLAC calculates MD5 data strangely on 8-bit audio, so the stored md5_data_source value will not match the decoded WAV file';
+		}
+		if (!empty($ThisFileInfo['ogg']['vendor'])) {
+			$ThisFileInfo['audio']['encoder'] = $ThisFileInfo['ogg']['vendor'];
+		}
+
+		return true;
+	}
+
+	function FLACmetaBlockTypeLookup($blocktype) {
+		static $FLACmetaBlockTypeLookup = array();
+		if (empty($FLACmetaBlockTypeLookup)) {
+			$FLACmetaBlockTypeLookup[0] = 'STREAMINFO';
+			$FLACmetaBlockTypeLookup[1] = 'PADDING';
+			$FLACmetaBlockTypeLookup[2] = 'APPLICATION';
+			$FLACmetaBlockTypeLookup[3] = 'SEEKTABLE';
+			$FLACmetaBlockTypeLookup[4] = 'VORBIS_COMMENT';
+			$FLACmetaBlockTypeLookup[5] = 'CUESHEET';
+		}
+		return (isset($FLACmetaBlockTypeLookup[$blocktype]) ? $FLACmetaBlockTypeLookup[$blocktype] : 'reserved');
+	}
+
+	function FLACapplicationIDLookup($applicationid) {
+		static $FLACapplicationIDLookup = array();
+		if (empty($FLACapplicationIDLookup)) {
+			// <A HREF="http://flac.sourceforge.net/id.html">http://flac.sourceforge.net/id.html</A>
+			$FLACapplicationIDLookup[0x46746F6C] = 'flac-tools';      // 'Ftol'
+			$FLACapplicationIDLookup[0x46746F6C] = 'Sound Font FLAC'; // 'SFFL'
+		}
+		return (isset($FLACapplicationIDLookup[$applicationid]) ? $FLACapplicationIDLookup[$applicationid] : 'reserved');
+	}
+
+	function FLACparseSTREAMINFO($METAdataBlockData, &amp;$ThisFileInfo) {
+		$offset = 0;
+		$ThisFileInfo['flac']['STREAMINFO']['min_block_size']  = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 2));
+		$offset += 2;
+		$ThisFileInfo['flac']['STREAMINFO']['max_block_size']  = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 2));
+		$offset += 2;
+		$ThisFileInfo['flac']['STREAMINFO']['min_frame_size']  = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 3));
+		$offset += 3;
+		$ThisFileInfo['flac']['STREAMINFO']['max_frame_size']  = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 3));
+		$offset += 3;
+
+		$SampleRateChannelsSampleBitsStreamSamples             = getid3_lib::BigEndian2Bin(substr($METAdataBlockData, $offset, 8));
+		$ThisFileInfo['flac']['STREAMINFO']['sample_rate']     = getid3_lib::Bin2Dec(substr($SampleRateChannelsSampleBitsStreamSamples,  0, 20));
+		$ThisFileInfo['flac']['STREAMINFO']['channels']        = getid3_lib::Bin2Dec(substr($SampleRateChannelsSampleBitsStreamSamples, 20,  3)) + 1;
+		$ThisFileInfo['flac']['STREAMINFO']['bits_per_sample'] = getid3_lib::Bin2Dec(substr($SampleRateChannelsSampleBitsStreamSamples, 23,  5)) + 1;
+		$ThisFileInfo['flac']['STREAMINFO']['samples_stream']  = getid3_lib::Bin2Dec(substr($SampleRateChannelsSampleBitsStreamSamples, 28, 36));
+		$offset += 8;
+
+		$ThisFileInfo['flac']['STREAMINFO']['audio_signature'] =               substr($METAdataBlockData, $offset, 16);
+		$offset += 16;
+
+		if (!empty($ThisFileInfo['flac']['STREAMINFO']['sample_rate'])) {
+
+			$ThisFileInfo['audio']['bitrate_mode']     = 'vbr';
+			$ThisFileInfo['audio']['sample_rate']      = $ThisFileInfo['flac']['STREAMINFO']['sample_rate'];
+			$ThisFileInfo['audio']['channels']         = $ThisFileInfo['flac']['STREAMINFO']['channels'];
+			$ThisFileInfo['audio']['bits_per_sample']  = $ThisFileInfo['flac']['STREAMINFO']['bits_per_sample'];
+			$ThisFileInfo['playtime_seconds']          = $ThisFileInfo['flac']['STREAMINFO']['samples_stream'] / $ThisFileInfo['flac']['STREAMINFO']['sample_rate'];
+			$ThisFileInfo['audio']['bitrate']          = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+
+		} else {
+
+			$ThisFileInfo['error'][] = 'Corrupt METAdata block: STREAMINFO';
+			return false;
+
+		}
+		return true;
+	}
+
+
+	function FLACparseAPPLICATION($METAdataBlockData, &amp;$ThisFileInfo) {
+		$offset = 0;
+		$ApplicationID = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 4));
+		$offset += 4;
+		$ThisFileInfo['flac']['APPLICATION'][$ApplicationID]['name'] = getid3_flac::FLACapplicationIDLookup($ApplicationID);
+		$ThisFileInfo['flac']['APPLICATION'][$ApplicationID]['data'] = substr($METAdataBlockData, $offset);
+		$offset = $METAdataBlockLength;
+
+		return true;
+	}
+
+
+	function FLACparseSEEKTABLE($METAdataBlockData, &amp;$ThisFileInfo) {
+		$offset = 0;
+		$METAdataBlockLength = strlen($METAdataBlockData);
+		$placeholderpattern = str_repeat(&quot;\xFF&quot;, 8);
+		while ($offset &lt; $METAdataBlockLength) {
+			$SampleNumberString = substr($METAdataBlockData, $offset, 8);
+			$offset += 8;
+			if ($SampleNumberString == $placeholderpattern) {
+
+				// placeholder point
+				@$ThisFileInfo['flac']['SEEKTABLE']['placeholders']++;
+				$offset += 10;
+
+			} else {
+
+				$SampleNumber                                                = getid3_lib::BigEndian2Int($SampleNumberString);
+				$ThisFileInfo['flac']['SEEKTABLE'][$SampleNumber]['offset']  = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 8));
+				$offset += 8;
+				$ThisFileInfo['flac']['SEEKTABLE'][$SampleNumber]['samples'] = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 2));
+				$offset += 2;
+
+			}
+		}
+		return true;
+	}
+
+	function FLACparseCUESHEET($METAdataBlockData, &amp;$ThisFileInfo) {
+		$offset = 0;
+		$ThisFileInfo['flac']['CUESHEET']['media_catalog_number'] =          trim(substr($METAdataBlockData, $offset, 128), &quot;\0&quot;);
+		$offset += 128;
+		$ThisFileInfo['flac']['CUESHEET']['lead_in_samples']      = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 8));
+		$offset += 8;
+		$ThisFileInfo['flac']['CUESHEET']['flags']['is_cd']       = (bool) (getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 1)) &amp; 0x80);
+		$offset += 1;
+
+		$offset += 258; // reserved
+
+		$ThisFileInfo['flac']['CUESHEET']['number_tracks']        = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 1));
+		$offset += 1;
+
+		for ($track = 0; $track &lt; $ThisFileInfo['flac']['CUESHEET']['number_tracks']; $track++) {
+			$TrackSampleOffset = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 8));
+			$offset += 8;
+			$TrackNumber       = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 1));
+			$offset += 1;
+
+			$ThisFileInfo['flac']['CUESHEET']['tracks'][$TrackNumber]['sample_offset']         = $TrackSampleOffset;
+
+			$ThisFileInfo['flac']['CUESHEET']['tracks'][$TrackNumber]['isrc']                  =               substr($METAdataBlockData, $offset, 12);
+			$offset += 12;
+
+			$TrackFlagsRaw                                                                     = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 1));
+			$offset += 1;
+			$ThisFileInfo['flac']['CUESHEET']['tracks'][$TrackNumber]['flags']['is_audio']     = (bool) ($TrackFlagsRaw &amp; 0x80);
+			$ThisFileInfo['flac']['CUESHEET']['tracks'][$TrackNumber]['flags']['pre_emphasis'] = (bool) ($TrackFlagsRaw &amp; 0x40);
+
+			$offset += 13; // reserved
+
+			$ThisFileInfo['flac']['CUESHEET']['tracks'][$TrackNumber]['index_points']          = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 1));
+			$offset += 1;
+
+			for ($index = 0; $index &lt; $ThisFileInfo['flac']['CUESHEET']['tracks'][$TrackNumber]['index_points']; $index++) {
+				$IndexSampleOffset = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 8));
+				$offset += 8;
+				$IndexNumber       = getid3_lib::BigEndian2Int(substr($METAdataBlockData, $offset, 1));
+				$offset += 1;
+
+				$offset += 3; // reserved
+
+				$ThisFileInfo['flac']['CUESHEET']['tracks'][$TrackNumber]['indexes'][$IndexNumber] = $IndexSampleOffset;
+			}
+		}
+		return true;
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.la.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.la.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.la.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,227 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.la.php                                         //
+// module for analyzing LA audio files                         //
+// dependencies: module.audio.riff.php                         //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.riff.php', __FILE__, true);
+
+class getid3_la
+{
+
+	function getid3_la(&amp;$fd, &amp;$ThisFileInfo) {
+		$offset = 0;
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$rawdata = fread($fd, GETID3_FREAD_BUFFER_SIZE);
+
+		switch (substr($rawdata, $offset, 4)) {
+			case 'LA02':
+			case 'LA03':
+			case 'LA04':
+				$ThisFileInfo['fileformat']          = 'la';
+				$ThisFileInfo['audio']['dataformat'] = 'la';
+				$ThisFileInfo['audio']['lossless']   = true;
+
+				$ThisFileInfo['la']['version_major'] = (int) substr($rawdata, $offset + 2, 1);
+				$ThisFileInfo['la']['version_minor'] = (int) substr($rawdata, $offset + 3, 1);
+				$ThisFileInfo['la']['version']       = (float) $ThisFileInfo['la']['version_major'] + ($ThisFileInfo['la']['version_minor'] / 10);
+				$offset += 4;
+
+				$ThisFileInfo['la']['uncompressed_size'] = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 4));
+				$offset += 4;
+				if ($ThisFileInfo['la']['uncompressed_size'] == 0) {
+					$ThisFileInfo['error'][] = 'Corrupt LA file: uncompressed_size == zero';
+					return false;
+				}
+
+				$WAVEchunk = substr($rawdata, $offset, 4);
+				if ($WAVEchunk !== 'WAVE') {
+					$ThisFileInfo['error'][] = 'Expected &quot;WAVE&quot; ('.getid3_lib::PrintHexBytes('WAVE').') at offset '.$offset.', found &quot;'.$WAVEchunk.'&quot; ('.getid3_lib::PrintHexBytes($WAVEchunk).') instead.';
+					return false;
+				}
+				$offset += 4;
+
+				$ThisFileInfo['la']['fmt_size'] = 24;
+				if ($ThisFileInfo['la']['version'] &gt;= 0.3) {
+
+					$ThisFileInfo['la']['fmt_size']    = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 4));
+					$ThisFileInfo['la']['header_size'] = 49 + $ThisFileInfo['la']['fmt_size'] - 24;
+					$offset += 4;
+
+				} else {
+
+					// version 0.2 didn't support additional data blocks
+					$ThisFileInfo['la']['header_size'] = 41;
+
+				}
+
+				$fmt_chunk = substr($rawdata, $offset, 4);
+				if ($fmt_chunk !== 'fmt ') {
+					$ThisFileInfo['error'][] = 'Expected &quot;fmt &quot; ('.getid3_lib::PrintHexBytes('fmt ').') at offset '.$offset.', found &quot;'.$fmt_chunk.'&quot; ('.getid3_lib::PrintHexBytes($fmt_chunk).') instead.';
+					return false;
+				}
+				$offset += 4;
+				$fmt_size = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 4));
+				$offset += 4;
+
+				$ThisFileInfo['la']['raw']['format']  = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 2));
+				$offset += 2;
+
+				$ThisFileInfo['la']['channels']       = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 2));
+				$offset += 2;
+				if ($ThisFileInfo['la']['channels'] == 0) {
+					$ThisFileInfo['error'][] = 'Corrupt LA file: channels == zero';
+						return false;
+				}
+
+				$ThisFileInfo['la']['sample_rate'] = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 4));
+				$offset += 4;
+				if ($ThisFileInfo['la']['sample_rate'] == 0) {
+					$ThisFileInfo['error'][] = 'Corrupt LA file: sample_rate == zero';
+						return false;
+				}
+
+				$ThisFileInfo['la']['bytes_per_second']     = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 4));
+				$offset += 4;
+				$ThisFileInfo['la']['bytes_per_sample']     = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 2));
+				$offset += 2;
+				$ThisFileInfo['la']['bits_per_sample']      = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 2));
+				$offset += 2;
+
+				$ThisFileInfo['la']['samples']              = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 4));
+				$offset += 4;
+
+				$ThisFileInfo['la']['raw']['flags']         = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 1));
+				$offset += 1;
+				$ThisFileInfo['la']['flags']['seekable']             = (bool) ($ThisFileInfo['la']['raw']['flags'] &amp; 0x01);
+				if ($ThisFileInfo['la']['version'] &gt;= 0.4) {
+					$ThisFileInfo['la']['flags']['high_compression'] = (bool) ($ThisFileInfo['la']['raw']['flags'] &amp; 0x02);
+				}
+
+				$ThisFileInfo['la']['original_crc']         = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 4));
+				$offset += 4;
+
+				// mike&#216;bevin*de
+				// Basically, the blocksize/seekevery are 61440/19 in La0.4 and 73728/16
+				// in earlier versions. A seekpoint is added every blocksize * seekevery
+				// samples, so 4 * int(totalSamples / (blockSize * seekEvery)) should
+				// give the number of bytes used for the seekpoints. Of course, if seeking
+				// is disabled, there are no seekpoints stored.
+				if ($ThisFileInfo['la']['version'] &gt;= 0.4) {
+					$ThisFileInfo['la']['blocksize'] = 61440;
+					$ThisFileInfo['la']['seekevery'] = 19;
+				} else {
+					$ThisFileInfo['la']['blocksize'] = 73728;
+					$ThisFileInfo['la']['seekevery'] = 16;
+				}
+
+				$ThisFileInfo['la']['seekpoint_count'] = 0;
+				if ($ThisFileInfo['la']['flags']['seekable']) {
+					$ThisFileInfo['la']['seekpoint_count'] = floor($ThisFileInfo['la']['samples'] / ($ThisFileInfo['la']['blocksize'] * $ThisFileInfo['la']['seekevery']));
+
+					for ($i = 0; $i &lt; $ThisFileInfo['la']['seekpoint_count']; $i++) {
+						$ThisFileInfo['la']['seekpoints'][] = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 4));
+						$offset += 4;
+					}
+				}
+
+				if ($ThisFileInfo['la']['version'] &gt;= 0.3) {
+
+					// Following the main header information, the program outputs all of the
+					// seekpoints. Following these is what I called the 'footer start',
+					// i.e. the position immediately after the La audio data is finished.
+					$ThisFileInfo['la']['footerstart'] = getid3_lib::LittleEndian2Int(substr($rawdata, $offset, 4));
+					$offset += 4;
+
+					if ($ThisFileInfo['la']['footerstart'] &gt; $ThisFileInfo['filesize']) {
+						$ThisFileInfo['warning'][] = 'FooterStart value points to offset '.$ThisFileInfo['la']['footerstart'].' which is beyond end-of-file ('.$ThisFileInfo['filesize'].')';
+						$ThisFileInfo['la']['footerstart'] = $ThisFileInfo['filesize'];
+					}
+
+				} else {
+
+					// La v0.2 didn't have FooterStart value
+					$ThisFileInfo['la']['footerstart'] = $ThisFileInfo['avdataend'];
+
+				}
+
+				if ($ThisFileInfo['la']['footerstart'] &lt; $ThisFileInfo['avdataend']) {
+					if ($RIFFtempfilename = tempnam('*', 'id3')) {
+						if ($RIFF_fp = fopen($RIFFtempfilename, 'w+b')) {
+							$RIFFdata = 'WAVE';
+							if ($ThisFileInfo['la']['version'] == 0.2) {
+								$RIFFdata .= substr($rawdata, 12, 24);
+							} else {
+								$RIFFdata .= substr($rawdata, 16, 24);
+							}
+							if ($ThisFileInfo['la']['footerstart'] &lt; $ThisFileInfo['avdataend']) {
+								fseek($fd, $ThisFileInfo['la']['footerstart'], SEEK_SET);
+								$RIFFdata .= fread($fd, $ThisFileInfo['avdataend'] - $ThisFileInfo['la']['footerstart']);
+							}
+							$RIFFdata = 'RIFF'.getid3_lib::LittleEndian2String(strlen($RIFFdata), 4, false).$RIFFdata;
+							fwrite($RIFF_fp, $RIFFdata, strlen($RIFFdata));
+							$dummy = $ThisFileInfo;
+							$dummy['filesize']     = strlen($RIFFdata);
+							$dummy['avdataoffset'] = 0;
+							$dummy['avdataend']    = $dummy['filesize'];
+
+							$riff = new getid3_riff($RIFF_fp, $dummy);
+							if (empty($dummy['error'])) {
+								$ThisFileInfo['riff'] = $dummy['riff'];
+							} else {
+								$ThisFileInfo['warning'][] = 'Error parsing RIFF portion of La file: '.implode($dummy['error']);
+							}
+							unset($dummy);
+							fclose($RIFF_fp);
+						}
+						unlink($RIFFtempfilename);
+					}
+				}
+
+				// $ThisFileInfo['avdataoffset'] should be zero to begin with, but just in case it's not, include the addition anyway
+				$ThisFileInfo['avdataend']    = $ThisFileInfo['avdataoffset'] + $ThisFileInfo['la']['footerstart'];
+				$ThisFileInfo['avdataoffset'] = $ThisFileInfo['avdataoffset'] + $offset;
+
+				//$ThisFileInfo['la']['codec']                = RIFFwFormatTagLookup($ThisFileInfo['la']['raw']['format']);
+				$ThisFileInfo['la']['compression_ratio']    = (float) (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) / $ThisFileInfo['la']['uncompressed_size']);
+				$ThisFileInfo['playtime_seconds']           = (float) ($ThisFileInfo['la']['samples'] / $ThisFileInfo['la']['sample_rate']) / $ThisFileInfo['la']['channels'];
+				if ($ThisFileInfo['playtime_seconds'] == 0) {
+					$ThisFileInfo['error'][] = 'Corrupt LA file: playtime_seconds == zero';
+					return false;
+				}
+
+				$ThisFileInfo['audio']['bitrate']            = ($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8 / $ThisFileInfo['playtime_seconds'];
+				//$ThisFileInfo['audio']['codec']              = $ThisFileInfo['la']['codec'];
+				$ThisFileInfo['audio']['bits_per_sample']    = $ThisFileInfo['la']['bits_per_sample'];
+				break;
+
+			default:
+				if (substr($rawdata, $offset, 2) == 'LA') {
+					$ThisFileInfo['error'][] = 'This version of getID3() (v'.GETID3_VERSION.') doesn\'t support LA version '.substr($rawdata, $offset + 2, 1).'.'.substr($rawdata, $offset + 3, 1).' which this appears to be - check <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A> for updates.';
+				} else {
+					$ThisFileInfo['error'][] = 'Not a LA (Lossless-Audio) file';
+				}
+				return false;
+				break;
+		}
+
+		$ThisFileInfo['audio']['channels']    = $ThisFileInfo['la']['channels'];
+		$ThisFileInfo['audio']['sample_rate'] = (int) $ThisFileInfo['la']['sample_rate'];
+		$ThisFileInfo['audio']['encoder']     = 'LA v'.$ThisFileInfo['la']['version'];
+
+		return true;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.lpac.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.lpac.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.lpac.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,125 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.lpac.php                                       //
+// module for analyzing LPAC Audio files                       //
+// dependencies: module.audio-video.riff.php                   //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.riff.php', __FILE__, true);
+
+class getid3_lpac
+{
+
+	function getid3_lpac(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$LPACheader = fread($fd, 14);
+		if (substr($LPACheader, 0, 4) != 'LPAC') {
+			$ThisFileInfo['error'][] = 'Expected &quot;LPAC&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$StreamMarker.'&quot;';
+			return false;
+		}
+		$ThisFileInfo['avdataoffset'] += 14;
+
+		$ThisFileInfo['fileformat']            = 'lpac';
+		$ThisFileInfo['audio']['dataformat']   = 'lpac';
+		$ThisFileInfo['audio']['lossless']     = true;
+		$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+
+		$ThisFileInfo['lpac']['file_version'] = getid3_lib::BigEndian2Int(substr($LPACheader,  4, 1));
+		$flags['audio_type']                  = getid3_lib::BigEndian2Int(substr($LPACheader,  5, 1));
+		$ThisFileInfo['lpac']['total_samples']= getid3_lib::BigEndian2Int(substr($LPACheader,  6, 4));
+		$flags['parameters']                  = getid3_lib::BigEndian2Int(substr($LPACheader, 10, 4));
+
+		$ThisFileInfo['lpac']['flags']['is_wave'] = (bool) ($flags['audio_type'] &amp; 0x40);
+		$ThisFileInfo['lpac']['flags']['stereo']  = (bool) ($flags['audio_type'] &amp; 0x04);
+		$ThisFileInfo['lpac']['flags']['24_bit']  = (bool) ($flags['audio_type'] &amp; 0x02);
+		$ThisFileInfo['lpac']['flags']['16_bit']  = (bool) ($flags['audio_type'] &amp; 0x01);
+
+		if ($ThisFileInfo['lpac']['flags']['24_bit'] &amp;&amp; $ThisFileInfo['lpac']['flags']['16_bit']) {
+			$ThisFileInfo['warning'][] = '24-bit and 16-bit flags cannot both be set';
+		}
+
+		$ThisFileInfo['lpac']['flags']['fast_compress']             =  (bool) ($flags['parameters'] &amp; 0x40000000);
+		$ThisFileInfo['lpac']['flags']['random_access']             =  (bool) ($flags['parameters'] &amp; 0x08000000);
+		$ThisFileInfo['lpac']['block_length']                       = pow(2, (($flags['parameters'] &amp; 0x07000000) &gt;&gt; 24)) * 256;
+		$ThisFileInfo['lpac']['flags']['adaptive_prediction_order'] =  (bool) ($flags['parameters'] &amp; 0x00800000);
+		$ThisFileInfo['lpac']['flags']['adaptive_quantization']     =  (bool) ($flags['parameters'] &amp; 0x00400000);
+		$ThisFileInfo['lpac']['flags']['joint_stereo']              =  (bool) ($flags['parameters'] &amp; 0x00040000);
+		$ThisFileInfo['lpac']['quantization']                       =         ($flags['parameters'] &amp; 0x00001F00) &gt;&gt; 8;
+		$ThisFileInfo['lpac']['max_prediction_order']               =         ($flags['parameters'] &amp; 0x0000003F);
+
+		if ($ThisFileInfo['lpac']['flags']['fast_compress'] &amp;&amp; ($ThisFileInfo['lpac']['max_prediction_order'] != 3)) {
+			$ThisFileInfo['warning'][] = 'max_prediction_order expected to be &quot;3&quot; if fast_compress is true, actual value is &quot;'.$ThisFileInfo['lpac']['max_prediction_order'].'&quot;';
+		}
+		switch ($ThisFileInfo['lpac']['file_version']) {
+			case 6:
+				if ($ThisFileInfo['lpac']['flags']['adaptive_quantization']) {
+					$ThisFileInfo['warning'][] = 'adaptive_quantization expected to be false in LPAC file stucture v6, actually true';
+				}
+				if ($ThisFileInfo['lpac']['quantization'] != 20) {
+					$ThisFileInfo['warning'][] = 'Quantization expected to be 20 in LPAC file stucture v6, actually '.$ThisFileInfo['lpac']['flags']['Q'];
+				}
+				break;
+
+			default:
+				//$ThisFileInfo['warning'][] = 'This version of getID3() only supports LPAC file format version 6, this file is version '.$ThisFileInfo['lpac']['file_version'].' - please report to <A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>';
+				break;
+		}
+
+		$dummy = $ThisFileInfo;
+		$riff = new getid3_riff($fd, $dummy);
+		$ThisFileInfo['avdataoffset']                = $dummy['avdataoffset'];
+		$ThisFileInfo['riff']                        = $dummy['riff'];
+		$ThisFileInfo['error']                       = $dummy['error'];
+		$ThisFileInfo['warning']                     = $dummy['warning'];
+		$ThisFileInfo['lpac']['comments']['comment'] = $dummy['comments'];
+		$ThisFileInfo['audio']['sample_rate']        = $dummy['audio']['sample_rate'];
+
+		$ThisFileInfo['audio']['channels']    = ($ThisFileInfo['lpac']['flags']['stereo'] ? 2 : 1);
+
+		if ($ThisFileInfo['lpac']['flags']['24_bit']) {
+			$ThisFileInfo['audio']['bits_per_sample'] = $ThisFileInfo['riff']['audio'][0]['bits_per_sample'];
+		} elseif ($ThisFileInfo['lpac']['flags']['16_bit']) {
+			$ThisFileInfo['audio']['bits_per_sample'] = 16;
+		} else {
+			$ThisFileInfo['audio']['bits_per_sample'] = 8;
+		}
+
+		if ($ThisFileInfo['lpac']['flags']['fast_compress']) {
+			 // fast
+			$ThisFileInfo['audio']['encoder_options'] = '-1';
+		} else {
+			switch ($ThisFileInfo['lpac']['max_prediction_order']) {
+				case 20: // simple
+					$ThisFileInfo['audio']['encoder_options'] = '-2';
+					break;
+				case 30: // medium
+					$ThisFileInfo['audio']['encoder_options'] = '-3';
+					break;
+				case 40: // high
+					$ThisFileInfo['audio']['encoder_options'] = '-4';
+					break;
+				case 60: // extrahigh
+					$ThisFileInfo['audio']['encoder_options'] = '-5';
+					break;
+			}
+		}
+
+		$ThisFileInfo['playtime_seconds'] = $ThisFileInfo['lpac']['total_samples'] / $ThisFileInfo['audio']['sample_rate'];
+		$ThisFileInfo['audio']['bitrate'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+
+		return true;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.midi.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.midi.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.midi.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,520 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.midi.php                                       //
+// module for Midi Audio files                                 //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_midi
+{
+
+	function getid3_midi(&amp;$fd, &amp;$ThisFileInfo, $scanwholefile=true) {
+
+		// shortcut
+		$ThisFileInfo['midi']['raw'] = array();
+		$thisfile_midi               = &amp;$ThisFileInfo['midi'];
+		$thisfile_midi_raw           = &amp;$thisfile_midi['raw'];
+
+		$ThisFileInfo['fileformat']          = 'midi';
+		$ThisFileInfo['audio']['dataformat'] = 'midi';
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$MIDIdata = fread($fd, GETID3_FREAD_BUFFER_SIZE);
+		$offset = 0;
+		$MIDIheaderID = substr($MIDIdata, $offset, 4); // 'MThd'
+		if ($MIDIheaderID != 'MThd') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;MThd&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$MIDIheaderID.'&quot;';
+			unset($ThisFileInfo['fileformat']);
+			return false;
+		}
+		$offset += 4;
+		$thisfile_midi_raw['headersize']    = getid3_lib::BigEndian2Int(substr($MIDIdata, $offset, 4));
+		$offset += 4;
+		$thisfile_midi_raw['fileformat']    = getid3_lib::BigEndian2Int(substr($MIDIdata, $offset, 2));
+		$offset += 2;
+		$thisfile_midi_raw['tracks']        = getid3_lib::BigEndian2Int(substr($MIDIdata, $offset, 2));
+		$offset += 2;
+		$thisfile_midi_raw['ticksperqnote'] = getid3_lib::BigEndian2Int(substr($MIDIdata, $offset, 2));
+		$offset += 2;
+
+		for ($i = 0; $i &lt; $thisfile_midi_raw['tracks']; $i++) {
+			if ((strlen($MIDIdata) - $offset) &lt; 8) {
+				$MIDIdata .= fread($fd, GETID3_FREAD_BUFFER_SIZE);
+			}
+			$trackID = substr($MIDIdata, $offset, 4);
+			$offset += 4;
+			if ($trackID == 'MTrk') {
+				$tracksize = getid3_lib::BigEndian2Int(substr($MIDIdata, $offset, 4));
+				$offset += 4;
+				// $thisfile_midi['tracks'][$i]['size'] = $tracksize;
+				$trackdataarray[$i] = substr($MIDIdata, $offset, $tracksize);
+				$offset += $tracksize;
+			} else {
+				$ThisFileInfo['error'][] = 'Expecting &quot;MTrk&quot; at '.$offset.', found '.$trackID.' instead';
+				return false;
+			}
+		}
+
+		if (!isset($trackdataarray) || !is_array($trackdataarray)) {
+			$ThisFileInfo['error'][] = 'Cannot find MIDI track information';
+			unset($thisfile_midi);
+			unset($ThisFileInfo['fileformat']);
+			return false;
+		}
+
+		if ($scanwholefile) { // this can take quite a long time, so have the option to bypass it if speed is very important
+			$thisfile_midi['totalticks']      = 0;
+			$ThisFileInfo['playtime_seconds'] = 0;
+			$CurrentMicroSecondsPerBeat       = 500000; // 120 beats per minute;  60,000,000 microseconds per minute -&gt; 500,000 microseconds per beat
+			$CurrentBeatsPerMinute            = 120;    // 120 beats per minute;  60,000,000 microseconds per minute -&gt; 500,000 microseconds per beat
+
+			foreach ($trackdataarray as $tracknumber =&gt; $trackdata) {
+
+				$eventsoffset               = 0;
+				$LastIssuedMIDIcommand      = 0;
+				$LastIssuedMIDIchannel      = 0;
+				$CumulativeDeltaTime        = 0;
+				$TicksAtCurrentBPM = 0;
+				while ($eventsoffset &lt; strlen($trackdata)) {
+					$eventid = 0;
+					if (isset($MIDIevents[$tracknumber]) &amp;&amp; is_array($MIDIevents[$tracknumber])) {
+						$eventid = count($MIDIevents[$tracknumber]);
+					}
+					$deltatime = 0;
+					for ($i = 0; $i &lt; 4; $i++) {
+						$deltatimebyte = ord(substr($trackdata, $eventsoffset++, 1));
+						$deltatime = ($deltatime &lt;&lt; 7) + ($deltatimebyte &amp; 0x7F);
+						if ($deltatimebyte &amp; 0x80) {
+							// another byte follows
+						} else {
+							break;
+						}
+					}
+					$CumulativeDeltaTime += $deltatime;
+					$TicksAtCurrentBPM   += $deltatime;
+					$MIDIevents[$tracknumber][$eventid]['deltatime'] = $deltatime;
+					$MIDI_event_channel                                  = ord(substr($trackdata, $eventsoffset++, 1));
+					if ($MIDI_event_channel &amp; 0x80) {
+						// OK, normal event - MIDI command has MSB set
+						$LastIssuedMIDIcommand = $MIDI_event_channel &gt;&gt; 4;
+						$LastIssuedMIDIchannel = $MIDI_event_channel &amp; 0x0F;
+					} else {
+						// running event - assume last command
+						$eventsoffset--;
+					}
+					$MIDIevents[$tracknumber][$eventid]['eventid']   = $LastIssuedMIDIcommand;
+					$MIDIevents[$tracknumber][$eventid]['channel']   = $LastIssuedMIDIchannel;
+					if ($MIDIevents[$tracknumber][$eventid]['eventid'] == 0x08) { // Note off (key is released)
+
+						$notenumber = ord(substr($trackdata, $eventsoffset++, 1));
+						$velocity   = ord(substr($trackdata, $eventsoffset++, 1));
+
+					} elseif ($MIDIevents[$tracknumber][$eventid]['eventid'] == 0x09) { // Note on (key is pressed)
+
+						$notenumber = ord(substr($trackdata, $eventsoffset++, 1));
+						$velocity   = ord(substr($trackdata, $eventsoffset++, 1));
+
+					} elseif ($MIDIevents[$tracknumber][$eventid]['eventid'] == 0x0A) { // Key after-touch
+
+						$notenumber = ord(substr($trackdata, $eventsoffset++, 1));
+						$velocity   = ord(substr($trackdata, $eventsoffset++, 1));
+
+					} elseif ($MIDIevents[$tracknumber][$eventid]['eventid'] == 0x0B) { // Control Change
+
+						$controllernum = ord(substr($trackdata, $eventsoffset++, 1));
+						$newvalue      = ord(substr($trackdata, $eventsoffset++, 1));
+
+					} elseif ($MIDIevents[$tracknumber][$eventid]['eventid'] == 0x0C) { // Program (patch) change
+
+						$newprogramnum = ord(substr($trackdata, $eventsoffset++, 1));
+
+						$thisfile_midi_raw['track'][$tracknumber]['instrumentid'] = $newprogramnum;
+						if ($tracknumber == 10) {
+							$thisfile_midi_raw['track'][$tracknumber]['instrument'] = $this-&gt;GeneralMIDIpercussionLookup($newprogramnum);
+						} else {
+							$thisfile_midi_raw['track'][$tracknumber]['instrument'] = $this-&gt;GeneralMIDIinstrumentLookup($newprogramnum);
+						}
+
+					} elseif ($MIDIevents[$tracknumber][$eventid]['eventid'] == 0x0D) { // Channel after-touch
+
+						$channelnumber = ord(substr($trackdata, $eventsoffset++, 1));
+
+					} elseif ($MIDIevents[$tracknumber][$eventid]['eventid'] == 0x0E) { // Pitch wheel change (2000H is normal or no change)
+
+						$changeLSB = ord(substr($trackdata, $eventsoffset++, 1));
+						$changeMSB = ord(substr($trackdata, $eventsoffset++, 1));
+						$pitchwheelchange = (($changeMSB &amp; 0x7F) &lt;&lt; 7) &amp; ($changeLSB &amp; 0x7F);
+
+					} elseif (($MIDIevents[$tracknumber][$eventid]['eventid'] == 0x0F) &amp;&amp; ($MIDIevents[$tracknumber][$eventid]['channel'] == 0x0F)) {
+
+						$METAeventCommand = ord(substr($trackdata, $eventsoffset++, 1));
+						$METAeventLength  = ord(substr($trackdata, $eventsoffset++, 1));
+						$METAeventData    = substr($trackdata, $eventsoffset, $METAeventLength);
+						$eventsoffset += $METAeventLength;
+						switch ($METAeventCommand) {
+							case 0x00: // Set track sequence number
+								$track_sequence_number = getid3_lib::BigEndian2Int(substr($METAeventData, 0, $METAeventLength));
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['seqno'] = $track_sequence_number;
+								break;
+
+							case 0x01: // Text: generic
+								$text_generic = substr($METAeventData, 0, $METAeventLength);
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['text'] = $text_generic;
+								$thisfile_midi['comments']['comment'][] = $text_generic;
+								break;
+
+							case 0x02: // Text: copyright
+								$text_copyright = substr($METAeventData, 0, $METAeventLength);
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['copyright'] = $text_copyright;
+								$thisfile_midi['comments']['copyright'][] = $text_copyright;
+								break;
+
+							case 0x03: // Text: track name
+								$text_trackname = substr($METAeventData, 0, $METAeventLength);
+								$thisfile_midi_raw['track'][$tracknumber]['name'] = $text_trackname;
+								break;
+
+							case 0x04: // Text: track instrument name
+								$text_instrument = substr($METAeventData, 0, $METAeventLength);
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['instrument'] = $text_instrument;
+								break;
+
+							case 0x05: // Text: lyrics
+								$text_lyrics  = substr($METAeventData, 0, $METAeventLength);
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['lyrics'] = $text_lyrics;
+								if (!isset($thisfile_midi['lyrics'])) {
+									$thisfile_midi['lyrics'] = '';
+								}
+								$thisfile_midi['lyrics'] .= $text_lyrics.&quot;\n&quot;;
+								break;
+
+							case 0x06: // Text: marker
+								$text_marker = substr($METAeventData, 0, $METAeventLength);
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['marker'] = $text_marker;
+								break;
+
+							case 0x07: // Text: cue point
+								$text_cuepoint = substr($METAeventData, 0, $METAeventLength);
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['cuepoint'] = $text_cuepoint;
+								break;
+
+							case 0x2F: // End Of Track
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['EOT'] = $CumulativeDeltaTime;
+								break;
+
+							case 0x51: // Tempo: microseconds / quarter note
+								$CurrentMicroSecondsPerBeat = getid3_lib::BigEndian2Int(substr($METAeventData, 0, $METAeventLength));
+								if ($CurrentMicroSecondsPerBeat == 0) {
+									$ThisFileInfo['error'][] = 'Corrupt MIDI file: CurrentMicroSecondsPerBeat == zero';
+									return false;
+								}
+								$thisfile_midi_raw['events'][$tracknumber][$CumulativeDeltaTime]['us_qnote'] = $CurrentMicroSecondsPerBeat;
+								$CurrentBeatsPerMinute = (1000000 / $CurrentMicroSecondsPerBeat) * 60;
+								$MicroSecondsPerQuarterNoteAfter[$CumulativeDeltaTime] = $CurrentMicroSecondsPerBeat;
+								$TicksAtCurrentBPM = 0;
+								break;
+
+							case 0x58: // Time signature
+								$timesig_numerator   = getid3_lib::BigEndian2Int($METAeventData{0});
+								$timesig_denominator = pow(2, getid3_lib::BigEndian2Int($METAeventData{1})); // $02 -&gt; x/4, $03 -&gt; x/8, etc
+								$timesig_32inqnote   = getid3_lib::BigEndian2Int($METAeventData{2});         // number of 32nd notes to the quarter note
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['timesig_32inqnote']   = $timesig_32inqnote;
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['timesig_numerator']   = $timesig_numerator;
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['timesig_denominator'] = $timesig_denominator;
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['timesig_text']        = $timesig_numerator.'/'.$timesig_denominator;
+								$thisfile_midi['timesignature'][] = $timesig_numerator.'/'.$timesig_denominator;
+								break;
+
+							case 0x59: // Keysignature
+								$keysig_sharpsflats = getid3_lib::BigEndian2Int($METAeventData{0});
+								if ($keysig_sharpsflats &amp; 0x80) {
+									// (-7 -&gt; 7 flats, 0 -&gt;key of C, 7 -&gt; 7 sharps)
+									$keysig_sharpsflats -= 256;
+								}
+
+								$keysig_majorminor  = getid3_lib::BigEndian2Int($METAeventData{1}); // 0 -&gt; major, 1 -&gt; minor
+								$keysigs = array(-7=&gt;'Cb', -6=&gt;'Gb', -5=&gt;'Db', -4=&gt;'Ab', -3=&gt;'Eb', -2=&gt;'Bb', -1=&gt;'F', 0=&gt;'C', 1=&gt;'G', 2=&gt;'D', 3=&gt;'A', 4=&gt;'E', 5=&gt;'B', 6=&gt;'F#', 7=&gt;'C#');
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['keysig_sharps'] = (($keysig_sharpsflats &gt; 0) ? abs($keysig_sharpsflats) : 0);
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['keysig_flats']  = (($keysig_sharpsflats &lt; 0) ? abs($keysig_sharpsflats) : 0);
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['keysig_minor']  = (bool) $keysig_majorminor;
+								//$thisfile_midi_raw['events'][$tracknumber][$eventid]['keysig_text']   = $keysigs[$keysig_sharpsflats].' '.($thisfile_midi_raw['events'][$tracknumber][$eventid]['keysig_minor'] ? 'minor' : 'major');
+
+								// $keysigs[$keysig_sharpsflats] gets an int key (correct) - $keysigs[&quot;$keysig_sharpsflats&quot;] gets a string key (incorrect)
+								$thisfile_midi['keysignature'][] = $keysigs[$keysig_sharpsflats].' '.((bool) $keysig_majorminor ? 'minor' : 'major');
+								break;
+
+							case 0x7F: // Sequencer specific information
+								$custom_data = substr($METAeventData, 0, $METAeventLength);
+								break;
+
+							default:
+								$ThisFileInfo['warning'][] = 'Unhandled META Event Command: '.$METAeventCommand;
+								break;
+						}
+
+					} else {
+
+						$ThisFileInfo['warning'][] = 'Unhandled MIDI Event ID: '.$MIDIevents[$tracknumber][$eventid]['eventid'].' + Channel ID: '.$MIDIevents[$tracknumber][$eventid]['channel'];
+
+					}
+				}
+				if (($tracknumber &gt; 0) || (count($trackdataarray) == 1)) {
+					$thisfile_midi['totalticks'] = max($thisfile_midi['totalticks'], $CumulativeDeltaTime);
+				}
+			}
+			$previoustickoffset = null;
+
+			ksort($MicroSecondsPerQuarterNoteAfter);
+			foreach ($MicroSecondsPerQuarterNoteAfter as $tickoffset =&gt; $microsecondsperbeat) {
+				if (is_null($previoustickoffset)) {
+					$prevmicrosecondsperbeat = $microsecondsperbeat;
+					$previoustickoffset = $tickoffset;
+					continue;
+				}
+				if ($thisfile_midi['totalticks'] &gt; $tickoffset) {
+
+					if ($thisfile_midi_raw['ticksperqnote'] == 0) {
+						$ThisFileInfo['error'][] = 'Corrupt MIDI file: ticksperqnote == zero';
+						return false;
+					}
+
+					$ThisFileInfo['playtime_seconds'] += (($tickoffset - $previoustickoffset) / $thisfile_midi_raw['ticksperqnote']) * ($prevmicrosecondsperbeat / 1000000);
+
+					$prevmicrosecondsperbeat = $microsecondsperbeat;
+					$previoustickoffset = $tickoffset;
+				}
+			}
+			if ($thisfile_midi['totalticks'] &gt; $previoustickoffset) {
+
+				if ($thisfile_midi_raw['ticksperqnote'] == 0) {
+					$ThisFileInfo['error'][] = 'Corrupt MIDI file: ticksperqnote == zero';
+					return false;
+				}
+
+				$ThisFileInfo['playtime_seconds'] += (($thisfile_midi['totalticks'] - $previoustickoffset) / $thisfile_midi_raw['ticksperqnote']) * ($microsecondsperbeat / 1000000);
+
+			}
+		}
+
+		if ($ThisFileInfo['playtime_seconds'] &gt; 0) {
+			$ThisFileInfo['bitrate'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+		}
+
+		if (!empty($thisfile_midi['lyrics'])) {
+			$thisfile_midi['comments']['lyrics'][] = $thisfile_midi['lyrics'];
+		}
+
+		return true;
+	}
+
+	function GeneralMIDIinstrumentLookup($instrumentid) {
+
+		$begin = __LINE__;
+
+		/** This is not a comment!
+
+			0	Acoustic Grand
+			1	Bright Acoustic
+			2	Electric Grand
+			3	Honky-Tonk
+			4	Electric Piano 1
+			5	Electric Piano 2
+			6	Harpsichord
+			7	Clavier
+			8	Celesta
+			9	Glockenspiel
+			10	Music Box
+			11	Vibraphone
+			12	Marimba
+			13	Xylophone
+			14	Tubular Bells
+			15	Dulcimer
+			16	Drawbar Organ
+			17	Percussive Organ
+			18	Rock Organ
+			19	Church Organ
+			20	Reed Organ
+			21	Accordian
+			22	Harmonica
+			23	Tango Accordian
+			24	Acoustic Guitar (nylon)
+			25	Acoustic Guitar (steel)
+			26	Electric Guitar (jazz)
+			27	Electric Guitar (clean)
+			28	Electric Guitar (muted)
+			29	Overdriven Guitar
+			30	Distortion Guitar
+			31	Guitar Harmonics
+			32	Acoustic Bass
+			33	Electric Bass (finger)
+			34	Electric Bass (pick)
+			35	Fretless Bass
+			36	Slap Bass 1
+			37	Slap Bass 2
+			38	Synth Bass 1
+			39	Synth Bass 2
+			40	Violin
+			41	Viola
+			42	Cello
+			43	Contrabass
+			44	Tremolo Strings
+			45	Pizzicato Strings
+			46	Orchestral Strings
+			47	Timpani
+			48	String Ensemble 1
+			49	String Ensemble 2
+			50	SynthStrings 1
+			51	SynthStrings 2
+			52	Choir Aahs
+			53	Voice Oohs
+			54	Synth Voice
+			55	Orchestra Hit
+			56	Trumpet
+			57	Trombone
+			58	Tuba
+			59	Muted Trumpet
+			60	French Horn
+			61	Brass Section
+			62	SynthBrass 1
+			63	SynthBrass 2
+			64	Soprano Sax
+			65	Alto Sax
+			66	Tenor Sax
+			67	Baritone Sax
+			68	Oboe
+			69	English Horn
+			70	Bassoon
+			71	Clarinet
+			72	Piccolo
+			73	Flute
+			74	Recorder
+			75	Pan Flute
+			76	Blown Bottle
+			77	Shakuhachi
+			78	Whistle
+			79	Ocarina
+			80	Lead 1 (square)
+			81	Lead 2 (sawtooth)
+			82	Lead 3 (calliope)
+			83	Lead 4 (chiff)
+			84	Lead 5 (charang)
+			85	Lead 6 (voice)
+			86	Lead 7 (fifths)
+			87	Lead 8 (bass + lead)
+			88	Pad 1 (new age)
+			89	Pad 2 (warm)
+			90	Pad 3 (polysynth)
+			91	Pad 4 (choir)
+			92	Pad 5 (bowed)
+			93	Pad 6 (metallic)
+			94	Pad 7 (halo)
+			95	Pad 8 (sweep)
+			96	FX 1 (rain)
+			97	FX 2 (soundtrack)
+			98	FX 3 (crystal)
+			99	FX 4 (atmosphere)
+			100	FX 5 (brightness)
+			101	FX 6 (goblins)
+			102	FX 7 (echoes)
+			103	FX 8 (sci-fi)
+			104	Sitar
+			105	Banjo
+			106	Shamisen
+			107	Koto
+			108	Kalimba
+			109	Bagpipe
+			110	Fiddle
+			111	Shanai
+			112	Tinkle Bell
+			113	Agogo
+			114	Steel Drums
+			115	Woodblock
+			116	Taiko Drum
+			117	Melodic Tom
+			118	Synth Drum
+			119	Reverse Cymbal
+			120	Guitar Fret Noise
+			121	Breath Noise
+			122	Seashore
+			123	Bird Tweet
+			124	Telephone Ring
+			125	Helicopter
+			126	Applause
+			127	Gunshot
+
+		*/
+
+		return getid3_lib::EmbeddedLookup($instrumentid, $begin, __LINE__, __FILE__, 'GeneralMIDIinstrument');
+	}
+
+	function GeneralMIDIpercussionLookup($instrumentid) {
+
+		$begin = __LINE__;
+
+		/** This is not a comment!
+
+			35	Acoustic Bass Drum
+			36	Bass Drum 1
+			37	Side Stick
+			38	Acoustic Snare
+			39	Hand Clap
+			40	Electric Snare
+			41	Low Floor Tom
+			42	Closed Hi-Hat
+			43	High Floor Tom
+			44	Pedal Hi-Hat
+			45	Low Tom
+			46	Open Hi-Hat
+			47	Low-Mid Tom
+			48	Hi-Mid Tom
+			49	Crash Cymbal 1
+			50	High Tom
+			51	Ride Cymbal 1
+			52	Chinese Cymbal
+			53	Ride Bell
+			54	Tambourine
+			55	Splash Cymbal
+			56	Cowbell
+			57	Crash Cymbal 2
+			59	Ride Cymbal 2
+			60	Hi Bongo
+			61	Low Bongo
+			62	Mute Hi Conga
+			63	Open Hi Conga
+			64	Low Conga
+			65	High Timbale
+			66	Low Timbale
+			67	High Agogo
+			68	Low Agogo
+			69	Cabasa
+			70	Maracas
+			71	Short Whistle
+			72	Long Whistle
+			73	Short Guiro
+			74	Long Guiro
+			75	Claves
+			76	Hi Wood Block
+			77	Low Wood Block
+			78	Mute Cuica
+			79	Open Cuica
+			80	Mute Triangle
+			81	Open Triangle
+
+		*/
+
+		return getid3_lib::EmbeddedLookup($instrumentid, $begin, __LINE__, __FILE__, 'GeneralMIDIpercussion');
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mod.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mod.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mod.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,101 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.mod.php                                        //
+// module for analyzing MOD Audio files                        //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_mod
+{
+
+	// new combined constructor
+	function getid3_mod(&amp;$fd, &amp;$ThisFileInfo, $option) {
+
+		if ($option === 'mod') {
+			$this-&gt;getMODheaderFilepointer($fd, $ThisFileInfo);
+		}
+		elseif ($option === 'xm') {
+			$this-&gt;getXMheaderFilepointer($fd, $ThisFileInfo);
+		}
+		elseif ($option === 'it') {
+			$this-&gt;getITheaderFilepointer($fd, $ThisFileInfo);
+		}
+		elseif ($option === 's3m') {
+			$this-&gt;getS3MheaderFilepointer($fd, $ThisFileInfo);
+		}
+	}
+
+
+	function getMODheaderFilepointer(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'] + 1080);
+		$FormatID = fread($fd, 4);
+		if (!ereg('^(M.K.|[5-9]CHN|[1-3][0-9]CH)$', $FormatID)) {
+			$ThisFileInfo['error'][] = 'This is not a known type of MOD file';
+			return false;
+		}
+
+		$ThisFileInfo['fileformat'] = 'mod';
+
+		$ThisFileInfo['error'][] = 'MOD parsing not enabled in this version of getID3()';
+		return false;
+	}
+
+	function getXMheaderFilepointer(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset']);
+		$FormatID = fread($fd, 15);
+		if (!ereg('^Extended Module$', $FormatID)) {
+			$ThisFileInfo['error'][] = 'This is not a known type of XM-MOD file';
+			return false;
+		}
+
+		$ThisFileInfo['fileformat'] = 'xm';
+
+		$ThisFileInfo['error'][] = 'XM-MOD parsing not enabled in this version of getID3()';
+		return false;
+	}
+
+	function getS3MheaderFilepointer(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'] + 44);
+		$FormatID = fread($fd, 4);
+		if (!ereg('^SCRM$', $FormatID)) {
+			$ThisFileInfo['error'][] = 'This is not a ScreamTracker MOD file';
+			return false;
+		}
+
+		$ThisFileInfo['fileformat'] = 's3m';
+
+		$ThisFileInfo['error'][] = 'ScreamTracker parsing not enabled in this version of getID3()';
+		return false;
+	}
+
+	function getITheaderFilepointer(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset']);
+		$FormatID = fread($fd, 4);
+		if (!ereg('^IMPM$', $FormatID)) {
+			$ThisFileInfo['error'][] = 'This is not an ImpulseTracker MOD file';
+			return false;
+		}
+
+		$ThisFileInfo['fileformat'] = 'it';
+
+		$ThisFileInfo['error'][] = 'ImpulseTracker parsing not enabled in this version of getID3()';
+		return false;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.monkey.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.monkey.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.monkey.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,202 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.monkey.php                                     //
+// module for analyzing Monkey's Audio files                   //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_monkey
+{
+
+	function getid3_monkey(&amp;$fd, &amp;$ThisFileInfo) {
+		// based loosely on code from TMonkey by Jurgen Faul &lt;jfaul&#216;gmx*de&gt;
+		// <A HREF="http://jfaul.de/atl">http://jfaul.de/atl</A>  or  <A HREF="http://j-faul.virtualave.net/atl/atl.html">http://j-faul.virtualave.net/atl/atl.html</A>
+
+		$ThisFileInfo['fileformat']            = 'mac';
+		$ThisFileInfo['audio']['dataformat']   = 'mac';
+		$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+		$ThisFileInfo['audio']['lossless']     = true;
+
+		$ThisFileInfo['monkeys_audio']['raw'] = array();
+		$thisfile_monkeysaudio                = &amp;$ThisFileInfo['monkeys_audio'];
+		$thisfile_monkeysaudio_raw            = &amp;$thisfile_monkeysaudio['raw'];
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$MACheaderData = fread($fd, 74);
+
+		$thisfile_monkeysaudio_raw['magic'] = substr($MACheaderData, 0, 4);
+		if ($thisfile_monkeysaudio_raw['magic'] != 'MAC ') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;MAC&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$thisfile_monkeysaudio_raw['magic'].'&quot;';
+			unset($ThisFileInfo['fileformat']);
+			return false;
+		}
+		$thisfile_monkeysaudio_raw['nVersion']             = getid3_lib::LittleEndian2Int(substr($MACheaderData, 4, 2)); // appears to be uint32 in 3.98+
+
+		if ($thisfile_monkeysaudio_raw['nVersion'] &lt; 3980) {
+			$thisfile_monkeysaudio_raw['nCompressionLevel']    = getid3_lib::LittleEndian2Int(substr($MACheaderData, 6, 2));
+			$thisfile_monkeysaudio_raw['nFormatFlags']         = getid3_lib::LittleEndian2Int(substr($MACheaderData, 8, 2));
+			$thisfile_monkeysaudio_raw['nChannels']            = getid3_lib::LittleEndian2Int(substr($MACheaderData, 10, 2));
+			$thisfile_monkeysaudio_raw['nSampleRate']          = getid3_lib::LittleEndian2Int(substr($MACheaderData, 12, 4));
+			$thisfile_monkeysaudio_raw['nHeaderDataBytes']     = getid3_lib::LittleEndian2Int(substr($MACheaderData, 16, 4));
+			$thisfile_monkeysaudio_raw['nWAVTerminatingBytes'] = getid3_lib::LittleEndian2Int(substr($MACheaderData, 20, 4));
+			$thisfile_monkeysaudio_raw['nTotalFrames']         = getid3_lib::LittleEndian2Int(substr($MACheaderData, 24, 4));
+			$thisfile_monkeysaudio_raw['nFinalFrameSamples']   = getid3_lib::LittleEndian2Int(substr($MACheaderData, 28, 4));
+			$thisfile_monkeysaudio_raw['nPeakLevel']           = getid3_lib::LittleEndian2Int(substr($MACheaderData, 32, 4));
+			$thisfile_monkeysaudio_raw['nSeekElements']        = getid3_lib::LittleEndian2Int(substr($MACheaderData, 38, 2));
+			$offset = 8;
+		} else {
+			$offset = 8;
+			// APE_DESCRIPTOR
+			$thisfile_monkeysaudio_raw['nDescriptorBytes']       = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset,  4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['nHeaderBytes']           = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset,  4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['nSeekTableBytes']        = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset,  4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['nHeaderDataBytes']       = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset,  4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['nAPEFrameDataBytes']     = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset,  4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['nAPEFrameDataBytesHigh'] = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset,  4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['nTerminatingDataBytes']  = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset,  4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['cFileMD5']               =                              substr($MACheaderData, $offset, 16);
+			$offset += 16;
+
+			// APE_HEADER
+			$thisfile_monkeysaudio_raw['nCompressionLevel']    = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset, 2));
+			$offset += 2;
+			$thisfile_monkeysaudio_raw['nFormatFlags']         = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset, 2));
+			$offset += 2;
+			$thisfile_monkeysaudio_raw['nBlocksPerFrame']      = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset, 4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['nFinalFrameBlocks']    = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset, 4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['nTotalFrames']         = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset, 4));
+			$offset += 4;
+			$thisfile_monkeysaudio_raw['nBitsPerSample']       = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset, 2));
+			$offset += 2;
+			$thisfile_monkeysaudio_raw['nChannels']            = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset, 2));
+			$offset += 2;
+			$thisfile_monkeysaudio_raw['nSampleRate']          = getid3_lib::LittleEndian2Int(substr($MACheaderData, $offset, 4));
+			$offset += 4;
+		}
+
+		$thisfile_monkeysaudio['flags']['8-bit']         = (bool) ($thisfile_monkeysaudio_raw['nFormatFlags'] &amp; 0x0001);
+		$thisfile_monkeysaudio['flags']['crc-32']        = (bool) ($thisfile_monkeysaudio_raw['nFormatFlags'] &amp; 0x0002);
+		$thisfile_monkeysaudio['flags']['peak_level']    = (bool) ($thisfile_monkeysaudio_raw['nFormatFlags'] &amp; 0x0004);
+		$thisfile_monkeysaudio['flags']['24-bit']        = (bool) ($thisfile_monkeysaudio_raw['nFormatFlags'] &amp; 0x0008);
+		$thisfile_monkeysaudio['flags']['seek_elements'] = (bool) ($thisfile_monkeysaudio_raw['nFormatFlags'] &amp; 0x0010);
+		$thisfile_monkeysaudio['flags']['no_wav_header'] = (bool) ($thisfile_monkeysaudio_raw['nFormatFlags'] &amp; 0x0020);
+		$thisfile_monkeysaudio['version']                = $thisfile_monkeysaudio_raw['nVersion'] / 1000;
+		$thisfile_monkeysaudio['compression']            = $this-&gt;MonkeyCompressionLevelNameLookup($thisfile_monkeysaudio_raw['nCompressionLevel']);
+		if ($thisfile_monkeysaudio_raw['nVersion'] &lt; 3980) {
+			$thisfile_monkeysaudio['samples_per_frame']      = $this-&gt;MonkeySamplesPerFrame($thisfile_monkeysaudio_raw['nVersion'], $thisfile_monkeysaudio_raw['nCompressionLevel']);
+		}
+		$thisfile_monkeysaudio['bits_per_sample']        = ($thisfile_monkeysaudio['flags']['24-bit'] ? 24 : ($thisfile_monkeysaudio['flags']['8-bit'] ? 8 : 16));
+		$thisfile_monkeysaudio['channels']               = $thisfile_monkeysaudio_raw['nChannels'];
+		$ThisFileInfo['audio']['channels']               = $thisfile_monkeysaudio['channels'];
+		$thisfile_monkeysaudio['sample_rate']            = $thisfile_monkeysaudio_raw['nSampleRate'];
+		if ($thisfile_monkeysaudio['sample_rate'] == 0) {
+			$ThisFileInfo['error'][] = 'Corrupt MAC file: frequency == zero';
+			return false;
+		}
+		$ThisFileInfo['audio']['sample_rate']            = $thisfile_monkeysaudio['sample_rate'];
+		if ($thisfile_monkeysaudio['flags']['peak_level']) {
+			$thisfile_monkeysaudio['peak_level']         = $thisfile_monkeysaudio_raw['nPeakLevel'];
+			$thisfile_monkeysaudio['peak_ratio']         = $thisfile_monkeysaudio['peak_level'] / pow(2, $thisfile_monkeysaudio['bits_per_sample'] - 1);
+		}
+		if ($thisfile_monkeysaudio_raw['nVersion'] &gt;= 3980) {
+			$thisfile_monkeysaudio['samples']            = (($thisfile_monkeysaudio_raw['nTotalFrames'] - 1) * $thisfile_monkeysaudio_raw['nBlocksPerFrame']) + $thisfile_monkeysaudio_raw['nFinalFrameBlocks'];
+		} else {
+			$thisfile_monkeysaudio['samples']            = (($thisfile_monkeysaudio_raw['nTotalFrames'] - 1) * $thisfile_monkeysaudio['samples_per_frame']) + $thisfile_monkeysaudio_raw['nFinalFrameSamples'];
+		}
+		$thisfile_monkeysaudio['playtime']               = $thisfile_monkeysaudio['samples'] / $thisfile_monkeysaudio['sample_rate'];
+		if ($thisfile_monkeysaudio['playtime'] == 0) {
+			$ThisFileInfo['error'][] = 'Corrupt MAC file: playtime == zero';
+			return false;
+		}
+		$ThisFileInfo['playtime_seconds']                = $thisfile_monkeysaudio['playtime'];
+		$thisfile_monkeysaudio['compressed_size']        = $ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset'];
+		$thisfile_monkeysaudio['uncompressed_size']      = $thisfile_monkeysaudio['samples'] * $thisfile_monkeysaudio['channels'] * ($thisfile_monkeysaudio['bits_per_sample'] / 8);
+		if ($thisfile_monkeysaudio['uncompressed_size'] == 0) {
+			$ThisFileInfo['error'][] = 'Corrupt MAC file: uncompressed_size == zero';
+			return false;
+		}
+		$thisfile_monkeysaudio['compression_ratio']      = $thisfile_monkeysaudio['compressed_size'] / ($thisfile_monkeysaudio['uncompressed_size'] + $thisfile_monkeysaudio_raw['nHeaderDataBytes']);
+		$thisfile_monkeysaudio['bitrate']                = (($thisfile_monkeysaudio['samples'] * $thisfile_monkeysaudio['channels'] * $thisfile_monkeysaudio['bits_per_sample']) / $thisfile_monkeysaudio['playtime']) * $thisfile_monkeysaudio['compression_ratio'];
+		$ThisFileInfo['audio']['bitrate']                = $thisfile_monkeysaudio['bitrate'];
+
+		// add size of MAC header to avdataoffset
+		if ($thisfile_monkeysaudio_raw['nVersion'] &gt;= 3980) {
+			$ThisFileInfo['avdataoffset'] += $thisfile_monkeysaudio_raw['nDescriptorBytes'];
+			$ThisFileInfo['avdataoffset'] += $thisfile_monkeysaudio_raw['nHeaderBytes'];
+			$ThisFileInfo['avdataoffset'] += $thisfile_monkeysaudio_raw['nSeekTableBytes'];
+			$ThisFileInfo['avdataoffset'] += $thisfile_monkeysaudio_raw['nHeaderDataBytes'];
+
+			$ThisFileInfo['avdataend'] -= $thisfile_monkeysaudio_raw['nTerminatingDataBytes'];
+		} else {
+			$ThisFileInfo['avdataoffset'] += $offset;
+		}
+
+		if ($thisfile_monkeysaudio_raw['nVersion'] &gt;= 3980) {
+			if ($thisfile_monkeysaudio_raw['cFileMD5'] === str_repeat(&quot;\x00&quot;, 16)) {
+				//$ThisFileInfo['warning'][] = 'cFileMD5 is null';
+			} else {
+				$ThisFileInfo['md5_data_source'] = '';
+				$md5 = $thisfile_monkeysaudio_raw['cFileMD5'];
+				for ($i = 0; $i &lt; strlen($md5); $i++) {
+					$ThisFileInfo['md5_data_source'] .= str_pad(dechex(ord($md5{$i})), 2, '00', STR_PAD_LEFT);
+				}
+				if (!preg_match('/^[0-9a-f]{32}$/', $ThisFileInfo['md5_data_source'])) {
+					unset($ThisFileInfo['md5_data_source']);
+				}
+			}
+		}
+
+
+
+		$ThisFileInfo['audio']['bits_per_sample'] = $thisfile_monkeysaudio['bits_per_sample'];
+		$ThisFileInfo['audio']['encoder']         = 'MAC v'.number_format($thisfile_monkeysaudio['version'], 2);
+		$ThisFileInfo['audio']['encoder_options'] = ucfirst($thisfile_monkeysaudio['compression']).' compression';
+
+		return true;
+	}
+
+	function MonkeyCompressionLevelNameLookup($compressionlevel) {
+		static $MonkeyCompressionLevelNameLookup = array(
+			0     =&gt; 'unknown',
+			1000  =&gt; 'fast',
+			2000  =&gt; 'normal',
+			3000  =&gt; 'high',
+			4000  =&gt; 'extra-high',
+			5000  =&gt; 'insane'
+		);
+		return (isset($MonkeyCompressionLevelNameLookup[$compressionlevel]) ? $MonkeyCompressionLevelNameLookup[$compressionlevel] : 'invalid');
+	}
+
+	function MonkeySamplesPerFrame($versionid, $compressionlevel) {
+		if ($versionid &gt;= 3950) {
+			return 73728 * 4;
+		} elseif ($versionid &gt;= 3900) {
+			return 73728;
+		} elseif (($versionid &gt;= 3800) &amp;&amp; ($compressionlevel == 4000)) {
+			return 73728;
+		} else {
+			return 9216;
+		}
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mp3.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mp3.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mp3.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,1931 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.mp3.php                                        //
+// module for analyzing MP3 files                              //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+// number of frames to scan to determine if MPEG-audio sequence is valid
+// Lower this number to 5-20 for faster scanning
+// Increase this number to 50+ for most accurate detection of valid VBR/CBR
+// mpeg-audio streams
+define('GETID3_MP3_VALID_CHECK_FRAMES', 35);
+
+
+class getid3_mp3
+{
+
+	var $allow_bruteforce = false; // forces getID3() to scan the file byte-by-byte and log all the valid audio frame headers - extremely slow, unrecommended, but may provide data from otherwise-unusuable files
+
+	function getid3_mp3(&amp;$fd, &amp;$ThisFileInfo) {
+
+		if (!$this-&gt;getOnlyMPEGaudioInfo($fd, $ThisFileInfo, $ThisFileInfo['avdataoffset'])) {
+			if ($this-&gt;allow_bruteforce) {
+				$ThisFileInfo['error'][] = 'Rescanning file in BruteForce mode';
+				$this-&gt;getOnlyMPEGaudioInfoBruteForce($fd, $ThisFileInfo);
+			}
+		}
+
+
+		if (isset($ThisFileInfo['mpeg']['audio']['bitrate_mode'])) {
+			$ThisFileInfo['audio']['bitrate_mode'] = strtolower($ThisFileInfo['mpeg']['audio']['bitrate_mode']);
+		}
+
+		if (((isset($ThisFileInfo['id3v2']['headerlength']) &amp;&amp; ($ThisFileInfo['avdataoffset'] &gt; $ThisFileInfo['id3v2']['headerlength'])) || (!isset($ThisFileInfo['id3v2']) &amp;&amp; ($ThisFileInfo['avdataoffset'] &gt; 0)))) {
+
+			$synchoffsetwarning = 'Unknown data before synch ';
+			if (isset($ThisFileInfo['id3v2']['headerlength'])) {
+				$synchoffsetwarning .= '(ID3v2 header ends at '.$ThisFileInfo['id3v2']['headerlength'].', then '.($ThisFileInfo['avdataoffset'] - $ThisFileInfo['id3v2']['headerlength']).' bytes garbage, ';
+			} else {
+				$synchoffsetwarning .= '(should be at beginning of file, ';
+			}
+			$synchoffsetwarning .= 'synch detected at '.$ThisFileInfo['avdataoffset'].')';
+			if ($ThisFileInfo['audio']['bitrate_mode'] == 'cbr') {
+
+				if (!empty($ThisFileInfo['id3v2']['headerlength']) &amp;&amp; (($ThisFileInfo['avdataoffset'] - $ThisFileInfo['id3v2']['headerlength']) == $ThisFileInfo['mpeg']['audio']['framelength'])) {
+
+					$synchoffsetwarning .= '. This is a known problem with some versions of LAME (3.90-3.92) DLL in CBR mode.';
+					$ThisFileInfo['audio']['codec'] = 'LAME';
+					$CurrentDataLAMEversionString = 'LAME3.';
+
+				} elseif (empty($ThisFileInfo['id3v2']['headerlength']) &amp;&amp; ($ThisFileInfo['avdataoffset'] == $ThisFileInfo['mpeg']['audio']['framelength'])) {
+
+					$synchoffsetwarning .= '. This is a known problem with some versions of LAME (3.90 - 3.92) DLL in CBR mode.';
+					$ThisFileInfo['audio']['codec'] = 'LAME';
+					$CurrentDataLAMEversionString = 'LAME3.';
+
+				}
+
+			}
+			$ThisFileInfo['warning'][] = $synchoffsetwarning;
+
+		}
+
+		if (isset($ThisFileInfo['mpeg']['audio']['LAME'])) {
+			$ThisFileInfo['audio']['codec'] = 'LAME';
+			if (!empty($ThisFileInfo['mpeg']['audio']['LAME']['long_version'])) {
+				$ThisFileInfo['audio']['encoder'] = rtrim($ThisFileInfo['mpeg']['audio']['LAME']['long_version'], &quot;\x00&quot;);
+			} elseif (!empty($ThisFileInfo['mpeg']['audio']['LAME']['short_version'])) {
+				$ThisFileInfo['audio']['encoder'] = rtrim($ThisFileInfo['mpeg']['audio']['LAME']['short_version'], &quot;\x00&quot;);
+			}
+		}
+
+		$CurrentDataLAMEversionString = (!empty($CurrentDataLAMEversionString) ? $CurrentDataLAMEversionString : @$ThisFileInfo['audio']['encoder']);
+		if (!empty($CurrentDataLAMEversionString) &amp;&amp; (substr($CurrentDataLAMEversionString, 0, 6) == 'LAME3.') &amp;&amp; !preg_match('[0-9\)]', substr($CurrentDataLAMEversionString, -1))) {
+			// a version number of LAME that does not end with a number like &quot;LAME3.92&quot;
+			// or with a closing parenthesis like &quot;LAME3.88 (alpha)&quot;
+			// or a version of LAME with the LAMEtag-not-filled-in-DLL-mode bug (3.90-3.92)
+
+			// not sure what the actual last frame length will be, but will be less than or equal to 1441
+			$PossiblyLongerLAMEversion_FrameLength = 1441;
+
+			// Not sure what version of LAME this is - look in padding of last frame for longer version string
+			$PossibleLAMEversionStringOffset = $ThisFileInfo['avdataend'] - $PossiblyLongerLAMEversion_FrameLength;
+			fseek($fd, $PossibleLAMEversionStringOffset);
+			$PossiblyLongerLAMEversion_Data = fread($fd, $PossiblyLongerLAMEversion_FrameLength);
+			switch (substr($CurrentDataLAMEversionString, -1)) {
+				case 'a':
+				case 'b':
+					// &quot;LAME3.94a&quot; will have a longer version string of &quot;LAME3.94 (alpha)&quot; for example
+					// need to trim off &quot;a&quot; to match longer string
+					$CurrentDataLAMEversionString = substr($CurrentDataLAMEversionString, 0, -1);
+					break;
+			}
+			if (($PossiblyLongerLAMEversion_String = strstr($PossiblyLongerLAMEversion_Data, $CurrentDataLAMEversionString)) !== false) {
+				if (substr($PossiblyLongerLAMEversion_String, 0, strlen($CurrentDataLAMEversionString)) == $CurrentDataLAMEversionString) {
+					$PossiblyLongerLAMEversion_NewString = substr($PossiblyLongerLAMEversion_String, 0, strspn($PossiblyLongerLAMEversion_String, 'LAME0123456789., (abcdefghijklmnopqrstuvwxyzJFSOND)')); //&quot;LAME3.90.3&quot;  &quot;LAME3.87 (beta 1, Sep 27 2000)&quot; &quot;LAME3.88 (beta)&quot;
+					if (strlen($PossiblyLongerLAMEversion_NewString) &gt; strlen(@$ThisFileInfo['audio']['encoder'])) {
+						$ThisFileInfo['audio']['encoder'] = $PossiblyLongerLAMEversion_NewString;
+					}
+				}
+			}
+		}
+		if (!empty($ThisFileInfo['audio']['encoder'])) {
+			$ThisFileInfo['audio']['encoder'] = rtrim($ThisFileInfo['audio']['encoder'], &quot;\x00 &quot;);
+		}
+
+		switch (@$ThisFileInfo['mpeg']['audio']['layer']) {
+			case 1:
+			case 2:
+				$ThisFileInfo['audio']['dataformat'] = 'mp'.$ThisFileInfo['mpeg']['audio']['layer'];
+				break;
+		}
+		if ($ThisFileInfo['fileformat'] == 'mp3') {
+			switch ($ThisFileInfo['audio']['dataformat']) {
+				case 'mp1':
+				case 'mp2':
+				case 'mp3':
+					$ThisFileInfo['fileformat'] = $ThisFileInfo['audio']['dataformat'];
+					break;
+
+				default:
+					$ThisFileInfo['warning'][] = 'Expecting [audio][dataformat] to be mp1/mp2/mp3 when fileformat == mp3, [audio][dataformat] actually &quot;'.$ThisFileInfo['audio']['dataformat'].'&quot;';
+					break;
+			}
+		}
+
+		if (empty($ThisFileInfo['fileformat'])) {
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['audio']['bitrate_mode']);
+			unset($ThisFileInfo['avdataoffset']);
+			unset($ThisFileInfo['avdataend']);
+			return false;
+		}
+
+		$ThisFileInfo['mime_type']         = 'audio/mpeg';
+		$ThisFileInfo['audio']['lossless'] = false;
+
+		// Calculate playtime
+		if (!isset($ThisFileInfo['playtime_seconds']) &amp;&amp; isset($ThisFileInfo['audio']['bitrate']) &amp;&amp; ($ThisFileInfo['audio']['bitrate'] &gt; 0)) {
+			$ThisFileInfo['playtime_seconds'] = ($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8 / $ThisFileInfo['audio']['bitrate'];
+		}
+
+		$ThisFileInfo['audio']['encoder_options'] = $this-&gt;GuessEncoderOptions($ThisFileInfo);
+
+		return true;
+	}
+
+
+	function GuessEncoderOptions(&amp;$ThisFileInfo) {
+		// shortcuts
+		if (!empty($ThisFileInfo['mpeg']['audio'])) {
+			$thisfile_mpeg_audio = &amp;$ThisFileInfo['mpeg']['audio'];
+			if (!empty($thisfile_mpeg_audio['LAME'])) {
+				$thisfile_mpeg_audio_lame = &amp;$thisfile_mpeg_audio['LAME'];
+			}
+		}
+
+		$encoder_options = '';
+		static $NamedPresetBitrates = array(16, 24, 40, 56, 112, 128, 160, 192, 256);
+
+		if ((@$thisfile_mpeg_audio['VBR_method'] == 'Fraunhofer') &amp;&amp; !empty($thisfile_mpeg_audio['VBR_quality'])) {
+
+			$encoder_options = 'VBR q'.$thisfile_mpeg_audio['VBR_quality'];
+
+		} elseif (!empty($thisfile_mpeg_audio_lame['preset_used']) &amp;&amp; (!in_array($thisfile_mpeg_audio_lame['preset_used_id'], $NamedPresetBitrates))) {
+
+			$encoder_options = $thisfile_mpeg_audio_lame['preset_used'];
+
+		} elseif (!empty($thisfile_mpeg_audio_lame['vbr_quality'])) {
+
+			static $KnownEncoderValues = array();
+			if (empty($KnownEncoderValues)) {
+
+				//$KnownEncoderValues[abrbitrate_minbitrate][vbr_quality][raw_vbr_method][raw_noise_shaping][raw_stereo_mode][ath_type][lowpass_frequency] = 'preset name';
+				$KnownEncoderValues[0xFF][58][1][1][3][2][20500] = '--alt-preset insane';        // 3.90,   3.90.1, 3.92
+				$KnownEncoderValues[0xFF][58][1][1][3][2][20600] = '--alt-preset insane';        // 3.90.2, 3.90.3, 3.91
+				$KnownEncoderValues[0xFF][57][1][1][3][4][20500] = '--alt-preset insane';        // 3.94,   3.95
+				$KnownEncoderValues['**'][78][3][2][3][2][19500] = '--alt-preset extreme';       // 3.90,   3.90.1, 3.92
+				$KnownEncoderValues['**'][78][3][2][3][2][19600] = '--alt-preset extreme';       // 3.90.2, 3.91
+				$KnownEncoderValues['**'][78][3][1][3][2][19600] = '--alt-preset extreme';       // 3.90.3
+				$KnownEncoderValues['**'][78][4][2][3][2][19500] = '--alt-preset fast extreme';  // 3.90,   3.90.1, 3.92
+				$KnownEncoderValues['**'][78][4][2][3][2][19600] = '--alt-preset fast extreme';  // 3.90.2, 3.90.3, 3.91
+				$KnownEncoderValues['**'][78][3][2][3][4][19000] = '--alt-preset standard';      // 3.90,   3.90.1, 3.90.2, 3.91, 3.92
+				$KnownEncoderValues['**'][78][3][1][3][4][19000] = '--alt-preset standard';      // 3.90.3
+				$KnownEncoderValues['**'][78][4][2][3][4][19000] = '--alt-preset fast standard'; // 3.90,   3.90.1, 3.90.2, 3.91, 3.92
+				$KnownEncoderValues['**'][78][4][1][3][4][19000] = '--alt-preset fast standard'; // 3.90.3
+				$KnownEncoderValues['**'][88][4][1][3][3][19500] = '--r3mix';                    // 3.90,   3.90.1, 3.92
+				$KnownEncoderValues['**'][88][4][1][3][3][19600] = '--r3mix';                    // 3.90.2, 3.90.3, 3.91
+				$KnownEncoderValues['**'][67][4][1][3][4][18000] = '--r3mix';                    // 3.94,   3.95
+				$KnownEncoderValues['**'][68][3][2][3][4][18000] = '--alt-preset medium';        // 3.90.3
+				$KnownEncoderValues['**'][68][4][2][3][4][18000] = '--alt-preset fast medium';   // 3.90.3
+
+				$KnownEncoderValues[0xFF][99][1][1][1][2][0]     = '--preset studio';            // 3.90,   3.90.1, 3.90.2, 3.91, 3.92
+				$KnownEncoderValues[0xFF][58][2][1][3][2][20600] = '--preset studio';            // 3.90.3, 3.93.1
+				$KnownEncoderValues[0xFF][58][2][1][3][2][20500] = '--preset studio';            // 3.93
+				$KnownEncoderValues[0xFF][57][2][1][3][4][20500] = '--preset studio';            // 3.94,   3.95
+				$KnownEncoderValues[0xC0][88][1][1][1][2][0]     = '--preset cd';                // 3.90,   3.90.1, 3.90.2,   3.91, 3.92
+				$KnownEncoderValues[0xC0][58][2][2][3][2][19600] = '--preset cd';                // 3.90.3, 3.93.1
+				$KnownEncoderValues[0xC0][58][2][2][3][2][19500] = '--preset cd';                // 3.93
+				$KnownEncoderValues[0xC0][57][2][1][3][4][19500] = '--preset cd';                // 3.94,   3.95
+				$KnownEncoderValues[0xA0][78][1][1][3][2][18000] = '--preset hifi';              // 3.90,   3.90.1, 3.90.2,   3.91, 3.92
+				$KnownEncoderValues[0xA0][58][2][2][3][2][18000] = '--preset hifi';              // 3.90.3, 3.93,   3.93.1
+				$KnownEncoderValues[0xA0][57][2][1][3][4][18000] = '--preset hifi';              // 3.94,   3.95
+				$KnownEncoderValues[0x80][67][1][1][3][2][18000] = '--preset tape';              // 3.90,   3.90.1, 3.90.2,   3.91, 3.92
+				$KnownEncoderValues[0x80][67][1][1][3][2][15000] = '--preset radio';             // 3.90,   3.90.1, 3.90.2,   3.91, 3.92
+				$KnownEncoderValues[0x70][67][1][1][3][2][15000] = '--preset fm';                // 3.90,   3.90.1, 3.90.2,   3.91, 3.92
+				$KnownEncoderValues[0x70][58][2][2][3][2][16000] = '--preset tape/radio/fm';     // 3.90.3, 3.93,   3.93.1
+				$KnownEncoderValues[0x70][57][2][1][3][4][16000] = '--preset tape/radio/fm';     // 3.94,   3.95
+				$KnownEncoderValues[0x38][58][2][2][0][2][10000] = '--preset voice';             // 3.90.3, 3.93,   3.93.1
+				$KnownEncoderValues[0x38][57][2][1][0][4][15000] = '--preset voice';             // 3.94,   3.95
+				$KnownEncoderValues[0x38][57][2][1][0][4][16000] = '--preset voice';             // 3.94a14
+				$KnownEncoderValues[0x28][65][1][1][0][2][7500]  = '--preset mw-us';             // 3.90,   3.90.1, 3.92
+				$KnownEncoderValues[0x28][65][1][1][0][2][7600]  = '--preset mw-us';             // 3.90.2, 3.91
+				$KnownEncoderValues[0x28][58][2][2][0][2][7000]  = '--preset mw-us';             // 3.90.3, 3.93,   3.93.1
+				$KnownEncoderValues[0x28][57][2][1][0][4][10500] = '--preset mw-us';             // 3.94,   3.95
+				$KnownEncoderValues[0x28][57][2][1][0][4][11200] = '--preset mw-us';             // 3.94a14
+				$KnownEncoderValues[0x28][57][2][1][0][4][8800]  = '--preset mw-us';             // 3.94a15
+				$KnownEncoderValues[0x18][58][2][2][0][2][4000]  = '--preset phon+/lw/mw-eu/sw'; // 3.90.3, 3.93.1
+				$KnownEncoderValues[0x18][58][2][2][0][2][3900]  = '--preset phon+/lw/mw-eu/sw'; // 3.93
+				$KnownEncoderValues[0x18][57][2][1][0][4][5900]  = '--preset phon+/lw/mw-eu/sw'; // 3.94,   3.95
+				$KnownEncoderValues[0x18][57][2][1][0][4][6200]  = '--preset phon+/lw/mw-eu/sw'; // 3.94a14
+				$KnownEncoderValues[0x18][57][2][1][0][4][3200]  = '--preset phon+/lw/mw-eu/sw'; // 3.94a15
+				$KnownEncoderValues[0x10][58][2][2][0][2][3800]  = '--preset phone';             // 3.90.3, 3.93.1
+				$KnownEncoderValues[0x10][58][2][2][0][2][3700]  = '--preset phone';             // 3.93
+				$KnownEncoderValues[0x10][57][2][1][0][4][5600]  = '--preset phone';             // 3.94,   3.95
+			}
+
+			if (isset($KnownEncoderValues[$thisfile_mpeg_audio_lame['raw']['abrbitrate_minbitrate']][$thisfile_mpeg_audio_lame['vbr_quality']][$thisfile_mpeg_audio_lame['raw']['vbr_method']][$thisfile_mpeg_audio_lame['raw']['noise_shaping']][$thisfile_mpeg_audio_lame['raw']['stereo_mode']][$thisfile_mpeg_audio_lame['ath_type']][$thisfile_mpeg_audio_lame['lowpass_frequency']])) {
+
+				$encoder_options = $KnownEncoderValues[$thisfile_mpeg_audio_lame['raw']['abrbitrate_minbitrate']][$thisfile_mpeg_audio_lame['vbr_quality']][$thisfile_mpeg_audio_lame['raw']['vbr_method']][$thisfile_mpeg_audio_lame['raw']['noise_shaping']][$thisfile_mpeg_audio_lame['raw']['stereo_mode']][$thisfile_mpeg_audio_lame['ath_type']][$thisfile_mpeg_audio_lame['lowpass_frequency']];
+
+			} elseif (isset($KnownEncoderValues['**'][$thisfile_mpeg_audio_lame['vbr_quality']][$thisfile_mpeg_audio_lame['raw']['vbr_method']][$thisfile_mpeg_audio_lame['raw']['noise_shaping']][$thisfile_mpeg_audio_lame['raw']['stereo_mode']][$thisfile_mpeg_audio_lame['ath_type']][$thisfile_mpeg_audio_lame['lowpass_frequency']])) {
+
+				$encoder_options = $KnownEncoderValues['**'][$thisfile_mpeg_audio_lame['vbr_quality']][$thisfile_mpeg_audio_lame['raw']['vbr_method']][$thisfile_mpeg_audio_lame['raw']['noise_shaping']][$thisfile_mpeg_audio_lame['raw']['stereo_mode']][$thisfile_mpeg_audio_lame['ath_type']][$thisfile_mpeg_audio_lame['lowpass_frequency']];
+
+			} elseif ($ThisFileInfo['audio']['bitrate_mode'] == 'vbr') {
+
+				// <A HREF="http://gabriel.mp3-tech.org/mp3infotag.html">http://gabriel.mp3-tech.org/mp3infotag.html</A>
+				// int    Quality = (100 - 10 * gfp-&gt;VBR_q - gfp-&gt;quality)h
+
+
+				$LAME_V_value = 10 - ceil($thisfile_mpeg_audio_lame['vbr_quality'] / 10);
+				$LAME_q_value = 100 - $thisfile_mpeg_audio_lame['vbr_quality'] - ($LAME_V_value * 10);
+				$encoder_options = '-V'.$LAME_V_value.' -q'.$LAME_q_value;
+
+			} elseif ($ThisFileInfo['audio']['bitrate_mode'] == 'cbr') {
+
+				$encoder_options = strtoupper($ThisFileInfo['audio']['bitrate_mode']).ceil($ThisFileInfo['audio']['bitrate'] / 1000);
+
+			} else {
+
+				$encoder_options = strtoupper($ThisFileInfo['audio']['bitrate_mode']);
+
+			}
+
+		} elseif (!empty($thisfile_mpeg_audio_lame['bitrate_abr'])) {
+
+			$encoder_options = 'ABR'.$thisfile_mpeg_audio_lame['bitrate_abr'];
+
+		} elseif (!empty($ThisFileInfo['audio']['bitrate'])) {
+
+			if ($ThisFileInfo['audio']['bitrate_mode'] == 'cbr') {
+				$encoder_options = strtoupper($ThisFileInfo['audio']['bitrate_mode']).ceil($ThisFileInfo['audio']['bitrate'] / 1000);
+			} else {
+				$encoder_options = strtoupper($ThisFileInfo['audio']['bitrate_mode']);
+			}
+
+		}
+		if (!empty($thisfile_mpeg_audio_lame['bitrate_min'])) {
+			$encoder_options .= ' -b'.$thisfile_mpeg_audio_lame['bitrate_min'];
+		}
+
+		if (@$thisfile_mpeg_audio_lame['encoding_flags']['nogap_prev'] || @$thisfile_mpeg_audio_lame['encoding_flags']['nogap_next']) {
+			$encoder_options .= ' --nogap';
+		}
+
+		if (!empty($thisfile_mpeg_audio_lame['lowpass_frequency'])) {
+			$ExplodedOptions = explode(' ', $encoder_options, 4);
+			if ($ExplodedOptions[0] == '--r3mix') {
+				$ExplodedOptions[1] = 'r3mix';
+			}
+			switch ($ExplodedOptions[0]) {
+				case '--preset':
+				case '--alt-preset':
+				case '--r3mix':
+					if ($ExplodedOptions[1] == 'fast') {
+						$ExplodedOptions[1] .= ' '.$ExplodedOptions[2];
+					}
+					switch ($ExplodedOptions[1]) {
+						case 'portable':
+						case 'medium':
+						case 'standard':
+						case 'extreme':
+						case 'insane':
+						case 'fast portable':
+						case 'fast medium':
+						case 'fast standard':
+						case 'fast extreme':
+						case 'fast insane':
+						case 'r3mix':
+							static $ExpectedLowpass = array(
+									'insane|20500'        =&gt; 20500,
+									'insane|20600'        =&gt; 20600,  // 3.90.2, 3.90.3, 3.91
+									'medium|18000'        =&gt; 18000,
+									'fast medium|18000'   =&gt; 18000,
+									'extreme|19500'       =&gt; 19500,  // 3.90,   3.90.1, 3.92, 3.95
+									'extreme|19600'       =&gt; 19600,  // 3.90.2, 3.90.3, 3.91, 3.93.1
+									'fast extreme|19500'  =&gt; 19500,  // 3.90,   3.90.1, 3.92, 3.95
+									'fast extreme|19600'  =&gt; 19600,  // 3.90.2, 3.90.3, 3.91, 3.93.1
+									'standard|19000'      =&gt; 19000,
+									'fast standard|19000' =&gt; 19000,
+									'r3mix|19500'         =&gt; 19500,  // 3.90,   3.90.1, 3.92
+									'r3mix|19600'         =&gt; 19600,  // 3.90.2, 3.90.3, 3.91
+									'r3mix|18000'         =&gt; 18000,  // 3.94,   3.95
+								);
+							if (!isset($ExpectedLowpass[$ExplodedOptions[1].'|'.$thisfile_mpeg_audio_lame['lowpass_frequency']]) &amp;&amp; ($thisfile_mpeg_audio_lame['lowpass_frequency'] &lt; 22050) &amp;&amp; (round($thisfile_mpeg_audio_lame['lowpass_frequency'] / 1000) &lt; round($thisfile_mpeg_audio['sample_rate'] / 2000))) {
+								$encoder_options .= ' --lowpass '.$thisfile_mpeg_audio_lame['lowpass_frequency'];
+							}
+							break;
+
+						default:
+							break;
+					}
+					break;
+			}
+		}
+
+		if (isset($thisfile_mpeg_audio_lame['raw']['source_sample_freq'])) {
+			if (($thisfile_mpeg_audio['sample_rate'] == 44100) &amp;&amp; ($thisfile_mpeg_audio_lame['raw']['source_sample_freq'] != 1)) {
+				$encoder_options .= ' --resample 44100';
+			} elseif (($thisfile_mpeg_audio['sample_rate'] == 48000) &amp;&amp; ($thisfile_mpeg_audio_lame['raw']['source_sample_freq'] != 2)) {
+				$encoder_options .= ' --resample 48000';
+			} elseif ($thisfile_mpeg_audio['sample_rate'] &lt; 44100) {
+				switch ($thisfile_mpeg_audio_lame['raw']['source_sample_freq']) {
+					case 0: // &lt;= 32000
+						// may or may not be same as source frequency - ignore
+						break;
+					case 1: // 44100
+					case 2: // 48000
+					case 3: // 48000+
+						$ExplodedOptions = explode(' ', $encoder_options, 4);
+						switch ($ExplodedOptions[0]) {
+							case '--preset':
+							case '--alt-preset':
+								switch ($ExplodedOptions[1]) {
+									case 'fast':
+									case 'portable':
+									case 'medium':
+									case 'standard':
+									case 'extreme':
+									case 'insane':
+										$encoder_options .= ' --resample '.$thisfile_mpeg_audio['sample_rate'];
+										break;
+
+									default:
+										static $ExpectedResampledRate = array(
+												'phon+/lw/mw-eu/sw|16000' =&gt; 16000,
+												'mw-us|24000'             =&gt; 24000, // 3.95
+												'mw-us|32000'             =&gt; 32000, // 3.93
+												'mw-us|16000'             =&gt; 16000, // 3.92
+												'phone|16000'             =&gt; 16000,
+												'phone|11025'             =&gt; 11025, // 3.94a15
+												'radio|32000'             =&gt; 32000, // 3.94a15
+												'fm/radio|32000'          =&gt; 32000, // 3.92
+												'fm|32000'                =&gt; 32000, // 3.90
+												'voice|32000'             =&gt; 32000);
+										if (!isset($ExpectedResampledRate[$ExplodedOptions[1].'|'.$thisfile_mpeg_audio['sample_rate']])) {
+											$encoder_options .= ' --resample '.$thisfile_mpeg_audio['sample_rate'];
+										}
+										break;
+								}
+								break;
+
+							case '--r3mix':
+							default:
+								$encoder_options .= ' --resample '.$thisfile_mpeg_audio['sample_rate'];
+								break;
+						}
+						break;
+				}
+			}
+		}
+		if (empty($encoder_options) &amp;&amp; !empty($ThisFileInfo['audio']['bitrate']) &amp;&amp; !empty($ThisFileInfo['audio']['bitrate_mode'])) {
+			//$encoder_options = strtoupper($ThisFileInfo['audio']['bitrate_mode']).ceil($ThisFileInfo['audio']['bitrate'] / 1000);
+			$encoder_options = strtoupper($ThisFileInfo['audio']['bitrate_mode']);
+		}
+
+		return $encoder_options;
+	}
+
+
+	function decodeMPEGaudioHeader($fd, $offset, &amp;$ThisFileInfo, $recursivesearch=true, $ScanAsCBR=false, $FastMPEGheaderScan=false) {
+
+		static $MPEGaudioVersionLookup;
+		static $MPEGaudioLayerLookup;
+		static $MPEGaudioBitrateLookup;
+		static $MPEGaudioFrequencyLookup;
+		static $MPEGaudioChannelModeLookup;
+		static $MPEGaudioModeExtensionLookup;
+		static $MPEGaudioEmphasisLookup;
+		if (empty($MPEGaudioVersionLookup)) {
+			$MPEGaudioVersionLookup       = getid3_mp3::MPEGaudioVersionArray();
+			$MPEGaudioLayerLookup         = getid3_mp3::MPEGaudioLayerArray();
+			$MPEGaudioBitrateLookup       = getid3_mp3::MPEGaudioBitrateArray();
+			$MPEGaudioFrequencyLookup     = getid3_mp3::MPEGaudioFrequencyArray();
+			$MPEGaudioChannelModeLookup   = getid3_mp3::MPEGaudioChannelModeArray();
+			$MPEGaudioModeExtensionLookup = getid3_mp3::MPEGaudioModeExtensionArray();
+			$MPEGaudioEmphasisLookup      = getid3_mp3::MPEGaudioEmphasisArray();
+		}
+
+		if ($offset &gt;= $ThisFileInfo['avdataend']) {
+			$ThisFileInfo['error'][] = 'end of file encounter looking for MPEG synch';
+			return false;
+		}
+		fseek($fd, $offset, SEEK_SET);
+		//$headerstring = fread($fd, 1441); // worst-case max length = 32kHz @ 320kbps layer 3 = 1441 bytes/frame
+		$headerstring = fread($fd, 226); // LAME header at offset 36 + 190 bytes of Xing/LAME data
+
+		// MP3 audio frame structure:
+		// $aa $aa $aa $aa [$bb $bb] $cc...
+		// where $aa..$aa is the four-byte mpeg-audio header (below)
+		// $bb $bb is the optional 2-byte CRC
+		// and $cc... is the audio data
+
+		$head4 = substr($headerstring, 0, 4);
+
+		static $MPEGaudioHeaderDecodeCache = array();
+		if (isset($MPEGaudioHeaderDecodeCache[$head4])) {
+			$MPEGheaderRawArray = $MPEGaudioHeaderDecodeCache[$head4];
+		} else {
+			$MPEGheaderRawArray = getid3_mp3::MPEGaudioHeaderDecode($head4);
+			$MPEGaudioHeaderDecodeCache[$head4] = $MPEGheaderRawArray;
+		}
+
+		static $MPEGaudioHeaderValidCache = array();
+
+		// Not in cache
+		if (!isset($MPEGaudioHeaderValidCache[$head4])) {
+			//$MPEGaudioHeaderValidCache[$head4] = getid3_mp3::MPEGaudioHeaderValid($MPEGheaderRawArray, false, true);  // allow badly-formatted freeformat (from LAME 3.90 - 3.93.1)
+			$MPEGaudioHeaderValidCache[$head4] = getid3_mp3::MPEGaudioHeaderValid($MPEGheaderRawArray, false, false);
+		}
+
+		// shortcut
+		if (!isset($ThisFileInfo['mpeg']['audio'])) {
+			$ThisFileInfo['mpeg']['audio'] = array();
+		}
+		$thisfile_mpeg_audio = &amp;$ThisFileInfo['mpeg']['audio'];
+
+
+		if ($MPEGaudioHeaderValidCache[$head4]) {
+			$thisfile_mpeg_audio['raw'] = $MPEGheaderRawArray;
+		} else {
+			$ThisFileInfo['error'][] = 'Invalid MPEG audio header at offset '.$offset;
+			return false;
+		}
+
+		if (!$FastMPEGheaderScan) {
+
+			$thisfile_mpeg_audio['version']       = $MPEGaudioVersionLookup[$thisfile_mpeg_audio['raw']['version']];
+			$thisfile_mpeg_audio['layer']         = $MPEGaudioLayerLookup[$thisfile_mpeg_audio['raw']['layer']];
+
+			$thisfile_mpeg_audio['channelmode']   = $MPEGaudioChannelModeLookup[$thisfile_mpeg_audio['raw']['channelmode']];
+			$thisfile_mpeg_audio['channels']      = (($thisfile_mpeg_audio['channelmode'] == 'mono') ? 1 : 2);
+			$thisfile_mpeg_audio['sample_rate']   = $MPEGaudioFrequencyLookup[$thisfile_mpeg_audio['version']][$thisfile_mpeg_audio['raw']['sample_rate']];
+			$thisfile_mpeg_audio['protection']    = !$thisfile_mpeg_audio['raw']['protection'];
+			$thisfile_mpeg_audio['private']       = (bool) $thisfile_mpeg_audio['raw']['private'];
+			$thisfile_mpeg_audio['modeextension'] = $MPEGaudioModeExtensionLookup[$thisfile_mpeg_audio['layer']][$thisfile_mpeg_audio['raw']['modeextension']];
+			$thisfile_mpeg_audio['copyright']     = (bool) $thisfile_mpeg_audio['raw']['copyright'];
+			$thisfile_mpeg_audio['original']      = (bool) $thisfile_mpeg_audio['raw']['original'];
+			$thisfile_mpeg_audio['emphasis']      = $MPEGaudioEmphasisLookup[$thisfile_mpeg_audio['raw']['emphasis']];
+
+			$ThisFileInfo['audio']['channels']    = $thisfile_mpeg_audio['channels'];
+			$ThisFileInfo['audio']['sample_rate'] = $thisfile_mpeg_audio['sample_rate'];
+
+			if ($thisfile_mpeg_audio['protection']) {
+				$thisfile_mpeg_audio['crc'] = getid3_lib::BigEndian2Int(substr($headerstring, 4, 2));
+			}
+
+		}
+
+		if ($thisfile_mpeg_audio['raw']['bitrate'] == 15) {
+			// <A HREF="http://www.hydrogenaudio.org/?act=ST&amp;f=16&amp;t=9682&amp;st=0">http://www.hydrogenaudio.org/?act=ST&amp;f=16&amp;t=9682&amp;st=0</A>
+			$ThisFileInfo['warning'][] = 'Invalid bitrate index (15), this is a known bug in free-format MP3s encoded by LAME v3.90 - 3.93.1';
+			$thisfile_mpeg_audio['raw']['bitrate'] = 0;
+		}
+		$thisfile_mpeg_audio['padding'] = (bool) $thisfile_mpeg_audio['raw']['padding'];
+		$thisfile_mpeg_audio['bitrate'] = $MPEGaudioBitrateLookup[$thisfile_mpeg_audio['version']][$thisfile_mpeg_audio['layer']][$thisfile_mpeg_audio['raw']['bitrate']];
+
+		if (($thisfile_mpeg_audio['bitrate'] == 'free') &amp;&amp; ($offset == $ThisFileInfo['avdataoffset'])) {
+			// only skip multiple frame check if free-format bitstream found at beginning of file
+			// otherwise is quite possibly simply corrupted data
+			$recursivesearch = false;
+		}
+
+		// For Layer 2 there are some combinations of bitrate and mode which are not allowed.
+		if (!$FastMPEGheaderScan &amp;&amp; ($thisfile_mpeg_audio['layer'] == '2')) {
+
+			$ThisFileInfo['audio']['dataformat'] = 'mp2';
+			switch ($thisfile_mpeg_audio['channelmode']) {
+
+				case 'mono':
+					if (($thisfile_mpeg_audio['bitrate'] == 'free') || ($thisfile_mpeg_audio['bitrate'] &lt;= 192000)) {
+						// these are ok
+					} else {
+						$ThisFileInfo['error'][] = $thisfile_mpeg_audio['bitrate'].'kbps not allowed in Layer 2, '.$thisfile_mpeg_audio['channelmode'].'.';
+						return false;
+					}
+					break;
+
+				case 'stereo':
+				case 'joint stereo':
+				case 'dual channel':
+					if (($thisfile_mpeg_audio['bitrate'] == 'free') || ($thisfile_mpeg_audio['bitrate'] == 64000) || ($thisfile_mpeg_audio['bitrate'] &gt;= 96000)) {
+						// these are ok
+					} else {
+						$ThisFileInfo['error'][] = intval(round($thisfile_mpeg_audio['bitrate'] / 1000)).'kbps not allowed in Layer 2, '.$thisfile_mpeg_audio['channelmode'].'.';
+						return false;
+					}
+					break;
+
+			}
+
+		}
+
+
+		if ($ThisFileInfo['audio']['sample_rate'] &gt; 0) {
+			$thisfile_mpeg_audio['framelength'] = getid3_mp3::MPEGaudioFrameLength($thisfile_mpeg_audio['bitrate'], $thisfile_mpeg_audio['version'], $thisfile_mpeg_audio['layer'], (int) $thisfile_mpeg_audio['padding'], $ThisFileInfo['audio']['sample_rate']);
+		}
+
+		$nextframetestoffset = $offset + 1;
+		if ($thisfile_mpeg_audio['bitrate'] != 'free') {
+
+			$ThisFileInfo['audio']['bitrate'] = $thisfile_mpeg_audio['bitrate'];
+
+			if (isset($thisfile_mpeg_audio['framelength'])) {
+				$nextframetestoffset = $offset + $thisfile_mpeg_audio['framelength'];
+			} else {
+				$ThisFileInfo['error'][] = 'Frame at offset('.$offset.') is has an invalid frame length.';
+				return false;
+			}
+
+		}
+
+		$ExpectedNumberOfAudioBytes = 0;
+
+		////////////////////////////////////////////////////////////////////////////////////
+		// Variable-bitrate headers
+
+		if (substr($headerstring, 4 + 32, 4) == 'VBRI') {
+			// Fraunhofer VBR header is hardcoded 'VBRI' at offset 0x24 (36)
+			// specs taken from <A HREF="http://minnie.tuhs.org/pipermail/mp3encoder/2001-January/001800.html">http://minnie.tuhs.org/pipermail/mp3encoder/2001-January/001800.html</A>
+
+			$thisfile_mpeg_audio['bitrate_mode'] = 'vbr';
+			$thisfile_mpeg_audio['VBR_method']   = 'Fraunhofer';
+			$ThisFileInfo['audio']['codec']                = 'Fraunhofer';
+
+			$SideInfoData = substr($headerstring, 4 + 2, 32);
+
+			$FraunhoferVBROffset = 36;
+
+			$thisfile_mpeg_audio['VBR_encoder_version']     = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset +  4, 2)); // VbriVersion
+			$thisfile_mpeg_audio['VBR_encoder_delay']       = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset +  6, 2)); // VbriDelay
+			$thisfile_mpeg_audio['VBR_quality']             = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset +  8, 2)); // VbriQuality
+			$thisfile_mpeg_audio['VBR_bytes']               = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset + 10, 4)); // VbriStreamBytes
+			$thisfile_mpeg_audio['VBR_frames']              = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset + 14, 4)); // VbriStreamFrames
+			$thisfile_mpeg_audio['VBR_seek_offsets']        = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset + 18, 2)); // VbriTableSize
+			$thisfile_mpeg_audio['VBR_seek_scale']          = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset + 20, 2)); // VbriTableScale
+			$thisfile_mpeg_audio['VBR_entry_bytes']         = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset + 22, 2)); // VbriEntryBytes
+			$thisfile_mpeg_audio['VBR_entry_frames']        = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset + 24, 2)); // VbriEntryFrames
+
+			$ExpectedNumberOfAudioBytes = $thisfile_mpeg_audio['VBR_bytes'];
+
+			$previousbyteoffset = $offset;
+			for ($i = 0; $i &lt; $thisfile_mpeg_audio['VBR_seek_offsets']; $i++) {
+				$Fraunhofer_OffsetN = getid3_lib::BigEndian2Int(substr($headerstring, $FraunhoferVBROffset, $thisfile_mpeg_audio['VBR_entry_bytes']));
+				$FraunhoferVBROffset += $thisfile_mpeg_audio['VBR_entry_bytes'];
+				$thisfile_mpeg_audio['VBR_offsets_relative'][$i] = ($Fraunhofer_OffsetN * $thisfile_mpeg_audio['VBR_seek_scale']);
+				$thisfile_mpeg_audio['VBR_offsets_absolute'][$i] = ($Fraunhofer_OffsetN * $thisfile_mpeg_audio['VBR_seek_scale']) + $previousbyteoffset;
+				$previousbyteoffset += $Fraunhofer_OffsetN;
+			}
+
+
+		} else {
+
+			// Xing VBR header is hardcoded 'Xing' at a offset 0x0D (13), 0x15 (21) or 0x24 (36)
+			// depending on MPEG layer and number of channels
+
+			$VBRidOffset = getid3_mp3::XingVBRidOffset($thisfile_mpeg_audio['version'], $thisfile_mpeg_audio['channelmode']);
+			$SideInfoData = substr($headerstring, 4 + 2, $VBRidOffset - 4);
+
+			if ((substr($headerstring, $VBRidOffset, strlen('Xing')) == 'Xing') || (substr($headerstring, $VBRidOffset, strlen('Info')) == 'Info')) {
+				// 'Xing' is traditional Xing VBR frame
+				// 'Info' is LAME-encoded CBR (This was done to avoid CBR files to be recognized as traditional Xing VBR files by some decoders.)
+				// 'Info' *can* legally be used to specify a VBR file as well, however.
+
+				// <A HREF="http://www.multiweb.cz/twoinches/MP3inside.htm">http://www.multiweb.cz/twoinches/MP3inside.htm</A>
+				//00..03 = &quot;Xing&quot; or &quot;Info&quot;
+				//04..07 = Flags:
+				//  0x01  Frames Flag     set if value for number of frames in file is stored
+				//  0x02  Bytes Flag      set if value for filesize in bytes is stored
+				//  0x04  TOC Flag        set if values for TOC are stored
+				//  0x08  VBR Scale Flag  set if values for VBR scale is stored
+				//08..11  Frames: Number of frames in file (including the first Xing/Info one)
+				//12..15  Bytes:  File length in Bytes
+				//16..115  TOC (Table of Contents):
+				//  Contains of 100 indexes (one Byte length) for easier lookup in file. Approximately solves problem with moving inside file.
+				//  Each Byte has a value according this formula:
+				//  (TOC[i] / 256) * fileLenInBytes
+				//  So if song lasts eg. 240 sec. and you want to jump to 60. sec. (and file is 5 000 000 Bytes length) you can use:
+				//  TOC[(60/240)*100] = TOC[25]
+				//  and corresponding Byte in file is then approximately at:
+				//  (TOC[25]/256) * 5000000
+				//116..119  VBR Scale
+
+
+				// should be safe to leave this at 'vbr' and let it be overriden to 'cbr' if a CBR preset/mode is used by LAME
+//				if (substr($headerstring, $VBRidOffset, strlen('Info')) == 'Xing') {
+					$thisfile_mpeg_audio['bitrate_mode'] = 'vbr';
+					$thisfile_mpeg_audio['VBR_method']   = 'Xing';
+//				} else {
+//					$ScanAsCBR = true;
+//					$thisfile_mpeg_audio['bitrate_mode'] = 'cbr';
+//				}
+
+				$thisfile_mpeg_audio['xing_flags_raw'] = getid3_lib::BigEndian2Int(substr($headerstring, $VBRidOffset + 4, 4));
+
+				$thisfile_mpeg_audio['xing_flags']['frames']    = (bool) ($thisfile_mpeg_audio['xing_flags_raw'] &amp; 0x00000001);
+				$thisfile_mpeg_audio['xing_flags']['bytes']     = (bool) ($thisfile_mpeg_audio['xing_flags_raw'] &amp; 0x00000002);
+				$thisfile_mpeg_audio['xing_flags']['toc']       = (bool) ($thisfile_mpeg_audio['xing_flags_raw'] &amp; 0x00000004);
+				$thisfile_mpeg_audio['xing_flags']['vbr_scale'] = (bool) ($thisfile_mpeg_audio['xing_flags_raw'] &amp; 0x00000008);
+
+				if ($thisfile_mpeg_audio['xing_flags']['frames']) {
+					$thisfile_mpeg_audio['VBR_frames'] = getid3_lib::BigEndian2Int(substr($headerstring, $VBRidOffset +  8, 4));
+					//$thisfile_mpeg_audio['VBR_frames']--; // don't count header Xing/Info frame
+				}
+				if ($thisfile_mpeg_audio['xing_flags']['bytes']) {
+					$thisfile_mpeg_audio['VBR_bytes']  = getid3_lib::BigEndian2Int(substr($headerstring, $VBRidOffset + 12, 4));
+				}
+
+				//if (($thisfile_mpeg_audio['bitrate'] == 'free') &amp;&amp; !empty($thisfile_mpeg_audio['VBR_frames']) &amp;&amp; !empty($thisfile_mpeg_audio['VBR_bytes'])) {
+				if (!empty($thisfile_mpeg_audio['VBR_frames']) &amp;&amp; !empty($thisfile_mpeg_audio['VBR_bytes'])) {
+
+					$framelengthfloat = $thisfile_mpeg_audio['VBR_bytes'] / $thisfile_mpeg_audio['VBR_frames'];
+
+					if ($thisfile_mpeg_audio['layer'] == '1') {
+						// BitRate = (((FrameLengthInBytes / 4) - Padding) * SampleRate) / 12
+						//$ThisFileInfo['audio']['bitrate'] = ((($framelengthfloat / 4) - intval($thisfile_mpeg_audio['padding'])) * $thisfile_mpeg_audio['sample_rate']) / 12;
+						$ThisFileInfo['audio']['bitrate'] = ($framelengthfloat / 4) * $thisfile_mpeg_audio['sample_rate'] * (2 / $ThisFileInfo['audio']['channels']) / 12;
+					} else {
+						// Bitrate = ((FrameLengthInBytes - Padding) * SampleRate) / 144
+						//$ThisFileInfo['audio']['bitrate'] = (($framelengthfloat - intval($thisfile_mpeg_audio['padding'])) * $thisfile_mpeg_audio['sample_rate']) / 144;
+						$ThisFileInfo['audio']['bitrate'] = $framelengthfloat * $thisfile_mpeg_audio['sample_rate'] * (2 / $ThisFileInfo['audio']['channels']) / 144;
+					}
+					$thisfile_mpeg_audio['framelength'] = floor($framelengthfloat);
+				}
+
+				if ($thisfile_mpeg_audio['xing_flags']['toc']) {
+					$LAMEtocData = substr($headerstring, $VBRidOffset + 16, 100);
+					for ($i = 0; $i &lt; 100; $i++) {
+						$thisfile_mpeg_audio['toc'][$i] = ord($LAMEtocData{$i});
+					}
+				}
+				if ($thisfile_mpeg_audio['xing_flags']['vbr_scale']) {
+					$thisfile_mpeg_audio['VBR_scale'] = getid3_lib::BigEndian2Int(substr($headerstring, $VBRidOffset + 116, 4));
+				}
+
+
+				// <A HREF="http://gabriel.mp3-tech.org/mp3infotag.html">http://gabriel.mp3-tech.org/mp3infotag.html</A>
+				if (substr($headerstring, $VBRidOffset + 120, 4) == 'LAME') {
+
+					// shortcut
+					$thisfile_mpeg_audio['LAME'] = array();
+					$thisfile_mpeg_audio_lame    = &amp;$thisfile_mpeg_audio['LAME'];
+
+
+					$thisfile_mpeg_audio_lame['long_version']  = substr($headerstring, $VBRidOffset + 120, 20);
+					$thisfile_mpeg_audio_lame['short_version'] = substr($thisfile_mpeg_audio_lame['long_version'], 0, 9);
+
+					if ($thisfile_mpeg_audio_lame['short_version'] &gt;= 'LAME3.90') {
+
+						// extra 11 chars are not part of version string when LAMEtag present
+						unset($thisfile_mpeg_audio_lame['long_version']);
+
+						// It the LAME tag was only introduced in LAME v3.90
+						// <A HREF="http://www.hydrogenaudio.org/?act=ST&amp;f=15&amp;t=9933">http://www.hydrogenaudio.org/?act=ST&amp;f=15&amp;t=9933</A>
+
+						// Offsets of various bytes in <A HREF="http://gabriel.mp3-tech.org/mp3infotag.html">http://gabriel.mp3-tech.org/mp3infotag.html</A>
+						// are assuming a 'Xing' identifier offset of 0x24, which is the case for
+						// MPEG-1 non-mono, but not for other combinations
+						$LAMEtagOffsetContant = $VBRidOffset - 0x24;
+
+						// shortcuts
+						$thisfile_mpeg_audio_lame['RGAD']    = array('track'=&gt;array(), 'album'=&gt;array());
+						$thisfile_mpeg_audio_lame_RGAD       = &amp;$thisfile_mpeg_audio_lame['RGAD'];
+						$thisfile_mpeg_audio_lame_RGAD_track = &amp;$thisfile_mpeg_audio_lame_RGAD['track'];
+						$thisfile_mpeg_audio_lame_RGAD_album = &amp;$thisfile_mpeg_audio_lame_RGAD['album'];
+						$thisfile_mpeg_audio_lame['raw'] = array();
+						$thisfile_mpeg_audio_lame_raw    = &amp;$thisfile_mpeg_audio_lame['raw'];
+
+						// byte $9B  VBR Quality
+						// This field is there to indicate a quality level, although the scale was not precised in the original Xing specifications.
+						// Actually overwrites original Xing bytes
+						unset($thisfile_mpeg_audio['VBR_scale']);
+						$thisfile_mpeg_audio_lame['vbr_quality'] = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0x9B, 1));
+
+						// bytes $9C-$A4  Encoder short VersionString
+						$thisfile_mpeg_audio_lame['short_version'] = substr($headerstring, $LAMEtagOffsetContant + 0x9C, 9);
+
+						// byte $A5  Info Tag revision + VBR method
+						$LAMEtagRevisionVBRmethod = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xA5, 1));
+
+						$thisfile_mpeg_audio_lame['tag_revision']      = ($LAMEtagRevisionVBRmethod &amp; 0xF0) &gt;&gt; 4;
+						$thisfile_mpeg_audio_lame_raw['vbr_method'] =  $LAMEtagRevisionVBRmethod &amp; 0x0F;
+						$thisfile_mpeg_audio_lame['vbr_method']        = getid3_mp3::LAMEvbrMethodLookup($thisfile_mpeg_audio_lame_raw['vbr_method']);
+						$thisfile_mpeg_audio['bitrate_mode']           = substr($thisfile_mpeg_audio_lame['vbr_method'], 0, 3); // usually either 'cbr' or 'vbr', but truncates 'vbr-old / vbr-rh' to 'vbr'
+
+						// byte $A6  Lowpass filter value
+						$thisfile_mpeg_audio_lame['lowpass_frequency'] = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xA6, 1)) * 100;
+
+						// bytes $A7-$AE  Replay Gain
+						// <A HREF="http://privatewww.essex.ac.uk/~djmrob/replaygain/rg_data_format.html">http://privatewww.essex.ac.uk/~djmrob/replaygain/rg_data_format.html</A>
+						// bytes $A7-$AA : 32 bit floating point &quot;Peak signal amplitude&quot;
+						if ($thisfile_mpeg_audio_lame['short_version'] &gt;= 'LAME3.94b') {
+							// LAME 3.94a16 and later - 9.23 fixed point
+							// ie 0x0059E2EE / (2^23) = 5890798 / 8388608 = 0.7022378444671630859375
+							$thisfile_mpeg_audio_lame_RGAD['peak_amplitude'] = (float) ((getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xA7, 4))) / 8388608);
+						} else {
+							// LAME 3.94a15 and earlier - 32-bit floating point
+							// Actually 3.94a16 will fall in here too and be WRONG, but is hard to detect 3.94a16 vs 3.94a15
+							$thisfile_mpeg_audio_lame_RGAD['peak_amplitude'] = getid3_lib::LittleEndian2Float(substr($headerstring, $LAMEtagOffsetContant + 0xA7, 4));
+						}
+						if ($thisfile_mpeg_audio_lame_RGAD['peak_amplitude'] == 0) {
+							unset($thisfile_mpeg_audio_lame_RGAD['peak_amplitude']);
+						} else {
+							$thisfile_mpeg_audio_lame_RGAD['peak_db'] = getid3_lib::RGADamplitude2dB($thisfile_mpeg_audio_lame_RGAD['peak_amplitude']);
+						}
+
+						$thisfile_mpeg_audio_lame_raw['RGAD_track']      =   getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xAB, 2));
+						$thisfile_mpeg_audio_lame_raw['RGAD_album']      =   getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xAD, 2));
+
+
+						if ($thisfile_mpeg_audio_lame_raw['RGAD_track'] != 0) {
+
+							$thisfile_mpeg_audio_lame_RGAD_track['raw']['name']        = ($thisfile_mpeg_audio_lame_raw['RGAD_track'] &amp; 0xE000) &gt;&gt; 13;
+							$thisfile_mpeg_audio_lame_RGAD_track['raw']['originator']  = ($thisfile_mpeg_audio_lame_raw['RGAD_track'] &amp; 0x1C00) &gt;&gt; 10;
+							$thisfile_mpeg_audio_lame_RGAD_track['raw']['sign_bit']    = ($thisfile_mpeg_audio_lame_raw['RGAD_track'] &amp; 0x0200) &gt;&gt; 9;
+							$thisfile_mpeg_audio_lame_RGAD_track['raw']['gain_adjust'] =  $thisfile_mpeg_audio_lame_raw['RGAD_track'] &amp; 0x01FF;
+							$thisfile_mpeg_audio_lame_RGAD_track['name']       = getid3_lib::RGADnameLookup($thisfile_mpeg_audio_lame_RGAD_track['raw']['name']);
+							$thisfile_mpeg_audio_lame_RGAD_track['originator'] = getid3_lib::RGADoriginatorLookup($thisfile_mpeg_audio_lame_RGAD_track['raw']['originator']);
+							$thisfile_mpeg_audio_lame_RGAD_track['gain_db']    = getid3_lib::RGADadjustmentLookup($thisfile_mpeg_audio_lame_RGAD_track['raw']['gain_adjust'], $thisfile_mpeg_audio_lame_RGAD_track['raw']['sign_bit']);
+
+							if (!empty($thisfile_mpeg_audio_lame_RGAD['peak_amplitude'])) {
+								$ThisFileInfo['replay_gain']['track']['peak']   = $thisfile_mpeg_audio_lame_RGAD['peak_amplitude'];
+							}
+							$ThisFileInfo['replay_gain']['track']['originator'] = $thisfile_mpeg_audio_lame_RGAD_track['originator'];
+							$ThisFileInfo['replay_gain']['track']['adjustment'] = $thisfile_mpeg_audio_lame_RGAD_track['gain_db'];
+						} else {
+							unset($thisfile_mpeg_audio_lame_RGAD['track']);
+						}
+						if ($thisfile_mpeg_audio_lame_raw['RGAD_album'] != 0) {
+
+							$thisfile_mpeg_audio_lame_RGAD_album['raw']['name']        = ($thisfile_mpeg_audio_lame_raw['RGAD_album'] &amp; 0xE000) &gt;&gt; 13;
+							$thisfile_mpeg_audio_lame_RGAD_album['raw']['originator']  = ($thisfile_mpeg_audio_lame_raw['RGAD_album'] &amp; 0x1C00) &gt;&gt; 10;
+							$thisfile_mpeg_audio_lame_RGAD_album['raw']['sign_bit']    = ($thisfile_mpeg_audio_lame_raw['RGAD_album'] &amp; 0x0200) &gt;&gt; 9;
+							$thisfile_mpeg_audio_lame_RGAD_album['raw']['gain_adjust'] = $thisfile_mpeg_audio_lame_raw['RGAD_album'] &amp; 0x01FF;
+							$thisfile_mpeg_audio_lame_RGAD_album['name']       = getid3_lib::RGADnameLookup($thisfile_mpeg_audio_lame_RGAD_album['raw']['name']);
+							$thisfile_mpeg_audio_lame_RGAD_album['originator'] = getid3_lib::RGADoriginatorLookup($thisfile_mpeg_audio_lame_RGAD_album['raw']['originator']);
+							$thisfile_mpeg_audio_lame_RGAD_album['gain_db']    = getid3_lib::RGADadjustmentLookup($thisfile_mpeg_audio_lame_RGAD_album['raw']['gain_adjust'], $thisfile_mpeg_audio_lame_RGAD_album['raw']['sign_bit']);
+
+							if (!empty($thisfile_mpeg_audio_lame_RGAD['peak_amplitude'])) {
+								$ThisFileInfo['replay_gain']['album']['peak']   = $thisfile_mpeg_audio_lame_RGAD['peak_amplitude'];
+							}
+							$ThisFileInfo['replay_gain']['album']['originator'] = $thisfile_mpeg_audio_lame_RGAD_album['originator'];
+							$ThisFileInfo['replay_gain']['album']['adjustment'] = $thisfile_mpeg_audio_lame_RGAD_album['gain_db'];
+						} else {
+							unset($thisfile_mpeg_audio_lame_RGAD['album']);
+						}
+						if (empty($thisfile_mpeg_audio_lame_RGAD)) {
+							unset($thisfile_mpeg_audio_lame['RGAD']);
+						}
+
+
+						// byte $AF  Encoding flags + ATH Type
+						$EncodingFlagsATHtype = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xAF, 1));
+						$thisfile_mpeg_audio_lame['encoding_flags']['nspsytune']   = (bool) ($EncodingFlagsATHtype &amp; 0x10);
+						$thisfile_mpeg_audio_lame['encoding_flags']['nssafejoint'] = (bool) ($EncodingFlagsATHtype &amp; 0x20);
+						$thisfile_mpeg_audio_lame['encoding_flags']['nogap_next']  = (bool) ($EncodingFlagsATHtype &amp; 0x40);
+						$thisfile_mpeg_audio_lame['encoding_flags']['nogap_prev']  = (bool) ($EncodingFlagsATHtype &amp; 0x80);
+						$thisfile_mpeg_audio_lame['ath_type']                      =         $EncodingFlagsATHtype &amp; 0x0F;
+
+						// byte $B0  if ABR {specified bitrate} else {minimal bitrate}
+						$thisfile_mpeg_audio_lame['raw']['abrbitrate_minbitrate'] = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xB0, 1));
+						if ($thisfile_mpeg_audio_lame_raw['vbr_method'] == 2) { // Average BitRate (ABR)
+							$thisfile_mpeg_audio_lame['bitrate_abr'] = $thisfile_mpeg_audio_lame['raw']['abrbitrate_minbitrate'];
+						} elseif ($thisfile_mpeg_audio_lame_raw['vbr_method'] == 1) { // Constant BitRate (CBR)
+							// ignore
+						} elseif ($thisfile_mpeg_audio_lame['raw']['abrbitrate_minbitrate'] &gt; 0) { // Variable BitRate (VBR) - minimum bitrate
+							$thisfile_mpeg_audio_lame['bitrate_min'] = $thisfile_mpeg_audio_lame['raw']['abrbitrate_minbitrate'];
+						}
+
+						// bytes $B1-$B3  Encoder delays
+						$EncoderDelays = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xB1, 3));
+						$thisfile_mpeg_audio_lame['encoder_delay'] = ($EncoderDelays &amp; 0xFFF000) &gt;&gt; 12;
+						$thisfile_mpeg_audio_lame['end_padding']   =  $EncoderDelays &amp; 0x000FFF;
+
+						// byte $B4  Misc
+						$MiscByte = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xB4, 1));
+						$thisfile_mpeg_audio_lame_raw['noise_shaping']       = ($MiscByte &amp; 0x03);
+						$thisfile_mpeg_audio_lame_raw['stereo_mode']         = ($MiscByte &amp; 0x1C) &gt;&gt; 2;
+						$thisfile_mpeg_audio_lame_raw['not_optimal_quality'] = ($MiscByte &amp; 0x20) &gt;&gt; 5;
+						$thisfile_mpeg_audio_lame_raw['source_sample_freq']  = ($MiscByte &amp; 0xC0) &gt;&gt; 6;
+						$thisfile_mpeg_audio_lame['noise_shaping']       = $thisfile_mpeg_audio_lame_raw['noise_shaping'];
+						$thisfile_mpeg_audio_lame['stereo_mode']         = getid3_mp3::LAMEmiscStereoModeLookup($thisfile_mpeg_audio_lame_raw['stereo_mode']);
+						$thisfile_mpeg_audio_lame['not_optimal_quality'] = (bool) $thisfile_mpeg_audio_lame_raw['not_optimal_quality'];
+						$thisfile_mpeg_audio_lame['source_sample_freq']  = getid3_mp3::LAMEmiscSourceSampleFrequencyLookup($thisfile_mpeg_audio_lame_raw['source_sample_freq']);
+
+						// byte $B5  MP3 Gain
+						$thisfile_mpeg_audio_lame_raw['mp3_gain'] = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xB5, 1), false, true);
+						$thisfile_mpeg_audio_lame['mp3_gain_db']     = (getid3_lib::RGADamplitude2dB(2) / 4) * $thisfile_mpeg_audio_lame_raw['mp3_gain'];
+						$thisfile_mpeg_audio_lame['mp3_gain_factor'] = pow(2, ($thisfile_mpeg_audio_lame['mp3_gain_db'] / 6));
+
+						// bytes $B6-$B7  Preset and surround info
+						$PresetSurroundBytes = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xB6, 2));
+						// Reserved                                                    = ($PresetSurroundBytes &amp; 0xC000);
+						$thisfile_mpeg_audio_lame_raw['surround_info'] = ($PresetSurroundBytes &amp; 0x3800);
+						$thisfile_mpeg_audio_lame['surround_info']     = getid3_mp3::LAMEsurroundInfoLookup($thisfile_mpeg_audio_lame_raw['surround_info']);
+						$thisfile_mpeg_audio_lame['preset_used_id']    = ($PresetSurroundBytes &amp; 0x07FF);
+						$thisfile_mpeg_audio_lame['preset_used']       = getid3_mp3::LAMEpresetUsedLookup($thisfile_mpeg_audio_lame);
+						if (!empty($thisfile_mpeg_audio_lame['preset_used_id']) &amp;&amp; empty($thisfile_mpeg_audio_lame['preset_used'])) {
+							$ThisFileInfo['warning'][] = 'Unknown LAME preset used ('.$thisfile_mpeg_audio_lame['preset_used_id'].') - please report to <A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>';
+						}
+						if (($thisfile_mpeg_audio_lame['short_version'] == 'LAME3.90.') &amp;&amp; !empty($thisfile_mpeg_audio_lame['preset_used_id'])) {
+							// this may change if 3.90.4 ever comes out
+							$thisfile_mpeg_audio_lame['short_version'] = 'LAME3.90.3';
+						}
+
+						// bytes $B8-$BB  MusicLength
+						$thisfile_mpeg_audio_lame['audio_bytes'] = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xB8, 4));
+						$ExpectedNumberOfAudioBytes = (($thisfile_mpeg_audio_lame['audio_bytes'] &gt; 0) ? $thisfile_mpeg_audio_lame['audio_bytes'] : $thisfile_mpeg_audio['VBR_bytes']);
+
+						// bytes $BC-$BD  MusicCRC
+						$thisfile_mpeg_audio_lame['music_crc']    = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xBC, 2));
+
+						// bytes $BE-$BF  CRC-16 of Info Tag
+						$thisfile_mpeg_audio_lame['lame_tag_crc'] = getid3_lib::BigEndian2Int(substr($headerstring, $LAMEtagOffsetContant + 0xBE, 2));
+
+
+						// LAME CBR
+						if ($thisfile_mpeg_audio_lame_raw['vbr_method'] == 1) {
+
+							$thisfile_mpeg_audio['bitrate_mode'] = 'cbr';
+							$thisfile_mpeg_audio['bitrate'] = getid3_mp3::ClosestStandardMP3Bitrate($thisfile_mpeg_audio['bitrate']);
+							$ThisFileInfo['audio']['bitrate'] = $thisfile_mpeg_audio['bitrate'];
+							//if (empty($thisfile_mpeg_audio['bitrate']) || (!empty($thisfile_mpeg_audio_lame['bitrate_min']) &amp;&amp; ($thisfile_mpeg_audio_lame['bitrate_min'] != 255))) {
+							//	$thisfile_mpeg_audio['bitrate'] = $thisfile_mpeg_audio_lame['bitrate_min'];
+							//}
+
+						}
+
+					}
+				}
+
+			} else {
+
+				// not Fraunhofer or Xing VBR methods, most likely CBR (but could be VBR with no header)
+				$thisfile_mpeg_audio['bitrate_mode'] = 'cbr';
+				if ($recursivesearch) {
+					$thisfile_mpeg_audio['bitrate_mode'] = 'vbr';
+					if (getid3_mp3::RecursiveFrameScanning($fd, $ThisFileInfo, $offset, $nextframetestoffset, true)) {
+						$recursivesearch = false;
+						$thisfile_mpeg_audio['bitrate_mode'] = 'cbr';
+					}
+					if ($thisfile_mpeg_audio['bitrate_mode'] == 'vbr') {
+						$ThisFileInfo['warning'][] = 'VBR file with no VBR header. Bitrate values calculated from actual frame bitrates.';
+					}
+				}
+
+			}
+
+		}
+
+		if (($ExpectedNumberOfAudioBytes &gt; 0) &amp;&amp; ($ExpectedNumberOfAudioBytes != ($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']))) {
+			if ($ExpectedNumberOfAudioBytes &gt; ($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset'])) {
+				if (($ExpectedNumberOfAudioBytes - ($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset'])) == 1) {
+					$ThisFileInfo['warning'][] = 'Last byte of data truncated (this is a known bug in Meracl ID3 Tag Writer before v1.3.5)';
+				} else {
+					$ThisFileInfo['warning'][] = 'Probable truncated file: expecting '.$ExpectedNumberOfAudioBytes.' bytes of audio data, only found '.($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']).' (short by '.($ExpectedNumberOfAudioBytes - ($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset'])).' bytes)';
+				}
+			} else {
+				if ((($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) - $ExpectedNumberOfAudioBytes) == 1) {
+				//	$prenullbytefileoffset = ftell($fd);
+				//	fseek($fd, $ThisFileInfo['avdataend'], SEEK_SET);
+				//	$PossibleNullByte = fread($fd, 1);
+				//	fseek($fd, $prenullbytefileoffset, SEEK_SET);
+				//	if ($PossibleNullByte === &quot;\x00&quot;) {
+						$ThisFileInfo['avdataend']--;
+				//		$ThisFileInfo['warning'][] = 'Extra null byte at end of MP3 data assumed to be RIFF padding and therefore ignored';
+				//	} else {
+				//		$ThisFileInfo['warning'][] = 'Too much data in file: expecting '.$ExpectedNumberOfAudioBytes.' bytes of audio data, found '.($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']).' ('.(($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) - $ExpectedNumberOfAudioBytes).' bytes too many)';
+				//	}
+				} else {
+					$ThisFileInfo['warning'][] = 'Too much data in file: expecting '.$ExpectedNumberOfAudioBytes.' bytes of audio data, found '.($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']).' ('.(($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) - $ExpectedNumberOfAudioBytes).' bytes too many)';
+				}
+			}
+		}
+
+		if (($thisfile_mpeg_audio['bitrate'] == 'free') &amp;&amp; empty($ThisFileInfo['audio']['bitrate'])) {
+			if (($offset == $ThisFileInfo['avdataoffset']) &amp;&amp; empty($thisfile_mpeg_audio['VBR_frames'])) {
+				$framebytelength = getid3_mp3::FreeFormatFrameLength($fd, $offset, $ThisFileInfo, true);
+				if ($framebytelength &gt; 0) {
+					$thisfile_mpeg_audio['framelength'] = $framebytelength;
+					if ($thisfile_mpeg_audio['layer'] == '1') {
+						// BitRate = (((FrameLengthInBytes / 4) - Padding) * SampleRate) / 12
+						$ThisFileInfo['audio']['bitrate'] = ((($framebytelength / 4) - intval($thisfile_mpeg_audio['padding'])) * $thisfile_mpeg_audio['sample_rate']) / 12;
+					} else {
+						// Bitrate = ((FrameLengthInBytes - Padding) * SampleRate) / 144
+						$ThisFileInfo['audio']['bitrate'] = (($framebytelength - intval($thisfile_mpeg_audio['padding'])) * $thisfile_mpeg_audio['sample_rate']) / 144;
+					}
+				} else {
+					$ThisFileInfo['error'][] = 'Error calculating frame length of free-format MP3 without Xing/LAME header';
+				}
+			}
+		}
+
+		if (!empty($thisfile_mpeg_audio['VBR_frames'])) {
+			switch ($thisfile_mpeg_audio['bitrate_mode']) {
+				case 'vbr':
+				case 'abr':
+					if (($thisfile_mpeg_audio['version'] == '1') &amp;&amp; ($thisfile_mpeg_audio['layer'] == 1)) {
+						$thisfile_mpeg_audio['VBR_bitrate'] = (($thisfile_mpeg_audio['VBR_bytes'] / $thisfile_mpeg_audio['VBR_frames']) * 8) * ($ThisFileInfo['audio']['sample_rate'] / 384);
+					} elseif ((($thisfile_mpeg_audio['version'] == '2') || ($thisfile_mpeg_audio['version'] == '2.5')) &amp;&amp; ($thisfile_mpeg_audio['layer'] == 3)) {
+						$thisfile_mpeg_audio['VBR_bitrate'] = (($thisfile_mpeg_audio['VBR_bytes'] / $thisfile_mpeg_audio['VBR_frames']) * 8) * ($ThisFileInfo['audio']['sample_rate'] / 576);
+					} else {
+						$thisfile_mpeg_audio['VBR_bitrate'] = (($thisfile_mpeg_audio['VBR_bytes'] / $thisfile_mpeg_audio['VBR_frames']) * 8) * ($ThisFileInfo['audio']['sample_rate'] / 1152);
+					}
+					if ($thisfile_mpeg_audio['VBR_bitrate'] &gt; 0) {
+						$ThisFileInfo['audio']['bitrate']         = $thisfile_mpeg_audio['VBR_bitrate'];
+						$thisfile_mpeg_audio['bitrate'] = $thisfile_mpeg_audio['VBR_bitrate']; // to avoid confusion
+					}
+					break;
+			}
+		}
+
+		// End variable-bitrate headers
+		////////////////////////////////////////////////////////////////////////////////////
+
+		if ($recursivesearch) {
+
+			if (!getid3_mp3::RecursiveFrameScanning($fd, $ThisFileInfo, $offset, $nextframetestoffset, $ScanAsCBR)) {
+				return false;
+			}
+
+		}
+
+
+		//if (false) {
+		//    // experimental side info parsing section - not returning anything useful yet
+		//
+		//    $SideInfoBitstream = getid3_lib::BigEndian2Bin($SideInfoData);
+		//    $SideInfoOffset = 0;
+		//
+		//    if ($thisfile_mpeg_audio['version'] == '1') {
+		//        if ($thisfile_mpeg_audio['channelmode'] == 'mono') {
+		//            // MPEG-1 (mono)
+		//            $thisfile_mpeg_audio['side_info']['main_data_begin'] = substr($SideInfoBitstream, $SideInfoOffset, 9);
+		//            $SideInfoOffset += 9;
+		//            $SideInfoOffset += 5;
+		//        } else {
+		//            // MPEG-1 (stereo, joint-stereo, dual-channel)
+		//            $thisfile_mpeg_audio['side_info']['main_data_begin'] = substr($SideInfoBitstream, $SideInfoOffset, 9);
+		//            $SideInfoOffset += 9;
+		//            $SideInfoOffset += 3;
+		//        }
+		//    } else { // 2 or 2.5
+		//        if ($thisfile_mpeg_audio['channelmode'] == 'mono') {
+		//            // MPEG-2, MPEG-2.5 (mono)
+		//            $thisfile_mpeg_audio['side_info']['main_data_begin'] = substr($SideInfoBitstream, $SideInfoOffset, 8);
+		//            $SideInfoOffset += 8;
+		//            $SideInfoOffset += 1;
+		//        } else {
+		//            // MPEG-2, MPEG-2.5 (stereo, joint-stereo, dual-channel)
+		//            $thisfile_mpeg_audio['side_info']['main_data_begin'] = substr($SideInfoBitstream, $SideInfoOffset, 8);
+		//            $SideInfoOffset += 8;
+		//            $SideInfoOffset += 2;
+		//        }
+		//    }
+		//
+		//    if ($thisfile_mpeg_audio['version'] == '1') {
+		//        for ($channel = 0; $channel &lt; $ThisFileInfo['audio']['channels']; $channel++) {
+		//            for ($scfsi_band = 0; $scfsi_band &lt; 4; $scfsi_band++) {
+		//                $thisfile_mpeg_audio['scfsi'][$channel][$scfsi_band] = substr($SideInfoBitstream, $SideInfoOffset, 1);
+		//                $SideInfoOffset += 2;
+		//            }
+		//        }
+		//    }
+		//    for ($granule = 0; $granule &lt; (($thisfile_mpeg_audio['version'] == '1') ? 2 : 1); $granule++) {
+		//        for ($channel = 0; $channel &lt; $ThisFileInfo['audio']['channels']; $channel++) {
+		//            $thisfile_mpeg_audio['part2_3_length'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 12);
+		//            $SideInfoOffset += 12;
+		//            $thisfile_mpeg_audio['big_values'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 9);
+		//            $SideInfoOffset += 9;
+		//            $thisfile_mpeg_audio['global_gain'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 8);
+		//            $SideInfoOffset += 8;
+		//            if ($thisfile_mpeg_audio['version'] == '1') {
+		//                $thisfile_mpeg_audio['scalefac_compress'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 4);
+		//                $SideInfoOffset += 4;
+		//            } else {
+		//                $thisfile_mpeg_audio['scalefac_compress'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 9);
+		//                $SideInfoOffset += 9;
+		//            }
+		//            $thisfile_mpeg_audio['window_switching_flag'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 1);
+		//            $SideInfoOffset += 1;
+		//
+		//            if ($thisfile_mpeg_audio['window_switching_flag'][$granule][$channel] == '1') {
+		//
+		//                $thisfile_mpeg_audio['block_type'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 2);
+		//                $SideInfoOffset += 2;
+		//                $thisfile_mpeg_audio['mixed_block_flag'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 1);
+		//                $SideInfoOffset += 1;
+		//
+		//                for ($region = 0; $region &lt; 2; $region++) {
+		//                    $thisfile_mpeg_audio['table_select'][$granule][$channel][$region] = substr($SideInfoBitstream, $SideInfoOffset, 5);
+		//                    $SideInfoOffset += 5;
+		//                }
+		//                $thisfile_mpeg_audio['table_select'][$granule][$channel][2] = 0;
+		//
+		//                for ($window = 0; $window &lt; 3; $window++) {
+		//                    $thisfile_mpeg_audio['subblock_gain'][$granule][$channel][$window] = substr($SideInfoBitstream, $SideInfoOffset, 3);
+		//                    $SideInfoOffset += 3;
+		//                }
+		//
+		//            } else {
+		//
+		//                for ($region = 0; $region &lt; 3; $region++) {
+		//                    $thisfile_mpeg_audio['table_select'][$granule][$channel][$region] = substr($SideInfoBitstream, $SideInfoOffset, 5);
+		//                    $SideInfoOffset += 5;
+		//                }
+		//
+		//                $thisfile_mpeg_audio['region0_count'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 4);
+		//                $SideInfoOffset += 4;
+		//                $thisfile_mpeg_audio['region1_count'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 3);
+		//                $SideInfoOffset += 3;
+		//                $thisfile_mpeg_audio['block_type'][$granule][$channel] = 0;
+		//            }
+		//
+		//            if ($thisfile_mpeg_audio['version'] == '1') {
+		//                $thisfile_mpeg_audio['preflag'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 1);
+		//                $SideInfoOffset += 1;
+		//            }
+		//            $thisfile_mpeg_audio['scalefac_scale'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 1);
+		//            $SideInfoOffset += 1;
+		//            $thisfile_mpeg_audio['count1table_select'][$granule][$channel] = substr($SideInfoBitstream, $SideInfoOffset, 1);
+		//            $SideInfoOffset += 1;
+		//        }
+		//    }
+		//}
+
+		return true;
+	}
+
+	function RecursiveFrameScanning(&amp;$fd, &amp;$ThisFileInfo, &amp;$offset, &amp;$nextframetestoffset, $ScanAsCBR) {
+		for ($i = 0; $i &lt; GETID3_MP3_VALID_CHECK_FRAMES; $i++) {
+			// check next GETID3_MP3_VALID_CHECK_FRAMES frames for validity, to make sure we haven't run across a false synch
+			if (($nextframetestoffset + 4) &gt;= $ThisFileInfo['avdataend']) {
+				// end of file
+				return true;
+			}
+
+			$nextframetestarray = array('error'=&gt;'', 'warning'=&gt;'', 'avdataend'=&gt;$ThisFileInfo['avdataend'], 'avdataoffset'=&gt;$ThisFileInfo['avdataoffset']);
+			if (getid3_mp3::decodeMPEGaudioHeader($fd, $nextframetestoffset, $nextframetestarray, false)) {
+				if ($ScanAsCBR) {
+					// force CBR mode, used for trying to pick out invalid audio streams with
+					// valid(?) VBR headers, or VBR streams with no VBR header
+					if (!isset($nextframetestarray['mpeg']['audio']['bitrate']) || !isset($ThisFileInfo['mpeg']['audio']['bitrate']) || ($nextframetestarray['mpeg']['audio']['bitrate'] != $ThisFileInfo['mpeg']['audio']['bitrate'])) {
+						return false;
+					}
+				}
+
+
+				// next frame is OK, get ready to check the one after that
+				if (isset($nextframetestarray['mpeg']['audio']['framelength']) &amp;&amp; ($nextframetestarray['mpeg']['audio']['framelength'] &gt; 0)) {
+					$nextframetestoffset += $nextframetestarray['mpeg']['audio']['framelength'];
+				} else {
+					$ThisFileInfo['error'][] = 'Frame at offset ('.$offset.') is has an invalid frame length.';
+					return false;
+				}
+
+			} else {
+
+				// next frame is not valid, note the error and fail, so scanning can contiue for a valid frame sequence
+				$ThisFileInfo['error'][] = 'Frame at offset ('.$offset.') is valid, but the next one at ('.$nextframetestoffset.') is not.';
+
+				return false;
+			}
+		}
+		return true;
+	}
+
+	function FreeFormatFrameLength($fd, $offset, &amp;$ThisFileInfo, $deepscan=false) {
+		fseek($fd, $offset, SEEK_SET);
+		$MPEGaudioData = fread($fd, 32768);
+
+		$SyncPattern1 = substr($MPEGaudioData, 0, 4);
+		// may be different pattern due to padding
+		$SyncPattern2 = $SyncPattern1{0}.$SyncPattern1{1}.chr(ord($SyncPattern1{2}) | 0x02).$SyncPattern1{3};
+		if ($SyncPattern2 === $SyncPattern1) {
+			$SyncPattern2 = $SyncPattern1{0}.$SyncPattern1{1}.chr(ord($SyncPattern1{2}) &amp; 0xFD).$SyncPattern1{3};
+		}
+
+		$framelength = false;
+		$framelength1 = strpos($MPEGaudioData, $SyncPattern1, 4);
+		$framelength2 = strpos($MPEGaudioData, $SyncPattern2, 4);
+		if ($framelength1 &gt; 4) {
+			$framelength = $framelength1;
+		}
+		if (($framelength2 &gt; 4) &amp;&amp; ($framelength2 &lt; $framelength1)) {
+			$framelength = $framelength2;
+		}
+		if (!$framelength) {
+
+			// LAME 3.88 has a different value for modeextension on the first frame vs the rest
+			$framelength1 = strpos($MPEGaudioData, substr($SyncPattern1, 0, 3), 4);
+			$framelength2 = strpos($MPEGaudioData, substr($SyncPattern2, 0, 3), 4);
+
+			if ($framelength1 &gt; 4) {
+				$framelength = $framelength1;
+			}
+			if (($framelength2 &gt; 4) &amp;&amp; ($framelength2 &lt; $framelength1)) {
+				$framelength = $framelength2;
+			}
+			if (!$framelength) {
+				$ThisFileInfo['error'][] = 'Cannot find next free-format synch pattern ('.getid3_lib::PrintHexBytes($SyncPattern1).' or '.getid3_lib::PrintHexBytes($SyncPattern2).') after offset '.$offset;
+				return false;
+			} else {
+				$ThisFileInfo['warning'][] = 'ModeExtension varies between first frame and other frames (known free-format issue in LAME 3.88)';
+				$ThisFileInfo['audio']['codec']   = 'LAME';
+				$ThisFileInfo['audio']['encoder'] = 'LAME3.88';
+				$SyncPattern1 = substr($SyncPattern1, 0, 3);
+				$SyncPattern2 = substr($SyncPattern2, 0, 3);
+			}
+		}
+
+		if ($deepscan) {
+
+			$ActualFrameLengthValues = array();
+			$nextoffset = $offset + $framelength;
+			while ($nextoffset &lt; ($ThisFileInfo['avdataend'] - 6)) {
+				fseek($fd, $nextoffset - 1, SEEK_SET);
+				$NextSyncPattern = fread($fd, 6);
+				if ((substr($NextSyncPattern, 1, strlen($SyncPattern1)) == $SyncPattern1) || (substr($NextSyncPattern, 1, strlen($SyncPattern2)) == $SyncPattern2)) {
+					// good - found where expected
+					$ActualFrameLengthValues[] = $framelength;
+				} elseif ((substr($NextSyncPattern, 0, strlen($SyncPattern1)) == $SyncPattern1) || (substr($NextSyncPattern, 0, strlen($SyncPattern2)) == $SyncPattern2)) {
+					// ok - found one byte earlier than expected (last frame wasn't padded, first frame was)
+					$ActualFrameLengthValues[] = ($framelength - 1);
+					$nextoffset--;
+				} elseif ((substr($NextSyncPattern, 2, strlen($SyncPattern1)) == $SyncPattern1) || (substr($NextSyncPattern, 2, strlen($SyncPattern2)) == $SyncPattern2)) {
+					// ok - found one byte later than expected (last frame was padded, first frame wasn't)
+					$ActualFrameLengthValues[] = ($framelength + 1);
+					$nextoffset++;
+				} else {
+					$ThisFileInfo['error'][] = 'Did not find expected free-format sync pattern at offset '.$nextoffset;
+					return false;
+				}
+				$nextoffset += $framelength;
+			}
+			if (count($ActualFrameLengthValues) &gt; 0) {
+				$framelength = intval(round(array_sum($ActualFrameLengthValues) / count($ActualFrameLengthValues)));
+			}
+		}
+		return $framelength;
+	}
+
+	function getOnlyMPEGaudioInfoBruteForce($fd, &amp;$ThisFileInfo) {
+
+		$MPEGaudioHeaderDecodeCache = array();
+		$MPEGaudioHeaderValidCache  = array();
+		$MPEGaudioHeaderLengthCache = array();
+		$MPEGaudioVersionLookup       = getid3_mp3::MPEGaudioVersionArray();
+		$MPEGaudioLayerLookup         = getid3_mp3::MPEGaudioLayerArray();
+		$MPEGaudioBitrateLookup       = getid3_mp3::MPEGaudioBitrateArray();
+		$MPEGaudioFrequencyLookup     = getid3_mp3::MPEGaudioFrequencyArray();
+		$MPEGaudioChannelModeLookup   = getid3_mp3::MPEGaudioChannelModeArray();
+		$MPEGaudioModeExtensionLookup = getid3_mp3::MPEGaudioModeExtensionArray();
+		$MPEGaudioEmphasisLookup      = getid3_mp3::MPEGaudioEmphasisArray();
+		$LongMPEGversionLookup   = array();
+		$LongMPEGlayerLookup     = array();
+		$LongMPEGbitrateLookup   = array();
+		$LongMPEGpaddingLookup   = array();
+		$LongMPEGfrequencyLookup = array();
+
+		$Distribution['bitrate']   = array();
+		$Distribution['frequency'] = array();
+		$Distribution['layer']     = array();
+		$Distribution['version']   = array();
+		$Distribution['padding']   = array();
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+		$previousvalidframe = $ThisFileInfo['avdataoffset'];
+		while (ftell($fd) &lt; $ThisFileInfo['avdataend']) {
+			set_time_limit(30);
+			$head4 = fread($fd, 4);
+			if (strlen($head4) &lt; 4) {
+				break;
+			}
+			if ($head4{0} != &quot;\xFF&quot;) {
+				for ($i = 1; $i &lt; 4; $i++) {
+					if ($head4{$i} == &quot;\xFF&quot;) {
+						fseek($fd, $i - 4, SEEK_CUR);
+						continue 2;
+					}
+				}
+				continue;
+			}
+			if (!isset($MPEGaudioHeaderDecodeCache[$head4])) {
+				$MPEGaudioHeaderDecodeCache[$head4] = getid3_mp3::MPEGaudioHeaderDecode($head4);
+			}
+			if (!isset($MPEGaudioHeaderValidCache[$head4])) {
+				$MPEGaudioHeaderValidCache[$head4] = getid3_mp3::MPEGaudioHeaderValid($MPEGaudioHeaderDecodeCache[$head4], false, false);
+			}
+			if ($MPEGaudioHeaderValidCache[$head4]) {
+
+				if (!isset($MPEGaudioHeaderLengthCache[$head4])) {
+					$LongMPEGversionLookup[$head4]   = $MPEGaudioVersionLookup[$MPEGaudioHeaderDecodeCache[$head4]['version']];
+					$LongMPEGlayerLookup[$head4]     = $MPEGaudioLayerLookup[$MPEGaudioHeaderDecodeCache[$head4]['layer']];
+					$LongMPEGbitrateLookup[$head4]   = $MPEGaudioBitrateLookup[$LongMPEGversionLookup[$head4]][$LongMPEGlayerLookup[$head4]][$MPEGaudioHeaderDecodeCache[$head4]['bitrate']];
+					$LongMPEGpaddingLookup[$head4]   = (bool) $MPEGaudioHeaderDecodeCache[$head4]['padding'];
+					$LongMPEGfrequencyLookup[$head4] = $MPEGaudioFrequencyLookup[$LongMPEGversionLookup[$head4]][$MPEGaudioHeaderDecodeCache[$head4]['sample_rate']];
+					$MPEGaudioHeaderLengthCache[$head4] = getid3_mp3::MPEGaudioFrameLength(
+						$LongMPEGbitrateLookup[$head4],
+						$LongMPEGversionLookup[$head4],
+						$LongMPEGlayerLookup[$head4],
+						$LongMPEGpaddingLookup[$head4],
+						$LongMPEGfrequencyLookup[$head4]);
+				}
+				if ($MPEGaudioHeaderLengthCache[$head4] &gt; 4) {
+					$WhereWeWere = ftell($fd);
+					fseek($fd, $MPEGaudioHeaderLengthCache[$head4] - 4, SEEK_CUR);
+					$next4 = fread($fd, 4);
+					if ($next4{0} == &quot;\xFF&quot;) {
+						if (!isset($MPEGaudioHeaderDecodeCache[$next4])) {
+							$MPEGaudioHeaderDecodeCache[$next4] = getid3_mp3::MPEGaudioHeaderDecode($next4);
+						}
+						if (!isset($MPEGaudioHeaderValidCache[$next4])) {
+							$MPEGaudioHeaderValidCache[$next4] = getid3_mp3::MPEGaudioHeaderValid($MPEGaudioHeaderDecodeCache[$next4], false, false);
+						}
+						if ($MPEGaudioHeaderValidCache[$next4]) {
+							fseek($fd, -4, SEEK_CUR);
+
+							@$Distribution['bitrate'][$LongMPEGbitrateLookup[$head4]]++;
+							@$Distribution['layer'][$LongMPEGlayerLookup[$head4]]++;
+							@$Distribution['version'][$LongMPEGversionLookup[$head4]]++;
+							@$Distribution['padding'][intval($LongMPEGpaddingLookup[$head4])]++;
+							@$Distribution['frequency'][$LongMPEGfrequencyLookup[$head4]]++;
+							continue;
+						}
+					}
+					unset($next4);
+					fseek($fd, $WhereWeWere - 3, SEEK_SET);
+				}
+
+			}
+		}
+		foreach ($Distribution as $key =&gt; $value) {
+			ksort($Distribution[$key], SORT_NUMERIC);
+		}
+		ksort($Distribution['version'], SORT_STRING);
+		$ThisFileInfo['mpeg']['audio']['bitrate_distribution']   = $Distribution['bitrate'];
+		$ThisFileInfo['mpeg']['audio']['frequency_distribution'] = $Distribution['frequency'];
+		$ThisFileInfo['mpeg']['audio']['layer_distribution']     = $Distribution['layer'];
+		$ThisFileInfo['mpeg']['audio']['version_distribution']   = $Distribution['version'];
+		$ThisFileInfo['mpeg']['audio']['padding_distribution']   = $Distribution['padding'];
+		if (count($Distribution['version']) &gt; 1) {
+			$ThisFileInfo['error'][] = 'Corrupt file - more than one MPEG version detected';
+		}
+		if (count($Distribution['layer']) &gt; 1) {
+			$ThisFileInfo['error'][] = 'Corrupt file - more than one MPEG layer detected';
+		}
+		if (count($Distribution['frequency']) &gt; 1) {
+			$ThisFileInfo['error'][] = 'Corrupt file - more than one MPEG sample rate detected';
+		}
+
+
+		$bittotal = 0;
+		foreach ($Distribution['bitrate'] as $bitratevalue =&gt; $bitratecount) {
+			if ($bitratevalue != 'free') {
+				$bittotal += ($bitratevalue * $bitratecount);
+			}
+		}
+		$ThisFileInfo['mpeg']['audio']['frame_count']  = array_sum($Distribution['bitrate']);
+		if ($ThisFileInfo['mpeg']['audio']['frame_count'] == 0) {
+			$ThisFileInfo['error'][] = 'no MPEG audio frames found';
+			return false;
+		}
+		$ThisFileInfo['mpeg']['audio']['bitrate']      = ($bittotal / $ThisFileInfo['mpeg']['audio']['frame_count']);
+		$ThisFileInfo['mpeg']['audio']['bitrate_mode'] = ((count($Distribution['bitrate']) &gt; 0) ? 'vbr' : 'cbr');
+		$ThisFileInfo['mpeg']['audio']['sample_rate']  = getid3_lib::array_max($Distribution['frequency'], true);
+
+		$ThisFileInfo['audio']['bitrate']      = $ThisFileInfo['mpeg']['audio']['bitrate'];
+		$ThisFileInfo['audio']['bitrate_mode'] = $ThisFileInfo['mpeg']['audio']['bitrate_mode'];
+		$ThisFileInfo['audio']['sample_rate']  = $ThisFileInfo['mpeg']['audio']['sample_rate'];
+		$ThisFileInfo['audio']['dataformat']   = 'mp'.getid3_lib::array_max($Distribution['layer'], true);
+		$ThisFileInfo['fileformat']            = $ThisFileInfo['audio']['dataformat'];
+
+		return true;
+	}
+
+
+	function getOnlyMPEGaudioInfo($fd, &amp;$ThisFileInfo, $avdataoffset, $BitrateHistogram=false) {
+		// looks for synch, decodes MPEG audio header
+
+		fseek($fd, $avdataoffset, SEEK_SET);
+		$header = '';
+		$SynchSeekOffset = 0;
+
+		static $MPEGaudioVersionLookup;
+		static $MPEGaudioLayerLookup;
+		static $MPEGaudioBitrateLookup;
+		if (empty($MPEGaudioVersionLookup)) {
+			$MPEGaudioVersionLookup = getid3_mp3::MPEGaudioVersionArray();
+			$MPEGaudioLayerLookup   = getid3_mp3::MPEGaudioLayerArray();
+			$MPEGaudioBitrateLookup = getid3_mp3::MPEGaudioBitrateArray();
+
+		}
+
+		$header_len = strlen($header) - intval(round(GETID3_FREAD_BUFFER_SIZE / 2));
+		while (true) {
+
+			if (($SynchSeekOffset &gt; $header_len) &amp;&amp; (($avdataoffset + $SynchSeekOffset)  &lt; $ThisFileInfo['avdataend']) &amp;&amp; !feof($fd)) {
+
+				if ($SynchSeekOffset &gt; 131072) {
+					// if a synch's not found within the first 128k bytes, then give up
+					$ThisFileInfo['error'][] = 'could not find valid MPEG audio synch within the first 128k bytes';
+					if (isset($ThisFileInfo['audio']['bitrate'])) {
+						unset($ThisFileInfo['audio']['bitrate']);
+					}
+					if (isset($ThisFileInfo['mpeg']['audio'])) {
+						unset($ThisFileInfo['mpeg']['audio']);
+					}
+					if (empty($ThisFileInfo['mpeg'])) {
+						unset($ThisFileInfo['mpeg']);
+					}
+					return false;
+
+				} elseif ($header .= fread($fd, GETID3_FREAD_BUFFER_SIZE)) {
+
+					// great
+					$header_len = strlen($header) - intval(round(GETID3_FREAD_BUFFER_SIZE / 2));
+
+				} else {
+
+					$ThisFileInfo['error'][] = 'could not find valid MPEG audio synch before end of file';
+					if (isset($ThisFileInfo['audio']['bitrate'])) {
+						unset($ThisFileInfo['audio']['bitrate']);
+					}
+					if (isset($ThisFileInfo['mpeg']['audio'])) {
+						unset($ThisFileInfo['mpeg']['audio']);
+					}
+					if (isset($ThisFileInfo['mpeg']) &amp;&amp; (!is_array($ThisFileInfo['mpeg']) || (count($ThisFileInfo['mpeg']) == 0))) {
+						unset($ThisFileInfo['mpeg']);
+					}
+					return false;
+
+				}
+			}
+
+			if (($SynchSeekOffset + 1) &gt;= strlen($header)) {
+				$ThisFileInfo['error'][] = 'could not find valid MPEG synch before end of file';
+				return false;
+			}
+
+			if (($header{$SynchSeekOffset} == &quot;\xFF&quot;) &amp;&amp; ($header{($SynchSeekOffset + 1)} &gt; &quot;\xE0&quot;)) { // synch detected
+
+				if (!isset($FirstFrameThisfileInfo) &amp;&amp; !isset($ThisFileInfo['mpeg']['audio'])) {
+					$FirstFrameThisfileInfo = $ThisFileInfo;
+					$FirstFrameAVDataOffset = $avdataoffset + $SynchSeekOffset;
+					if (!getid3_mp3::decodeMPEGaudioHeader($fd, $avdataoffset + $SynchSeekOffset, $FirstFrameThisfileInfo, false)) {
+						// if this is the first valid MPEG-audio frame, save it in case it's a VBR header frame and there's
+						// garbage between this frame and a valid sequence of MPEG-audio frames, to be restored below
+						unset($FirstFrameThisfileInfo);
+					}
+				}
+
+				$dummy = $ThisFileInfo; // only overwrite real data if valid header found
+				if (getid3_mp3::decodeMPEGaudioHeader($fd, $avdataoffset + $SynchSeekOffset, $dummy, true)) {
+					$ThisFileInfo = $dummy;
+					$ThisFileInfo['avdataoffset'] = $avdataoffset + $SynchSeekOffset;
+					switch ($ThisFileInfo['fileformat']) {
+						case '':
+						case 'id3':
+						case 'ape':
+						case 'mp3':
+							$ThisFileInfo['fileformat']          = 'mp3';
+							$ThisFileInfo['audio']['dataformat'] = 'mp3';
+							break;
+					}
+					if (isset($FirstFrameThisfileInfo['mpeg']['audio']['bitrate_mode']) &amp;&amp; ($FirstFrameThisfileInfo['mpeg']['audio']['bitrate_mode'] == 'vbr')) {
+						if (!(abs($ThisFileInfo['audio']['bitrate'] - $FirstFrameThisfileInfo['audio']['bitrate']) &lt;= 1)) {
+							// If there is garbage data between a valid VBR header frame and a sequence
+							// of valid MPEG-audio frames the VBR data is no longer discarded.
+							$ThisFileInfo = $FirstFrameThisfileInfo;
+							$ThisFileInfo['avdataoffset']        = $FirstFrameAVDataOffset;
+							$ThisFileInfo['fileformat']          = 'mp3';
+							$ThisFileInfo['audio']['dataformat'] = 'mp3';
+							$dummy                               = $ThisFileInfo;
+							unset($dummy['mpeg']['audio']);
+							$GarbageOffsetStart = $FirstFrameAVDataOffset + $FirstFrameThisfileInfo['mpeg']['audio']['framelength'];
+							$GarbageOffsetEnd   = $avdataoffset + $SynchSeekOffset;
+							if (getid3_mp3::decodeMPEGaudioHeader($fd, $GarbageOffsetEnd, $dummy, true, true)) {
+
+								$ThisFileInfo = $dummy;
+								$ThisFileInfo['avdataoffset'] = $GarbageOffsetEnd;
+								$ThisFileInfo['warning'][] = 'apparently-valid VBR header not used because could not find '.GETID3_MP3_VALID_CHECK_FRAMES.' consecutive MPEG-audio frames immediately after VBR header (garbage data for '.($GarbageOffsetEnd - $GarbageOffsetStart).' bytes between '.$GarbageOffsetStart.' and '.$GarbageOffsetEnd.'), but did find valid CBR stream starting at '.$GarbageOffsetEnd;
+
+							} else {
+
+								$ThisFileInfo['warning'][] = 'using data from VBR header even though could not find '.GETID3_MP3_VALID_CHECK_FRAMES.' consecutive MPEG-audio frames immediately after VBR header (garbage data for '.($GarbageOffsetEnd - $GarbageOffsetStart).' bytes between '.$GarbageOffsetStart.' and '.$GarbageOffsetEnd.')';
+
+							}
+						}
+					}
+					if (isset($ThisFileInfo['mpeg']['audio']['bitrate_mode']) &amp;&amp; ($ThisFileInfo['mpeg']['audio']['bitrate_mode'] == 'vbr') &amp;&amp; !isset($ThisFileInfo['mpeg']['audio']['VBR_method'])) {
+						// VBR file with no VBR header
+						$BitrateHistogram = true;
+					}
+
+					if ($BitrateHistogram) {
+
+						$ThisFileInfo['mpeg']['audio']['stereo_distribution']  = array('stereo'=&gt;0, 'joint stereo'=&gt;0, 'dual channel'=&gt;0, 'mono'=&gt;0);
+						$ThisFileInfo['mpeg']['audio']['version_distribution'] = array('1'=&gt;0, '2'=&gt;0, '2.5'=&gt;0);
+
+						if ($ThisFileInfo['mpeg']['audio']['version'] == '1') {
+							if ($ThisFileInfo['mpeg']['audio']['layer'] == 3) {
+								$ThisFileInfo['mpeg']['audio']['bitrate_distribution'] = array('free'=&gt;0, 32000=&gt;0, 40000=&gt;0, 48000=&gt;0, 56000=&gt;0, 64000=&gt;0, 80000=&gt;0, 96000=&gt;0, 112000=&gt;0, 128000=&gt;0, 160000=&gt;0, 192000=&gt;0, 224000=&gt;0, 256000=&gt;0, 320000=&gt;0);
+							} elseif ($ThisFileInfo['mpeg']['audio']['layer'] == 2) {
+								$ThisFileInfo['mpeg']['audio']['bitrate_distribution'] = array('free'=&gt;0, 32000=&gt;0, 48000=&gt;0, 56000=&gt;0, 64000=&gt;0, 80000=&gt;0, 96000=&gt;0, 112000=&gt;0, 128000=&gt;0, 160000=&gt;0, 192000=&gt;0, 224000=&gt;0, 256000=&gt;0, 320000=&gt;0, 384000=&gt;0);
+							} elseif ($ThisFileInfo['mpeg']['audio']['layer'] == 1) {
+								$ThisFileInfo['mpeg']['audio']['bitrate_distribution'] = array('free'=&gt;0, 32000=&gt;0, 64000=&gt;0, 96000=&gt;0, 128000=&gt;0, 160000=&gt;0, 192000=&gt;0, 224000=&gt;0, 256000=&gt;0, 288000=&gt;0, 320000=&gt;0, 352000=&gt;0, 384000=&gt;0, 416000=&gt;0, 448000=&gt;0);
+							}
+						} elseif ($ThisFileInfo['mpeg']['audio']['layer'] == 1) {
+							$ThisFileInfo['mpeg']['audio']['bitrate_distribution'] = array('free'=&gt;0, 32000=&gt;0, 48000=&gt;0, 56000=&gt;0, 64000=&gt;0, 80000=&gt;0, 96000=&gt;0, 112000=&gt;0, 128000=&gt;0, 144000=&gt;0, 160000=&gt;0, 176000=&gt;0, 192000=&gt;0, 224000=&gt;0, 256000=&gt;0);
+						} else {
+							$ThisFileInfo['mpeg']['audio']['bitrate_distribution'] = array('free'=&gt;0, 8000=&gt;0, 16000=&gt;0, 24000=&gt;0, 32000=&gt;0, 40000=&gt;0, 48000=&gt;0, 56000=&gt;0, 64000=&gt;0, 80000=&gt;0, 96000=&gt;0, 112000=&gt;0, 128000=&gt;0, 144000=&gt;0, 160000=&gt;0);
+						}
+
+						$dummy = array('error'=&gt;$ThisFileInfo['error'], 'warning'=&gt;$ThisFileInfo['warning'], 'avdataend'=&gt;$ThisFileInfo['avdataend'], 'avdataoffset'=&gt;$ThisFileInfo['avdataoffset']);
+						$synchstartoffset = $ThisFileInfo['avdataoffset'];
+
+						$FastMode = false;
+						$SynchErrorsFound = 0;
+						while (getid3_mp3::decodeMPEGaudioHeader($fd, $synchstartoffset, $dummy, false, false, $FastMode)) {
+							$FastMode = true;
+							$thisframebitrate = $MPEGaudioBitrateLookup[$MPEGaudioVersionLookup[$dummy['mpeg']['audio']['raw']['version']]][$MPEGaudioLayerLookup[$dummy['mpeg']['audio']['raw']['layer']]][$dummy['mpeg']['audio']['raw']['bitrate']];
+
+							if (empty($dummy['mpeg']['audio']['framelength'])) {
+								$SynchErrorsFound++;
+							} else {
+								$ThisFileInfo['mpeg']['audio']['bitrate_distribution'][$thisframebitrate]++;
+								$ThisFileInfo['mpeg']['audio']['stereo_distribution'][$dummy['mpeg']['audio']['channelmode']]++;
+								$ThisFileInfo['mpeg']['audio']['version_distribution'][$dummy['mpeg']['audio']['version']]++;
+
+								$synchstartoffset += $dummy['mpeg']['audio']['framelength'];
+							}
+						}
+						if ($SynchErrorsFound &gt; 0) {
+							$ThisFileInfo['warning'][] = 'Found '.$SynchErrorsFound.' synch errors in histogram analysis';
+							//return false;
+						}
+
+						$bittotal     = 0;
+						$framecounter = 0;
+						foreach ($ThisFileInfo['mpeg']['audio']['bitrate_distribution'] as $bitratevalue =&gt; $bitratecount) {
+							$framecounter += $bitratecount;
+							if ($bitratevalue != 'free') {
+								$bittotal += ($bitratevalue * $bitratecount);
+							}
+						}
+						if ($framecounter == 0) {
+							$ThisFileInfo['error'][] = 'Corrupt MP3 file: framecounter == zero';
+							return false;
+						}
+						$ThisFileInfo['mpeg']['audio']['frame_count'] = $framecounter;
+						$ThisFileInfo['mpeg']['audio']['bitrate']     = ($bittotal / $framecounter);
+
+						$ThisFileInfo['audio']['bitrate'] = $ThisFileInfo['mpeg']['audio']['bitrate'];
+
+
+						// Definitively set VBR vs CBR, even if the Xing/LAME/VBRI header says differently
+						$distinct_bitrates = 0;
+						foreach ($ThisFileInfo['mpeg']['audio']['bitrate_distribution'] as $bitrate_value =&gt; $bitrate_count) {
+							if ($bitrate_count &gt; 0) {
+								$distinct_bitrates++;
+							}
+						}
+						if ($distinct_bitrates &gt; 1) {
+							$ThisFileInfo['mpeg']['audio']['bitrate_mode'] = 'vbr';
+						} else {
+							$ThisFileInfo['mpeg']['audio']['bitrate_mode'] = 'cbr';
+						}
+						$ThisFileInfo['audio']['bitrate_mode'] = $ThisFileInfo['mpeg']['audio']['bitrate_mode'];
+
+					}
+
+					break; // exit while()
+				}
+			}
+
+			$SynchSeekOffset++;
+			if (($avdataoffset + $SynchSeekOffset) &gt;= $ThisFileInfo['avdataend']) {
+				// end of file/data
+
+				if (empty($ThisFileInfo['mpeg']['audio'])) {
+
+					$ThisFileInfo['error'][] = 'could not find valid MPEG synch before end of file';
+					if (isset($ThisFileInfo['audio']['bitrate'])) {
+						unset($ThisFileInfo['audio']['bitrate']);
+					}
+					if (isset($ThisFileInfo['mpeg']['audio'])) {
+						unset($ThisFileInfo['mpeg']['audio']);
+					}
+					if (isset($ThisFileInfo['mpeg']) &amp;&amp; (!is_array($ThisFileInfo['mpeg']) || empty($ThisFileInfo['mpeg']))) {
+						unset($ThisFileInfo['mpeg']);
+					}
+					return false;
+
+				}
+				break;
+			}
+
+		}
+		$ThisFileInfo['audio']['channels']        = $ThisFileInfo['mpeg']['audio']['channels'];
+		$ThisFileInfo['audio']['channelmode']     = $ThisFileInfo['mpeg']['audio']['channelmode'];
+		$ThisFileInfo['audio']['sample_rate']     = $ThisFileInfo['mpeg']['audio']['sample_rate'];
+		return true;
+	}
+
+
+	function MPEGaudioVersionArray() {
+		static $MPEGaudioVersion = array('2.5', false, '2', '1');
+		return $MPEGaudioVersion;
+	}
+
+	function MPEGaudioLayerArray() {
+		static $MPEGaudioLayer = array(false, 3, 2, 1);
+		return $MPEGaudioLayer;
+	}
+
+	function MPEGaudioBitrateArray() {
+		static $MPEGaudioBitrate;
+		if (empty($MPEGaudioBitrate)) {
+		    $MPEGaudioBitrate = array (
+			    '1'  =&gt;  array (1 =&gt; array('free', 32000, 64000, 96000, 128000, 160000, 192000, 224000, 256000, 288000, 320000, 352000, 384000, 416000, 448000),
+			                    2 =&gt; array('free', 32000, 48000, 56000,  64000,  80000,  96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000, 384000),
+			                    3 =&gt; array('free', 32000, 40000, 48000,  56000,  64000,  80000,  96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000)
+			                   ),
+
+			    '2'  =&gt;  array (1 =&gt; array('free', 32000, 48000, 56000,  64000,  80000,  96000, 112000, 128000, 144000, 160000, 176000, 192000, 224000, 256000),
+			                    2 =&gt; array('free',  8000, 16000, 24000,  32000,  40000,  48000,  56000,  64000,  80000,  96000, 112000, 128000, 144000, 160000),
+			                   )
+			);
+			$MPEGaudioBitrate['2'][3] = $MPEGaudioBitrate['2'][2];
+			$MPEGaudioBitrate['2.5']  = $MPEGaudioBitrate['2'];
+		}
+		return $MPEGaudioBitrate;
+	}
+
+	function MPEGaudioFrequencyArray() {
+		static $MPEGaudioFrequency;
+		if (empty($MPEGaudioFrequency)) {
+		    $MPEGaudioFrequency = array (
+			    '1'   =&gt; array(44100, 48000, 32000),
+			    '2'   =&gt; array(22050, 24000, 16000),
+			    '2.5' =&gt; array(11025, 12000,  8000)
+			);
+		}
+		return $MPEGaudioFrequency;
+	}
+
+	function MPEGaudioChannelModeArray() {
+		static $MPEGaudioChannelMode = array('stereo', 'joint stereo', 'dual channel', 'mono');
+		return $MPEGaudioChannelMode;
+	}
+
+	function MPEGaudioModeExtensionArray() {
+		static $MPEGaudioModeExtension;
+		if (empty($MPEGaudioModeExtension)) {
+		    $MPEGaudioModeExtension = array (
+			    1 =&gt; array('4-31', '8-31', '12-31', '16-31'),
+			    2 =&gt; array('4-31', '8-31', '12-31', '16-31'),
+			    3 =&gt; array('', 'IS', 'MS', 'IS+MS')
+			);
+		}
+		return $MPEGaudioModeExtension;
+	}
+
+	function MPEGaudioEmphasisArray() {
+		static $MPEGaudioEmphasis = array('none', '50/15ms', false, 'CCIT J.17');
+		return $MPEGaudioEmphasis;
+	}
+
+	function MPEGaudioHeaderBytesValid($head4, $allowBitrate15=false) {
+		return getid3_mp3::MPEGaudioHeaderValid(getid3_mp3::MPEGaudioHeaderDecode($head4), false, $allowBitrate15);
+	}
+
+	function MPEGaudioHeaderValid($rawarray, $echoerrors=false, $allowBitrate15=false) {
+		if (($rawarray['synch'] &amp; 0x0FFE) != 0x0FFE) {
+			return false;
+		}
+
+		static $MPEGaudioVersionLookup;
+		static $MPEGaudioLayerLookup;
+		static $MPEGaudioBitrateLookup;
+		static $MPEGaudioFrequencyLookup;
+		static $MPEGaudioChannelModeLookup;
+		static $MPEGaudioModeExtensionLookup;
+		static $MPEGaudioEmphasisLookup;
+		if (empty($MPEGaudioVersionLookup)) {
+			$MPEGaudioVersionLookup       = getid3_mp3::MPEGaudioVersionArray();
+			$MPEGaudioLayerLookup         = getid3_mp3::MPEGaudioLayerArray();
+			$MPEGaudioBitrateLookup       = getid3_mp3::MPEGaudioBitrateArray();
+			$MPEGaudioFrequencyLookup     = getid3_mp3::MPEGaudioFrequencyArray();
+			$MPEGaudioChannelModeLookup   = getid3_mp3::MPEGaudioChannelModeArray();
+			$MPEGaudioModeExtensionLookup = getid3_mp3::MPEGaudioModeExtensionArray();
+			$MPEGaudioEmphasisLookup      = getid3_mp3::MPEGaudioEmphasisArray();
+		}
+
+		if (isset($MPEGaudioVersionLookup[$rawarray['version']])) {
+			$decodedVersion = $MPEGaudioVersionLookup[$rawarray['version']];
+		} else {
+			echo ($echoerrors ? &quot;\n&quot;.'invalid Version ('.$rawarray['version'].')' : '');
+			return false;
+		}
+		if (isset($MPEGaudioLayerLookup[$rawarray['layer']])) {
+			$decodedLayer = $MPEGaudioLayerLookup[$rawarray['layer']];
+		} else {
+			echo ($echoerrors ? &quot;\n&quot;.'invalid Layer ('.$rawarray['layer'].')' : '');
+			return false;
+		}
+		if (!isset($MPEGaudioBitrateLookup[$decodedVersion][$decodedLayer][$rawarray['bitrate']])) {
+			echo ($echoerrors ? &quot;\n&quot;.'invalid Bitrate ('.$rawarray['bitrate'].')' : '');
+			if ($rawarray['bitrate'] == 15) {
+				// known issue in LAME 3.90 - 3.93.1 where free-format has bitrate ID of 15 instead of 0
+				// let it go through here otherwise file will not be identified
+				if (!$allowBitrate15) {
+					return false;
+				}
+			} else {
+				return false;
+			}
+		}
+		if (!isset($MPEGaudioFrequencyLookup[$decodedVersion][$rawarray['sample_rate']])) {
+			echo ($echoerrors ? &quot;\n&quot;.'invalid Frequency ('.$rawarray['sample_rate'].')' : '');
+			return false;
+		}
+		if (!isset($MPEGaudioChannelModeLookup[$rawarray['channelmode']])) {
+			echo ($echoerrors ? &quot;\n&quot;.'invalid ChannelMode ('.$rawarray['channelmode'].')' : '');
+			return false;
+		}
+		if (!isset($MPEGaudioModeExtensionLookup[$decodedLayer][$rawarray['modeextension']])) {
+			echo ($echoerrors ? &quot;\n&quot;.'invalid Mode Extension ('.$rawarray['modeextension'].')' : '');
+			return false;
+		}
+		if (!isset($MPEGaudioEmphasisLookup[$rawarray['emphasis']])) {
+			echo ($echoerrors ? &quot;\n&quot;.'invalid Emphasis ('.$rawarray['emphasis'].')' : '');
+			return false;
+		}
+		// These are just either set or not set, you can't mess that up :)
+		// $rawarray['protection'];
+		// $rawarray['padding'];
+		// $rawarray['private'];
+		// $rawarray['copyright'];
+		// $rawarray['original'];
+
+		return true;
+	}
+
+	function MPEGaudioHeaderDecode($Header4Bytes) {
+		// AAAA AAAA  AAAB BCCD  EEEE FFGH  IIJJ KLMM
+		// A - Frame sync (all bits set)
+		// B - MPEG Audio version ID
+		// C - Layer description
+		// D - Protection bit
+		// E - Bitrate index
+		// F - Sampling rate frequency index
+		// G - Padding bit
+		// H - Private bit
+		// I - Channel Mode
+		// J - Mode extension (Only if Joint stereo)
+		// K - Copyright
+		// L - Original
+		// M - Emphasis
+
+		if (strlen($Header4Bytes) != 4) {
+			return false;
+		}
+
+		$MPEGrawHeader['synch']         = (getid3_lib::BigEndian2Int(substr($Header4Bytes, 0, 2)) &amp; 0xFFE0) &gt;&gt; 4;
+		$MPEGrawHeader['version']       = (ord($Header4Bytes{1}) &amp; 0x18) &gt;&gt; 3; //    BB
+		$MPEGrawHeader['layer']         = (ord($Header4Bytes{1}) &amp; 0x06) &gt;&gt; 1; //      CC
+		$MPEGrawHeader['protection']    = (ord($Header4Bytes{1}) &amp; 0x01);      //        D
+		$MPEGrawHeader['bitrate']       = (ord($Header4Bytes{2}) &amp; 0xF0) &gt;&gt; 4; // EEEE
+		$MPEGrawHeader['sample_rate']   = (ord($Header4Bytes{2}) &amp; 0x0C) &gt;&gt; 2; //     FF
+		$MPEGrawHeader['padding']       = (ord($Header4Bytes{2}) &amp; 0x02) &gt;&gt; 1; //       G
+		$MPEGrawHeader['private']       = (ord($Header4Bytes{2}) &amp; 0x01);      //        H
+		$MPEGrawHeader['channelmode']   = (ord($Header4Bytes{3}) &amp; 0xC0) &gt;&gt; 6; // II
+		$MPEGrawHeader['modeextension'] = (ord($Header4Bytes{3}) &amp; 0x30) &gt;&gt; 4; //   JJ
+		$MPEGrawHeader['copyright']     = (ord($Header4Bytes{3}) &amp; 0x08) &gt;&gt; 3; //     K
+		$MPEGrawHeader['original']      = (ord($Header4Bytes{3}) &amp; 0x04) &gt;&gt; 2; //      L
+		$MPEGrawHeader['emphasis']      = (ord($Header4Bytes{3}) &amp; 0x03);      //       MM
+
+		return $MPEGrawHeader;
+	}
+
+	function MPEGaudioFrameLength(&amp;$bitrate, &amp;$version, &amp;$layer, $padding, &amp;$samplerate) {
+		static $AudioFrameLengthCache = array();
+
+		if (!isset($AudioFrameLengthCache[$bitrate][$version][$layer][$padding][$samplerate])) {
+			$AudioFrameLengthCache[$bitrate][$version][$layer][$padding][$samplerate] = false;
+			if ($bitrate != 'free') {
+
+				if ($version == '1') {
+
+					if ($layer == '1') {
+
+						// For Layer I slot is 32 bits long
+						$FrameLengthCoefficient = 48;
+						$SlotLength = 4;
+
+					} else { // Layer 2 / 3
+
+						// for Layer 2 and Layer 3 slot is 8 bits long.
+						$FrameLengthCoefficient = 144;
+						$SlotLength = 1;
+
+					}
+
+				} else { // MPEG-2 / MPEG-2.5
+
+					if ($layer == '1') {
+
+						// For Layer I slot is 32 bits long
+						$FrameLengthCoefficient = 24;
+						$SlotLength = 4;
+
+					} elseif ($layer == '2') {
+
+						// for Layer 2 and Layer 3 slot is 8 bits long.
+						$FrameLengthCoefficient = 144;
+						$SlotLength = 1;
+
+					} else { // layer 3
+
+						// for Layer 2 and Layer 3 slot is 8 bits long.
+						$FrameLengthCoefficient = 72;
+						$SlotLength = 1;
+
+					}
+
+				}
+
+				// FrameLengthInBytes = ((Coefficient * BitRate) / SampleRate) + Padding
+				if ($samplerate &gt; 0) {
+					$NewFramelength  = ($FrameLengthCoefficient * $bitrate) / $samplerate;
+					$NewFramelength  = floor($NewFramelength / $SlotLength) * $SlotLength; // round to next-lower multiple of SlotLength (1 byte for Layer 2/3, 4 bytes for Layer I)
+					if ($padding) {
+						$NewFramelength += $SlotLength;
+					}
+					$AudioFrameLengthCache[$bitrate][$version][$layer][$padding][$samplerate] = (int) $NewFramelength;
+				}
+			}
+		}
+		return $AudioFrameLengthCache[$bitrate][$version][$layer][$padding][$samplerate];
+	}
+
+	function ClosestStandardMP3Bitrate($bitrate) {
+		static $StandardBitrates = array(320000, 256000, 224000, 192000, 160000, 128000, 112000, 96000, 80000, 64000, 56000, 48000, 40000, 32000, 24000, 16000, 8000);
+		static $BitrateTable = array(0=&gt;'-');
+		$roundbitrate = intval(round($bitrate, -3));
+		if (!isset($BitrateTable[$roundbitrate])) {
+			if ($roundbitrate &gt; 320000) {
+				$BitrateTable[$roundbitrate] = round($bitrate, -4);
+			} else {
+				$LastBitrate = 320000;
+				foreach ($StandardBitrates as $StandardBitrate) {
+					$BitrateTable[$roundbitrate] = $StandardBitrate;
+					if ($roundbitrate &gt;= $StandardBitrate - (($LastBitrate - $StandardBitrate) / 2)) {
+						break;
+					}
+					$LastBitrate = $StandardBitrate;
+				}
+			}
+		}
+		return $BitrateTable[$roundbitrate];
+	}
+
+	function XingVBRidOffset($version, $channelmode) {
+		static $XingVBRidOffsetCache = array();
+		if (empty($XingVBRidOffset)) {
+			$XingVBRidOffset = array (
+			    '1'   =&gt; array ('mono'          =&gt; 0x15, // 4 + 17 = 21
+			                    'stereo'        =&gt; 0x24, // 4 + 32 = 36
+			                    'joint stereo'  =&gt; 0x24,
+			                    'dual channel'  =&gt; 0x24
+			                   ),
+
+			    '2'   =&gt; array ('mono'          =&gt; 0x0D, // 4 +  9 = 13
+			                    'stereo'        =&gt; 0x15, // 4 + 17 = 21
+			                    'joint stereo'  =&gt; 0x15,
+			                    'dual channel'  =&gt; 0x15
+			                   ),
+
+			    '2.5' =&gt; array ('mono'          =&gt; 0x15,
+			                    'stereo'        =&gt; 0x15,
+			                    'joint stereo'  =&gt; 0x15,
+			                    'dual channel'  =&gt; 0x15
+			                   )
+		    );
+		}
+		return $XingVBRidOffset[$version][$channelmode];
+	}
+
+	function LAMEvbrMethodLookup($VBRmethodID) {
+		static $LAMEvbrMethodLookup = array(
+			0x00 =&gt; 'unknown',
+			0x01 =&gt; 'cbr',
+			0x02 =&gt; 'abr',
+			0x03 =&gt; 'vbr-old / vbr-rh',
+			0x04 =&gt; 'vbr-new / vbr-mtrh',
+			0x05 =&gt; 'vbr-mt',
+			0x06 =&gt; 'Full VBR Method 4',
+			0x08 =&gt; 'constant bitrate 2 pass',
+			0x09 =&gt; 'abr 2 pass',
+			0x0F =&gt; 'reserved'
+		);
+		return (isset($LAMEvbrMethodLookup[$VBRmethodID]) ? $LAMEvbrMethodLookup[$VBRmethodID] : '');
+	}
+
+	function LAMEmiscStereoModeLookup($StereoModeID) {
+		static $LAMEmiscStereoModeLookup = array(
+			0 =&gt; 'mono',
+			1 =&gt; 'stereo',
+			2 =&gt; 'dual mono',
+			3 =&gt; 'joint stereo',
+			4 =&gt; 'forced stereo',
+			5 =&gt; 'auto',
+			6 =&gt; 'intensity stereo',
+			7 =&gt; 'other'
+		);
+		return (isset($LAMEmiscStereoModeLookup[$StereoModeID]) ? $LAMEmiscStereoModeLookup[$StereoModeID] : '');
+	}
+
+	function LAMEmiscSourceSampleFrequencyLookup($SourceSampleFrequencyID) {
+		static $LAMEmiscSourceSampleFrequencyLookup = array(
+			0 =&gt; '&lt;= 32 kHz',
+			1 =&gt; '44.1 kHz',
+			2 =&gt; '48 kHz',
+			3 =&gt; '&gt; 48kHz'
+		);
+		return (isset($LAMEmiscSourceSampleFrequencyLookup[$SourceSampleFrequencyID]) ? $LAMEmiscSourceSampleFrequencyLookup[$SourceSampleFrequencyID] : '');
+	}
+
+	function LAMEsurroundInfoLookup($SurroundInfoID) {
+		static $LAMEsurroundInfoLookup = array(
+			0 =&gt; 'no surround info',
+			1 =&gt; 'DPL encoding',
+			2 =&gt; 'DPL2 encoding',
+			3 =&gt; 'Ambisonic encoding'
+		);
+		return (isset($LAMEsurroundInfoLookup[$SurroundInfoID]) ? $LAMEsurroundInfoLookup[$SurroundInfoID] : 'reserved');
+	}
+
+	function LAMEpresetUsedLookup($LAMEtag) {
+		if ($LAMEtag['preset_used_id'] == 0) {
+			// no preset used (LAME &gt;=3.93)
+			// no preset recorded (LAME &lt;3.93)
+			return '';
+		}
+		static $LAMEpresetUsedLookup = array();
+		if (empty($LAMEpresetUsedLookup)) {
+			for ($i = 8; $i &lt;= 320; $i++) {
+				switch ($LAMEtag['vbr_method']) {
+					case 'cbr':
+						$LAMEpresetUsedLookup[$i] = '--alt-preset '.$LAMEtag['vbr_method'].' '.$i;
+						break;
+					case 'abr':
+					default: // other VBR modes shouldn't be here(?)
+						$LAMEpresetUsedLookup[$i] = '--alt-preset '.$i;
+						break;
+				}
+			}
+
+			// named old-style presets (studio, phone, voice, etc) are handled in GuessEncoderOptions()
+
+			// named alt-presets
+			$LAMEpresetUsedLookup[1000] = '--r3mix';
+			$LAMEpresetUsedLookup[1001] = '--alt-preset standard';
+			$LAMEpresetUsedLookup[1002] = '--alt-preset extreme';
+			$LAMEpresetUsedLookup[1003] = '--alt-preset insane';
+			$LAMEpresetUsedLookup[1004] = '--alt-preset fast standard';
+			$LAMEpresetUsedLookup[1005] = '--alt-preset fast extreme';
+			$LAMEpresetUsedLookup[1006] = '--alt-preset medium';
+			$LAMEpresetUsedLookup[1007] = '--alt-preset fast medium';
+
+			// LAME 3.94 additions/changes
+			$LAMEpresetUsedLookup[1010] = '--preset portable';                                                           // 3.94a15 Oct 21 2003
+			$LAMEpresetUsedLookup[1015] = '--preset radio';                                                              // 3.94a15 Oct 21 2003
+
+			$LAMEpresetUsedLookup[320]  = '--preset insane';                                                             // 3.94a15 Nov 12 2003
+			$LAMEpresetUsedLookup[430]  = '--preset radio';                                                              // 3.94a15 Nov 12 2003
+			$LAMEpresetUsedLookup[450]  = '--preset '.(($LAMEtag['raw']['vbr_method'] == 4) ? 'fast ' : '').'portable';  // 3.94a15 Nov 12 2003
+			$LAMEpresetUsedLookup[460]  = '--preset '.(($LAMEtag['raw']['vbr_method'] == 4) ? 'fast ' : '').'medium';    // 3.94a15 Nov 12 2003
+			$LAMEpresetUsedLookup[470]  = '--r3mix';                                                                     // 3.94b1  Dec 18 2003
+			$LAMEpresetUsedLookup[480]  = '--preset '.(($LAMEtag['raw']['vbr_method'] == 4) ? 'fast ' : '').'standard';  // 3.94a15 Nov 12 2003
+			$LAMEpresetUsedLookup[500]  = '--preset '.(($LAMEtag['raw']['vbr_method'] == 4) ? 'fast ' : '').'extreme';   // 3.94a15 Nov 12 2003
+		}
+		return (isset($LAMEpresetUsedLookup[$LAMEtag['preset_used_id']]) ? $LAMEpresetUsedLookup[$LAMEtag['preset_used_id']] : 'new/unknown preset: '.$LAMEtag['preset_used_id'].' - report to <A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>');
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mpc.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mpc.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.mpc.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,296 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.mpc.php                                        //
+// module for analyzing Musepack/MPEG+ Audio files             //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_mpc
+{
+
+	function getid3_mpc(&amp;$fd, &amp;$ThisFileInfo) {
+		// <A HREF="http://www.uni-jena.de/~pfk/mpp/sv8/header.html">http://www.uni-jena.de/~pfk/mpp/sv8/header.html</A>
+
+		$ThisFileInfo['mpc']['header'] = array();
+		$thisfile_mpc_header           = &amp;$ThisFileInfo['mpc']['header'];
+
+		$ThisFileInfo['fileformat']               = 'mpc';
+		$ThisFileInfo['audio']['dataformat']      = 'mpc';
+		$ThisFileInfo['audio']['bitrate_mode']    = 'vbr';
+		$ThisFileInfo['audio']['channels']        = 2;  // the format appears to be hardcoded for stereo only
+		$ThisFileInfo['audio']['lossless']        = false;
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+		$thisfile_mpc_header['size'] = 28;
+		$MPCheaderData = fread($fd, $thisfile_mpc_header['size']);
+		$offset = 0;
+
+		if (substr($MPCheaderData, $offset, 3) == 'MP+') {
+
+			// great, this is SV7+
+			$thisfile_mpc_header['raw']['preamble'] = substr($MPCheaderData, $offset, 3); // should be 'MP+'
+			$offset += 3;
+
+		} elseif (preg_match('/^[\x00\x01\x10\x11\x40\x41\x50\x51\x80\x81\x90\x91\xC0\xC1\xD0\xD1][\x20-37][\x00\x20\x40\x60\x80\xA0\xC0\xE0]/s', substr($MPCheaderData, 0, 4))) {
+
+			// this is SV4 - SV6, handle seperately
+            $thisfile_mpc_header['size'] = 8;
+
+            // add size of file header to avdataoffset - calc bitrate correctly + MD5 data
+		    $ThisFileInfo['avdataoffset'] += $thisfile_mpc_header['size'];
+
+			// Most of this code adapted from Jurgen Faul's MPEGplus source code - thanks Jurgen! :)
+			$HeaderDWORD[0] = getid3_lib::LittleEndian2Int(substr($MPCheaderData, 0, 4));
+			$HeaderDWORD[1] = getid3_lib::LittleEndian2Int(substr($MPCheaderData, 4, 4));
+
+
+			// DDDD DDDD  CCCC CCCC  BBBB BBBB  AAAA AAAA
+			// aaaa aaaa  abcd dddd  dddd deee  eeff ffff
+			//
+			// a = bitrate       = anything
+			// b = IS            = anything
+			// c = MS            = anything
+			// d = streamversion = 0000000004 or 0000000005 or 0000000006
+			// e = maxband       = anything
+			// f = blocksize     = 000001 for SV5+, anything(?) for SV4
+
+			$thisfile_mpc_header['target_bitrate']       =        (($HeaderDWORD[0] &amp; 0xFF800000) &gt;&gt; 23);
+			$thisfile_mpc_header['intensity_stereo']     = (bool) (($HeaderDWORD[0] &amp; 0x00400000) &gt;&gt; 22);
+			$thisfile_mpc_header['mid-side_stereo']      = (bool) (($HeaderDWORD[0] &amp; 0x00200000) &gt;&gt; 21);
+			$thisfile_mpc_header['stream_major_version'] =         ($HeaderDWORD[0] &amp; 0x001FF800) &gt;&gt; 11;
+			$thisfile_mpc_header['stream_minor_version'] = 0; // no sub-version numbers before SV7
+			$thisfile_mpc_header['max_band']             =         ($HeaderDWORD[0] &amp; 0x000007C0) &gt;&gt;  6;  // related to lowpass frequency, not sure how it translates exactly
+			$thisfile_mpc_header['block_size']           =         ($HeaderDWORD[0] &amp; 0x0000003F);
+
+			switch ($thisfile_mpc_header['stream_major_version']) {
+				case 4:
+					$thisfile_mpc_header['frame_count'] = ($HeaderDWORD[1] &gt;&gt; 16);
+					break;
+
+				case 5:
+				case 6:
+					$thisfile_mpc_header['frame_count'] =  $HeaderDWORD[1];
+					break;
+
+				default:
+					$ThisFileInfo['error'] = 'Expecting 4, 5 or 6 in version field, found '.$thisfile_mpc_header['stream_major_version'].' instead';
+					unset($ThisFileInfo['mpc']);
+					return false;
+					break;
+			}
+
+			if (($thisfile_mpc_header['stream_major_version'] &gt; 4) &amp;&amp; ($thisfile_mpc_header['block_size'] != 1)) {
+				$ThisFileInfo['warning'][] = 'Block size expected to be 1, actual value found: '.$thisfile_mpc_header['block_size'];
+			}
+
+			$thisfile_mpc_header['sample_rate']   = 44100; // AB: used by all files up to SV7
+			$ThisFileInfo['audio']['sample_rate'] = $thisfile_mpc_header['sample_rate'];
+			$thisfile_mpc_header['samples']       = $thisfile_mpc_header['frame_count'] * 1152 * $ThisFileInfo['audio']['channels'];
+
+			if ($thisfile_mpc_header['target_bitrate'] == 0) {
+				$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+			} else {
+				$ThisFileInfo['audio']['bitrate_mode'] = 'cbr';
+			}
+
+			$ThisFileInfo['mpc']['bitrate']   = ($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8 * 44100 / $thisfile_mpc_header['frame_count'] / 1152;
+			$ThisFileInfo['audio']['bitrate'] = $ThisFileInfo['mpc']['bitrate'];
+			$ThisFileInfo['audio']['encoder'] = 'SV'.$thisfile_mpc_header['stream_major_version'];
+
+			return true;
+
+		} else {
+
+			$ThisFileInfo['error'][] = 'Expecting &quot;MP+&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.substr($MPCheaderData, $offset, 3).'&quot;';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['mpc']);
+			return false;
+
+		}
+
+		// Continue with SV7+ handling
+		$StreamVersionByte                           = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 1));
+		$offset += 1;
+		$thisfile_mpc_header['stream_major_version'] = ($StreamVersionByte &amp; 0x0F);
+		$thisfile_mpc_header['stream_minor_version'] = ($StreamVersionByte &amp; 0xF0) &gt;&gt; 4;
+		$thisfile_mpc_header['frame_count']          = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 4));
+		$offset += 4;
+
+		switch ($thisfile_mpc_header['stream_major_version']) {
+			case 7:
+				//$ThisFileInfo['fileformat'] = 'SV7';
+				break;
+
+			default:
+				$ThisFileInfo['error'][] = 'Only Musepack SV7 supported';
+				return false;
+		}
+
+		$FlagsDWORD1                                   = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 4));
+		$offset += 4;
+		$thisfile_mpc_header['intensity_stereo']       = (bool) (($FlagsDWORD1 &amp; 0x80000000) &gt;&gt; 31);
+		$thisfile_mpc_header['mid_side_stereo']        = (bool) (($FlagsDWORD1 &amp; 0x40000000) &gt;&gt; 30);
+		$thisfile_mpc_header['max_subband']            =         ($FlagsDWORD1 &amp; 0x3F000000) &gt;&gt; 24;
+		$thisfile_mpc_header['raw']['profile']         =         ($FlagsDWORD1 &amp; 0x00F00000) &gt;&gt; 20;
+		$thisfile_mpc_header['begin_loud']             = (bool) (($FlagsDWORD1 &amp; 0x00080000) &gt;&gt; 19);
+		$thisfile_mpc_header['end_loud']               = (bool) (($FlagsDWORD1 &amp; 0x00040000) &gt;&gt; 18);
+		$thisfile_mpc_header['raw']['sample_rate']     =         ($FlagsDWORD1 &amp; 0x00030000) &gt;&gt; 16;
+		$thisfile_mpc_header['max_level']              =         ($FlagsDWORD1 &amp; 0x0000FFFF);
+
+		$thisfile_mpc_header['raw']['title_peak']      = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 2));
+		$offset += 2;
+		$thisfile_mpc_header['raw']['title_gain']      = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 2), true);
+		$offset += 2;
+
+		$thisfile_mpc_header['raw']['album_peak']      = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 2));
+		$offset += 2;
+		$thisfile_mpc_header['raw']['album_gain']      = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 2), true);
+		$offset += 2;
+
+		$FlagsDWORD2                                   = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 4));
+		$offset += 4;
+		$thisfile_mpc_header['true_gapless']           = (bool) (($FlagsDWORD2 &amp; 0x80000000) &gt;&gt; 31);
+		$thisfile_mpc_header['last_frame_length']      =         ($FlagsDWORD2 &amp; 0x7FF00000) &gt;&gt; 20;
+
+
+		$thisfile_mpc_header['raw']['not_sure_what']   = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 3));
+		$offset += 3;
+		$thisfile_mpc_header['raw']['encoder_version'] = getid3_lib::LittleEndian2Int(substr($MPCheaderData, $offset, 1));
+		$offset += 1;
+
+		$thisfile_mpc_header['profile']     = $this-&gt;MPCprofileNameLookup($thisfile_mpc_header['raw']['profile']);
+		$thisfile_mpc_header['sample_rate'] = $this-&gt;MPCfrequencyLookup($thisfile_mpc_header['raw']['sample_rate']);
+		if ($thisfile_mpc_header['sample_rate'] == 0) {
+			$ThisFileInfo['error'][] = 'Corrupt MPC file: frequency == zero';
+			return false;
+		}
+		$ThisFileInfo['audio']['sample_rate'] = $thisfile_mpc_header['sample_rate'];
+		$thisfile_mpc_header['samples']       = ((($thisfile_mpc_header['frame_count'] - 1) * 1152) + $thisfile_mpc_header['last_frame_length']) * $ThisFileInfo['audio']['channels'];
+
+		$ThisFileInfo['playtime_seconds']     = ($thisfile_mpc_header['samples'] / $ThisFileInfo['audio']['channels']) / $ThisFileInfo['audio']['sample_rate'];
+		if ($ThisFileInfo['playtime_seconds'] == 0) {
+			$ThisFileInfo['error'][] = 'Corrupt MPC file: playtime_seconds == zero';
+			return false;
+		}
+
+		// add size of file header to avdataoffset - calc bitrate correctly + MD5 data
+		$ThisFileInfo['avdataoffset'] += $thisfile_mpc_header['size'];
+
+		$ThisFileInfo['audio']['bitrate'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+
+		$thisfile_mpc_header['title_peak']        = $thisfile_mpc_header['raw']['title_peak'];
+		$thisfile_mpc_header['title_peak_db']     = $this-&gt;MPCpeakDBLookup($thisfile_mpc_header['title_peak']);
+		if ($thisfile_mpc_header['raw']['title_gain'] &lt; 0) {
+			$thisfile_mpc_header['title_gain_db'] = (float) (32768 + $thisfile_mpc_header['raw']['title_gain']) / -100;
+		} else {
+			$thisfile_mpc_header['title_gain_db'] = (float) $thisfile_mpc_header['raw']['title_gain'] / 100;
+		}
+
+		$thisfile_mpc_header['album_peak']        = $thisfile_mpc_header['raw']['album_peak'];
+		$thisfile_mpc_header['album_peak_db']     = $this-&gt;MPCpeakDBLookup($thisfile_mpc_header['album_peak']);
+		if ($thisfile_mpc_header['raw']['album_gain'] &lt; 0) {
+			$thisfile_mpc_header['album_gain_db'] = (float) (32768 + $thisfile_mpc_header['raw']['album_gain']) / -100;
+		} else {
+			$thisfile_mpc_header['album_gain_db'] = (float) $thisfile_mpc_header['raw']['album_gain'] / 100;;
+		}
+		$thisfile_mpc_header['encoder_version']   = $this-&gt;MPCencoderVersionLookup($thisfile_mpc_header['raw']['encoder_version']);
+
+		$ThisFileInfo['replay_gain']['track']['adjustment'] = $thisfile_mpc_header['title_gain_db'];
+		$ThisFileInfo['replay_gain']['album']['adjustment'] = $thisfile_mpc_header['album_gain_db'];
+
+		if ($thisfile_mpc_header['title_peak'] &gt; 0) {
+			$ThisFileInfo['replay_gain']['track']['peak'] = $thisfile_mpc_header['title_peak'];
+		} elseif (round($thisfile_mpc_header['max_level'] * 1.18) &gt; 0) {
+			$ThisFileInfo['replay_gain']['track']['peak'] = getid3_lib::CastAsInt(round($thisfile_mpc_header['max_level'] * 1.18)); // why? I don't know - see mppdec.c
+		}
+		if ($thisfile_mpc_header['album_peak'] &gt; 0) {
+			$ThisFileInfo['replay_gain']['album']['peak'] = $thisfile_mpc_header['album_peak'];
+		}
+
+		//$ThisFileInfo['audio']['encoder'] = 'SV'.$thisfile_mpc_header['stream_major_version'].'.'.$thisfile_mpc_header['stream_minor_version'].', '.$thisfile_mpc_header['encoder_version'];
+		$ThisFileInfo['audio']['encoder'] = $thisfile_mpc_header['encoder_version'];
+		$ThisFileInfo['audio']['encoder_options'] = $thisfile_mpc_header['profile'];
+
+		return true;
+	}
+
+	function MPCprofileNameLookup($profileid) {
+		static $MPCprofileNameLookup = array(
+			0  =&gt; 'no profile',
+			1  =&gt; 'Experimental',
+			2  =&gt; 'unused',
+			3  =&gt; 'unused',
+			4  =&gt; 'unused',
+			5  =&gt; 'below Telephone (q = 0.0)',
+			6  =&gt; 'below Telephone (q = 1.0)',
+			7  =&gt; 'Telephone (q = 2.0)',
+			8  =&gt; 'Thumb (q = 3.0)',
+			9  =&gt; 'Radio (q = 4.0)',
+			10 =&gt; 'Standard (q = 5.0)',
+			11 =&gt; 'Extreme (q = 6.0)',
+			12 =&gt; 'Insane (q = 7.0)',
+			13 =&gt; 'BrainDead (q = 8.0)',
+			14 =&gt; 'above BrainDead (q = 9.0)',
+			15 =&gt; 'above BrainDead (q = 10.0)'
+		);
+		return (isset($MPCprofileNameLookup[$profileid]) ? $MPCprofileNameLookup[$profileid] : 'invalid');
+	}
+
+	function MPCfrequencyLookup($frequencyid) {
+		static $MPCfrequencyLookup = array(
+			0 =&gt; 44100,
+			1 =&gt; 48000,
+			2 =&gt; 37800,
+			3 =&gt; 32000
+		);
+		return (isset($MPCfrequencyLookup[$frequencyid]) ? $MPCfrequencyLookup[$frequencyid] : 'invalid');
+	}
+
+	function MPCpeakDBLookup($intvalue) {
+		if ($intvalue &gt; 0) {
+			return ((log10($intvalue) / log10(2)) - 15) * 6;
+		}
+		return false;
+	}
+
+	function MPCencoderVersionLookup($encoderversion) {
+		//Encoder version * 100  (106 = 1.06)
+		//EncoderVersion % 10 == 0        Release (1.0)
+		//EncoderVersion %  2 == 0        Beta (1.06)
+		//EncoderVersion %  2 == 1        Alpha (1.05a...z)
+
+		if ($encoderversion == 0) {
+			// very old version, not known exactly which
+			return 'Buschmann v1.7.0-v1.7.9 or Klemm v0.90-v1.05';
+		}
+
+		if (($encoderversion % 10) == 0) {
+
+			// release version
+			return number_format($encoderversion / 100, 2);
+
+		} elseif (($encoderversion % 2) == 0) {
+
+			// beta version
+			return number_format($encoderversion / 100, 2).' beta';
+
+		}
+
+		// alpha version
+		return number_format($encoderversion / 100, 2).' alpha';
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.ogg.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.ogg.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.ogg.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,543 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.ogg.php                                        //
+// module for analyzing Ogg Vorbis, OggFLAC and Speex files    //
+// dependencies: module.audio.flac.php                         //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.flac.php', __FILE__, true);
+
+class getid3_ogg
+{
+
+	function getid3_ogg(&amp;$fd, &amp;$ThisFileInfo) {
+
+		$ThisFileInfo['fileformat'] = 'ogg';
+
+		// Warn about illegal tags - only vorbiscomments are allowed
+		if (isset($ThisFileInfo['id3v2'])) {
+			$ThisFileInfo['warning'][] = 'Illegal ID3v2 tag present.';
+		}
+		if (isset($ThisFileInfo['id3v1'])) {
+			$ThisFileInfo['warning'][] = 'Illegal ID3v1 tag present.';
+		}
+		if (isset($ThisFileInfo['ape'])) {
+			$ThisFileInfo['warning'][] = 'Illegal APE tag present.';
+		}
+
+
+		// Page 1 - Stream Header
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+		$oggpageinfo = getid3_ogg::ParseOggPageHeader($fd);
+		$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']] = $oggpageinfo;
+
+		if (ftell($fd) &gt;= GETID3_FREAD_BUFFER_SIZE) {
+			$ThisFileInfo['error'][] = 'Could not find start of Ogg page in the first '.GETID3_FREAD_BUFFER_SIZE.' bytes (this might not be an Ogg-Vorbis file?)';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['ogg']);
+			return false;
+		}
+
+		$filedata = fread($fd, $oggpageinfo['page_length']);
+		$filedataoffset = 0;
+
+		if (substr($filedata, 0, 4) == 'fLaC') {
+
+			$ThisFileInfo['audio']['dataformat']   = 'flac';
+			$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+			$ThisFileInfo['audio']['lossless']     = true;
+
+		} elseif (substr($filedata, 1, 6) == 'vorbis') {
+
+			$ThisFileInfo['audio']['dataformat'] = 'vorbis';
+			$ThisFileInfo['audio']['lossless']   = false;
+
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['packet_type'] = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 1));
+			$filedataoffset += 1;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['stream_type'] = substr($filedata, $filedataoffset, 6); // hard-coded to 'vorbis'
+			$filedataoffset += 6;
+			$ThisFileInfo['ogg']['bitstreamversion'] = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['numberofchannels'] = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 1));
+			$filedataoffset += 1;
+			$ThisFileInfo['audio']['channels']                = $ThisFileInfo['ogg']['numberofchannels'];
+			$ThisFileInfo['ogg']['samplerate']       = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			if ($ThisFileInfo['ogg']['samplerate'] == 0) {
+				$ThisFileInfo['error'][] = 'Corrupt Ogg file: sample rate == zero';
+				return false;
+			}
+			$ThisFileInfo['audio']['sample_rate']               = $ThisFileInfo['ogg']['samplerate'];
+			$ThisFileInfo['ogg']['samples']          = 0; // filled in later
+			$ThisFileInfo['ogg']['bitrate_average']  = 0; // filled in later
+			$ThisFileInfo['ogg']['bitrate_max']      = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['bitrate_nominal']  = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['bitrate_min']      = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['blocksize_small']  = pow(2,  getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 1)) &amp; 0x0F);
+			$ThisFileInfo['ogg']['blocksize_large']  = pow(2, (getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 1)) &amp; 0xF0) &gt;&gt; 4);
+			$ThisFileInfo['ogg']['stop_bit']         = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 1)); // must be 1, marks end of packet
+
+			$ThisFileInfo['audio']['bitrate_mode'] = 'vbr'; // overridden if actually abr
+			if ($ThisFileInfo['ogg']['bitrate_max'] == 0xFFFFFFFF) {
+				unset($ThisFileInfo['ogg']['bitrate_max']);
+				$ThisFileInfo['audio']['bitrate_mode'] = 'abr';
+			}
+			if ($ThisFileInfo['ogg']['bitrate_nominal'] == 0xFFFFFFFF) {
+				unset($ThisFileInfo['ogg']['bitrate_nominal']);
+			}
+			if ($ThisFileInfo['ogg']['bitrate_min'] == 0xFFFFFFFF) {
+				unset($ThisFileInfo['ogg']['bitrate_min']);
+				$ThisFileInfo['audio']['bitrate_mode'] = 'abr';
+			}
+
+		} elseif (substr($filedata, 0, 8) == 'Speex   ') {
+
+			// <A HREF="http://www.speex.org/manual/node10.html">http://www.speex.org/manual/node10.html</A>
+
+			$ThisFileInfo['audio']['dataformat']   = 'speex';
+			$ThisFileInfo['mime_type']             = 'audio/speex';
+			$ThisFileInfo['audio']['bitrate_mode'] = 'abr';
+			$ThisFileInfo['audio']['lossless']     = false;
+
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['speex_string']           =                  substr($filedata, $filedataoffset, 8); // hard-coded to 'Speex   '
+			$filedataoffset += 8;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['speex_version']          =                  substr($filedata, $filedataoffset, 20);
+			$filedataoffset += 20;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['speex_version_id']       = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['header_size']            = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['rate']                   = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['mode']                   = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['mode_bitstream_version'] = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['nb_channels']            = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['bitrate']                = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['framesize']              = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['vbr']                    = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['frames_per_packet']      = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['extra_headers']          = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['reserved1']              = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+			$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['reserved2']              = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+			$filedataoffset += 4;
+
+			$ThisFileInfo['speex']['speex_version'] = trim($ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['speex_version']);
+			$ThisFileInfo['speex']['sample_rate']   = $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['rate'];
+			$ThisFileInfo['speex']['channels']      = $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['nb_channels'];
+			$ThisFileInfo['speex']['vbr']           = (bool) $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['vbr'];
+			$ThisFileInfo['speex']['band_type']     = getid3_ogg::SpeexBandModeLookup($ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['mode']);
+
+			$ThisFileInfo['audio']['sample_rate']   = $ThisFileInfo['speex']['sample_rate'];
+			$ThisFileInfo['audio']['channels']      = $ThisFileInfo['speex']['channels'];
+			if ($ThisFileInfo['speex']['vbr']) {
+				$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+			}
+
+		} else {
+
+			$ThisFileInfo['error'][] = 'Expecting either &quot;Speex   &quot; or &quot;vorbis&quot; identifier strings, found neither';
+			unset($ThisFileInfo['ogg']);
+			unset($ThisFileInfo['mime_type']);
+			return false;
+
+		}
+
+
+		// Page 2 - Comment Header
+
+		$oggpageinfo = getid3_ogg::ParseOggPageHeader($fd);
+		$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']] = $oggpageinfo;
+
+		switch ($ThisFileInfo['audio']['dataformat']) {
+
+			case 'vorbis':
+				$filedata = fread($fd, $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['page_length']);
+				$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['packet_type'] = getid3_lib::LittleEndian2Int(substr($filedata, 0, 1));
+				$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['stream_type'] =                  substr($filedata, 1, 6); // hard-coded to 'vorbis'
+
+				getid3_ogg::ParseVorbisCommentsFilepointer($fd, $ThisFileInfo);
+				break;
+
+			case 'flac':
+				if (!getid3_flac::FLACparseMETAdata($fd, $ThisFileInfo)) {
+					$ThisFileInfo['error'][] = 'Failed to parse FLAC headers';
+					return false;
+				}
+				break;
+
+			case 'speex':
+				fseek($fd, $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['page_length'], SEEK_CUR);
+				getid3_ogg::ParseVorbisCommentsFilepointer($fd, $ThisFileInfo);
+				break;
+
+		}
+
+
+
+		// Last Page - Number of Samples
+
+		fseek($fd, max($ThisFileInfo['avdataend'] - GETID3_FREAD_BUFFER_SIZE, 0), SEEK_SET);
+		$LastChunkOfOgg = strrev(fread($fd, GETID3_FREAD_BUFFER_SIZE));
+		if ($LastOggSpostion = strpos($LastChunkOfOgg, 'SggO')) {
+			fseek($fd, $ThisFileInfo['avdataend'] - ($LastOggSpostion + strlen('SggO')), SEEK_SET);
+			$ThisFileInfo['avdataend'] = ftell($fd);
+			$ThisFileInfo['ogg']['pageheader']['eos'] = getid3_ogg::ParseOggPageHeader($fd);
+			$ThisFileInfo['ogg']['samples']   = $ThisFileInfo['ogg']['pageheader']['eos']['pcm_abs_position'];
+			if ($ThisFileInfo['ogg']['samples'] == 0) {
+				$ThisFileInfo['error'][] = 'Corrupt Ogg file: eos.number of samples == zero';
+				return false;
+			}
+			$ThisFileInfo['ogg']['bitrate_average'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / ($ThisFileInfo['ogg']['samples'] / $ThisFileInfo['audio']['sample_rate']);
+		}
+
+		if (!empty($ThisFileInfo['ogg']['bitrate_average'])) {
+			$ThisFileInfo['audio']['bitrate'] = $ThisFileInfo['ogg']['bitrate_average'];
+		} elseif (!empty($ThisFileInfo['ogg']['bitrate_nominal'])) {
+			$ThisFileInfo['audio']['bitrate'] = $ThisFileInfo['ogg']['bitrate_nominal'];
+		} elseif (!empty($ThisFileInfo['ogg']['bitrate_min']) &amp;&amp; !empty($ThisFileInfo['ogg']['bitrate_max'])) {
+			$ThisFileInfo['audio']['bitrate'] = ($ThisFileInfo['ogg']['bitrate_min'] + $ThisFileInfo['ogg']['bitrate_max']) / 2;
+		}
+		if (isset($ThisFileInfo['audio']['bitrate']) &amp;&amp; !isset($ThisFileInfo['playtime_seconds'])) {
+			if ($ThisFileInfo['audio']['bitrate'] == 0) {
+				$ThisFileInfo['error'][] = 'Corrupt Ogg file: bitrate_audio == zero';
+				return false;
+			}
+			$ThisFileInfo['playtime_seconds'] = (float) ((($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['audio']['bitrate']);
+		}
+
+		if (isset($ThisFileInfo['ogg']['vendor'])) {
+			$ThisFileInfo['audio']['encoder'] = preg_replace('/^Encoded with /', '', $ThisFileInfo['ogg']['vendor']);
+
+			// Vorbis only
+			if ($ThisFileInfo['audio']['dataformat'] == 'vorbis') {
+
+				// Vorbis 1.0 starts with Xiph.Org
+				if  (preg_match('/^Xiph.Org/', $ThisFileInfo['audio']['encoder'])) {
+
+					if ($ThisFileInfo['audio']['bitrate_mode'] == 'abr') {
+
+						// Set -b 128 on abr files
+						$ThisFileInfo['audio']['encoder_options'] = '-b '.round($ThisFileInfo['ogg']['bitrate_nominal'] / 1000);
+
+					} elseif (($ThisFileInfo['audio']['bitrate_mode'] == 'vbr') &amp;&amp; ($ThisFileInfo['audio']['channels'] == 2) &amp;&amp; ($ThisFileInfo['audio']['sample_rate'] &gt;= 44100) &amp;&amp; ($ThisFileInfo['audio']['sample_rate'] &lt;= 48000)) {
+						// Set -q N on vbr files
+						$ThisFileInfo['audio']['encoder_options'] = '-q '.$this-&gt;get_quality_from_nominal_bitrate($ThisFileInfo['ogg']['bitrate_nominal']);
+
+					}
+				}
+
+				if (empty($ThisFileInfo['audio']['encoder_options']) &amp;&amp; !empty($ThisFileInfo['ogg']['bitrate_nominal'])) {
+					$ThisFileInfo['audio']['encoder_options'] = 'Nominal bitrate: '.intval(round($ThisFileInfo['ogg']['bitrate_nominal'] / 1000)).'kbps';
+				}
+			}
+		}
+
+		return true;
+	}
+
+
+	function ParseOggPageHeader(&amp;$fd) {
+		// <A HREF="http://xiph.org/ogg/vorbis/doc/framing.html">http://xiph.org/ogg/vorbis/doc/framing.html</A>
+		$oggheader['page_start_offset'] = ftell($fd); // where we started from in the file
+
+		$filedata = fread($fd, GETID3_FREAD_BUFFER_SIZE);
+		$filedataoffset = 0;
+		while ((substr($filedata, $filedataoffset++, 4) != 'OggS')) {
+			if ((ftell($fd) - $oggheader['page_start_offset']) &gt;= GETID3_FREAD_BUFFER_SIZE) {
+				// should be found before here
+				return false;
+			}
+			if ((($filedataoffset + 28) &gt; strlen($filedata)) || (strlen($filedata) &lt; 28)) {
+				if (feof($fd) || (($filedata .= fread($fd, GETID3_FREAD_BUFFER_SIZE)) === false)) {
+					// get some more data, unless eof, in which case fail
+					return false;
+				}
+			}
+		}
+		$filedataoffset += strlen('OggS') - 1; // page, delimited by 'OggS'
+
+		$oggheader['stream_structver']  = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 1));
+		$filedataoffset += 1;
+		$oggheader['flags_raw']         = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 1));
+		$filedataoffset += 1;
+		$oggheader['flags']['fresh']    = (bool) ($oggheader['flags_raw'] &amp; 0x01); // fresh packet
+		$oggheader['flags']['bos']      = (bool) ($oggheader['flags_raw'] &amp; 0x02); // first page of logical bitstream (bos)
+		$oggheader['flags']['eos']      = (bool) ($oggheader['flags_raw'] &amp; 0x04); // last page of logical bitstream (eos)
+
+		$oggheader['pcm_abs_position']  = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 8));
+		$filedataoffset += 8;
+		$oggheader['stream_serialno']   = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+		$filedataoffset += 4;
+		$oggheader['page_seqno']        = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+		$filedataoffset += 4;
+		$oggheader['page_checksum']     = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 4));
+		$filedataoffset += 4;
+		$oggheader['page_segments']     = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 1));
+		$filedataoffset += 1;
+		$oggheader['page_length'] = 0;
+		for ($i = 0; $i &lt; $oggheader['page_segments']; $i++) {
+			$oggheader['segment_table'][$i] = getid3_lib::LittleEndian2Int(substr($filedata, $filedataoffset, 1));
+			$filedataoffset += 1;
+			$oggheader['page_length'] += $oggheader['segment_table'][$i];
+		}
+		$oggheader['header_end_offset'] = $oggheader['page_start_offset'] + $filedataoffset;
+		$oggheader['page_end_offset']   = $oggheader['header_end_offset'] + $oggheader['page_length'];
+		fseek($fd, $oggheader['header_end_offset'], SEEK_SET);
+
+		return $oggheader;
+	}
+
+
+	function ParseVorbisCommentsFilepointer(&amp;$fd, &amp;$ThisFileInfo) {
+
+		$OriginalOffset = ftell($fd);
+		$CommentStartOffset = $OriginalOffset;
+		$commentdataoffset = 0;
+		$VorbisCommentPage = 1;
+
+		switch ($ThisFileInfo['audio']['dataformat']) {
+			case 'vorbis':
+				$CommentStartOffset = $ThisFileInfo['ogg']['pageheader'][$VorbisCommentPage]['page_start_offset'];  // Second Ogg page, after header block
+				fseek($fd, $CommentStartOffset, SEEK_SET);
+				$commentdataoffset = 27 + $ThisFileInfo['ogg']['pageheader'][$VorbisCommentPage]['page_segments'];
+				$commentdata = fread($fd, getid3_ogg::OggPageSegmentLength($ThisFileInfo['ogg']['pageheader'][$VorbisCommentPage], 1) + $commentdataoffset);
+
+				$commentdataoffset += (strlen('vorbis') + 1);
+				break;
+
+			case 'flac':
+				fseek($fd, $ThisFileInfo['flac']['VORBIS_COMMENT']['raw']['offset'] + 4, SEEK_SET);
+				$commentdata = fread($fd, $ThisFileInfo['flac']['VORBIS_COMMENT']['raw']['block_length']);
+				break;
+
+			case 'speex':
+				$CommentStartOffset = $ThisFileInfo['ogg']['pageheader'][$VorbisCommentPage]['page_start_offset'];  // Second Ogg page, after header block
+				fseek($fd, $CommentStartOffset, SEEK_SET);
+				$commentdataoffset = 27 + $ThisFileInfo['ogg']['pageheader'][$VorbisCommentPage]['page_segments'];
+				$commentdata = fread($fd, getid3_ogg::OggPageSegmentLength($ThisFileInfo['ogg']['pageheader'][$VorbisCommentPage], 1) + $commentdataoffset);
+				break;
+
+			default:
+				return false;
+				break;
+		}
+
+		$VendorSize = getid3_lib::LittleEndian2Int(substr($commentdata, $commentdataoffset, 4));
+		$commentdataoffset += 4;
+
+		$ThisFileInfo['ogg']['vendor'] = substr($commentdata, $commentdataoffset, $VendorSize);
+		$commentdataoffset += $VendorSize;
+
+		$CommentsCount = getid3_lib::LittleEndian2Int(substr($commentdata, $commentdataoffset, 4));
+		$commentdataoffset += 4;
+		$ThisFileInfo['avdataoffset'] = $CommentStartOffset + $commentdataoffset;
+
+		$basicfields = array('TITLE', 'ARTIST', 'ALBUM', 'TRACKNUMBER', 'GENRE', 'DATE', 'DESCRIPTION', 'COMMENT');
+		for ($i = 0; $i &lt; $CommentsCount; $i++) {
+
+			$ThisFileInfo['ogg']['comments_raw'][$i]['dataoffset'] = $CommentStartOffset + $commentdataoffset;
+
+			if (ftell($fd) &lt; ($ThisFileInfo['ogg']['comments_raw'][$i]['dataoffset'] + 4)) {
+				$VorbisCommentPage++;
+
+				$oggpageinfo = getid3_ogg::ParseOggPageHeader($fd);
+				$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']] = $oggpageinfo;
+
+				// First, save what we haven't read yet
+				$AsYetUnusedData = substr($commentdata, $commentdataoffset);
+
+				// Then take that data off the end
+				$commentdata     = substr($commentdata, 0, $commentdataoffset);
+
+				// Add [headerlength] bytes of dummy data for the Ogg Page Header, just to keep absolute offsets correct
+				$commentdata .= str_repeat(&quot;\x00&quot;, 27 + $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['page_segments']);
+				$commentdataoffset += (27 + $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['page_segments']);
+
+				// Finally, stick the unused data back on the end
+				$commentdata .= $AsYetUnusedData;
+
+				//$commentdata .= fread($fd, $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['page_length']);
+				$commentdata .= fread($fd, getid3_ogg::OggPageSegmentLength($ThisFileInfo['ogg']['pageheader'][$VorbisCommentPage], 1));
+
+			}
+			$ThisFileInfo['ogg']['comments_raw'][$i]['size']       = getid3_lib::LittleEndian2Int(substr($commentdata, $commentdataoffset, 4));
+
+			// replace avdataoffset with position just after the last vorbiscomment
+			$ThisFileInfo['avdataoffset'] = $ThisFileInfo['ogg']['comments_raw'][$i]['dataoffset'] + $ThisFileInfo['ogg']['comments_raw'][$i]['size'] + 4;
+
+			$commentdataoffset += 4;
+			while ((strlen($commentdata) - $commentdataoffset) &lt; $ThisFileInfo['ogg']['comments_raw'][$i]['size']) {
+				if (($ThisFileInfo['ogg']['comments_raw'][$i]['size'] &gt; $ThisFileInfo['avdataend']) || ($ThisFileInfo['ogg']['comments_raw'][$i]['size'] &lt; 0)) {
+					$ThisFileInfo['error'][] = 'Invalid Ogg comment size (comment #'.$i.', claims to be '.number_format($ThisFileInfo['ogg']['comments_raw'][$i]['size']).' bytes) - aborting reading comments';
+					break 2;
+				}
+
+				$VorbisCommentPage++;
+
+				$oggpageinfo = getid3_ogg::ParseOggPageHeader($fd);
+				$ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']] = $oggpageinfo;
+
+				// First, save what we haven't read yet
+				$AsYetUnusedData = substr($commentdata, $commentdataoffset);
+
+				// Then take that data off the end
+				$commentdata     = substr($commentdata, 0, $commentdataoffset);
+
+				// Add [headerlength] bytes of dummy data for the Ogg Page Header, just to keep absolute offsets correct
+				$commentdata .= str_repeat(&quot;\x00&quot;, 27 + $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['page_segments']);
+				$commentdataoffset += (27 + $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['page_segments']);
+
+				// Finally, stick the unused data back on the end
+				$commentdata .= $AsYetUnusedData;
+
+				//$commentdata .= fread($fd, $ThisFileInfo['ogg']['pageheader'][$oggpageinfo['page_seqno']]['page_length']);
+				$commentdata .= fread($fd, getid3_ogg::OggPageSegmentLength($ThisFileInfo['ogg']['pageheader'][$VorbisCommentPage], 1));
+
+				//$filebaseoffset += $oggpageinfo['header_end_offset'] - $oggpageinfo['page_start_offset'];
+			}
+			$commentstring = substr($commentdata, $commentdataoffset, $ThisFileInfo['ogg']['comments_raw'][$i]['size']);
+			$commentdataoffset += $ThisFileInfo['ogg']['comments_raw'][$i]['size'];
+
+			if (!$commentstring) {
+
+				// no comment?
+				$ThisFileInfo['warning'][] = 'Blank Ogg comment ['.$i.']';
+
+			} elseif (strstr($commentstring, '=')) {
+
+				$commentexploded = explode('=', $commentstring, 2);
+				$ThisFileInfo['ogg']['comments_raw'][$i]['key']   = strtoupper($commentexploded[0]);
+				$ThisFileInfo['ogg']['comments_raw'][$i]['value'] = @$commentexploded[1];
+				$ThisFileInfo['ogg']['comments_raw'][$i]['data']  = base64_decode($ThisFileInfo['ogg']['comments_raw'][$i]['value']);
+
+				$ThisFileInfo['ogg']['comments'][strtolower($ThisFileInfo['ogg']['comments_raw'][$i]['key'])][] = $ThisFileInfo['ogg']['comments_raw'][$i]['value'];
+
+				$imagechunkcheck = getid3_lib::GetDataImageSize($ThisFileInfo['ogg']['comments_raw'][$i]['data']);
+				$ThisFileInfo['ogg']['comments_raw'][$i]['image_mime'] = getid3_lib::image_type_to_mime_type($imagechunkcheck[2]);
+				if (!$ThisFileInfo['ogg']['comments_raw'][$i]['image_mime'] || ($ThisFileInfo['ogg']['comments_raw'][$i]['image_mime'] == 'application/octet-stream')) {
+					unset($ThisFileInfo['ogg']['comments_raw'][$i]['image_mime']);
+					unset($ThisFileInfo['ogg']['comments_raw'][$i]['data']);
+				}
+
+			} else {
+
+				$ThisFileInfo['warning'][] = '[known problem with CDex &gt;= v1.40, &lt; v1.50b7] Invalid Ogg comment name/value pair ['.$i.']: '.$commentstring;
+
+			}
+		}
+
+
+		// Replay Gain Adjustment
+		// <A HREF="http://privatewww.essex.ac.uk/~djmrob/replaygain/">http://privatewww.essex.ac.uk/~djmrob/replaygain/</A>
+		if (isset($ThisFileInfo['ogg']['comments']) &amp;&amp; is_array($ThisFileInfo['ogg']['comments'])) {
+			foreach ($ThisFileInfo['ogg']['comments'] as $index =&gt; $commentvalue) {
+				switch ($index) {
+					case 'rg_audiophile':
+					case 'replaygain_album_gain':
+						$ThisFileInfo['replay_gain']['album']['adjustment'] = (double) $commentvalue[0];
+						unset($ThisFileInfo['ogg']['comments'][$index]);
+						break;
+
+					case 'rg_radio':
+					case 'replaygain_track_gain':
+						$ThisFileInfo['replay_gain']['track']['adjustment'] = (double) $commentvalue[0];
+						unset($ThisFileInfo['ogg']['comments'][$index]);
+						break;
+
+					case 'replaygain_album_peak':
+						$ThisFileInfo['replay_gain']['album']['peak'] = (double) $commentvalue[0];
+						unset($ThisFileInfo['ogg']['comments'][$index]);
+						break;
+
+					case 'rg_peak':
+					case 'replaygain_track_peak':
+						$ThisFileInfo['replay_gain']['track']['peak'] = (double) $commentvalue[0];
+						unset($ThisFileInfo['ogg']['comments'][$index]);
+						break;
+
+
+					default:
+						// do nothing
+						break;
+				}
+			}
+		}
+
+		fseek($fd, $OriginalOffset, SEEK_SET);
+
+		return true;
+	}
+
+	function SpeexBandModeLookup($mode) {
+		static $SpeexBandModeLookup = array();
+		if (empty($SpeexBandModeLookup)) {
+			$SpeexBandModeLookup[0] = 'narrow';
+			$SpeexBandModeLookup[1] = 'wide';
+			$SpeexBandModeLookup[2] = 'ultra-wide';
+		}
+		return (isset($SpeexBandModeLookup[$mode]) ? $SpeexBandModeLookup[$mode] : null);
+	}
+
+
+	function OggPageSegmentLength($OggInfoArray, $SegmentNumber=1) {
+		for ($i = 0; $i &lt; $SegmentNumber; $i++) {
+			$segmentlength = 0;
+			foreach ($OggInfoArray['segment_table'] as $key =&gt; $value) {
+				$segmentlength += $value;
+				if ($value &lt; 255) {
+					break;
+				}
+			}
+		}
+		return $segmentlength;
+	}
+
+
+	function get_quality_from_nominal_bitrate($nominal_bitrate) {
+
+		// decrease precision
+		$nominal_bitrate = $nominal_bitrate / 1000;
+
+		if ($nominal_bitrate &lt; 128) {
+			// q-1 to q4
+			$qval = ($nominal_bitrate - 64) / 16;
+		} elseif ($nominal_bitrate &lt; 256) {
+			// q4 to q8
+			$qval = $nominal_bitrate / 32;
+		} elseif ($nominal_bitrate &lt; 320) {
+			// q8 to q9
+			$qval = ($nominal_bitrate + 256) / 64;
+		} else {
+			// q9 to q10
+			$qval = ($nominal_bitrate + 1300) / 180;
+		}
+		//return $qval; // 5.031324
+		//return intval($qval); // 5
+		return round($qval, 1); // 5 or 4.9
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.optimfrog.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.optimfrog.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.optimfrog.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,408 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.optimfrog.php                                  //
+// module for analyzing OptimFROG audio files                  //
+// dependencies: module.audio.riff.php                         //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.riff.php', __FILE__, true);
+
+class getid3_optimfrog
+{
+
+	function getid3_optimfrog(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat']            = 'ofr';
+		$ThisFileInfo['audio']['dataformat']   = 'ofr';
+		$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+		$ThisFileInfo['audio']['lossless']     = true;
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$OFRheader  = fread($fd, 8);
+		if (substr($OFRheader, 0, 5) == '*RIFF') {
+
+			return $this-&gt;ParseOptimFROGheader42($fd, $ThisFileInfo);
+
+		} elseif (substr($OFRheader, 0, 3) == 'OFR') {
+
+			return $this-&gt;ParseOptimFROGheader45($fd, $ThisFileInfo);
+
+		}
+
+		$ThisFileInfo['error'][] = 'Expecting &quot;*RIFF&quot; or &quot;OFR &quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$OFRheader.'&quot;';
+		unset($ThisFileInfo['fileformat']);
+		return false;
+	}
+
+
+	function ParseOptimFROGheader42(&amp;$fd, &amp;$ThisFileInfo) {
+		// for fileformat of v4.21 and older
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$OptimFROGheaderData = fread($fd, 45);
+		$ThisFileInfo['avdataoffset'] = 45;
+
+		$OptimFROGencoderVersion_raw   = getid3_lib::LittleEndian2Int(substr($OptimFROGheaderData, 0, 1));
+		$OptimFROGencoderVersion_major = floor($OptimFROGencoderVersion_raw / 10);
+		$OptimFROGencoderVersion_minor = $OptimFROGencoderVersion_raw - ($OptimFROGencoderVersion_major * 10);
+		$RIFFdata                = substr($OptimFROGheaderData, 1, 44);
+		$OrignalRIFFheaderSize   = getid3_lib::LittleEndian2Int(substr($RIFFdata,  4, 4)) +  8;
+		$OrignalRIFFdataSize     = getid3_lib::LittleEndian2Int(substr($RIFFdata, 40, 4)) + 44;
+
+		if ($OrignalRIFFheaderSize &gt; $OrignalRIFFdataSize) {
+			$ThisFileInfo['avdataend'] -= ($OrignalRIFFheaderSize - $OrignalRIFFdataSize);
+			fseek($fd, $ThisFileInfo['avdataend'], SEEK_SET);
+			$RIFFdata .= fread($fd, $OrignalRIFFheaderSize - $OrignalRIFFdataSize);
+		}
+
+		// move the data chunk after all other chunks (if any)
+		// so that the RIFF parser doesn't see EOF when trying
+		// to skip over the data chunk
+		$RIFFdata = substr($RIFFdata, 0, 36).substr($RIFFdata, 44).substr($RIFFdata, 36, 8);
+		getid3_riff::ParseRIFFdata($RIFFdata, $ThisFileInfo);
+
+		$ThisFileInfo['audio']['encoder']         = 'OptimFROG '.$OptimFROGencoderVersion_major.'.'.$OptimFROGencoderVersion_minor;
+		$ThisFileInfo['audio']['channels']        = $ThisFileInfo['riff']['audio'][0]['channels'];
+		$ThisFileInfo['audio']['sample_rate']     = $ThisFileInfo['riff']['audio'][0]['sample_rate'];
+		$ThisFileInfo['audio']['bits_per_sample'] = $ThisFileInfo['riff']['audio'][0]['bits_per_sample'];
+		$ThisFileInfo['playtime_seconds']         = $OrignalRIFFdataSize / ($ThisFileInfo['audio']['channels'] * $ThisFileInfo['audio']['sample_rate'] * ($ThisFileInfo['audio']['bits_per_sample'] / 8));
+		$ThisFileInfo['audio']['bitrate']         = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+
+		return true;
+	}
+
+
+	function ParseOptimFROGheader45(&amp;$fd, &amp;$ThisFileInfo) {
+		// for fileformat of v4.50a and higher
+
+		$RIFFdata = '';
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		while (!feof($fd) &amp;&amp; (ftell($fd) &lt; $ThisFileInfo['avdataend'])) {
+			$BlockOffset = ftell($fd);
+			$BlockData   = fread($fd, 8);
+			$offset      = 8;
+			$BlockName   =                  substr($BlockData, 0, 4);
+			$BlockSize   = getid3_lib::LittleEndian2Int(substr($BlockData, 4, 4));
+
+			if ($BlockName == 'OFRX') {
+				$BlockName = 'OFR ';
+			}
+			if (!isset($ThisFileInfo['ofr'][$BlockName])) {
+				$ThisFileInfo['ofr'][$BlockName] = array();
+			}
+			$thisfile_ofr_thisblock = &amp;$ThisFileInfo['ofr'][$BlockName];
+
+			switch ($BlockName) {
+				case 'OFR ':
+
+					// shortcut
+					$thisfile_ofr_thisblock['offset'] = $BlockOffset;
+					$thisfile_ofr_thisblock['size']   = $BlockSize;
+
+					$ThisFileInfo['audio']['encoder'] = 'OptimFROG 4.50 alpha';
+					switch ($BlockSize) {
+						case 12:
+						case 15:
+							// good
+							break;
+
+						default:
+							$ThisFileInfo['warning'][] = '&quot;'.$BlockName.'&quot; contains more data than expected (expected 12 or 15 bytes, found '.$BlockSize.' bytes)';
+							break;
+					}
+					$BlockData .= fread($fd, $BlockSize);
+
+					$thisfile_ofr_thisblock['total_samples']      = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 6));
+					$offset += 6;
+					$thisfile_ofr_thisblock['raw']['sample_type'] = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 1));
+					$thisfile_ofr_thisblock['sample_type']        = $this-&gt;OptimFROGsampleTypeLookup($thisfile_ofr_thisblock['raw']['sample_type']);
+					$offset += 1;
+					$thisfile_ofr_thisblock['channel_config']     = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 1));
+					$thisfile_ofr_thisblock['channels']           = $thisfile_ofr_thisblock['channel_config'];
+					$offset += 1;
+					$thisfile_ofr_thisblock['sample_rate']        = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 4));
+					$offset += 4;
+
+					if ($BlockSize &gt; 12) {
+
+						// OFR 4.504b or higher
+						$thisfile_ofr_thisblock['channels']           = $this-&gt;OptimFROGchannelConfigNumChannelsLookup($thisfile_ofr_thisblock['channel_config']);
+						$thisfile_ofr_thisblock['raw']['encoder_id']  = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 2));
+						$thisfile_ofr_thisblock['encoder']            = $this-&gt;OptimFROGencoderNameLookup($thisfile_ofr_thisblock['raw']['encoder_id']);
+						$offset += 2;
+						$thisfile_ofr_thisblock['raw']['compression'] = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 1));
+						$thisfile_ofr_thisblock['compression']        = $this-&gt;OptimFROGcompressionLookup($thisfile_ofr_thisblock['raw']['compression']);
+						$thisfile_ofr_thisblock['speedup']            = $this-&gt;OptimFROGspeedupLookup($thisfile_ofr_thisblock['raw']['compression']);
+						$offset += 1;
+
+						$ThisFileInfo['audio']['encoder']         = 'OptimFROG '.$thisfile_ofr_thisblock['encoder'];
+						$ThisFileInfo['audio']['encoder_options'] = '--mode '.$thisfile_ofr_thisblock['compression'];
+
+						if ((($thisfile_ofr_thisblock['raw']['encoder_id'] &amp; 0xF0) &gt;&gt; 4) == 7) { // v4.507
+							if (strtolower(getid3_lib::fileextension($ThisFileInfo['filename'])) == 'ofs') {
+								// OptimFROG DualStream format is lossy, but as of v4.507 there is no way to tell the difference
+								// between lossless and lossy other than the file extension.
+								$ThisFileInfo['audio']['dataformat']   = 'ofs';
+								$ThisFileInfo['audio']['lossless']     = true;
+							}
+						}
+
+					}
+
+					$ThisFileInfo['audio']['channels']        = $thisfile_ofr_thisblock['channels'];
+					$ThisFileInfo['audio']['sample_rate']     = $thisfile_ofr_thisblock['sample_rate'];
+					$ThisFileInfo['audio']['bits_per_sample'] = $this-&gt;OptimFROGbitsPerSampleTypeLookup($thisfile_ofr_thisblock['raw']['sample_type']);
+					break;
+
+
+				case 'COMP':
+					// unlike other block types, there CAN be multiple COMP blocks
+
+					$COMPdata['offset'] = $BlockOffset;
+					$COMPdata['size']   = $BlockSize;
+
+					if ($ThisFileInfo['avdataoffset'] == 0) {
+						$ThisFileInfo['avdataoffset'] = $BlockOffset;
+					}
+
+					// Only interested in first 14 bytes (only first 12 needed for v4.50 alpha), not actual audio data
+					$BlockData .= fread($fd, 14);
+					fseek($fd, $BlockSize - 14, SEEK_CUR);
+
+					$COMPdata['crc_32']                       = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 4));
+					$offset += 4;
+					$COMPdata['sample_count']                 = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 4));
+					$offset += 4;
+					$COMPdata['raw']['sample_type']           = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 1));
+					$COMPdata['sample_type']                  = $this-&gt;OptimFROGsampleTypeLookup($COMPdata['raw']['sample_type']);
+					$offset += 1;
+					$COMPdata['raw']['channel_configuration'] = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 1));
+					$COMPdata['channel_configuration']        = $this-&gt;OptimFROGchannelConfigurationLookup($COMPdata['raw']['channel_configuration']);
+					$offset += 1;
+					$COMPdata['raw']['algorithm_id']          = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 2));
+					//$COMPdata['algorithm']                    = OptimFROGalgorithmNameLookup($COMPdata['raw']['algorithm_id']);
+					$offset += 2;
+
+					if ($ThisFileInfo['ofr']['OFR ']['size'] &gt; 12) {
+
+						// OFR 4.504b or higher
+						$COMPdata['raw']['encoder_id']        = getid3_lib::LittleEndian2Int(substr($BlockData, $offset, 2));
+						$COMPdata['encoder']                  = $this-&gt;OptimFROGencoderNameLookup($COMPdata['raw']['encoder_id']);
+						$offset += 2;
+
+					}
+
+					if ($COMPdata['crc_32'] == 0x454E4F4E) {
+						// ASCII value of 'NONE' - placeholder value in v4.50a
+						$COMPdata['crc_32'] = false;
+					}
+
+					$thisfile_ofr_thisblock[] = $COMPdata;
+					break;
+
+				case 'HEAD':
+					$thisfile_ofr_thisblock['offset'] = $BlockOffset;
+					$thisfile_ofr_thisblock['size']   = $BlockSize;
+
+					$RIFFdata .= fread($fd, $BlockSize);
+					break;
+
+				case 'TAIL':
+					$thisfile_ofr_thisblock['offset'] = $BlockOffset;
+					$thisfile_ofr_thisblock['size']   = $BlockSize;
+
+					if ($BlockSize &gt; 0) {
+						$RIFFdata .= fread($fd, $BlockSize);
+					}
+					break;
+
+				case 'RECV':
+					// block contains no useful meta data - simply note and skip
+
+					$thisfile_ofr_thisblock['offset'] = $BlockOffset;
+					$thisfile_ofr_thisblock['size']   = $BlockSize;
+
+					fseek($fd, $BlockSize, SEEK_CUR);
+					break;
+
+
+				case 'APET':
+					// APEtag v2
+
+					$thisfile_ofr_thisblock['offset'] = $BlockOffset;
+					$thisfile_ofr_thisblock['size']   = $BlockSize;
+					$ThisFileInfo['warning'][] = 'APEtag processing inside OptimFROG not supported in this version ('.GETID3_VERSION.') of getID3()';
+
+					fseek($fd, $BlockSize, SEEK_CUR);
+					break;
+
+
+				case 'MD5 ':
+					// APEtag v2
+
+					$thisfile_ofr_thisblock['offset'] = $BlockOffset;
+					$thisfile_ofr_thisblock['size']   = $BlockSize;
+
+					if ($BlockSize == 16) {
+
+						$thisfile_ofr_thisblock['md5_binary'] = fread($fd, $BlockSize);
+						$thisfile_ofr_thisblock['md5_string'] = getid3_lib::PrintHexBytes($thisfile_ofr_thisblock['md5_binary'], true, false, false);
+						$ThisFileInfo['md5_data_source'] = $thisfile_ofr_thisblock['md5_string'];
+
+					} else {
+
+						$ThisFileInfo['warning'][] = 'Expecting block size of 16 in &quot;MD5 &quot; chunk, found '.$BlockSize.' instead';
+						fseek($fd, $BlockSize, SEEK_CUR);
+
+					}
+					break;
+
+
+				default:
+					$thisfile_ofr_thisblock['offset'] = $BlockOffset;
+					$thisfile_ofr_thisblock['size']   = $BlockSize;
+
+					$ThisFileInfo['warning'][] = 'Unhandled OptimFROG block type &quot;'.$BlockName.'&quot; at offset '.$thisfile_ofr_thisblock['offset'];
+					fseek($fd, $BlockSize, SEEK_CUR);
+					break;
+			}
+		}
+		if (isset($ThisFileInfo['ofr']['TAIL']['offset'])) {
+			$ThisFileInfo['avdataend'] = $ThisFileInfo['ofr']['TAIL']['offset'];
+		}
+
+		$ThisFileInfo['playtime_seconds'] = (float) $ThisFileInfo['ofr']['OFR ']['total_samples'] / ($ThisFileInfo['audio']['channels'] * $ThisFileInfo['audio']['sample_rate']);
+		$ThisFileInfo['audio']['bitrate'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+
+		// move the data chunk after all other chunks (if any)
+		// so that the RIFF parser doesn't see EOF when trying
+		// to skip over the data chunk
+		$RIFFdata = substr($RIFFdata, 0, 36).substr($RIFFdata, 44).substr($RIFFdata, 36, 8);
+		getid3_riff::ParseRIFFdata($RIFFdata, $ThisFileInfo);
+
+		return true;
+	}
+
+
+	function OptimFROGsampleTypeLookup($SampleType) {
+		static $OptimFROGsampleTypeLookup = array(
+			0  =&gt; 'unsigned int (8-bit)',
+			1  =&gt; 'signed int (8-bit)',
+			2  =&gt; 'unsigned int (16-bit)',
+			3  =&gt; 'signed int (16-bit)',
+			4  =&gt; 'unsigned int (24-bit)',
+			5  =&gt; 'signed int (24-bit)',
+			6  =&gt; 'unsigned int (32-bit)',
+			7  =&gt; 'signed int (32-bit)',
+			8  =&gt; 'float 0.24 (32-bit)',
+			9  =&gt; 'float 16.8 (32-bit)',
+			10 =&gt; 'float 24.0 (32-bit)'
+		);
+		return (isset($OptimFROGsampleTypeLookup[$SampleType]) ? $OptimFROGsampleTypeLookup[$SampleType] : false);
+	}
+
+	function OptimFROGbitsPerSampleTypeLookup($SampleType) {
+		static $OptimFROGbitsPerSampleTypeLookup = array(
+			0  =&gt; 8,
+			1  =&gt; 8,
+			2  =&gt; 16,
+			3  =&gt; 16,
+			4  =&gt; 24,
+			5  =&gt; 24,
+			6  =&gt; 32,
+			7  =&gt; 32,
+			8  =&gt; 32,
+			9  =&gt; 32,
+			10 =&gt; 32
+		);
+		return (isset($OptimFROGbitsPerSampleTypeLookup[$SampleType]) ? $OptimFROGbitsPerSampleTypeLookup[$SampleType] : false);
+	}
+
+	function OptimFROGchannelConfigurationLookup($ChannelConfiguration) {
+		static $OptimFROGchannelConfigurationLookup = array(
+			0 =&gt; 'mono',
+			1 =&gt; 'stereo'
+		);
+		return (isset($OptimFROGchannelConfigurationLookup[$ChannelConfiguration]) ? $OptimFROGchannelConfigurationLookup[$ChannelConfiguration] : false);
+	}
+
+	function OptimFROGchannelConfigNumChannelsLookup($ChannelConfiguration) {
+		static $OptimFROGchannelConfigNumChannelsLookup = array(
+			0 =&gt; 1,
+			1 =&gt; 2
+		);
+		return (isset($OptimFROGchannelConfigNumChannelsLookup[$ChannelConfiguration]) ? $OptimFROGchannelConfigNumChannelsLookup[$ChannelConfiguration] : false);
+	}
+
+
+
+	// function OptimFROGalgorithmNameLookup($AlgorithID) {
+	//     static $OptimFROGalgorithmNameLookup = array();
+	//     return (isset($OptimFROGalgorithmNameLookup[$AlgorithID]) ? $OptimFROGalgorithmNameLookup[$AlgorithID] : false);
+	// }
+
+
+	function OptimFROGencoderNameLookup($EncoderID) {
+		// version = (encoderID &gt;&gt; 4) + 4500
+		// system  =  encoderID &amp; 0xF
+
+		$EncoderVersion  = number_format(((($EncoderID &amp; 0xF0) &gt;&gt; 4) + 4500) / 1000, 3);
+		$EncoderSystemID = ($EncoderID &amp; 0x0F);
+
+		static $OptimFROGencoderSystemLookup = array(
+			0x00 =&gt; 'Windows console',
+			0x01 =&gt; 'Linux console',
+			0x0F =&gt; 'unknown'
+		);
+		return $EncoderVersion.' ('.(isset($OptimFROGencoderSystemLookup[$EncoderSystemID]) ? $OptimFROGencoderSystemLookup[$EncoderSystemID] : 'undefined encoder type (0x'.dechex($EncoderSystemID).')').')';
+	}
+
+	function OptimFROGcompressionLookup($CompressionID) {
+		// mode    = compression &gt;&gt; 3
+		// speedup = compression &amp; 0x07
+
+		$CompressionModeID    = ($CompressionID &amp; 0xF8) &gt;&gt; 3;
+		//$CompressionSpeedupID = ($CompressionID &amp; 0x07);
+
+		static $OptimFROGencoderModeLookup = array(
+			0x00 =&gt; 'fast',
+			0x01 =&gt; 'normal',
+			0x02 =&gt; 'high',
+			0x03 =&gt; 'extra', // extranew (some versions)
+			0x04 =&gt; 'best',  // bestnew (some versions)
+			0x05 =&gt; 'ultra',
+			0x06 =&gt; 'insane',
+			0x07 =&gt; 'highnew',
+			0x08 =&gt; 'extranew',
+			0x09 =&gt; 'bestnew'
+		);
+		return (isset($OptimFROGencoderModeLookup[$CompressionModeID]) ? $OptimFROGencoderModeLookup[$CompressionModeID] : 'undefined mode (0x'.str_pad(dechex($CompressionModeID), 2, '0', STR_PAD_LEFT).')');
+	}
+
+	function OptimFROGspeedupLookup($CompressionID) {
+		// mode    = compression &gt;&gt; 3
+		// speedup = compression &amp; 0x07
+
+		//$CompressionModeID    = ($CompressionID &amp; 0xF8) &gt;&gt; 3;
+		$CompressionSpeedupID = ($CompressionID &amp; 0x07);
+
+		static $OptimFROGencoderSpeedupLookup = array(
+			0x00 =&gt; '1x',
+			0x01 =&gt; '2x',
+			0x02 =&gt; '4x'
+		);
+
+		return (isset($OptimFROGencoderSpeedupLookup[$CompressionSpeedupID]) ? $OptimFROGencoderSpeedupLookup[$CompressionSpeedupID] : 'undefined mode (0x'.dechex($CompressionSpeedupID));
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.rkau.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.rkau.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.rkau.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,92 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.shorten.php                                    //
+// module for analyzing Shorten Audio files                    //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_rkau
+{
+
+	function getid3_rkau(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$RKAUHeader = fread($fd, 20);
+		if (substr($RKAUHeader, 0, 3) != 'RKA') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;RKA&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.substr($RKAUHeader, 0, 3).'&quot;';
+			return false;
+		}
+
+		$ThisFileInfo['fileformat']            = 'rkau';
+		$ThisFileInfo['audio']['dataformat']   = 'rkau';
+		$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+
+		$ThisFileInfo['rkau']['raw']['version']   = getid3_lib::LittleEndian2Int(substr($RKAUHeader, 3, 1));
+		$ThisFileInfo['rkau']['version']          = '1.'.str_pad($ThisFileInfo['rkau']['raw']['version'] &amp; 0x0F, 2, '0', STR_PAD_LEFT);
+		if (($ThisFileInfo['rkau']['version'] &gt; 1.07) || ($ThisFileInfo['rkau']['version'] &lt; 1.06)) {
+			$ThisFileInfo['error'][] = 'This version of getID3() can only parse RKAU files v1.06 and 1.07 (this file is v'.$ThisFileInfo['rkau']['version'].')';
+			unset($ThisFileInfo['rkau']);
+			return false;
+		}
+
+		$ThisFileInfo['rkau']['source_bytes']     = getid3_lib::LittleEndian2Int(substr($RKAUHeader,  4, 4));
+		$ThisFileInfo['rkau']['sample_rate']      = getid3_lib::LittleEndian2Int(substr($RKAUHeader,  8, 4));
+		$ThisFileInfo['rkau']['channels']         = getid3_lib::LittleEndian2Int(substr($RKAUHeader, 12, 1));
+		$ThisFileInfo['rkau']['bits_per_sample']  = getid3_lib::LittleEndian2Int(substr($RKAUHeader, 13, 1));
+
+		$ThisFileInfo['rkau']['raw']['quality']   = getid3_lib::LittleEndian2Int(substr($RKAUHeader, 14, 1));
+		$this-&gt;RKAUqualityLookup($ThisFileInfo['rkau']);
+
+		$ThisFileInfo['rkau']['raw']['flags']            = getid3_lib::LittleEndian2Int(substr($RKAUHeader, 15, 1));
+		$ThisFileInfo['rkau']['flags']['joint_stereo']   = (bool) (!($ThisFileInfo['rkau']['raw']['flags'] &amp; 0x01));
+		$ThisFileInfo['rkau']['flags']['streaming']      =  (bool)  ($ThisFileInfo['rkau']['raw']['flags'] &amp; 0x02);
+		$ThisFileInfo['rkau']['flags']['vrq_lossy_mode'] =  (bool)  ($ThisFileInfo['rkau']['raw']['flags'] &amp; 0x04);
+
+		if ($ThisFileInfo['rkau']['flags']['streaming']) {
+			$ThisFileInfo['avdataoffset'] += 20;
+			$ThisFileInfo['rkau']['compressed_bytes']  = getid3_lib::LittleEndian2Int(substr($RKAUHeader, 16, 4));
+		} else {
+			$ThisFileInfo['avdataoffset'] += 16;
+			$ThisFileInfo['rkau']['compressed_bytes'] = $ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset'] - 1;
+		}
+		// Note: compressed_bytes does not always equal what appears to be the actual number of compressed bytes,
+		// sometimes it's more, sometimes less. No idea why(?)
+
+		$ThisFileInfo['audio']['lossless']        = $ThisFileInfo['rkau']['lossless'];
+		$ThisFileInfo['audio']['channels']        = $ThisFileInfo['rkau']['channels'];
+		$ThisFileInfo['audio']['bits_per_sample'] = $ThisFileInfo['rkau']['bits_per_sample'];
+		$ThisFileInfo['audio']['sample_rate']     = $ThisFileInfo['rkau']['sample_rate'];
+
+		$ThisFileInfo['playtime_seconds']         = $ThisFileInfo['rkau']['source_bytes'] / ($ThisFileInfo['rkau']['sample_rate'] * $ThisFileInfo['rkau']['channels'] * ($ThisFileInfo['rkau']['bits_per_sample'] / 8));
+		$ThisFileInfo['audio']['bitrate']         = ($ThisFileInfo['rkau']['compressed_bytes'] * 8) / $ThisFileInfo['playtime_seconds'];
+
+		return true;
+
+	}
+
+
+	function RKAUqualityLookup(&amp;$RKAUdata) {
+		$level   = ($RKAUdata['raw']['quality'] &amp; 0xF0) &gt;&gt; 4;
+		$quality =  $RKAUdata['raw']['quality'] &amp; 0x0F;
+
+		$RKAUdata['lossless']          = (($quality == 0) ? true : false);
+		$RKAUdata['compression_level'] = $level + 1;
+		if (!$RKAUdata['lossless']) {
+			$RKAUdata['quality_setting'] = $quality;
+		}
+
+		return true;
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.shorten.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.shorten.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.shorten.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,178 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.shorten.php                                    //
+// module for analyzing Shorten Audio files                    //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_shorten
+{
+
+	function getid3_shorten(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+		$ShortenHeader = fread($fd, 8);
+		if (substr($ShortenHeader, 0, 4) != 'ajkg') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;ajkg&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.substr($ShortenHeader, 0, 4).'&quot;';
+			return false;
+		}
+		$ThisFileInfo['fileformat']            = 'shn';
+		$ThisFileInfo['audio']['dataformat']   = 'shn';
+		$ThisFileInfo['audio']['lossless']     = true;
+		$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+
+		$ThisFileInfo['shn']['version'] = getid3_lib::LittleEndian2Int(substr($ShortenHeader, 4, 1));
+
+		fseek($fd, $ThisFileInfo['avdataend'] - 12, SEEK_SET);
+		$SeekTableSignatureTest = fread($fd, 12);
+		$ThisFileInfo['shn']['seektable']['present'] = (bool) (substr($SeekTableSignatureTest, 4, 8) == 'SHNAMPSK');
+		if ($ThisFileInfo['shn']['seektable']['present']) {
+			$ThisFileInfo['shn']['seektable']['length'] = getid3_lib::LittleEndian2Int(substr($SeekTableSignatureTest, 0, 4));
+			$ThisFileInfo['shn']['seektable']['offset'] = $ThisFileInfo['avdataend'] - $ThisFileInfo['shn']['seektable']['length'];
+			fseek($fd, $ThisFileInfo['shn']['seektable']['offset'], SEEK_SET);
+			$SeekTableMagic = fread($fd, 4);
+			if ($SeekTableMagic != 'SEEK') {
+
+				$ThisFileInfo['error'][] = 'Expecting &quot;SEEK&quot; at offset '.$ThisFileInfo['shn']['seektable']['offset'].', found &quot;'.$SeekTableMagic.'&quot;';
+				return false;
+
+			} else {
+
+				// typedef struct tag_TSeekEntry
+				// {
+				//   unsigned long SampleNumber;
+				//   unsigned long SHNFileByteOffset;
+				//   unsigned long SHNLastBufferReadPosition;
+				//   unsigned short SHNByteGet;
+				//   unsigned short SHNBufferOffset;
+				//   unsigned short SHNFileBitOffset;
+				//   unsigned long SHNGBuffer;
+				//   unsigned short SHNBitShift;
+				//   long CBuf0[3];
+				//   long CBuf1[3];
+				//   long Offset0[4];
+				//   long Offset1[4];
+				// }TSeekEntry;
+
+				$SeekTableData = fread($fd, $ThisFileInfo['shn']['seektable']['length'] - 16);
+				$ThisFileInfo['shn']['seektable']['entry_count'] = floor(strlen($SeekTableData) / 80);
+				//$ThisFileInfo['shn']['seektable']['entries'] = array();
+				//$SeekTableOffset = 0;
+				//for ($i = 0; $i &lt; $ThisFileInfo['shn']['seektable']['entry_count']; $i++) {
+				//	$SeekTableEntry['sample_number'] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 4));
+				//	$SeekTableOffset += 4;
+				//	$SeekTableEntry['shn_file_byte_offset'] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 4));
+				//	$SeekTableOffset += 4;
+				//	$SeekTableEntry['shn_last_buffer_read_position'] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 4));
+				//	$SeekTableOffset += 4;
+				//	$SeekTableEntry['shn_byte_get'] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 2));
+				//	$SeekTableOffset += 2;
+				//	$SeekTableEntry['shn_buffer_offset'] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 2));
+				//	$SeekTableOffset += 2;
+				//	$SeekTableEntry['shn_file_bit_offset'] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 2));
+				//	$SeekTableOffset += 2;
+				//	$SeekTableEntry['shn_gbuffer'] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 4));
+				//	$SeekTableOffset += 4;
+				//	$SeekTableEntry['shn_bit_shift'] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 2));
+				//	$SeekTableOffset += 2;
+				//	for ($j = 0; $j &lt; 3; $j++) {
+				//		$SeekTableEntry['cbuf0'][$j] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 4));
+				//		$SeekTableOffset += 4;
+				//	}
+				//	for ($j = 0; $j &lt; 3; $j++) {
+				//		$SeekTableEntry['cbuf1'][$j] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 4));
+				//		$SeekTableOffset += 4;
+				//	}
+				//	for ($j = 0; $j &lt; 4; $j++) {
+				//		$SeekTableEntry['offset0'][$j] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 4));
+				//		$SeekTableOffset += 4;
+				//	}
+				//	for ($j = 0; $j &lt; 4; $j++) {
+				//		$SeekTableEntry['offset1'][$j] = getid3_lib::LittleEndian2Int(substr($SeekTableData, $SeekTableOffset, 4));
+				//		$SeekTableOffset += 4;
+				//	}
+                //
+				//	$ThisFileInfo['shn']['seektable']['entries'][] = $SeekTableEntry;
+				//}
+
+			}
+
+		}
+
+		if ((bool) ini_get('safe_mode')) {
+			$ThisFileInfo['error'][] = 'PHP running in Safe Mode - backtick operator not available, cannot run shntool to analyze Shorten files';
+			return false;
+		}
+
+		if (GETID3_OS_ISWINDOWS) {
+
+			$RequiredFiles = array('shorten.exe', 'cygwin1.dll', 'head.exe');
+			foreach ($RequiredFiles as $required_file) {
+				if (!is_readable(GETID3_HELPERAPPSDIR.$required_file)) {
+					$ThisFileInfo['error'][] = GETID3_HELPERAPPSDIR.$required_file.' does not exist';
+					return false;
+				}
+			}
+			$commandline = GETID3_HELPERAPPSDIR.'shorten.exe -x &quot;'.$ThisFileInfo['filenamepath'].'&quot; - | '.GETID3_HELPERAPPSDIR.'head.exe -c 44';
+
+		} else {
+
+	        static $shorten_present;
+	        if (!isset($shorten_present)) {
+                $shorten_present = file_exists('/usr/local/bin/shorten') || `which shorten`;
+            }
+            if (!$shorten_present) {
+                $ThisFileInfo['error'][] = 'shorten binary was not found in path or /usr/local/bin';
+                return false;
+            }
+            $commandline = (file_exists('/usr/local/bin/shorten') ? '/usr/local/bin/' : '' ) . 'shorten -x &quot;'.$ThisFileInfo['filenamepath'].'&quot; - | head -c 44';
+
+		}
+
+		$output = `$commandline`;
+
+		if (!empty($output) &amp;&amp; (substr($output, 12, 4) == 'fmt ')) {
+
+			getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.riff.php', __FILE__, true);
+
+			$DecodedWAVFORMATEX = getid3_riff::RIFFparseWAVEFORMATex(substr($output, 20, 16));
+			$ThisFileInfo['audio']['channels']        = $DecodedWAVFORMATEX['channels'];
+			$ThisFileInfo['audio']['bits_per_sample'] = $DecodedWAVFORMATEX['bits_per_sample'];
+			$ThisFileInfo['audio']['sample_rate']     = $DecodedWAVFORMATEX['sample_rate'];
+
+			if (substr($output, 36, 4) == 'data') {
+
+				$ThisFileInfo['playtime_seconds'] = getid3_lib::LittleEndian2Int(substr($output, 40, 4)) / $DecodedWAVFORMATEX['raw']['nAvgBytesPerSec'];
+
+			} else {
+
+				$ThisFileInfo['error'][] = 'shorten failed to decode DATA chunk to expected location, cannot determine playtime';
+				return false;
+
+			}
+
+			$ThisFileInfo['audio']['bitrate'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) / $ThisFileInfo['playtime_seconds']) * 8;
+
+		} else {
+
+			$ThisFileInfo['error'][] = 'shorten failed to decode file to WAV for parsing';
+			return false;
+
+		}
+
+		return true;
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.tta.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.tta.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.tta.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,107 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.tta.php                                        //
+// module for analyzing TTA Audio files                        //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_tta
+{
+
+	function getid3_tta(&amp;$fd, &amp;$ThisFileInfo) {
+
+		$ThisFileInfo['fileformat']            = 'tta';
+		$ThisFileInfo['audio']['dataformat']   = 'tta';
+		$ThisFileInfo['audio']['lossless']     = true;
+		$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$ttaheader = fread($fd, 26);
+
+		$ThisFileInfo['tta']['magic'] = substr($ttaheader,  0,  3);
+		if ($ThisFileInfo['tta']['magic'] != 'TTA') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;TTA&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$ThisFileInfo['tta']['magic'].'&quot;';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['audio']);
+			unset($ThisFileInfo['tta']);
+			return false;
+		}
+
+		switch ($ttaheader{3}) {
+			case &quot;\x01&quot;: // TTA v1.x
+			case &quot;\x02&quot;: // TTA v1.x
+			case &quot;\x03&quot;: // TTA v1.x
+				// &quot;It was the demo-version of the TTA encoder. There is no released format with such header. TTA encoder v1 is not supported about a year.&quot;
+				$ThisFileInfo['tta']['major_version'] = 1;
+				$ThisFileInfo['avdataoffset'] += 16;
+
+				$ThisFileInfo['tta']['compression_level']   = ord($ttaheader{3});
+				$ThisFileInfo['tta']['channels']            = getid3_lib::LittleEndian2Int(substr($ttaheader,  4,  2));
+				$ThisFileInfo['tta']['bits_per_sample']     = getid3_lib::LittleEndian2Int(substr($ttaheader,  6,  2));
+				$ThisFileInfo['tta']['sample_rate']         = getid3_lib::LittleEndian2Int(substr($ttaheader,  8,  4));
+				$ThisFileInfo['tta']['samples_per_channel'] = getid3_lib::LittleEndian2Int(substr($ttaheader, 12,  4));
+
+				$ThisFileInfo['audio']['encoder_options']   = '-e'.$ThisFileInfo['tta']['compression_level'];
+				$ThisFileInfo['playtime_seconds']           = $ThisFileInfo['tta']['samples_per_channel'] / $ThisFileInfo['tta']['sample_rate'];
+				break;
+
+			case '2': // TTA v2.x
+				// &quot;I have hurried to release the TTA 2.0 encoder. Format documentation is removed from our site. This format still in development. Please wait the TTA2 format, encoder v4.&quot;
+				$ThisFileInfo['tta']['major_version'] = 2;
+				$ThisFileInfo['avdataoffset'] += 20;
+
+				$ThisFileInfo['tta']['compression_level']   = getid3_lib::LittleEndian2Int(substr($ttaheader,  4,  2));
+				$ThisFileInfo['tta']['audio_format']        = getid3_lib::LittleEndian2Int(substr($ttaheader,  6,  2));
+				$ThisFileInfo['tta']['channels']            = getid3_lib::LittleEndian2Int(substr($ttaheader,  8,  2));
+				$ThisFileInfo['tta']['bits_per_sample']     = getid3_lib::LittleEndian2Int(substr($ttaheader, 10,  2));
+				$ThisFileInfo['tta']['sample_rate']         = getid3_lib::LittleEndian2Int(substr($ttaheader, 12,  4));
+				$ThisFileInfo['tta']['data_length']         = getid3_lib::LittleEndian2Int(substr($ttaheader, 16,  4));
+
+				$ThisFileInfo['audio']['encoder_options']   = '-e'.$ThisFileInfo['tta']['compression_level'];
+				$ThisFileInfo['playtime_seconds']           = $ThisFileInfo['tta']['data_length'] / $ThisFileInfo['tta']['sample_rate'];
+				break;
+
+			case '1': // TTA v3.x
+				// &quot;This is a first stable release of the TTA format. It will be supported by the encoders v3 or higher.&quot;
+				$ThisFileInfo['tta']['major_version'] = 3;
+				$ThisFileInfo['avdataoffset'] += 26;
+
+				$ThisFileInfo['tta']['audio_format']        = getid3_lib::LittleEndian2Int(substr($ttaheader,  4,  2)); // getid3_riff::RIFFwFormatTagLookup()
+				$ThisFileInfo['tta']['channels']            = getid3_lib::LittleEndian2Int(substr($ttaheader,  6,  2));
+				$ThisFileInfo['tta']['bits_per_sample']     = getid3_lib::LittleEndian2Int(substr($ttaheader,  8,  2));
+				$ThisFileInfo['tta']['sample_rate']         = getid3_lib::LittleEndian2Int(substr($ttaheader, 10,  4));
+				$ThisFileInfo['tta']['data_length']         = getid3_lib::LittleEndian2Int(substr($ttaheader, 14,  4));
+				$ThisFileInfo['tta']['crc32_footer']        =                              substr($ttaheader, 18,  4);
+				$ThisFileInfo['tta']['seek_point']          = getid3_lib::LittleEndian2Int(substr($ttaheader, 22,  4));
+
+				$ThisFileInfo['playtime_seconds']           = $ThisFileInfo['tta']['data_length'] / $ThisFileInfo['tta']['sample_rate'];
+				break;
+
+			default:
+				$ThisFileInfo['error'][] = 'This version of getID3() only knows how to handle TTA v1 and v2 - it may not work correctly with this file which appears to be TTA v'.$ttaheader{3};
+				return false;
+				break;
+		}
+
+		$ThisFileInfo['audio']['encoder']         = 'TTA v'.$ThisFileInfo['tta']['major_version'];
+		$ThisFileInfo['audio']['bits_per_sample'] = $ThisFileInfo['tta']['bits_per_sample'];
+		$ThisFileInfo['audio']['sample_rate']     = $ThisFileInfo['tta']['sample_rate'];
+		$ThisFileInfo['audio']['channels']        = $ThisFileInfo['tta']['channels'];
+		$ThisFileInfo['audio']['bitrate']         = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+
+		return true;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.voc.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.voc.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.voc.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,205 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.voc.php                                        //
+// module for analyzing Creative VOC Audio files               //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_voc
+{
+
+	function getid3_voc(&amp;$fd, &amp;$ThisFileInfo) {
+
+		$OriginalAVdataOffset = $ThisFileInfo['avdataoffset'];
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$VOCheader  = fread($fd, 26);
+
+		if (substr($VOCheader, 0, 19) != 'Creative Voice File') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;Creative Voice File&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.substr($VOCheader, 0, 19).'&quot;';
+			return false;
+		}
+
+		// shortcuts
+		$thisfile_audio = &amp;$ThisFileInfo['audio'];
+		$ThisFileInfo['voc'] = array();
+		$thisfile_voc        = &amp;$ThisFileInfo['voc'];
+
+		$ThisFileInfo['fileformat']               = 'voc';
+		$thisfile_audio['dataformat']      = 'voc';
+		$thisfile_audio['bitrate_mode']    = 'cbr';
+		$thisfile_audio['lossless']        = true;
+		$thisfile_audio['channels']        = 1; // might be overriden below
+		$thisfile_audio['bits_per_sample'] = 8; // might be overriden below
+
+		// byte #     Description
+		// ------     ------------------------------------------
+		// 00-12      'Creative Voice File'
+		// 13         1A (eof to abort printing of file)
+		// 14-15      Offset of first datablock in .voc file (std 1A 00 in Intel Notation)
+		// 16-17      Version number (minor,major) (VOC-HDR puts 0A 01)
+		// 18-19      2's Comp of Ver. # + 1234h (VOC-HDR puts 29 11)
+
+		$thisfile_voc['header']['datablock_offset'] = getid3_lib::LittleEndian2Int(substr($VOCheader, 20, 2));
+		$thisfile_voc['header']['minor_version']    = getid3_lib::LittleEndian2Int(substr($VOCheader, 22, 1));
+		$thisfile_voc['header']['major_version']    = getid3_lib::LittleEndian2Int(substr($VOCheader, 23, 1));
+
+		do {
+
+			$BlockOffset    = ftell($fd);
+			$BlockData      = fread($fd, 4);
+			$BlockType      = ord($BlockData{0});
+			$BlockSize      = getid3_lib::LittleEndian2Int(substr($BlockData, 1, 3));
+			$ThisBlock      = array();
+
+			@$thisfile_voc['blocktypes'][$BlockType]++;
+			switch ($BlockType) {
+				case 0:  // Terminator
+					// do nothing, we'll break out of the loop down below
+					break;
+
+				case 1:  // Sound data
+					$BlockData .= fread($fd, 2);
+					if ($ThisFileInfo['avdataoffset'] &lt;= $OriginalAVdataOffset) {
+						$ThisFileInfo['avdataoffset'] = ftell($fd);
+					}
+					fseek($fd, $BlockSize - 2, SEEK_CUR);
+
+					$ThisBlock['sample_rate_id']   = getid3_lib::LittleEndian2Int(substr($BlockData, 4, 1));
+					$ThisBlock['compression_type'] = getid3_lib::LittleEndian2Int(substr($BlockData, 5, 1));
+
+					$ThisBlock['compression_name'] = $this-&gt;VOCcompressionTypeLookup($ThisBlock['compression_type']);
+					if ($ThisBlock['compression_type'] &lt;= 3) {
+						$thisfile_voc['compressed_bits_per_sample'] = getid3_lib::CastAsInt(str_replace('-bit', '', $ThisBlock['compression_name']));
+					}
+
+					// Less accurate sample_rate calculation than the Extended block (#8) data (but better than nothing if Extended Block is not available)
+					if (empty($thisfile_audio['sample_rate'])) {
+						// SR byte = 256 - (1000000 / sample_rate)
+						$thisfile_audio['sample_rate'] = getid3_lib::trunc((1000000 / (256 - $ThisBlock['sample_rate_id'])) / $thisfile_audio['channels']);
+					}
+					break;
+
+				case 2:  // Sound continue
+				case 3:  // Silence
+				case 4:  // Marker
+				case 6:  // Repeat
+				case 7:  // End repeat
+					// nothing useful, just skip
+					fseek($fd, $BlockSize, SEEK_CUR);
+					break;
+
+				case 8:  // Extended
+					$BlockData .= fread($fd, 4);
+
+					//00-01  Time Constant:
+					//   Mono: 65536 - (256000000 / sample_rate)
+					// Stereo: 65536 - (256000000 / (sample_rate * 2))
+					$ThisBlock['time_constant'] =        getid3_lib::LittleEndian2Int(substr($BlockData, 4, 2));
+					$ThisBlock['pack_method']   =        getid3_lib::LittleEndian2Int(substr($BlockData, 6, 1));
+					$ThisBlock['stereo']        = (bool) getid3_lib::LittleEndian2Int(substr($BlockData, 7, 1));
+
+					$thisfile_audio['channels']    = ($ThisBlock['stereo'] ? 2 : 1);
+					$thisfile_audio['sample_rate'] = getid3_lib::trunc((256000000 / (65536 - $ThisBlock['time_constant'])) / $thisfile_audio['channels']);
+					break;
+
+				case 9:  // data block that supersedes blocks 1 and 8. Used for stereo, 16 bit
+					$BlockData .= fread($fd, 12);
+					if ($ThisFileInfo['avdataoffset'] &lt;= $OriginalAVdataOffset) {
+						$ThisFileInfo['avdataoffset'] = ftell($fd);
+					}
+					fseek($fd, $BlockSize - 12, SEEK_CUR);
+
+					$ThisBlock['sample_rate']      = getid3_lib::LittleEndian2Int(substr($BlockData,  4, 4));
+					$ThisBlock['bits_per_sample']  = getid3_lib::LittleEndian2Int(substr($BlockData,  8, 1));
+					$ThisBlock['channels']         = getid3_lib::LittleEndian2Int(substr($BlockData,  9, 1));
+					$ThisBlock['wFormat']          = getid3_lib::LittleEndian2Int(substr($BlockData, 10, 2));
+
+					$ThisBlock['compression_name'] = $this-&gt;VOCwFormatLookup($ThisBlock['wFormat']);
+					if ($this-&gt;VOCwFormatActualBitsPerSampleLookup($ThisBlock['wFormat'])) {
+						$thisfile_voc['compressed_bits_per_sample'] = $this-&gt;VOCwFormatActualBitsPerSampleLookup($ThisBlock['wFormat']);
+					}
+
+					$thisfile_audio['sample_rate']     = $ThisBlock['sample_rate'];
+					$thisfile_audio['bits_per_sample'] = $ThisBlock['bits_per_sample'];
+					$thisfile_audio['channels']        = $ThisBlock['channels'];
+					break;
+
+				default:
+					$ThisFileInfo['warning'][] = 'Unhandled block type &quot;'.$BlockType.'&quot; at offset '.$BlockOffset;
+					fseek($fd, $BlockSize, SEEK_CUR);
+					break;
+			}
+
+			if (!empty($ThisBlock)) {
+				$ThisBlock['block_offset']  = $BlockOffset;
+				$ThisBlock['block_size']    = $BlockSize;
+				$ThisBlock['block_type_id'] = $BlockType;
+				$thisfile_voc['blocks'][] = $ThisBlock;
+			}
+
+		} while (!feof($fd) &amp;&amp; ($BlockType != 0));
+
+		// Terminator block doesn't have size field, so seek back 3 spaces
+		fseek($fd, -3, SEEK_CUR);
+
+		ksort($thisfile_voc['blocktypes']);
+
+		if (!empty($thisfile_voc['compressed_bits_per_sample'])) {
+			$ThisFileInfo['playtime_seconds'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / ($thisfile_voc['compressed_bits_per_sample'] * $thisfile_audio['channels'] * $thisfile_audio['sample_rate']);
+			$thisfile_audio['bitrate'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+		}
+
+		return true;
+	}
+
+	function VOCcompressionTypeLookup($index) {
+		static $VOCcompressionTypeLookup = array(
+			0 =&gt; '8-bit',
+			1 =&gt; '4-bit',
+			2 =&gt; '2.6-bit',
+			3 =&gt; '2-bit'
+		);
+		return (isset($VOCcompressionTypeLookup[$index]) ? $VOCcompressionTypeLookup[$index] : 'Multi DAC ('.($index - 3).') channels');
+	}
+
+	function VOCwFormatLookup($index) {
+		static $VOCwFormatLookup = array(
+			0x0000 =&gt; '8-bit unsigned PCM',
+			0x0001 =&gt; 'Creative 8-bit to 4-bit ADPCM',
+			0x0002 =&gt; 'Creative 8-bit to 3-bit ADPCM',
+			0x0003 =&gt; 'Creative 8-bit to 2-bit ADPCM',
+			0x0004 =&gt; '16-bit signed PCM',
+			0x0006 =&gt; 'CCITT a-Law',
+			0x0007 =&gt; 'CCITT u-Law',
+			0x2000 =&gt; 'Creative 16-bit to 4-bit ADPCM'
+		);
+		return (isset($VOCwFormatLookup[$index]) ? $VOCwFormatLookup[$index] : false);
+	}
+
+	function VOCwFormatActualBitsPerSampleLookup($index) {
+		static $VOCwFormatLookup = array(
+			0x0000 =&gt; 8,
+			0x0001 =&gt; 4,
+			0x0002 =&gt; 3,
+			0x0003 =&gt; 2,
+			0x0004 =&gt; 16,
+			0x0006 =&gt; 8,
+			0x0007 =&gt; 8,
+			0x2000 =&gt; 4
+		);
+		return (isset($VOCwFormatLookup[$index]) ? $VOCwFormatLookup[$index] : false);
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.vqf.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.vqf.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.vqf.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,159 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.vqf.php                                        //
+// module for analyzing VQF audio files                        //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_vqf
+{
+	function getid3_vqf(&amp;$fd, &amp;$ThisFileInfo) {
+		// based loosely on code from TTwinVQ by Jurgen Faul &lt;jfaul&#216;gmx*de&gt;
+		// <A HREF="http://jfaul.de/atl">http://jfaul.de/atl</A>  or  <A HREF="http://j-faul.virtualave.net/atl/atl.html">http://j-faul.virtualave.net/atl/atl.html</A>
+
+		$ThisFileInfo['fileformat']            = 'vqf';
+		$ThisFileInfo['audio']['dataformat']   = 'vqf';
+		$ThisFileInfo['audio']['bitrate_mode'] = 'cbr';
+		$ThisFileInfo['audio']['lossless']     = false;
+
+		// shortcut
+		$ThisFileInfo['vqf']['raw'] = array();
+		$thisfile_vqf               = &amp;$ThisFileInfo['vqf'];
+		$thisfile_vqf_raw           = &amp;$thisfile_vqf['raw'];
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$VQFheaderData = fread($fd, 16);
+
+		$offset = 0;
+		$thisfile_vqf_raw['header_tag']     =               substr($VQFheaderData, $offset, 4);
+		if ($thisfile_vqf_raw['header_tag'] != 'TWIN') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;TWIN&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$thisfile_vqf_raw['header_tag'].'&quot;';
+			unset($ThisFileInfo['vqf']);
+			unset($ThisFileInfo['fileformat']);
+			return false;
+		}
+		$offset += 4;
+		$thisfile_vqf_raw['version']        =               substr($VQFheaderData, $offset, 8);
+		$offset += 8;
+		$thisfile_vqf_raw['size']           = getid3_lib::BigEndian2Int(substr($VQFheaderData, $offset, 4));
+		$offset += 4;
+
+		while (ftell($fd) &lt; $ThisFileInfo['avdataend']) {
+
+			$ChunkBaseOffset = ftell($fd);
+			$chunkoffset = 0;
+			$ChunkData = fread($fd, 8);
+			$ChunkName = substr($ChunkData, $chunkoffset, 4);
+			if ($ChunkName == 'DATA') {
+				$ThisFileInfo['avdataoffset'] = $ChunkBaseOffset;
+				break;
+			}
+			$chunkoffset += 4;
+			$ChunkSize = getid3_lib::BigEndian2Int(substr($ChunkData, $chunkoffset, 4));
+			$chunkoffset += 4;
+			if ($ChunkSize &gt; ($ThisFileInfo['avdataend'] - ftell($fd))) {
+				$ThisFileInfo['error'][] = 'Invalid chunk size ('.$ChunkSize.') for chunk &quot;'.$ChunkName.'&quot; at offset '.$ChunkBaseOffset;
+				break;
+			}
+			if ($ChunkSize &gt; 0) {
+				$ChunkData .= fread($fd, $ChunkSize);
+			}
+
+			switch ($ChunkName) {
+				case 'COMM':
+					// shortcut
+					$thisfile_vqf['COMM'] = array();
+					$thisfile_vqf_COMM    = &amp;$thisfile_vqf['COMM'];
+
+					$thisfile_vqf_COMM['channel_mode']   = getid3_lib::BigEndian2Int(substr($ChunkData, $chunkoffset, 4));
+					$chunkoffset += 4;
+					$thisfile_vqf_COMM['bitrate']        = getid3_lib::BigEndian2Int(substr($ChunkData, $chunkoffset, 4));
+					$chunkoffset += 4;
+					$thisfile_vqf_COMM['sample_rate']    = getid3_lib::BigEndian2Int(substr($ChunkData, $chunkoffset, 4));
+					$chunkoffset += 4;
+					$thisfile_vqf_COMM['security_level'] = getid3_lib::BigEndian2Int(substr($ChunkData, $chunkoffset, 4));
+					$chunkoffset += 4;
+
+					$ThisFileInfo['audio']['channels']        = $thisfile_vqf_COMM['channel_mode'] + 1;
+					$ThisFileInfo['audio']['sample_rate']     = $this-&gt;VQFchannelFrequencyLookup($thisfile_vqf_COMM['sample_rate']);
+					$ThisFileInfo['audio']['bitrate']         = $thisfile_vqf_COMM['bitrate'] * 1000;
+					$ThisFileInfo['audio']['encoder_options'] = 'CBR' . ceil($ThisFileInfo['audio']['bitrate']/1000);
+
+					if ($ThisFileInfo['audio']['bitrate'] == 0) {
+						$ThisFileInfo['error'][] = 'Corrupt VQF file: bitrate_audio == zero';
+						return false;
+					}
+					break;
+
+				case 'NAME':
+				case 'AUTH':
+				case '(c) ':
+				case 'FILE':
+				case 'COMT':
+				case 'ALBM':
+					$thisfile_vqf['comments'][$this-&gt;VQFcommentNiceNameLookup($ChunkName)][] = trim(substr($ChunkData, 8));
+					break;
+
+				case 'DSIZ':
+					$thisfile_vqf['DSIZ'] = getid3_lib::BigEndian2Int(substr($ChunkData, 8, 4));
+					break;
+
+				default:
+					$ThisFileInfo['warning'][] = 'Unhandled chunk type &quot;'.$ChunkName.'&quot; at offset '.$ChunkBaseOffset;
+					break;
+			}
+		}
+
+		$ThisFileInfo['playtime_seconds'] = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['audio']['bitrate'];
+
+		if (isset($thisfile_vqf['DSIZ']) &amp;&amp; (($thisfile_vqf['DSIZ'] != ($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset'] - strlen('DATA'))))) {
+			switch ($thisfile_vqf['DSIZ']) {
+				case 0:
+				case 1:
+					$ThisFileInfo['warning'][] = 'Invalid DSIZ value &quot;'.$thisfile_vqf['DSIZ'].'&quot;. This is known to happen with VQF files encoded by Ahead Nero, and seems to be its way of saying this is TwinVQF v'.($thisfile_vqf['DSIZ'] + 1).'.0';
+					$ThisFileInfo['audio']['encoder'] = 'Ahead Nero';
+					break;
+
+				default:
+					$ThisFileInfo['warning'][] = 'Probable corrupted file - should be '.$thisfile_vqf['DSIZ'].' bytes, actually '.($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset'] - strlen('DATA'));
+					break;
+			}
+		}
+
+		return true;
+	}
+
+	function VQFchannelFrequencyLookup($frequencyid) {
+		static $VQFchannelFrequencyLookup = array(
+			11 =&gt; 11025,
+			22 =&gt; 22050,
+			44 =&gt; 44100
+		);
+		return (isset($VQFchannelFrequencyLookup[$frequencyid]) ? $VQFchannelFrequencyLookup[$frequencyid] : $frequencyid * 1000);
+	}
+
+	function VQFcommentNiceNameLookup($shortname) {
+		static $VQFcommentNiceNameLookup = array(
+			'NAME' =&gt; 'title',
+			'AUTH' =&gt; 'artist',
+			'(c) ' =&gt; 'copyright',
+			'FILE' =&gt; 'filename',
+			'COMT' =&gt; 'comment',
+			'ALBM' =&gt; 'album'
+		);
+		return (isset($VQFcommentNiceNameLookup[$shortname]) ? $VQFcommentNiceNameLookup[$shortname] : $shortname);
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.wavpack.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.wavpack.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.audio.wavpack.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,372 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.audio.wavpack.php                                    //
+// module for analyzing WavPack v4.0+ Audio files              //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_wavpack
+{
+
+	function getid3_wavpack(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+		while (true) {
+
+			$wavpackheader = fread($fd, 32);
+
+			if (ftell($fd) &gt;= $ThisFileInfo['avdataend']) {
+				break;
+			} elseif (feof($fd)) {
+				break;
+			} elseif (
+				(@$ThisFileInfo['wavpack']['blockheader']['total_samples'] &gt; 0) &amp;&amp;
+				(@$ThisFileInfo['wavpack']['blockheader']['block_samples'] &gt; 0) &amp;&amp;
+				(!isset($ThisFileInfo['wavpack']['riff_trailer_size']) || ($ThisFileInfo['wavpack']['riff_trailer_size'] &lt;= 0)) &amp;&amp;
+				((@$ThisFileInfo['wavpack']['config_flags']['md5_checksum'] === false) || !empty($ThisFileInfo['md5_data_source']))) {
+					break;
+			}
+
+			$blockheader_offset = ftell($fd) - 32;
+			$blockheader_magic  =                              substr($wavpackheader,  0,  4);
+			$blockheader_size   = getid3_lib::LittleEndian2Int(substr($wavpackheader,  4,  4));
+
+			if ($blockheader_magic != 'wvpk') {
+				$ThisFileInfo['error'][] = 'Expecting &quot;wvpk&quot; at offset '.$blockheader_offset.', found &quot;'.$blockheader_magic.'&quot;';
+				if ((@$ThisFileInfo['audio']['dataformat'] != 'wavpack') &amp;&amp; (@$ThisFileInfo['audio']['dataformat'] != 'wvc')) {
+					unset($ThisFileInfo['fileformat']);
+					unset($ThisFileInfo['audio']);
+					unset($ThisFileInfo['wavpack']);
+				}
+				return false;
+			}
+
+
+			if ((@$ThisFileInfo['wavpack']['blockheader']['block_samples'] &lt;= 0) ||
+				(@$ThisFileInfo['wavpack']['blockheader']['total_samples'] &lt;= 0)) {
+				// Also, it is possible that the first block might not have
+				// any samples (block_samples == 0) and in this case you should skip blocks
+				// until you find one with samples because the other information (like
+				// total_samples) are not guaranteed to be correct until (block_samples &gt; 0)
+
+				// Finally, I have defined a format for files in which the length is not known
+				// (for example when raw files are created using pipes). In these cases
+				// total_samples will be -1 and you must seek to the final block to determine
+				// the total number of samples.
+
+
+				$ThisFileInfo['audio']['dataformat']   = 'wavpack';
+				$ThisFileInfo['fileformat']            = 'wavpack';
+				$ThisFileInfo['audio']['lossless']     = true;
+				$ThisFileInfo['audio']['bitrate_mode'] = 'vbr';
+
+				$ThisFileInfo['wavpack']['blockheader']['offset'] = $blockheader_offset;
+				$ThisFileInfo['wavpack']['blockheader']['magic']  = $blockheader_magic;
+				$ThisFileInfo['wavpack']['blockheader']['size']   = $blockheader_size;
+
+				if ($ThisFileInfo['wavpack']['blockheader']['size'] &gt;= 0x100000) {
+					$ThisFileInfo['error'][] = 'Expecting WavPack block size less than &quot;0x100000&quot;, found &quot;'.$ThisFileInfo['wavpack']['blockheader']['size'].'&quot; at offset '.$ThisFileInfo['wavpack']['blockheader']['offset'];
+					if ((@$ThisFileInfo['audio']['dataformat'] != 'wavpack') &amp;&amp; (@$ThisFileInfo['audio']['dataformat'] != 'wvc')) {
+						unset($ThisFileInfo['fileformat']);
+						unset($ThisFileInfo['audio']);
+						unset($ThisFileInfo['wavpack']);
+					}
+					return false;
+				}
+
+				$ThisFileInfo['wavpack']['blockheader']['minor_version'] = ord($wavpackheader{8});
+				$ThisFileInfo['wavpack']['blockheader']['major_version'] = ord($wavpackheader{9});
+
+				if (($ThisFileInfo['wavpack']['blockheader']['major_version'] != 4) ||
+					(($ThisFileInfo['wavpack']['blockheader']['minor_version'] &lt; 4) &amp;&amp;
+					($ThisFileInfo['wavpack']['blockheader']['minor_version'] &gt; 16))) {
+						$ThisFileInfo['error'][] = 'Expecting WavPack version between &quot;4.2&quot; and &quot;4.16&quot;, found version &quot;'.$ThisFileInfo['wavpack']['blockheader']['major_version'].'.'.$ThisFileInfo['wavpack']['blockheader']['minor_version'].'&quot; at offset '.$ThisFileInfo['wavpack']['blockheader']['offset'];
+						if ((@$ThisFileInfo['audio']['dataformat'] != 'wavpack') &amp;&amp; (@$ThisFileInfo['audio']['dataformat'] != 'wvc')) {
+							unset($ThisFileInfo['fileformat']);
+							unset($ThisFileInfo['audio']);
+							unset($ThisFileInfo['wavpack']);
+						}
+						return false;
+				}
+
+				$ThisFileInfo['wavpack']['blockheader']['track_number']  = ord($wavpackheader{10}); // unused
+				$ThisFileInfo['wavpack']['blockheader']['index_number']  = ord($wavpackheader{11}); // unused
+				$ThisFileInfo['wavpack']['blockheader']['total_samples'] = getid3_lib::LittleEndian2Int(substr($wavpackheader, 12,  4));
+				$ThisFileInfo['wavpack']['blockheader']['block_index']   = getid3_lib::LittleEndian2Int(substr($wavpackheader, 16,  4));
+				$ThisFileInfo['wavpack']['blockheader']['block_samples'] = getid3_lib::LittleEndian2Int(substr($wavpackheader, 20,  4));
+				$ThisFileInfo['wavpack']['blockheader']['flags_raw']     = getid3_lib::LittleEndian2Int(substr($wavpackheader, 24,  4));
+				$ThisFileInfo['wavpack']['blockheader']['crc']           = getid3_lib::LittleEndian2Int(substr($wavpackheader, 28,  4));
+
+				$ThisFileInfo['wavpack']['blockheader']['flags']['bytes_per_sample']     =    1 + ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000003);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['mono']                 = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000004);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['hybrid']               = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000008);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['joint_stereo']         = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000010);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['cross_decorrelation']  = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000020);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['hybrid_noiseshape']    = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000040);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['ieee_32bit_float']     = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000080);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['int_32bit']            = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000100);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['hybrid_bitrate_noise'] = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000200);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['hybrid_balance_noise'] = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000400);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['multichannel_initial'] = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00000800);
+				$ThisFileInfo['wavpack']['blockheader']['flags']['multichannel_final']   = (bool) ($ThisFileInfo['wavpack']['blockheader']['flags_raw'] &amp; 0x00001000);
+
+				$ThisFileInfo['audio']['lossless'] = !$ThisFileInfo['wavpack']['blockheader']['flags']['hybrid'];
+			}
+
+			while (!feof($fd) &amp;&amp; (ftell($fd) &lt; ($blockheader_offset + $blockheader_size + 8))) {
+
+				$metablock = array('offset'=&gt;ftell($fd));
+				$metablockheader = fread($fd, 2);
+				if (feof($fd)) {
+					break;
+				}
+				$metablock['id'] = ord($metablockheader{0});
+				$metablock['function_id'] = ($metablock['id'] &amp; 0x3F);
+				$metablock['function_name'] = $this-&gt;WavPackMetablockNameLookup($metablock['function_id']);
+
+				// The 0x20 bit in the id of the meta subblocks (which is defined as
+				// ID_OPTIONAL_DATA) is a permanent part of the id. The idea is that
+				// if a decoder encounters an id that it does not know about, it uses
+				// that &quot;ID_OPTIONAL_DATA&quot; flag to determine what to do. If it is set
+				// then the decoder simply ignores the metadata, but if it is zero
+				// then the decoder should quit because it means that an understanding
+				// of the metadata is required to correctly decode the audio.
+				$metablock['non_decoder'] = (bool) ($metablock['id'] &amp; 0x20);
+
+				$metablock['padded_data'] = (bool) ($metablock['id'] &amp; 0x40);
+				$metablock['large_block'] = (bool) ($metablock['id'] &amp; 0x80);
+				if ($metablock['large_block']) {
+					$metablockheader .= fread($fd, 2);
+				}
+				$metablock['size'] = getid3_lib::LittleEndian2Int(substr($metablockheader, 1)) * 2; // size is stored in words
+				$metablock['data'] = null;
+
+				if ($metablock['size'] &gt; 0) {
+
+					switch ($metablock['function_id']) {
+						case 0x21: // ID_RIFF_HEADER
+						case 0x22: // ID_RIFF_TRAILER
+						case 0x23: // ID_REPLAY_GAIN
+						case 0x24: // ID_CUESHEET
+						case 0x25: // ID_CONFIG_BLOCK
+						case 0x26: // ID_MD5_CHECKSUM
+							$metablock['data'] = fread($fd, $metablock['size']);
+
+							if ($metablock['padded_data']) {
+								// padded to the nearest even byte
+								$metablock['size']--;
+								$metablock['data'] = substr($metablock['data'], 0, -1);
+							}
+							break;
+
+						case 0x00: // ID_DUMMY
+						case 0x01: // ID_ENCODER_INFO
+						case 0x02: // ID_DECORR_TERMS
+						case 0x03: // ID_DECORR_WEIGHTS
+						case 0x04: // ID_DECORR_SAMPLES
+						case 0x05: // ID_ENTROPY_VARS
+						case 0x06: // ID_HYBRID_PROFILE
+						case 0x07: // ID_SHAPING_WEIGHTS
+						case 0x08: // ID_FLOAT_INFO
+						case 0x09: // ID_INT32_INFO
+						case 0x0A: // ID_WV_BITSTREAM
+						case 0x0B: // ID_WVC_BITSTREAM
+						case 0x0C: // ID_WVX_BITSTREAM
+						case 0x0D: // ID_CHANNEL_INFO
+							fseek($fd, $metablock['offset'] + ($metablock['large_block'] ? 4 : 2) + $metablock['size'], SEEK_SET);
+							break;
+
+						default:
+							$ThisFileInfo['warning'][] = 'Unexpected metablock type &quot;0x'.str_pad(dechex($metablock['function_id']), 2, '0', STR_PAD_LEFT).'&quot; at offset '.$metablock['offset'];
+							fseek($fd, $metablock['offset'] + ($metablock['large_block'] ? 4 : 2) + $metablock['size'], SEEK_SET);
+							break;
+					}
+
+					switch ($metablock['function_id']) {
+						case 0x21: // ID_RIFF_HEADER
+							getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.riff.php', __FILE__, true);
+							$original_wav_filesize = getid3_lib::LittleEndian2Int(substr($metablock['data'], 4, 4));
+							getid3_riff::ParseRIFFdata($metablock['data'], $ParsedRIFFheader);
+							$metablock['riff'] = $ParsedRIFFheader['riff'];
+							$metablock['riff']['original_filesize'] = $original_wav_filesize;
+							$ThisFileInfo['wavpack']['riff_trailer_size'] = $original_wav_filesize - $metablock['riff']['WAVE']['data'][0]['size'] - $metablock['riff']['header_size'];
+
+							$ThisFileInfo['audio']['sample_rate'] = $ParsedRIFFheader['riff']['raw']['fmt ']['nSamplesPerSec'];
+							$ThisFileInfo['playtime_seconds']     = $ThisFileInfo['wavpack']['blockheader']['total_samples'] / $ThisFileInfo['audio']['sample_rate'];
+
+							// Safe RIFF header in case there's a RIFF footer later
+							$metablockRIFFheader = $metablock['data'];
+							break;
+
+
+						case 0x22: // ID_RIFF_TRAILER
+							$metablockRIFFfooter = $metablockRIFFheader.$metablock['data'];
+							getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio-video.riff.php', __FILE__, true);
+
+							$ftell_old = ftell($fd);
+							$startoffset = $metablock['offset'] + ($metablock['large_block'] ? 4 : 2);
+							$ParsedRIFFfooter = array('avdataend'=&gt;$ThisFileInfo['avdataend'], 'fileformat'=&gt;'riff', 'error'=&gt;array(), 'warning'=&gt;array());
+							$metablock['riff'] = getid3_riff::ParseRIFF($fd, $startoffset, $startoffset + $metablock['size'], $ParsedRIFFfooter);
+							fseek($fd, $ftell_old, SEEK_SET);
+
+							if (!empty($metablock['riff']['INFO'])) {
+								getid3_riff::RIFFcommentsParse($metablock['riff']['INFO'], $metablock['comments']);
+								$ThisFileInfo['tags']['riff'] = $metablock['comments'];
+							}
+							break;
+
+
+						case 0x23: // ID_REPLAY_GAIN
+							$ThisFileInfo['warning'][] = 'WavPack &quot;Replay Gain&quot; contents not yet handled by getID3() in metablock at offset '.$metablock['offset'];
+							break;
+
+
+						case 0x24: // ID_CUESHEET
+							$ThisFileInfo['warning'][] = 'WavPack &quot;Cuesheet&quot; contents not yet handled by getID3() in metablock at offset '.$metablock['offset'];
+							break;
+
+
+						case 0x25: // ID_CONFIG_BLOCK
+							$metablock['flags_raw'] = getid3_lib::LittleEndian2Int(substr($metablock['data'], 0, 3));
+
+							$metablock['flags']['adobe_mode']     = (bool) ($metablock['flags_raw'] &amp; 0x000001); // &quot;adobe&quot; mode for 32-bit floats
+							$metablock['flags']['fast_flag']      = (bool) ($metablock['flags_raw'] &amp; 0x000002); // fast mode
+							$metablock['flags']['very_fast_flag'] = (bool) ($metablock['flags_raw'] &amp; 0x000004); // double fast
+							$metablock['flags']['high_flag']      = (bool) ($metablock['flags_raw'] &amp; 0x000008); // high quality mode
+							$metablock['flags']['very_high_flag'] = (bool) ($metablock['flags_raw'] &amp; 0x000010); // double high (not used yet)
+							$metablock['flags']['bitrate_kbps']   = (bool) ($metablock['flags_raw'] &amp; 0x000020); // bitrate is kbps, not bits / sample
+							$metablock['flags']['auto_shaping']   = (bool) ($metablock['flags_raw'] &amp; 0x000040); // automatic noise shaping
+							$metablock['flags']['shape_override'] = (bool) ($metablock['flags_raw'] &amp; 0x000080); // shaping mode specified
+							$metablock['flags']['joint_override'] = (bool) ($metablock['flags_raw'] &amp; 0x000100); // joint-stereo mode specified
+							$metablock['flags']['copy_time']      = (bool) ($metablock['flags_raw'] &amp; 0x000200); // copy file-time from source
+							$metablock['flags']['create_exe']     = (bool) ($metablock['flags_raw'] &amp; 0x000400); // create executable
+							$metablock['flags']['create_wvc']     = (bool) ($metablock['flags_raw'] &amp; 0x000800); // create correction file
+							$metablock['flags']['optimize_wvc']   = (bool) ($metablock['flags_raw'] &amp; 0x001000); // maximize bybrid compression
+							$metablock['flags']['quality_mode']   = (bool) ($metablock['flags_raw'] &amp; 0x002000); // psychoacoustic quality mode
+							$metablock['flags']['raw_flag']       = (bool) ($metablock['flags_raw'] &amp; 0x004000); // raw mode (not implemented yet)
+							$metablock['flags']['calc_noise']     = (bool) ($metablock['flags_raw'] &amp; 0x008000); // calc noise in hybrid mode
+							$metablock['flags']['lossy_mode']     = (bool) ($metablock['flags_raw'] &amp; 0x010000); // obsolete (for information)
+							$metablock['flags']['extra_mode']     = (bool) ($metablock['flags_raw'] &amp; 0x020000); // extra processing mode
+							$metablock['flags']['skip_wvx']       = (bool) ($metablock['flags_raw'] &amp; 0x040000); // no wvx stream w/ floats &amp; big ints
+							$metablock['flags']['md5_checksum']   = (bool) ($metablock['flags_raw'] &amp; 0x080000); // compute &amp; store MD5 signature
+							$metablock['flags']['quiet_mode']     = (bool) ($metablock['flags_raw'] &amp; 0x100000); // don't report progress %
+
+							$ThisFileInfo['wavpack']['config_flags'] = $metablock['flags'];
+
+
+							if ($ThisFileInfo['wavpack']['blockheader']['flags']['hybrid']) {
+								@$ThisFileInfo['audio']['encoder_options'] .= ' -b???';
+							}
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['adobe_mode']     ? ' -a' : '');
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['optimize_wvc']   ? ' -cc' : '');
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['create_exe']     ? ' -e' : '');
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['fast_flag']      ? ' -f' : '');
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['joint_override'] ? ' -j?' : '');
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['high_flag']      ? ' -h' : '');
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['md5_checksum']   ? ' -m' : '');
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['calc_noise']     ? ' -n' : '');
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['shape_override'] ? ' -s?' : '');
+							@$ThisFileInfo['audio']['encoder_options'] .= ($metablock['flags']['extra_mode']     ? ' -x?' : '');
+							if (@$ThisFileInfo['audio']['encoder_options']) {
+							    $ThisFileInfo['audio']['encoder_options'] = trim(@$ThisFileInfo['audio']['encoder_options']);
+							}
+							elseif (isset($ThisFileInfo['audio']['encoder_options'])) {
+							    unset($ThisFileInfo['audio']['encoder_options']);
+							}
+							break;
+
+
+						case 0x26: // ID_MD5_CHECKSUM
+							if (strlen($metablock['data']) == 16) {
+								$ThisFileInfo['md5_data_source'] = strtolower(getid3_lib::PrintHexBytes($metablock['data'], true, false, false));
+							} else {
+								$ThisFileInfo['warning'][] = 'Expecting 16 bytes of WavPack &quot;MD5 Checksum&quot; in metablock at offset '.$metablock['offset'].', but found '.strlen($metablock['data']).' bytes';
+							}
+							break;
+
+
+						case 0x00: // ID_DUMMY
+						case 0x01: // ID_ENCODER_INFO
+						case 0x02: // ID_DECORR_TERMS
+						case 0x03: // ID_DECORR_WEIGHTS
+						case 0x04: // ID_DECORR_SAMPLES
+						case 0x05: // ID_ENTROPY_VARS
+						case 0x06: // ID_HYBRID_PROFILE
+						case 0x07: // ID_SHAPING_WEIGHTS
+						case 0x08: // ID_FLOAT_INFO
+						case 0x09: // ID_INT32_INFO
+						case 0x0A: // ID_WV_BITSTREAM
+						case 0x0B: // ID_WVC_BITSTREAM
+						case 0x0C: // ID_WVX_BITSTREAM
+						case 0x0D: // ID_CHANNEL_INFO
+							unset($metablock);
+							break;
+					}
+
+				}
+				if (!empty($metablock)) {
+					$ThisFileInfo['wavpack']['metablocks'][] = $metablock;
+				}
+
+			}
+
+		}
+
+		$ThisFileInfo['audio']['encoder']         = 'WavPack v'.$ThisFileInfo['wavpack']['blockheader']['major_version'].'.'.str_pad($ThisFileInfo['wavpack']['blockheader']['minor_version'], 2, '0', STR_PAD_LEFT);
+		$ThisFileInfo['audio']['bits_per_sample'] = $ThisFileInfo['wavpack']['blockheader']['flags']['bytes_per_sample'] * 8;
+		$ThisFileInfo['audio']['channels']        = ($ThisFileInfo['wavpack']['blockheader']['flags']['mono'] ? 1 : 2);
+
+		if (@$ThisFileInfo['playtime_seconds']) {
+
+			$ThisFileInfo['audio']['bitrate']     = (($ThisFileInfo['avdataend'] - $ThisFileInfo['avdataoffset']) * 8) / $ThisFileInfo['playtime_seconds'];
+
+		} else {
+
+			$ThisFileInfo['audio']['dataformat']  = 'wvc';
+
+		}
+
+		return true;
+	}
+
+
+	function WavPackMetablockNameLookup(&amp;$id) {
+		static $WavPackMetablockNameLookup = array(
+			0x00 =&gt; 'Dummy',
+			0x01 =&gt; 'Encoder Info',
+			0x02 =&gt; 'Decorrelation Terms',
+			0x03 =&gt; 'Decorrelation Weights',
+			0x04 =&gt; 'Decorrelation Samples',
+			0x05 =&gt; 'Entropy Variables',
+			0x06 =&gt; 'Hybrid Profile',
+			0x07 =&gt; 'Shaping Weights',
+			0x08 =&gt; 'Float Info',
+			0x09 =&gt; 'Int32 Info',
+			0x0A =&gt; 'WV Bitstream',
+			0x0B =&gt; 'WVC Bitstream',
+			0x0C =&gt; 'WVX Bitstream',
+			0x0D =&gt; 'Channel Info',
+			0x21 =&gt; 'RIFF header',
+			0x22 =&gt; 'RIFF trailer',
+			0x23 =&gt; 'Replay Gain',
+			0x24 =&gt; 'Cuesheet',
+			0x25 =&gt; 'Config Block',
+			0x26 =&gt; 'MD5 Checksum',
+		);
+		return (@$WavPackMetablockNameLookup[$id]);
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.bmp.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.bmp.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.bmp.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,683 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.graphic.bmp.php                                      //
+// module for analyzing BMP Image files                        //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_bmp
+{
+
+	function getid3_bmp(&amp;$fd, &amp;$ThisFileInfo, $ExtractPalette=false, $ExtractData=false) {
+
+	    // shortcuts
+	    $ThisFileInfo['bmp']['header']['raw'] = array();
+	    $thisfile_bmp                         = &amp;$ThisFileInfo['bmp'];
+	    $thisfile_bmp_header                  = &amp;$thisfile_bmp['header'];
+	    $thisfile_bmp_header_raw              = &amp;$thisfile_bmp_header['raw'];
+
+		// BITMAPFILEHEADER [14 bytes] - <A HREF="http://msdn.microsoft.com/library/en-us/gdi/bitmaps_62uq.asp">http://msdn.microsoft.com/library/en-us/gdi/bitmaps_62uq.asp</A>
+		// all versions
+		// WORD    bfType;
+		// DWORD   bfSize;
+		// WORD    bfReserved1;
+		// WORD    bfReserved2;
+		// DWORD   bfOffBits;
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$offset = 0;
+		$BMPheader = fread($fd, 14 + 40);
+
+		$thisfile_bmp_header_raw['identifier']  = substr($BMPheader, $offset, 2);
+		$offset += 2;
+
+		if ($thisfile_bmp_header_raw['identifier'] != 'BM') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;BM&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$thisfile_bmp_header_raw['identifier'].'&quot;';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['bmp']);
+			return false;
+		}
+
+		$thisfile_bmp_header_raw['filesize']    = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+		$offset += 4;
+		$thisfile_bmp_header_raw['reserved1']   = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+		$offset += 2;
+		$thisfile_bmp_header_raw['reserved2']   = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+		$offset += 2;
+		$thisfile_bmp_header_raw['data_offset'] = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+		$offset += 4;
+		$thisfile_bmp_header_raw['header_size'] = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+		$offset += 4;
+
+
+		// check if the hardcoded-to-1 &quot;planes&quot; is at offset 22 or 26
+		$planes22 = getid3_lib::LittleEndian2Int(substr($BMPheader, 22, 2));
+		$planes26 = getid3_lib::LittleEndian2Int(substr($BMPheader, 26, 2));
+		if (($planes22 == 1) &amp;&amp; ($planes26 != 1)) {
+			$thisfile_bmp['type_os']      = 'OS/2';
+			$thisfile_bmp['type_version'] = 1;
+		} elseif (($planes26 == 1) &amp;&amp; ($planes22 != 1)) {
+			$thisfile_bmp['type_os']      = 'Windows';
+			$thisfile_bmp['type_version'] = 1;
+		} elseif ($thisfile_bmp_header_raw['header_size'] == 12) {
+			$thisfile_bmp['type_os']      = 'OS/2';
+			$thisfile_bmp['type_version'] = 1;
+		} elseif ($thisfile_bmp_header_raw['header_size'] == 40) {
+			$thisfile_bmp['type_os']      = 'Windows';
+			$thisfile_bmp['type_version'] = 1;
+		} elseif ($thisfile_bmp_header_raw['header_size'] == 84) {
+			$thisfile_bmp['type_os']      = 'Windows';
+			$thisfile_bmp['type_version'] = 4;
+		} elseif ($thisfile_bmp_header_raw['header_size'] == 100) {
+			$thisfile_bmp['type_os']      = 'Windows';
+			$thisfile_bmp['type_version'] = 5;
+		} else {
+			$ThisFileInfo['error'][] = 'Unknown BMP subtype (or not a BMP file)';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['bmp']);
+			return false;
+		}
+
+		$ThisFileInfo['fileformat']                  = 'bmp';
+		$ThisFileInfo['video']['dataformat']         = 'bmp';
+		$ThisFileInfo['video']['lossless']           = true;
+		$ThisFileInfo['video']['pixel_aspect_ratio'] = (float) 1;
+
+		if ($thisfile_bmp['type_os'] == 'OS/2') {
+
+			// OS/2-format BMP
+			// <A HREF="http://netghost.narod.ru/gff/graphics/summary/os2bmp.htm">http://netghost.narod.ru/gff/graphics/summary/os2bmp.htm</A>
+
+			// DWORD  Size;             /* Size of this structure in bytes */
+			// DWORD  Width;            /* Bitmap width in pixels */
+			// DWORD  Height;           /* Bitmap height in pixel */
+			// WORD   NumPlanes;        /* Number of bit planes (color depth) */
+			// WORD   BitsPerPixel;     /* Number of bits per pixel per plane */
+
+			$thisfile_bmp_header_raw['width']          = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+			$offset += 2;
+			$thisfile_bmp_header_raw['height']         = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+			$offset += 2;
+			$thisfile_bmp_header_raw['planes']         = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+			$offset += 2;
+			$thisfile_bmp_header_raw['bits_per_pixel'] = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+			$offset += 2;
+
+			$ThisFileInfo['video']['resolution_x']    = $thisfile_bmp_header_raw['width'];
+			$ThisFileInfo['video']['resolution_y']    = $thisfile_bmp_header_raw['height'];
+			$ThisFileInfo['video']['codec']           = 'BI_RGB '.$thisfile_bmp_header_raw['bits_per_pixel'].'-bit';
+			$ThisFileInfo['video']['bits_per_sample'] = $thisfile_bmp_header_raw['bits_per_pixel'];
+
+			if ($thisfile_bmp['type_version'] &gt;= 2) {
+				// DWORD  Compression;      /* Bitmap compression scheme */
+				// DWORD  ImageDataSize;    /* Size of bitmap data in bytes */
+				// DWORD  XResolution;      /* X resolution of display device */
+				// DWORD  YResolution;      /* Y resolution of display device */
+				// DWORD  ColorsUsed;       /* Number of color table indices used */
+				// DWORD  ColorsImportant;  /* Number of important color indices */
+				// WORD   Units;            /* Type of units used to measure resolution */
+				// WORD   Reserved;         /* Pad structure to 4-byte boundary */
+				// WORD   Recording;        /* Recording algorithm */
+				// WORD   Rendering;        /* Halftoning algorithm used */
+				// DWORD  Size1;            /* Reserved for halftoning algorithm use */
+				// DWORD  Size2;            /* Reserved for halftoning algorithm use */
+				// DWORD  ColorEncoding;    /* Color model used in bitmap */
+				// DWORD  Identifier;       /* Reserved for application use */
+
+				$thisfile_bmp_header_raw['compression']      = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['bmp_data_size']    = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['resolution_h']     = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['resolution_v']     = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['colors_used']      = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['colors_important'] = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['resolution_units'] = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+				$offset += 2;
+				$thisfile_bmp_header_raw['reserved1']        = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+				$offset += 2;
+				$thisfile_bmp_header_raw['recording']        = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+				$offset += 2;
+				$thisfile_bmp_header_raw['rendering']        = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+				$offset += 2;
+				$thisfile_bmp_header_raw['size1']            = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['size2']            = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['color_encoding']   = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['identifier']       = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+
+				$thisfile_bmp_header['compression']             = $this-&gt;BMPcompressionOS2Lookup($thisfile_bmp_header_raw['compression']);
+
+				$ThisFileInfo['video']['codec'] = $thisfile_bmp_header['compression'].' '.$thisfile_bmp_header_raw['bits_per_pixel'].'-bit';
+			}
+
+		} elseif ($thisfile_bmp['type_os'] == 'Windows') {
+
+			// Windows-format BMP
+
+			// BITMAPINFOHEADER - [40 bytes] <A HREF="http://msdn.microsoft.com/library/en-us/gdi/bitmaps_1rw2.asp">http://msdn.microsoft.com/library/en-us/gdi/bitmaps_1rw2.asp</A>
+			// all versions
+			// DWORD  biSize;
+			// LONG   biWidth;
+			// LONG   biHeight;
+			// WORD   biPlanes;
+			// WORD   biBitCount;
+			// DWORD  biCompression;
+			// DWORD  biSizeImage;
+			// LONG   biXPelsPerMeter;
+			// LONG   biYPelsPerMeter;
+			// DWORD  biClrUsed;
+			// DWORD  biClrImportant;
+
+			$thisfile_bmp_header_raw['width']            = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4), true);
+			$offset += 4;
+			$thisfile_bmp_header_raw['height']           = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4), true);
+			$offset += 4;
+			$thisfile_bmp_header_raw['planes']           = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+			$offset += 2;
+			$thisfile_bmp_header_raw['bits_per_pixel']   = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 2));
+			$offset += 2;
+			$thisfile_bmp_header_raw['compression']      = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+			$offset += 4;
+			$thisfile_bmp_header_raw['bmp_data_size']    = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+			$offset += 4;
+			$thisfile_bmp_header_raw['resolution_h']     = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4), true);
+			$offset += 4;
+			$thisfile_bmp_header_raw['resolution_v']     = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4), true);
+			$offset += 4;
+			$thisfile_bmp_header_raw['colors_used']      = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+			$offset += 4;
+			$thisfile_bmp_header_raw['colors_important'] = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+			$offset += 4;
+
+			$thisfile_bmp_header['compression']  = $this-&gt;BMPcompressionWindowsLookup($thisfile_bmp_header_raw['compression']);
+			$ThisFileInfo['video']['resolution_x']    = $thisfile_bmp_header_raw['width'];
+			$ThisFileInfo['video']['resolution_y']    = $thisfile_bmp_header_raw['height'];
+			$ThisFileInfo['video']['codec']           = $thisfile_bmp_header['compression'].' '.$thisfile_bmp_header_raw['bits_per_pixel'].'-bit';
+			$ThisFileInfo['video']['bits_per_sample'] = $thisfile_bmp_header_raw['bits_per_pixel'];
+
+			if (($thisfile_bmp['type_version'] &gt;= 4) || ($thisfile_bmp_header_raw['compression'] == 3)) {
+				// should only be v4+, but BMPs with type_version==1 and BI_BITFIELDS compression have been seen
+				$BMPheader .= fread($fd, 44);
+
+				// BITMAPV4HEADER - [44 bytes] - <A HREF="http://msdn.microsoft.com/library/en-us/gdi/bitmaps_2k1e.asp">http://msdn.microsoft.com/library/en-us/gdi/bitmaps_2k1e.asp</A>
+				// Win95+, WinNT4.0+
+				// DWORD        bV4RedMask;
+				// DWORD        bV4GreenMask;
+				// DWORD        bV4BlueMask;
+				// DWORD        bV4AlphaMask;
+				// DWORD        bV4CSType;
+				// CIEXYZTRIPLE bV4Endpoints;
+				// DWORD        bV4GammaRed;
+				// DWORD        bV4GammaGreen;
+				// DWORD        bV4GammaBlue;
+				$thisfile_bmp_header_raw['red_mask']     = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['green_mask']   = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['blue_mask']    = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['alpha_mask']   = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['cs_type']      = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['ciexyz_red']   =                  substr($BMPheader, $offset, 4);
+				$offset += 4;
+				$thisfile_bmp_header_raw['ciexyz_green'] =                  substr($BMPheader, $offset, 4);
+				$offset += 4;
+				$thisfile_bmp_header_raw['ciexyz_blue']  =                  substr($BMPheader, $offset, 4);
+				$offset += 4;
+				$thisfile_bmp_header_raw['gamma_red']    = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['gamma_green']  = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['gamma_blue']   = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+
+				$thisfile_bmp_header['ciexyz_red']   = getid3_lib::FixedPoint2_30(strrev($thisfile_bmp_header_raw['ciexyz_red']));
+				$thisfile_bmp_header['ciexyz_green'] = getid3_lib::FixedPoint2_30(strrev($thisfile_bmp_header_raw['ciexyz_green']));
+				$thisfile_bmp_header['ciexyz_blue']  = getid3_lib::FixedPoint2_30(strrev($thisfile_bmp_header_raw['ciexyz_blue']));
+			}
+
+			if ($thisfile_bmp['type_version'] &gt;= 5) {
+				$BMPheader .= fread($fd, 16);
+
+				// BITMAPV5HEADER - [16 bytes] - <A HREF="http://msdn.microsoft.com/library/en-us/gdi/bitmaps_7c36.asp">http://msdn.microsoft.com/library/en-us/gdi/bitmaps_7c36.asp</A>
+				// Win98+, Win2000+
+				// DWORD        bV5Intent;
+				// DWORD        bV5ProfileData;
+				// DWORD        bV5ProfileSize;
+				// DWORD        bV5Reserved;
+				$thisfile_bmp_header_raw['intent']              = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['profile_data_offset'] = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['profile_data_size']   = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+				$thisfile_bmp_header_raw['reserved3']           = getid3_lib::LittleEndian2Int(substr($BMPheader, $offset, 4));
+				$offset += 4;
+			}
+
+		} else {
+
+			$ThisFileInfo['error'][] = 'Unknown BMP format in header.';
+			return false;
+
+		}
+
+
+		if ($ExtractPalette || $ExtractData) {
+			$PaletteEntries = 0;
+			if ($thisfile_bmp_header_raw['bits_per_pixel'] &lt; 16) {
+				$PaletteEntries = pow(2, $thisfile_bmp_header_raw['bits_per_pixel']);
+			} elseif (isset($thisfile_bmp_header_raw['colors_used']) &amp;&amp; ($thisfile_bmp_header_raw['colors_used'] &gt; 0) &amp;&amp; ($thisfile_bmp_header_raw['colors_used'] &lt;= 256)) {
+				$PaletteEntries = $thisfile_bmp_header_raw['colors_used'];
+			}
+			if ($PaletteEntries &gt; 0) {
+				$BMPpalette = fread($fd, 4 * $PaletteEntries);
+				$paletteoffset = 0;
+				for ($i = 0; $i &lt; $PaletteEntries; $i++) {
+					// RGBQUAD          - <A HREF="http://msdn.microsoft.com/library/en-us/gdi/bitmaps_5f8y.asp">http://msdn.microsoft.com/library/en-us/gdi/bitmaps_5f8y.asp</A>
+					// BYTE    rgbBlue;
+					// BYTE    rgbGreen;
+					// BYTE    rgbRed;
+					// BYTE    rgbReserved;
+					$blue  = getid3_lib::LittleEndian2Int(substr($BMPpalette, $paletteoffset++, 1));
+					$green = getid3_lib::LittleEndian2Int(substr($BMPpalette, $paletteoffset++, 1));
+					$red   = getid3_lib::LittleEndian2Int(substr($BMPpalette, $paletteoffset++, 1));
+					if (($thisfile_bmp['type_os'] == 'OS/2') &amp;&amp; ($thisfile_bmp['type_version'] == 1)) {
+						// no padding byte
+					} else {
+						$paletteoffset++; // padding byte
+					}
+					$thisfile_bmp['palette'][$i] = (($red &lt;&lt; 16) | ($green &lt;&lt; 8) | $blue);
+				}
+			}
+		}
+
+		if ($ExtractData) {
+			fseek($fd, $thisfile_bmp_header_raw['data_offset'], SEEK_SET);
+			$RowByteLength = ceil(($thisfile_bmp_header_raw['width'] * ($thisfile_bmp_header_raw['bits_per_pixel'] / 8)) / 4) * 4; // round up to nearest DWORD boundry
+			$BMPpixelData = fread($fd, $thisfile_bmp_header_raw['height'] * $RowByteLength);
+			$pixeldataoffset = 0;
+			switch (@$thisfile_bmp_header_raw['compression']) {
+
+				case 0: // BI_RGB
+					switch ($thisfile_bmp_header_raw['bits_per_pixel']) {
+						case 1:
+							for ($row = ($thisfile_bmp_header_raw['height'] - 1); $row &gt;= 0; $row--) {
+								for ($col = 0; $col &lt; $thisfile_bmp_header_raw['width']; $col = $col) {
+									$paletteindexbyte = ord($BMPpixelData{$pixeldataoffset++});
+									for ($i = 7; $i &gt;= 0; $i--) {
+										$paletteindex = ($paletteindexbyte &amp; (0x01 &lt;&lt; $i)) &gt;&gt; $i;
+										$thisfile_bmp['data'][$row][$col] = $thisfile_bmp['palette'][$paletteindex];
+										$col++;
+									}
+								}
+								while (($pixeldataoffset % 4) != 0) {
+									// lines are padded to nearest DWORD
+									$pixeldataoffset++;
+								}
+							}
+							break;
+
+						case 4:
+							for ($row = ($thisfile_bmp_header_raw['height'] - 1); $row &gt;= 0; $row--) {
+								for ($col = 0; $col &lt; $thisfile_bmp_header_raw['width']; $col = $col) {
+									$paletteindexbyte = ord($BMPpixelData{$pixeldataoffset++});
+									for ($i = 1; $i &gt;= 0; $i--) {
+										$paletteindex = ($paletteindexbyte &amp; (0x0F &lt;&lt; (4 * $i))) &gt;&gt; (4 * $i);
+										$thisfile_bmp['data'][$row][$col] = $thisfile_bmp['palette'][$paletteindex];
+										$col++;
+									}
+								}
+								while (($pixeldataoffset % 4) != 0) {
+									// lines are padded to nearest DWORD
+									$pixeldataoffset++;
+								}
+							}
+							break;
+
+						case 8:
+							for ($row = ($thisfile_bmp_header_raw['height'] - 1); $row &gt;= 0; $row--) {
+								for ($col = 0; $col &lt; $thisfile_bmp_header_raw['width']; $col++) {
+									$paletteindex = ord($BMPpixelData{$pixeldataoffset++});
+									$thisfile_bmp['data'][$row][$col] = $thisfile_bmp['palette'][$paletteindex];
+								}
+								while (($pixeldataoffset % 4) != 0) {
+									// lines are padded to nearest DWORD
+									$pixeldataoffset++;
+								}
+							}
+							break;
+
+						case 24:
+							for ($row = ($thisfile_bmp_header_raw['height'] - 1); $row &gt;= 0; $row--) {
+								for ($col = 0; $col &lt; $thisfile_bmp_header_raw['width']; $col++) {
+									$thisfile_bmp['data'][$row][$col] = (ord($BMPpixelData{$pixeldataoffset+2}) &lt;&lt; 16) | (ord($BMPpixelData{$pixeldataoffset+1}) &lt;&lt; 8) | ord($BMPpixelData{$pixeldataoffset});
+									$pixeldataoffset += 3;
+								}
+								while (($pixeldataoffset % 4) != 0) {
+									// lines are padded to nearest DWORD
+									$pixeldataoffset++;
+								}
+							}
+							break;
+
+						case 32:
+							for ($row = ($thisfile_bmp_header_raw['height'] - 1); $row &gt;= 0; $row--) {
+								for ($col = 0; $col &lt; $thisfile_bmp_header_raw['width']; $col++) {
+									$thisfile_bmp['data'][$row][$col] = (ord($BMPpixelData{$pixeldataoffset+3}) &lt;&lt; 24) | (ord($BMPpixelData{$pixeldataoffset+2}) &lt;&lt; 16) | (ord($BMPpixelData{$pixeldataoffset+1}) &lt;&lt; 8) | ord($BMPpixelData{$pixeldataoffset});
+									$pixeldataoffset += 4;
+								}
+								while (($pixeldataoffset % 4) != 0) {
+									// lines are padded to nearest DWORD
+									$pixeldataoffset++;
+								}
+							}
+							break;
+
+						case 16:
+							// ?
+							break;
+
+						default:
+							$ThisFileInfo['error'][] = 'Unknown bits-per-pixel value ('.$thisfile_bmp_header_raw['bits_per_pixel'].') - cannot read pixel data';
+							break;
+					}
+					break;
+
+
+				case 1: // BI_RLE8 - <A HREF="http://msdn.microsoft.com/library/en-us/gdi/bitmaps_6x0u.asp">http://msdn.microsoft.com/library/en-us/gdi/bitmaps_6x0u.asp</A>
+					switch ($thisfile_bmp_header_raw['bits_per_pixel']) {
+						case 8:
+							$pixelcounter = 0;
+							while ($pixeldataoffset &lt; strlen($BMPpixelData)) {
+								$firstbyte  = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+								$secondbyte = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+								if ($firstbyte == 0) {
+
+									// escaped/absolute mode - the first byte of the pair can be set to zero to
+									// indicate an escape character that denotes the end of a line, the end of
+									// a bitmap, or a delta, depending on the value of the second byte.
+									switch ($secondbyte) {
+										case 0:
+											// end of line
+											// no need for special processing, just ignore
+											break;
+
+										case 1:
+											// end of bitmap
+											$pixeldataoffset = strlen($BMPpixelData); // force to exit loop just in case
+											break;
+
+										case 2:
+											// delta - The 2 bytes following the escape contain unsigned values
+											// indicating the horizontal and vertical offsets of the next pixel
+											// from the current position.
+											$colincrement = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+											$rowincrement = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+											$col = ($pixelcounter % $thisfile_bmp_header_raw['width']) + $colincrement;
+											$row = ($thisfile_bmp_header_raw['height'] - 1 - (($pixelcounter - $col) / $thisfile_bmp_header_raw['width'])) - $rowincrement;
+											$pixelcounter = ($row * $thisfile_bmp_header_raw['width']) + $col;
+											break;
+
+										default:
+											// In absolute mode, the first byte is zero and the second byte is a
+											// value in the range 03H through FFH. The second byte represents the
+											// number of bytes that follow, each of which contains the color index
+											// of a single pixel. Each run must be aligned on a word boundary.
+											for ($i = 0; $i &lt; $secondbyte; $i++) {
+												$paletteindex = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+												$col = $pixelcounter % $thisfile_bmp_header_raw['width'];
+												$row = $thisfile_bmp_header_raw['height'] - 1 - (($pixelcounter - $col) / $thisfile_bmp_header_raw['width']);
+												$thisfile_bmp['data'][$row][$col] = $thisfile_bmp['palette'][$paletteindex];
+												$pixelcounter++;
+											}
+											while (($pixeldataoffset % 2) != 0) {
+												// Each run must be aligned on a word boundary.
+												$pixeldataoffset++;
+											}
+											break;
+									}
+
+								} else {
+
+									// encoded mode - the first byte specifies the number of consecutive pixels
+									// to be drawn using the color index contained in the second byte.
+									for ($i = 0; $i &lt; $firstbyte; $i++) {
+										$col = $pixelcounter % $thisfile_bmp_header_raw['width'];
+										$row = $thisfile_bmp_header_raw['height'] - 1 - (($pixelcounter - $col) / $thisfile_bmp_header_raw['width']);
+										$thisfile_bmp['data'][$row][$col] = $thisfile_bmp['palette'][$secondbyte];
+										$pixelcounter++;
+									}
+
+								}
+							}
+							break;
+
+						default:
+							$ThisFileInfo['error'][] = 'Unknown bits-per-pixel value ('.$thisfile_bmp_header_raw['bits_per_pixel'].') - cannot read pixel data';
+							break;
+					}
+					break;
+
+
+
+				case 2: // BI_RLE4 - <A HREF="http://msdn.microsoft.com/library/en-us/gdi/bitmaps_6x0u.asp">http://msdn.microsoft.com/library/en-us/gdi/bitmaps_6x0u.asp</A>
+					switch ($thisfile_bmp_header_raw['bits_per_pixel']) {
+						case 4:
+							$pixelcounter = 0;
+							while ($pixeldataoffset &lt; strlen($BMPpixelData)) {
+								$firstbyte  = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+								$secondbyte = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+								if ($firstbyte == 0) {
+
+									// escaped/absolute mode - the first byte of the pair can be set to zero to
+									// indicate an escape character that denotes the end of a line, the end of
+									// a bitmap, or a delta, depending on the value of the second byte.
+									switch ($secondbyte) {
+										case 0:
+											// end of line
+											// no need for special processing, just ignore
+											break;
+
+										case 1:
+											// end of bitmap
+											$pixeldataoffset = strlen($BMPpixelData); // force to exit loop just in case
+											break;
+
+										case 2:
+											// delta - The 2 bytes following the escape contain unsigned values
+											// indicating the horizontal and vertical offsets of the next pixel
+											// from the current position.
+											$colincrement = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+											$rowincrement = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+											$col = ($pixelcounter % $thisfile_bmp_header_raw['width']) + $colincrement;
+											$row = ($thisfile_bmp_header_raw['height'] - 1 - (($pixelcounter - $col) / $thisfile_bmp_header_raw['width'])) - $rowincrement;
+											$pixelcounter = ($row * $thisfile_bmp_header_raw['width']) + $col;
+											break;
+
+										default:
+											// In absolute mode, the first byte is zero. The second byte contains the number
+											// of color indexes that follow. Subsequent bytes contain color indexes in their
+											// high- and low-order 4 bits, one color index for each pixel. In absolute mode,
+											// each run must be aligned on a word boundary.
+											unset($paletteindexes);
+											for ($i = 0; $i &lt; ceil($secondbyte / 2); $i++) {
+												$paletteindexbyte = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset++, 1));
+												$paletteindexes[] = ($paletteindexbyte &amp; 0xF0) &gt;&gt; 4;
+												$paletteindexes[] = ($paletteindexbyte &amp; 0x0F);
+											}
+											while (($pixeldataoffset % 2) != 0) {
+												// Each run must be aligned on a word boundary.
+												$pixeldataoffset++;
+											}
+
+											foreach ($paletteindexes as $paletteindex) {
+												$col = $pixelcounter % $thisfile_bmp_header_raw['width'];
+												$row = $thisfile_bmp_header_raw['height'] - 1 - (($pixelcounter - $col) / $thisfile_bmp_header_raw['width']);
+												$thisfile_bmp['data'][$row][$col] = $thisfile_bmp['palette'][$paletteindex];
+												$pixelcounter++;
+											}
+											break;
+									}
+
+								} else {
+
+									// encoded mode - the first byte of the pair contains the number of pixels to be
+									// drawn using the color indexes in the second byte. The second byte contains two
+									// color indexes, one in its high-order 4 bits and one in its low-order 4 bits.
+									// The first of the pixels is drawn using the color specified by the high-order
+									// 4 bits, the second is drawn using the color in the low-order 4 bits, the third
+									// is drawn using the color in the high-order 4 bits, and so on, until all the
+									// pixels specified by the first byte have been drawn.
+									$paletteindexes[0] = ($secondbyte &amp; 0xF0) &gt;&gt; 4;
+									$paletteindexes[1] = ($secondbyte &amp; 0x0F);
+									for ($i = 0; $i &lt; $firstbyte; $i++) {
+										$col = $pixelcounter % $thisfile_bmp_header_raw['width'];
+										$row = $thisfile_bmp_header_raw['height'] - 1 - (($pixelcounter - $col) / $thisfile_bmp_header_raw['width']);
+										$thisfile_bmp['data'][$row][$col] = $thisfile_bmp['palette'][$paletteindexes[($i % 2)]];
+										$pixelcounter++;
+									}
+
+								}
+							}
+							break;
+
+						default:
+							$ThisFileInfo['error'][] = 'Unknown bits-per-pixel value ('.$thisfile_bmp_header_raw['bits_per_pixel'].') - cannot read pixel data';
+							break;
+					}
+					break;
+
+
+				case 3: // BI_BITFIELDS
+					switch ($thisfile_bmp_header_raw['bits_per_pixel']) {
+						case 16:
+						case 32:
+							$redshift   = 0;
+							$greenshift = 0;
+							$blueshift  = 0;
+							while ((($thisfile_bmp_header_raw['red_mask'] &gt;&gt; $redshift) &amp; 0x01) == 0) {
+								$redshift++;
+							}
+							while ((($thisfile_bmp_header_raw['green_mask'] &gt;&gt; $greenshift) &amp; 0x01) == 0) {
+								$greenshift++;
+							}
+							while ((($thisfile_bmp_header_raw['blue_mask'] &gt;&gt; $blueshift) &amp; 0x01) == 0) {
+								$blueshift++;
+							}
+							for ($row = ($thisfile_bmp_header_raw['height'] - 1); $row &gt;= 0; $row--) {
+								for ($col = 0; $col &lt; $thisfile_bmp_header_raw['width']; $col++) {
+									$pixelvalue = getid3_lib::LittleEndian2Int(substr($BMPpixelData, $pixeldataoffset, $thisfile_bmp_header_raw['bits_per_pixel'] / 8));
+									$pixeldataoffset += $thisfile_bmp_header_raw['bits_per_pixel'] / 8;
+
+									$red   = intval(round(((($pixelvalue &amp; $thisfile_bmp_header_raw['red_mask'])   &gt;&gt; $redshift)   / ($thisfile_bmp_header_raw['red_mask']   &gt;&gt; $redshift))   * 255));
+									$green = intval(round(((($pixelvalue &amp; $thisfile_bmp_header_raw['green_mask']) &gt;&gt; $greenshift) / ($thisfile_bmp_header_raw['green_mask'] &gt;&gt; $greenshift)) * 255));
+									$blue  = intval(round(((($pixelvalue &amp; $thisfile_bmp_header_raw['blue_mask'])  &gt;&gt; $blueshift)  / ($thisfile_bmp_header_raw['blue_mask']  &gt;&gt; $blueshift))  * 255));
+									$thisfile_bmp['data'][$row][$col] = (($red &lt;&lt; 16) | ($green &lt;&lt; 8) | ($blue));
+								}
+								while (($pixeldataoffset % 4) != 0) {
+									// lines are padded to nearest DWORD
+									$pixeldataoffset++;
+								}
+							}
+							break;
+
+						default:
+							$ThisFileInfo['error'][] = 'Unknown bits-per-pixel value ('.$thisfile_bmp_header_raw['bits_per_pixel'].') - cannot read pixel data';
+							break;
+					}
+					break;
+
+
+				default: // unhandled compression type
+					$ThisFileInfo['error'][] = 'Unknown/unhandled compression type value ('.$thisfile_bmp_header_raw['compression'].') - cannot decompress pixel data';
+					break;
+			}
+		}
+
+		return true;
+	}
+
+
+	function PlotBMP(&amp;$BMPinfo) {
+		$starttime = time();
+		if (!isset($BMPinfo['bmp']['data']) || !is_array($BMPinfo['bmp']['data'])) {
+			echo 'ERROR: no pixel data&lt;BR&gt;';
+			return false;
+		}
+		set_time_limit(intval(round($BMPinfo['resolution_x'] * $BMPinfo['resolution_y'] / 10000)));
+		if ($im = ImageCreateTrueColor($BMPinfo['resolution_x'], $BMPinfo['resolution_y'])) {
+			for ($row = 0; $row &lt; $BMPinfo['resolution_y']; $row++) {
+				for ($col = 0; $col &lt; $BMPinfo['resolution_x']; $col++) {
+					if (isset($BMPinfo['bmp']['data'][$row][$col])) {
+						$red   = ($BMPinfo['bmp']['data'][$row][$col] &amp; 0x00FF0000) &gt;&gt; 16;
+						$green = ($BMPinfo['bmp']['data'][$row][$col] &amp; 0x0000FF00) &gt;&gt; 8;
+						$blue  = ($BMPinfo['bmp']['data'][$row][$col] &amp; 0x000000FF);
+						$pixelcolor = ImageColorAllocate($im, $red, $green, $blue);
+						ImageSetPixel($im, $col, $row, $pixelcolor);
+					} else {
+						//echo 'ERROR: no data for pixel '.$row.' x '.$col.'&lt;BR&gt;';
+						//return false;
+					}
+				}
+			}
+			if (headers_sent()) {
+				echo 'plotted '.($BMPinfo['resolution_x'] * $BMPinfo['resolution_y']).' pixels in '.(time() - $starttime).' seconds&lt;BR&gt;';
+				ImageDestroy($im);
+				exit;
+			} else {
+				header('Content-type: image/png');
+				ImagePNG($im);
+				ImageDestroy($im);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	function BMPcompressionWindowsLookup($compressionid) {
+		static $BMPcompressionWindowsLookup = array(
+			0 =&gt; 'BI_RGB',
+			1 =&gt; 'BI_RLE8',
+			2 =&gt; 'BI_RLE4',
+			3 =&gt; 'BI_BITFIELDS',
+			4 =&gt; 'BI_JPEG',
+			5 =&gt; 'BI_PNG'
+		);
+		return (isset($BMPcompressionWindowsLookup[$compressionid]) ? $BMPcompressionWindowsLookup[$compressionid] : 'invalid');
+	}
+
+	function BMPcompressionOS2Lookup($compressionid) {
+		static $BMPcompressionOS2Lookup = array(
+			0 =&gt; 'BI_RGB',
+			1 =&gt; 'BI_RLE8',
+			2 =&gt; 'BI_RLE4',
+			3 =&gt; 'Huffman 1D',
+			4 =&gt; 'BI_RLE24',
+		);
+		return (isset($BMPcompressionOS2Lookup[$compressionid]) ? $BMPcompressionOS2Lookup[$compressionid] : 'invalid');
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.gif.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.gif.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.gif.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,183 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.graphic.gif.php                                      //
+// module for analyzing GIF Image files                        //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_gif
+{
+
+	function getid3_gif(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat']                  = 'gif';
+		$ThisFileInfo['video']['dataformat']         = 'gif';
+		$ThisFileInfo['video']['lossless']           = true;
+		$ThisFileInfo['video']['pixel_aspect_ratio'] = (float) 1;
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$GIFheader = fread($fd, 13);
+		$offset = 0;
+
+		$ThisFileInfo['gif']['header']['raw']['identifier']            =                              substr($GIFheader, $offset, 3);
+		$offset += 3;
+
+		if ($ThisFileInfo['gif']['header']['raw']['identifier'] != 'GIF') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;GIF&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.$ThisFileInfo['gif']['header']['raw']['identifier'].'&quot;';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['gif']);
+			return false;
+		}
+
+		$ThisFileInfo['gif']['header']['raw']['version']               =                              substr($GIFheader, $offset, 3);
+		$offset += 3;
+		$ThisFileInfo['gif']['header']['raw']['width']                 = getid3_lib::LittleEndian2Int(substr($GIFheader, $offset, 2));
+		$offset += 2;
+		$ThisFileInfo['gif']['header']['raw']['height']                = getid3_lib::LittleEndian2Int(substr($GIFheader, $offset, 2));
+		$offset += 2;
+		$ThisFileInfo['gif']['header']['raw']['flags']                 = getid3_lib::LittleEndian2Int(substr($GIFheader, $offset, 1));
+		$offset += 1;
+		$ThisFileInfo['gif']['header']['raw']['bg_color_index']        = getid3_lib::LittleEndian2Int(substr($GIFheader, $offset, 1));
+		$offset += 1;
+		$ThisFileInfo['gif']['header']['raw']['aspect_ratio']          = getid3_lib::LittleEndian2Int(substr($GIFheader, $offset, 1));
+		$offset += 1;
+
+		$ThisFileInfo['video']['resolution_x']                         = $ThisFileInfo['gif']['header']['raw']['width'];
+		$ThisFileInfo['video']['resolution_y']                         = $ThisFileInfo['gif']['header']['raw']['height'];
+		$ThisFileInfo['gif']['version']                                = $ThisFileInfo['gif']['header']['raw']['version'];
+		$ThisFileInfo['gif']['header']['flags']['global_color_table']  = (bool) ($ThisFileInfo['gif']['header']['raw']['flags'] &amp; 0x80);
+		if ($ThisFileInfo['gif']['header']['raw']['flags'] &amp; 0x80) {
+			// Number of bits per primary color available to the original image, minus 1
+			$ThisFileInfo['gif']['header']['bits_per_pixel']  = 3 * ((($ThisFileInfo['gif']['header']['raw']['flags'] &amp; 0x70) &gt;&gt; 4) + 1);
+		} else {
+			$ThisFileInfo['gif']['header']['bits_per_pixel']  = 0;
+		}
+		$ThisFileInfo['gif']['header']['flags']['global_color_sorted'] = (bool) ($ThisFileInfo['gif']['header']['raw']['flags'] &amp; 0x40);
+		if ($ThisFileInfo['gif']['header']['flags']['global_color_table']) {
+			// the number of bytes contained in the Global Color Table. To determine that
+			// actual size of the color table, raise 2 to [the value of the field + 1]
+			$ThisFileInfo['gif']['header']['global_color_size'] = pow(2, ($ThisFileInfo['gif']['header']['raw']['flags'] &amp; 0x07) + 1);
+			$ThisFileInfo['video']['bits_per_sample']           = ($ThisFileInfo['gif']['header']['raw']['flags'] &amp; 0x07) + 1;
+		} else {
+			$ThisFileInfo['gif']['header']['global_color_size'] = 0;
+		}
+		if ($ThisFileInfo['gif']['header']['raw']['aspect_ratio'] != 0) {
+			// Aspect Ratio = (Pixel Aspect Ratio + 15) / 64
+			$ThisFileInfo['gif']['header']['aspect_ratio'] = ($ThisFileInfo['gif']['header']['raw']['aspect_ratio'] + 15) / 64;
+		}
+
+//		if ($ThisFileInfo['gif']['header']['flags']['global_color_table']) {
+//			$GIFcolorTable = fread($fd, 3 * $ThisFileInfo['gif']['header']['global_color_size']);
+//			$offset = 0;
+//			for ($i = 0; $i &lt; $ThisFileInfo['gif']['header']['global_color_size']; $i++) {
+//				$red   = getid3_lib::LittleEndian2Int(substr($GIFcolorTable, $offset++, 1));
+//				$green = getid3_lib::LittleEndian2Int(substr($GIFcolorTable, $offset++, 1));
+//				$blue  = getid3_lib::LittleEndian2Int(substr($GIFcolorTable, $offset++, 1));
+//				$ThisFileInfo['gif']['global_color_table'][$i] = (($red &lt;&lt; 16) | ($green &lt;&lt; 8) | ($blue));
+//			}
+//		}
+//
+//		// Image Descriptor
+//		while (!feof($fd)) {
+//			$NextBlockTest = fread($fd, 1);
+//			switch ($NextBlockTest) {
+//
+//				case ',': // ',' - Image separator character
+//
+//					$ImageDescriptorData = $NextBlockTest.fread($fd, 9);
+//					$ImageDescriptor = array();
+//					$ImageDescriptor['image_left']   = getid3_lib::LittleEndian2Int(substr($ImageDescriptorData, 1, 2));
+//					$ImageDescriptor['image_top']    = getid3_lib::LittleEndian2Int(substr($ImageDescriptorData, 3, 2));
+//					$ImageDescriptor['image_width']  = getid3_lib::LittleEndian2Int(substr($ImageDescriptorData, 5, 2));
+//					$ImageDescriptor['image_height'] = getid3_lib::LittleEndian2Int(substr($ImageDescriptorData, 7, 2));
+//					$ImageDescriptor['flags_raw']    = getid3_lib::LittleEndian2Int(substr($ImageDescriptorData, 9, 1));
+//					$ImageDescriptor['flags']['use_local_color_map'] = (bool) ($ImageDescriptor['flags_raw'] &amp; 0x80);
+//					$ImageDescriptor['flags']['image_interlaced']    = (bool) ($ImageDescriptor['flags_raw'] &amp; 0x40);
+//					$ThisFileInfo['gif']['image_descriptor'][] = $ImageDescriptor;
+//
+//					if ($ImageDescriptor['flags']['use_local_color_map']) {
+//
+//						$ThisFileInfo['warning'][] = 'This version of getID3() cannot parse local color maps for GIFs';
+//						return true;
+//
+//					}
+//echo 'Start of raster data: '.ftell($fd).'&lt;BR&gt;';
+//					$RasterData = array();
+//					$RasterData['code_size']        = getid3_lib::LittleEndian2Int(fread($fd, 1));
+//					$RasterData['block_byte_count'] = getid3_lib::LittleEndian2Int(fread($fd, 1));
+//					$ThisFileInfo['gif']['raster_data'][count($ThisFileInfo['gif']['image_descriptor']) - 1] = $RasterData;
+//
+//					$CurrentCodeSize = $RasterData['code_size'] + 1;
+//					for ($i = 0; $i &lt; pow(2, $RasterData['code_size']); $i++) {
+//						$DefaultDataLookupTable[$i] = chr($i);
+//					}
+//					$DefaultDataLookupTable[pow(2, $RasterData['code_size']) + 0] = ''; // Clear Code
+//					$DefaultDataLookupTable[pow(2, $RasterData['code_size']) + 1] = ''; // End Of Image Code
+//
+//
+//					$NextValue = $this-&gt;GetLSBits($fd, $CurrentCodeSize);
+//					echo 'Clear Code: '.$NextValue.'&lt;BR&gt;';
+//
+//					$NextValue = $this-&gt;GetLSBits($fd, $CurrentCodeSize);
+//					echo 'First Color: '.$NextValue.'&lt;BR&gt;';
+//
+//					$Prefix = $NextValue;
+//$i = 0;
+//					while ($i++ &lt; 20) {
+//						$NextValue = $this-&gt;GetLSBits($fd, $CurrentCodeSize);
+//						echo $NextValue.'&lt;BR&gt;';
+//					}
+//return true;
+//					break;
+//
+//				case '!':
+//					// GIF Extension Block
+//					$ExtensionBlockData = $NextBlockTest.fread($fd, 2);
+//					$ExtensionBlock = array();
+//					$ExtensionBlock['function_code']  = getid3_lib::LittleEndian2Int(substr($ExtensionBlockData, 1, 1));
+//					$ExtensionBlock['byte_length']    = getid3_lib::LittleEndian2Int(substr($ExtensionBlockData, 2, 1));
+//					$ExtensionBlock['data']           = fread($fd, $ExtensionBlock['byte_length']);
+//					$ThisFileInfo['gif']['extension_blocks'][] = $ExtensionBlock;
+//					break;
+//
+//				case ';':
+//					$ThisFileInfo['gif']['terminator_offset'] = ftell($fd) - 1;
+//					// GIF Terminator
+//					break;
+//
+//				default:
+//					break;
+//
+//
+//			}
+//		}
+
+		return true;
+	}
+
+
+	function GetLSBits($fd, $bits) {
+		static $bitbuffer = '';
+		while (strlen($bitbuffer) &lt; $bits) {
+//echo 'Read another byte: '.ftell($fd).'&lt;BR&gt;';
+			$bitbuffer = str_pad(decbin(ord(fread($fd, 1))), 8, '0', STR_PAD_LEFT).$bitbuffer;
+		}
+
+		$value = bindec(substr($bitbuffer, 0 - $bits));
+		$bitbuffer = substr($bitbuffer, 0, 0 - $bits);
+
+		return $value;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.jpg.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.jpg.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.jpg.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,72 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.graphic.jpg.php                                      //
+// module for analyzing JPEG Image files                       //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_jpg
+{
+
+
+	function getid3_jpg(&amp;$fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat']                  = 'jpg';
+		$ThisFileInfo['video']['dataformat']         = 'jpg';
+		$ThisFileInfo['video']['lossless']           = false;
+		$ThisFileInfo['video']['bits_per_sample']    = 24;
+		$ThisFileInfo['video']['pixel_aspect_ratio'] = (float) 1;
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+
+		list($width, $height, $type) = getid3_lib::GetDataImageSize(fread($fd, $ThisFileInfo['filesize']));
+		if ($type == 2) {
+
+			$ThisFileInfo['video']['resolution_x'] = $width;
+			$ThisFileInfo['video']['resolution_y'] = $height;
+
+			if (version_compare(phpversion(), '4.2.0', '&gt;=')) {
+
+				if (function_exists('exif_read_data')) {
+
+					ob_start();
+					$ThisFileInfo['jpg']['exif'] = exif_read_data($ThisFileInfo['filenamepath'], '', true, false);
+					$errors = ob_get_contents();
+					if ($errors) {
+						$ThisFileInfo['error'][] = strip_tags($errors);
+						unset($ThisFileInfo['jpg']['exif']);
+					}
+					ob_end_clean();
+
+				} else {
+
+					$ThisFileInfo['warning'][] = 'EXIF parsing only available when '.(GETID3_OS_ISWINDOWS ? 'php_exif.dll enabled' : 'compiled with --enable-exif');
+
+				}
+
+			} else {
+
+				$ThisFileInfo['warning'][] = 'EXIF parsing only available in PHP v4.2.0 and higher compiled with --enable-exif (or php_exif.dll enabled for Windows). You are using PHP v'.phpversion();
+
+			}
+
+			return true;
+
+		}
+
+		unset($ThisFileInfo['fileformat']);
+		return false;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.pcd.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.pcd.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.pcd.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,130 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.graphic.pcd.php                                      //
+// module for analyzing PhotoCD (PCD) Image files              //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_pcd
+{
+	function getid3_pcd(&amp;$fd, &amp;$ThisFileInfo, $ExtractData=0) {
+		$ThisFileInfo['fileformat']          = 'pcd';
+		$ThisFileInfo['video']['dataformat'] = 'pcd';
+		$ThisFileInfo['video']['lossless']   = false;
+
+
+		fseek($fd, $ThisFileInfo['avdataoffset'] + 72, SEEK_SET);
+
+		$PCDflags = fread($fd, 1);
+		$PCDisVertical = ((ord($PCDflags) &amp; 0x01) ? true : false);
+
+
+		if ($PCDisVertical) {
+			$ThisFileInfo['video']['resolution_x'] = 3072;
+			$ThisFileInfo['video']['resolution_y'] = 2048;
+		} else {
+			$ThisFileInfo['video']['resolution_x'] = 2048;
+			$ThisFileInfo['video']['resolution_y'] = 3072;
+		}
+
+
+		if ($ExtractData &gt; 3) {
+
+			$ThisFileInfo['error'][] = 'Cannot extract PSD image data for detail levels above BASE (3)';
+
+		} elseif ($ExtractData &gt; 0) {
+
+			$PCD_levels[1] = array( 192,  128, 0x02000); // BASE/16
+			$PCD_levels[2] = array( 384,  256, 0x0B800); // BASE/4
+			$PCD_levels[3] = array( 768,  512, 0x30000); // BASE
+			//$PCD_levels[4] = array(1536, 1024,    ??); // BASE*4  - encrypted with Kodak-proprietary compression/encryption
+			//$PCD_levels[5] = array(3072, 2048,    ??); // BASE*16 - encrypted with Kodak-proprietary compression/encryption
+			//$PCD_levels[6] = array(6144, 4096,    ??); // BASE*64 - encrypted with Kodak-proprietary compression/encryption; PhotoCD-Pro only
+
+			list($PCD_width, $PCD_height, $PCD_dataOffset) = $PCD_levels[3];
+
+			fseek($fd, $ThisFileInfo['avdataoffset'] + $PCD_dataOffset, SEEK_SET);
+
+			for ($y = 0; $y &lt; $PCD_height; $y += 2) {
+				// The image-data of these subtypes start at the respective offsets of 02000h, 0b800h and 30000h.
+				// To decode the YcbYr to the more usual RGB-code, three lines of data have to be read, each
+				// consisting of &#145;w&#146; bytes, where &#145;w&#146; is the width of the image-subtype. The first &#145;w&#146; bytes and
+				// the first half of the third &#145;w&#146; bytes contain data for the first RGB-line, the second &#145;w&#146; bytes
+				// and the second half of the third &#145;w&#146; bytes contain data for a second RGB-line.
+
+				$PCD_data_Y1 = fread($fd, $PCD_width);
+				$PCD_data_Y2 = fread($fd, $PCD_width);
+				$PCD_data_Cb = fread($fd, intval(round($PCD_width / 2)));
+				$PCD_data_Cr = fread($fd, intval(round($PCD_width / 2)));
+
+				for ($x = 0; $x &lt; $PCD_width; $x++) {
+					if ($PCDisVertical) {
+						$ThisFileInfo['pcd']['data'][$PCD_width - $x][$y]     = $this-&gt;YCbCr2RGB(ord($PCD_data_Y1{$x}), ord($PCD_data_Cb{floor($x / 2)}), ord($PCD_data_Cr{floor($x / 2)}));
+						$ThisFileInfo['pcd']['data'][$PCD_width - $x][$y + 1] = $this-&gt;YCbCr2RGB(ord($PCD_data_Y2{$x}), ord($PCD_data_Cb{floor($x / 2)}), ord($PCD_data_Cr{floor($x / 2)}));
+					} else {
+						$ThisFileInfo['pcd']['data'][$y][$x]                  = $this-&gt;YCbCr2RGB(ord($PCD_data_Y1{$x}), ord($PCD_data_Cb{floor($x / 2)}), ord($PCD_data_Cr{floor($x / 2)}));
+						$ThisFileInfo['pcd']['data'][$y + 1][$x]              = $this-&gt;YCbCr2RGB(ord($PCD_data_Y2{$x}), ord($PCD_data_Cb{floor($x / 2)}), ord($PCD_data_Cr{floor($x / 2)}));
+					}
+				}
+			}
+
+			// Example for plotting extracted data
+			//getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.audio.ac3.php', __FILE__, true);
+			//if ($PCDisVertical) {
+			//	$BMPinfo['resolution_x'] = $PCD_height;
+			//	$BMPinfo['resolution_y'] = $PCD_width;
+			//} else {
+			//	$BMPinfo['resolution_x'] = $PCD_width;
+			//	$BMPinfo['resolution_y'] = $PCD_height;
+			//}
+			//$BMPinfo['bmp']['data'] = $ThisFileInfo['pcd']['data'];
+			//getid3_bmp::PlotBMP($BMPinfo);
+			//exit;
+
+		}
+
+	}
+
+	function YCbCr2RGB($Y, $Cb, $Cr) {
+		static $YCbCr_constants = array();
+		if (empty($YCbCr_constants)) {
+			$YCbCr_constants['red']['Y']    =  0.0054980 * 256;
+			$YCbCr_constants['red']['Cb']   =  0.0000000 * 256;
+			$YCbCr_constants['red']['Cr']   =  0.0051681 * 256;
+			$YCbCr_constants['green']['Y']  =  0.0054980 * 256;
+			$YCbCr_constants['green']['Cb'] = -0.0015446 * 256;
+			$YCbCr_constants['green']['Cr'] = -0.0026325 * 256;
+			$YCbCr_constants['blue']['Y']   =  0.0054980 * 256;
+			$YCbCr_constants['blue']['Cb']  =  0.0079533 * 256;
+			$YCbCr_constants['blue']['Cr']  =  0.0000000 * 256;
+		}
+
+		$RGBcolor = array('red'=&gt;0, 'green'=&gt;0, 'blue'=&gt;0);
+		foreach ($RGBcolor as $rgbname =&gt; $dummy) {
+			$RGBcolor[$rgbname] = max(0,
+										min(255,
+											intval(
+												round(
+													($YCbCr_constants[$rgbname]['Y'] * $Y) +
+													($YCbCr_constants[$rgbname]['Cb'] * ($Cb - 156)) +
+													($YCbCr_constants[$rgbname]['Cr'] * ($Cr - 137))
+												)
+											)
+										)
+									);
+		}
+		return (($RGBcolor['red'] * 65536) + ($RGBcolor['green'] * 256) + $RGBcolor['blue']);
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.png.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.png.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.png.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,519 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.graphic.png.php                                      //
+// module for analyzing PNG Image files                        //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_png
+{
+
+	function getid3_png(&amp;$fd, &amp;$ThisFileInfo) {
+
+	    // shortcut
+	    $ThisFileInfo['png'] = array();
+	    $thisfile_png = &amp;$ThisFileInfo['png'];
+
+		$ThisFileInfo['fileformat']          = 'png';
+		$ThisFileInfo['video']['dataformat'] = 'png';
+		$ThisFileInfo['video']['lossless']   = false;
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$PNGfiledata = fread($fd, GETID3_FREAD_BUFFER_SIZE);
+		$offset = 0;
+
+		$PNGidentifier = substr($PNGfiledata, $offset, 8); // $89 $50 $4E $47 $0D $0A $1A $0A
+		$offset += 8;
+
+		if ($PNGidentifier != &quot;\x89\x50\x4E\x47\x0D\x0A\x1A\x0A&quot;) {
+			$ThisFileInfo['error'][] = 'First 8 bytes of file ('.getid3_lib::PrintHexBytes($PNGidentifier).') did not match expected PNG identifier';
+			unset($ThisFileInfo['fileformat']);
+			return false;
+		}
+
+		while (((ftell($fd) - (strlen($PNGfiledata) - $offset)) &lt; $ThisFileInfo['filesize'])) {
+			$chunk['data_length'] = getid3_lib::BigEndian2Int(substr($PNGfiledata, $offset, 4));
+			$offset += 4;
+			while (((strlen($PNGfiledata) - $offset) &lt; ($chunk['data_length'] + 4)) &amp;&amp; (ftell($fd) &lt; $ThisFileInfo['filesize'])) {
+				$PNGfiledata .= fread($fd, GETID3_FREAD_BUFFER_SIZE);
+			}
+			$chunk['type_text']   =               substr($PNGfiledata, $offset, 4);
+			$offset += 4;
+			$chunk['type_raw']    = getid3_lib::BigEndian2Int($chunk['type_text']);
+			$chunk['data']        =               substr($PNGfiledata, $offset, $chunk['data_length']);
+			$offset += $chunk['data_length'];
+			$chunk['crc']         = getid3_lib::BigEndian2Int(substr($PNGfiledata, $offset, 4));
+			$offset += 4;
+
+			$chunk['flags']['ancilliary']   = (bool) ($chunk['type_raw'] &amp; 0x20000000);
+			$chunk['flags']['private']      = (bool) ($chunk['type_raw'] &amp; 0x00200000);
+			$chunk['flags']['reserved']     = (bool) ($chunk['type_raw'] &amp; 0x00002000);
+			$chunk['flags']['safe_to_copy'] = (bool) ($chunk['type_raw'] &amp; 0x00000020);
+
+			// shortcut
+			$thisfile_png[$chunk['type_text']] = array();
+			$thisfile_png_chunk_type_text = &amp;$thisfile_png[$chunk['type_text']];
+
+			switch ($chunk['type_text']) {
+
+				case 'IHDR': // Image Header
+					$thisfile_png_chunk_type_text['header'] = $chunk;
+					$thisfile_png_chunk_type_text['width']                     = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'],  0, 4));
+					$thisfile_png_chunk_type_text['height']                    = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'],  4, 4));
+					$thisfile_png_chunk_type_text['raw']['bit_depth']          = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'],  8, 1));
+					$thisfile_png_chunk_type_text['raw']['color_type']         = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'],  9, 1));
+					$thisfile_png_chunk_type_text['raw']['compression_method'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 10, 1));
+					$thisfile_png_chunk_type_text['raw']['filter_method']      = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 11, 1));
+					$thisfile_png_chunk_type_text['raw']['interlace_method']   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 12, 1));
+
+					$thisfile_png_chunk_type_text['compression_method_text']   = $this-&gt;PNGcompressionMethodLookup($thisfile_png_chunk_type_text['raw']['compression_method']);
+					$thisfile_png_chunk_type_text['color_type']['palette']     = (bool) ($thisfile_png_chunk_type_text['raw']['color_type'] &amp; 0x01);
+					$thisfile_png_chunk_type_text['color_type']['true_color']  = (bool) ($thisfile_png_chunk_type_text['raw']['color_type'] &amp; 0x02);
+					$thisfile_png_chunk_type_text['color_type']['alpha']       = (bool) ($thisfile_png_chunk_type_text['raw']['color_type'] &amp; 0x04);
+
+					$ThisFileInfo['video']['resolution_x']    = $thisfile_png_chunk_type_text['width'];
+					$ThisFileInfo['video']['resolution_y']    = $thisfile_png_chunk_type_text['height'];
+
+					$ThisFileInfo['video']['bits_per_sample'] = $this-&gt;IHDRcalculateBitsPerSample($thisfile_png_chunk_type_text['raw']['color_type'], $thisfile_png_chunk_type_text['raw']['bit_depth']);
+					break;
+
+
+				case 'PLTE': // Palette
+					$thisfile_png_chunk_type_text['header'] = $chunk;
+					$paletteoffset = 0;
+					for ($i = 0; $i &lt;= 255; $i++) {
+						//$thisfile_png_chunk_type_text['red'][$i]   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $paletteoffset++, 1));
+						//$thisfile_png_chunk_type_text['green'][$i] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $paletteoffset++, 1));
+						//$thisfile_png_chunk_type_text['blue'][$i]  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $paletteoffset++, 1));
+						$red   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $paletteoffset++, 1));
+						$green = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $paletteoffset++, 1));
+						$blue  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $paletteoffset++, 1));
+						$thisfile_png_chunk_type_text[$i] = (($red &lt;&lt; 16) | ($green &lt;&lt; 8) | ($blue));
+					}
+					break;
+
+
+				case 'tRNS': // Transparency
+					$thisfile_png_chunk_type_text['header'] = $chunk;
+					switch ($thisfile_png['IHDR']['raw']['color_type']) {
+						case 0:
+							$thisfile_png_chunk_type_text['transparent_color_gray']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 2));
+							break;
+
+						case 2:
+							$thisfile_png_chunk_type_text['transparent_color_red']   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 2));
+							$thisfile_png_chunk_type_text['transparent_color_green'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 2, 2));
+							$thisfile_png_chunk_type_text['transparent_color_blue']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 4, 2));
+							break;
+
+						case 3:
+							for ($i = 0; $i &lt; strlen($thisfile_png_chunk_type_text['header']['data']); $i++) {
+								$thisfile_png_chunk_type_text['palette_opacity'][$i] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $i, 1));
+							}
+							break;
+
+						case 4:
+						case 6:
+							$ThisFileInfo['error'][] = 'Invalid color_type in tRNS chunk: '.$thisfile_png['IHDR']['raw']['color_type'];
+
+						default:
+							$ThisFileInfo['warning'][] = 'Unhandled color_type in tRNS chunk: '.$thisfile_png['IHDR']['raw']['color_type'];
+							break;
+					}
+					break;
+
+
+				case 'gAMA': // Image Gamma
+					$thisfile_png_chunk_type_text['header'] = $chunk;
+					$thisfile_png_chunk_type_text['gamma']  = getid3_lib::BigEndian2Int($thisfile_png_chunk_type_text['header']['data']) / 100000;
+					break;
+
+
+				case 'cHRM': // Primary Chromaticities
+					$thisfile_png_chunk_type_text['header']  = $chunk;
+					$thisfile_png_chunk_type_text['white_x'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'],  0, 4)) / 100000;
+					$thisfile_png_chunk_type_text['white_y'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'],  4, 4)) / 100000;
+					$thisfile_png_chunk_type_text['red_y']   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'],  8, 4)) / 100000;
+					$thisfile_png_chunk_type_text['red_y']   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 12, 4)) / 100000;
+					$thisfile_png_chunk_type_text['green_y'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 16, 4)) / 100000;
+					$thisfile_png_chunk_type_text['green_y'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 20, 4)) / 100000;
+					$thisfile_png_chunk_type_text['blue_y']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 24, 4)) / 100000;
+					$thisfile_png_chunk_type_text['blue_y']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 28, 4)) / 100000;
+					break;
+
+
+				case 'sRGB': // Standard RGB Color Space
+					$thisfile_png_chunk_type_text['header']                 = $chunk;
+					$thisfile_png_chunk_type_text['reindering_intent']      = getid3_lib::BigEndian2Int($thisfile_png_chunk_type_text['header']['data']);
+					$thisfile_png_chunk_type_text['reindering_intent_text'] = $this-&gt;PNGsRGBintentLookup($thisfile_png_chunk_type_text['reindering_intent']);
+					break;
+
+
+				case 'iCCP': // Embedded ICC Profile
+					$thisfile_png_chunk_type_text['header']                  = $chunk;
+					list($profilename, $compressiondata)                                 = explode(&quot;\x00&quot;, $thisfile_png_chunk_type_text['header']['data'], 2);
+					$thisfile_png_chunk_type_text['profile_name']            = $profilename;
+					$thisfile_png_chunk_type_text['compression_method']      = getid3_lib::BigEndian2Int(substr($compressiondata, 0, 1));
+					$thisfile_png_chunk_type_text['compression_profile']     = substr($compressiondata, 1);
+
+					$thisfile_png_chunk_type_text['compression_method_text'] = $this-&gt;PNGcompressionMethodLookup($thisfile_png_chunk_type_text['compression_method']);
+					break;
+
+
+				case 'tEXt': // Textual Data
+					$thisfile_png_chunk_type_text['header']  = $chunk;
+					list($keyword, $text)                                = explode(&quot;\x00&quot;, $thisfile_png_chunk_type_text['header']['data'], 2);
+					$thisfile_png_chunk_type_text['keyword'] = $keyword;
+					$thisfile_png_chunk_type_text['text']    = $text;
+
+					$thisfile_png['comments'][$thisfile_png_chunk_type_text['keyword']][] = $thisfile_png_chunk_type_text['text'];
+					break;
+
+
+				case 'zTXt': // Compressed Textual Data
+					$thisfile_png_chunk_type_text['header']                  = $chunk;
+					list($keyword, $otherdata)                                           = explode(&quot;\x00&quot;, $thisfile_png_chunk_type_text['header']['data'], 2);
+					$thisfile_png_chunk_type_text['keyword']                 = $keyword;
+					$thisfile_png_chunk_type_text['compression_method']      = getid3_lib::BigEndian2Int(substr($otherdata, 0, 1));
+					$thisfile_png_chunk_type_text['compressed_text']         = substr($otherdata, 1);
+					$thisfile_png_chunk_type_text['compression_method_text'] = $this-&gt;PNGcompressionMethodLookup($thisfile_png_chunk_type_text['compression_method']);
+					switch ($thisfile_png_chunk_type_text['compression_method']) {
+						case 0:
+							$thisfile_png_chunk_type_text['text']            = gzuncompress($thisfile_png_chunk_type_text['compressed_text']);
+							break;
+
+						default:
+							// unknown compression method
+							break;
+					}
+
+					if (isset($thisfile_png_chunk_type_text['text'])) {
+						$thisfile_png['comments'][$thisfile_png_chunk_type_text['keyword']][] = $thisfile_png_chunk_type_text['text'];
+					}
+					break;
+
+
+				case 'iTXt': // International Textual Data
+					$thisfile_png_chunk_type_text['header']                  = $chunk;
+					list($keyword, $otherdata)                                           = explode(&quot;\x00&quot;, $thisfile_png_chunk_type_text['header']['data'], 2);
+					$thisfile_png_chunk_type_text['keyword']                 = $keyword;
+					$thisfile_png_chunk_type_text['compression']             = (bool) getid3_lib::BigEndian2Int(substr($otherdata, 0, 1));
+					$thisfile_png_chunk_type_text['compression_method']      = getid3_lib::BigEndian2Int(substr($otherdata, 1, 1));
+					$thisfile_png_chunk_type_text['compression_method_text'] = $this-&gt;PNGcompressionMethodLookup($thisfile_png_chunk_type_text['compression_method']);
+					list($languagetag, $translatedkeyword, $text)                        = explode(&quot;\x00&quot;, substr($otherdata, 2), 3);
+					$thisfile_png_chunk_type_text['language_tag']            = $languagetag;
+					$thisfile_png_chunk_type_text['translated_keyword']      = $translatedkeyword;
+
+					if ($thisfile_png_chunk_type_text['compression']) {
+
+						switch ($thisfile_png_chunk_type_text['compression_method']) {
+							case 0:
+								$thisfile_png_chunk_type_text['text']        = gzuncompress($text);
+								break;
+
+							default:
+								// unknown compression method
+								break;
+						}
+
+					} else {
+
+						$thisfile_png_chunk_type_text['text']                = $text;
+
+					}
+
+					if (isset($thisfile_png_chunk_type_text['text'])) {
+						$thisfile_png['comments'][$thisfile_png_chunk_type_text['keyword']][] = $thisfile_png_chunk_type_text['text'];
+					}
+					break;
+
+
+				case 'bKGD': // Background Color
+					$thisfile_png_chunk_type_text['header']                   = $chunk;
+					switch ($thisfile_png['IHDR']['raw']['color_type']) {
+						case 0:
+						case 4:
+							$thisfile_png_chunk_type_text['background_gray']  = getid3_lib::BigEndian2Int($thisfile_png_chunk_type_text['header']['data']);
+							break;
+
+						case 2:
+						case 6:
+							$thisfile_png_chunk_type_text['background_red']   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0 * $thisfile_png['IHDR']['raw']['bit_depth'], $thisfile_png['IHDR']['raw']['bit_depth']));
+							$thisfile_png_chunk_type_text['background_green'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 1 * $thisfile_png['IHDR']['raw']['bit_depth'], $thisfile_png['IHDR']['raw']['bit_depth']));
+							$thisfile_png_chunk_type_text['background_blue']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 2 * $thisfile_png['IHDR']['raw']['bit_depth'], $thisfile_png['IHDR']['raw']['bit_depth']));
+							break;
+
+						case 3:
+							$thisfile_png_chunk_type_text['background_index'] = getid3_lib::BigEndian2Int($thisfile_png_chunk_type_text['header']['data']);
+							break;
+
+						default:
+							break;
+					}
+					break;
+
+
+				case 'pHYs': // Physical Pixel Dimensions
+					$thisfile_png_chunk_type_text['header']                 = $chunk;
+					$thisfile_png_chunk_type_text['pixels_per_unit_x']      = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 4));
+					$thisfile_png_chunk_type_text['pixels_per_unit_y']      = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 4, 4));
+					$thisfile_png_chunk_type_text['unit_specifier']         = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 8, 1));
+					$thisfile_png_chunk_type_text['unit']                   = $this-&gt;PNGpHYsUnitLookup($thisfile_png_chunk_type_text['unit_specifier']);
+					break;
+
+
+				case 'sBIT': // Significant Bits
+					$thisfile_png_chunk_type_text['header'] = $chunk;
+					switch ($thisfile_png['IHDR']['raw']['color_type']) {
+						case 0:
+							$thisfile_png_chunk_type_text['significant_bits_gray']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 1));
+							break;
+
+						case 2:
+						case 3:
+							$thisfile_png_chunk_type_text['significant_bits_red']   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 1));
+							$thisfile_png_chunk_type_text['significant_bits_green'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 1, 1));
+							$thisfile_png_chunk_type_text['significant_bits_blue']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 2, 1));
+							break;
+
+						case 4:
+							$thisfile_png_chunk_type_text['significant_bits_gray']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 1));
+							$thisfile_png_chunk_type_text['significant_bits_alpha'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 1, 1));
+							break;
+
+						case 6:
+							$thisfile_png_chunk_type_text['significant_bits_red']   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 1));
+							$thisfile_png_chunk_type_text['significant_bits_green'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 1, 1));
+							$thisfile_png_chunk_type_text['significant_bits_blue']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 2, 1));
+							$thisfile_png_chunk_type_text['significant_bits_alpha'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 3, 1));
+							break;
+
+						default:
+							break;
+					}
+					break;
+
+
+				case 'sPLT': // Suggested Palette
+					$thisfile_png_chunk_type_text['header']                           = $chunk;
+					list($palettename, $otherdata)                                                = explode(&quot;\x00&quot;, $thisfile_png_chunk_type_text['header']['data'], 2);
+					$thisfile_png_chunk_type_text['palette_name']                     = $palettename;
+					$sPLToffset = 0;
+					$thisfile_png_chunk_type_text['sample_depth_bits']                = getid3_lib::BigEndian2Int(substr($otherdata, $sPLToffset, 1));
+					$sPLToffset += 1;
+					$thisfile_png_chunk_type_text['sample_depth_bytes']               = $thisfile_png_chunk_type_text['sample_depth_bits'] / 8;
+					$paletteCounter = 0;
+					while ($sPLToffset &lt; strlen($otherdata)) {
+						$thisfile_png_chunk_type_text['red'][$paletteCounter]       = getid3_lib::BigEndian2Int(substr($otherdata, $sPLToffset, $thisfile_png_chunk_type_text['sample_depth_bytes']));
+						$sPLToffset += $thisfile_png_chunk_type_text['sample_depth_bytes'];
+						$thisfile_png_chunk_type_text['green'][$paletteCounter]     = getid3_lib::BigEndian2Int(substr($otherdata, $sPLToffset, $thisfile_png_chunk_type_text['sample_depth_bytes']));
+						$sPLToffset += $thisfile_png_chunk_type_text['sample_depth_bytes'];
+						$thisfile_png_chunk_type_text['blue'][$paletteCounter]      = getid3_lib::BigEndian2Int(substr($otherdata, $sPLToffset, $thisfile_png_chunk_type_text['sample_depth_bytes']));
+						$sPLToffset += $thisfile_png_chunk_type_text['sample_depth_bytes'];
+						$thisfile_png_chunk_type_text['alpha'][$paletteCounter]     = getid3_lib::BigEndian2Int(substr($otherdata, $sPLToffset, $thisfile_png_chunk_type_text['sample_depth_bytes']));
+						$sPLToffset += $thisfile_png_chunk_type_text['sample_depth_bytes'];
+						$thisfile_png_chunk_type_text['frequency'][$paletteCounter] = getid3_lib::BigEndian2Int(substr($otherdata, $sPLToffset, 2));
+						$sPLToffset += 2;
+						$paletteCounter++;
+					}
+					break;
+
+
+				case 'hIST': // Palette Histogram
+					$thisfile_png_chunk_type_text['header'] = $chunk;
+					$hISTcounter = 0;
+					while ($hISTcounter &lt; strlen($thisfile_png_chunk_type_text['header']['data'])) {
+						$thisfile_png_chunk_type_text[$hISTcounter] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $hISTcounter / 2, 2));
+						$hISTcounter += 2;
+					}
+					break;
+
+
+				case 'tIME': // Image Last-Modification Time
+					$thisfile_png_chunk_type_text['header'] = $chunk;
+					$thisfile_png_chunk_type_text['year']   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 2));
+					$thisfile_png_chunk_type_text['month']  = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 2, 1));
+					$thisfile_png_chunk_type_text['day']    = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 3, 1));
+					$thisfile_png_chunk_type_text['hour']   = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 4, 1));
+					$thisfile_png_chunk_type_text['minute'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 5, 1));
+					$thisfile_png_chunk_type_text['second'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 6, 1));
+					$thisfile_png_chunk_type_text['unix']   = gmmktime($thisfile_png_chunk_type_text['hour'], $thisfile_png_chunk_type_text['minute'], $thisfile_png_chunk_type_text['second'], $thisfile_png_chunk_type_text['month'], $thisfile_png_chunk_type_text['day'], $thisfile_png_chunk_type_text['year']);
+					break;
+
+
+				case 'oFFs': // Image Offset
+					$thisfile_png_chunk_type_text['header']         = $chunk;
+					$thisfile_png_chunk_type_text['position_x']     = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 4), false, true);
+					$thisfile_png_chunk_type_text['position_y']     = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 4, 4), false, true);
+					$thisfile_png_chunk_type_text['unit_specifier'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 8, 1));
+					$thisfile_png_chunk_type_text['unit']           = $this-&gt;PNGoFFsUnitLookup($thisfile_png_chunk_type_text['unit_specifier']);
+					break;
+
+
+				case 'pCAL': // Calibration Of Pixel Values
+					$thisfile_png_chunk_type_text['header']             = $chunk;
+					list($calibrationname, $otherdata)                              = explode(&quot;\x00&quot;, $thisfile_png_chunk_type_text['header']['data'], 2);
+					$thisfile_png_chunk_type_text['calibration_name']   = $calibrationname;
+					$pCALoffset = 0;
+					$thisfile_png_chunk_type_text['original_zero']      = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $pCALoffset, 4), false, true);
+					$pCALoffset += 4;
+					$thisfile_png_chunk_type_text['original_max']       = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $pCALoffset, 4), false, true);
+					$pCALoffset += 4;
+					$thisfile_png_chunk_type_text['equation_type']      = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $pCALoffset, 1));
+					$pCALoffset += 1;
+					$thisfile_png_chunk_type_text['equation_type_text'] = $this-&gt;PNGpCALequationTypeLookup($thisfile_png_chunk_type_text['equation_type']);
+					$thisfile_png_chunk_type_text['parameter_count']    = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], $pCALoffset, 1));
+					$pCALoffset += 1;
+					$thisfile_png_chunk_type_text['parameters']         = explode(&quot;\x00&quot;, substr($thisfile_png_chunk_type_text['header']['data'], $pCALoffset));
+					break;
+
+
+				case 'sCAL': // Physical Scale Of Image Subject
+					$thisfile_png_chunk_type_text['header']         = $chunk;
+					$thisfile_png_chunk_type_text['unit_specifier'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 1));
+					$thisfile_png_chunk_type_text['unit']           = $this-&gt;PNGsCALUnitLookup($thisfile_png_chunk_type_text['unit_specifier']);
+					list($pixelwidth, $pixelheight)                             = explode(&quot;\x00&quot;, substr($thisfile_png_chunk_type_text['header']['data'], 1));
+					$thisfile_png_chunk_type_text['pixel_width']    = $pixelwidth;
+					$thisfile_png_chunk_type_text['pixel_height']   = $pixelheight;
+					break;
+
+
+				case 'gIFg': // GIF Graphic Control Extension
+					$gIFgCounter = 0;
+					if (isset($thisfile_png_chunk_type_text) &amp;&amp; is_array($thisfile_png_chunk_type_text)) {
+						$gIFgCounter = count($thisfile_png_chunk_type_text);
+					}
+					$thisfile_png_chunk_type_text[$gIFgCounter]['header']          = $chunk;
+					$thisfile_png_chunk_type_text[$gIFgCounter]['disposal_method'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 0, 1));
+					$thisfile_png_chunk_type_text[$gIFgCounter]['user_input_flag'] = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 1, 1));
+					$thisfile_png_chunk_type_text[$gIFgCounter]['delay_time']      = getid3_lib::BigEndian2Int(substr($thisfile_png_chunk_type_text['header']['data'], 2, 2));
+					break;
+
+
+				case 'gIFx': // GIF Application Extension
+					$gIFxCounter = 0;
+					if (isset($thisfile_png_chunk_type_text) &amp;&amp; is_array($thisfile_png_chunk_type_text)) {
+						$gIFxCounter = count($thisfile_png_chunk_type_text);
+					}
+					$thisfile_png_chunk_type_text[$gIFxCounter]['header']                 = $chunk;
+					$thisfile_png_chunk_type_text[$gIFxCounter]['application_identifier'] = substr($thisfile_png_chunk_type_text['header']['data'],  0, 8);
+					$thisfile_png_chunk_type_text[$gIFxCounter]['authentication_code']    = substr($thisfile_png_chunk_type_text['header']['data'],  8, 3);
+					$thisfile_png_chunk_type_text[$gIFxCounter]['application_data']       = substr($thisfile_png_chunk_type_text['header']['data'], 11);
+					break;
+
+
+				case 'IDAT': // Image Data
+					$idatinformationfieldindex = 0;
+					if (isset($thisfile_png['IDAT']) &amp;&amp; is_array($thisfile_png['IDAT'])) {
+						$idatinformationfieldindex = count($thisfile_png['IDAT']);
+					}
+					unset($chunk['data']);
+					$thisfile_png_chunk_type_text[$idatinformationfieldindex]['header'] = $chunk;
+					break;
+
+
+				case 'IEND': // Image Trailer
+					$thisfile_png_chunk_type_text['header'] = $chunk;
+					break;
+
+
+				default:
+					//unset($chunk['data']);
+					$thisfile_png_chunk_type_text['header'] = $chunk;
+					$ThisFileInfo['warning'][] = 'Unhandled chunk type: '.$chunk['type_text'];
+					break;
+			}
+		}
+
+		return true;
+	}
+
+	function PNGsRGBintentLookup($sRGB) {
+		static $PNGsRGBintentLookup = array(
+			0 =&gt; 'Perceptual',
+			1 =&gt; 'Relative colorimetric',
+			2 =&gt; 'Saturation',
+			3 =&gt; 'Absolute colorimetric'
+		);
+		return (isset($PNGsRGBintentLookup[$sRGB]) ? $PNGsRGBintentLookup[$sRGB] : 'invalid');
+	}
+
+	function PNGcompressionMethodLookup($compressionmethod) {
+		static $PNGcompressionMethodLookup = array(
+			0 =&gt; 'deflate/inflate'
+		);
+		return (isset($PNGcompressionMethodLookup[$compressionmethod]) ? $PNGcompressionMethodLookup[$compressionmethod] : 'invalid');
+	}
+
+	function PNGpHYsUnitLookup($unitid) {
+		static $PNGpHYsUnitLookup = array(
+			0 =&gt; 'unknown',
+			1 =&gt; 'meter'
+		);
+		return (isset($PNGpHYsUnitLookup[$unitid]) ? $PNGpHYsUnitLookup[$unitid] : 'invalid');
+	}
+
+	function PNGoFFsUnitLookup($unitid) {
+		static $PNGoFFsUnitLookup = array(
+			0 =&gt; 'pixel',
+			1 =&gt; 'micrometer'
+		);
+		return (isset($PNGoFFsUnitLookup[$unitid]) ? $PNGoFFsUnitLookup[$unitid] : 'invalid');
+	}
+
+	function PNGpCALequationTypeLookup($equationtype) {
+		static $PNGpCALequationTypeLookup = array(
+			0 =&gt; 'Linear mapping',
+			1 =&gt; 'Base-e exponential mapping',
+			2 =&gt; 'Arbitrary-base exponential mapping',
+			3 =&gt; 'Hyperbolic mapping'
+		);
+		return (isset($PNGpCALequationTypeLookup[$equationtype]) ? $PNGpCALequationTypeLookup[$equationtype] : 'invalid');
+	}
+
+	function PNGsCALUnitLookup($unitid) {
+		static $PNGsCALUnitLookup = array(
+			0 =&gt; 'meter',
+			1 =&gt; 'radian'
+		);
+		return (isset($PNGsCALUnitLookup[$unitid]) ? $PNGsCALUnitLookup[$unitid] : 'invalid');
+	}
+
+	function IHDRcalculateBitsPerSample($color_type, $bit_depth) {
+		switch ($color_type) {
+			case 0: // Each pixel is a grayscale sample.
+				return $bit_depth;
+				break;
+
+			case 2: // Each pixel is an R,G,B triple
+				return 3 * $bit_depth;
+				break;
+
+			case 3: // Each pixel is a palette index; a PLTE chunk must appear.
+				return $bit_depth;
+				break;
+
+			case 4: // Each pixel is a grayscale sample, followed by an alpha sample.
+				return 2 * $bit_depth;
+				break;
+
+			case 6: // Each pixel is an R,G,B triple, followed by an alpha sample.
+				return 4 * $bit_depth;
+				break;
+		}
+		return false;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.tiff.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.tiff.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.graphic.tiff.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,221 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.archive.tiff.php                                     //
+// module for analyzing TIFF files                             //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_tiff
+{
+
+	function getid3_tiff(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$TIFFheader = fread($fd, 4);
+
+		switch (substr($TIFFheader, 0, 2)) {
+			case 'II':
+				$ThisFileInfo['tiff']['byte_order'] = 'Intel';
+				break;
+			case 'MM':
+				$ThisFileInfo['tiff']['byte_order'] = 'Motorola';
+				break;
+			default:
+				$ThisFileInfo['error'][] = 'Invalid TIFF byte order identifier ('.substr($TIFFheader, 0, 2).') at offset '.$ThisFileInfo['avdataoffset'];
+				return false;
+				break;
+		}
+
+		$ThisFileInfo['fileformat']          = 'tiff';
+		$ThisFileInfo['video']['dataformat'] = 'tiff';
+		$ThisFileInfo['video']['lossless']   = true;
+		$ThisFileInfo['tiff']['ifd']         = array();
+		$CurrentIFD                          = array();
+
+		$FieldTypeByteLength = array(1=&gt;1, 2=&gt;1, 3=&gt;2, 4=&gt;4, 5=&gt;8);
+
+		$nextIFDoffset = $this-&gt;TIFFendian2Int(fread($fd, 4), $ThisFileInfo['tiff']['byte_order']);
+
+		while ($nextIFDoffset &gt; 0) {
+
+			$CurrentIFD['offset'] = $nextIFDoffset;
+
+			fseek($fd, $ThisFileInfo['avdataoffset'] + $nextIFDoffset, SEEK_SET);
+			$CurrentIFD['fieldcount'] = $this-&gt;TIFFendian2Int(fread($fd, 2), $ThisFileInfo['tiff']['byte_order']);
+
+			for ($i = 0; $i &lt; $CurrentIFD['fieldcount']; $i++) {
+				$CurrentIFD['fields'][$i]['raw']['tag']    = $this-&gt;TIFFendian2Int(fread($fd, 2), $ThisFileInfo['tiff']['byte_order']);
+				$CurrentIFD['fields'][$i]['raw']['type']   = $this-&gt;TIFFendian2Int(fread($fd, 2), $ThisFileInfo['tiff']['byte_order']);
+				$CurrentIFD['fields'][$i]['raw']['length'] = $this-&gt;TIFFendian2Int(fread($fd, 4), $ThisFileInfo['tiff']['byte_order']);
+				$CurrentIFD['fields'][$i]['raw']['offset'] =                       fread($fd, 4);
+
+				switch ($CurrentIFD['fields'][$i]['raw']['type']) {
+					case 1: // BYTE  An 8-bit unsigned integer.
+						if ($CurrentIFD['fields'][$i]['raw']['length'] &lt;= 4) {
+							$CurrentIFD['fields'][$i]['value']  = $this-&gt;TIFFendian2Int(substr($CurrentIFD['fields'][$i]['raw']['offset'], 0, 1), $ThisFileInfo['tiff']['byte_order']);
+						} else {
+							$CurrentIFD['fields'][$i]['offset'] = $this-&gt;TIFFendian2Int($CurrentIFD['fields'][$i]['raw']['offset'], $ThisFileInfo['tiff']['byte_order']);
+						}
+						break;
+
+					case 2: // ASCII 8-bit bytes  that store ASCII codes; the last byte must be null.
+						if ($CurrentIFD['fields'][$i]['raw']['length'] &lt;= 4) {
+							$CurrentIFD['fields'][$i]['value']  = substr($CurrentIFD['fields'][$i]['raw']['offset'], 3);
+						} else {
+							$CurrentIFD['fields'][$i]['offset'] = $this-&gt;TIFFendian2Int($CurrentIFD['fields'][$i]['raw']['offset'], $ThisFileInfo['tiff']['byte_order']);
+						}
+						break;
+
+					case 3: // SHORT A 16-bit (2-byte) unsigned integer.
+						if ($CurrentIFD['fields'][$i]['raw']['length'] &lt;= 2) {
+							$CurrentIFD['fields'][$i]['value']  = $this-&gt;TIFFendian2Int(substr($CurrentIFD['fields'][$i]['raw']['offset'], 0, 2), $ThisFileInfo['tiff']['byte_order']);
+						} else {
+							$CurrentIFD['fields'][$i]['offset'] = $this-&gt;TIFFendian2Int($CurrentIFD['fields'][$i]['raw']['offset'], $ThisFileInfo['tiff']['byte_order']);
+						}
+						break;
+
+					case 4: // LONG  A 32-bit (4-byte) unsigned integer.
+						if ($CurrentIFD['fields'][$i]['raw']['length'] &lt;= 1) {
+							$CurrentIFD['fields'][$i]['value']  = $this-&gt;TIFFendian2Int($CurrentIFD['fields'][$i]['raw']['offset'], $ThisFileInfo['tiff']['byte_order']);
+						} else {
+							$CurrentIFD['fields'][$i]['offset'] = $this-&gt;TIFFendian2Int($CurrentIFD['fields'][$i]['raw']['offset'], $ThisFileInfo['tiff']['byte_order']);
+						}
+						break;
+
+					case 5: // RATIONAL   Two LONG_s:  the first represents the numerator of a fraction, the second the denominator.
+						break;
+				}
+			}
+
+			$ThisFileInfo['tiff']['ifd'][] = $CurrentIFD;
+			$CurrentIFD = array();
+			$nextIFDoffset = $this-&gt;TIFFendian2Int(fread($fd, 4), $ThisFileInfo['tiff']['byte_order']);
+
+		}
+
+		foreach ($ThisFileInfo['tiff']['ifd'] as $IFDid =&gt; $IFDarray) {
+			foreach ($IFDarray['fields'] as $key =&gt; $fieldarray) {
+				switch ($fieldarray['raw']['tag']) {
+					case 256: // ImageWidth
+					case 257: // ImageLength
+					case 258: // BitsPerSample
+					case 259: // Compression
+						if (!isset($fieldarray['value'])) {
+							fseek($fd, $fieldarray['offset'], SEEK_SET);
+							$ThisFileInfo['tiff']['ifd'][$IFDid]['fields'][$key]['raw']['data'] = fread($fd, $fieldarray['raw']['length'] * $FieldTypeByteLength[$fieldarray['raw']['type']]);
+
+						}
+						break;
+
+					case 270: // ImageDescription
+					case 271: // Make
+					case 272: // Model
+					case 305: // Software
+					case 306: // DateTime
+					case 315: // Artist
+					case 316: // HostComputer
+						if (isset($fieldarray['value'])) {
+							$ThisFileInfo['tiff']['ifd'][$IFDid]['fields'][$key]['raw']['data'] = $fieldarray['value'];
+						} else {
+							fseek($fd, $fieldarray['offset'], SEEK_SET);
+							$ThisFileInfo['tiff']['ifd'][$IFDid]['fields'][$key]['raw']['data'] = fread($fd, $fieldarray['raw']['length'] * $FieldTypeByteLength[$fieldarray['raw']['type']]);
+
+						}
+						break;
+				}
+				switch ($fieldarray['raw']['tag']) {
+					case 256: // ImageWidth
+						$ThisFileInfo['video']['resolution_x'] = $fieldarray['value'];
+						break;
+
+					case 257: // ImageLength
+						$ThisFileInfo['video']['resolution_y'] = $fieldarray['value'];
+						break;
+
+					case 258: // BitsPerSample
+						if (isset($fieldarray['value'])) {
+							$ThisFileInfo['video']['bits_per_sample'] = $fieldarray['value'];
+						} else {
+							$ThisFileInfo['video']['bits_per_sample'] = 0;
+							for ($i = 0; $i &lt; $fieldarray['raw']['length']; $i++) {
+								$ThisFileInfo['video']['bits_per_sample'] += $this-&gt;TIFFendian2Int(substr($ThisFileInfo['tiff']['ifd'][$IFDid]['fields'][$key]['raw']['data'], $i * $FieldTypeByteLength[$fieldarray['raw']['type']], $FieldTypeByteLength[$fieldarray['raw']['type']]), $ThisFileInfo['tiff']['byte_order']);
+							}
+						}
+						break;
+
+					case 259: // Compression
+						$ThisFileInfo['video']['codec'] = $this-&gt;TIFFcompressionMethod($fieldarray['value']);
+						break;
+
+					case 270: // ImageDescription
+					case 271: // Make
+					case 272: // Model
+					case 305: // Software
+					case 306: // DateTime
+					case 315: // Artist
+					case 316: // HostComputer
+						@$ThisFileInfo['tiff']['comments'][$this-&gt;TIFFcommentName($fieldarray['raw']['tag'])][] = $ThisFileInfo['tiff']['ifd'][$IFDid]['fields'][$key]['raw']['data'];
+						break;
+
+					default:
+						break;
+				}
+			}
+		}
+
+		return true;
+	}
+
+
+	function TIFFendian2Int($bytestring, $byteorder) {
+		if ($byteorder == 'Intel') {
+			return getid3_lib::LittleEndian2Int($bytestring);
+		} elseif ($byteorder == 'Motorola') {
+			return getid3_lib::BigEndian2Int($bytestring);
+		}
+		return false;
+	}
+
+	function TIFFcompressionMethod($id) {
+		static $TIFFcompressionMethod = array();
+		if (empty($TIFFcompressionMethod)) {
+			$TIFFcompressionMethod = array(
+				1     =&gt; 'Uncompressed',
+				2     =&gt; 'Huffman',
+				3     =&gt; 'Fax - CCITT 3',
+				5     =&gt; 'LZW',
+				32773 =&gt; 'PackBits',
+			);
+		}
+		return (isset($TIFFcompressionMethod[$id]) ? $TIFFcompressionMethod[$id] : 'unknown/invalid ('.$id.')');
+	}
+
+	function TIFFcommentName($id) {
+		static $TIFFcommentName = array();
+		if (empty($TIFFcommentName)) {
+			$TIFFcommentName = array(
+				270 =&gt; 'imagedescription',
+				271 =&gt; 'make',
+				272 =&gt; 'model',
+				305 =&gt; 'software',
+				306 =&gt; 'datetime',
+				315 =&gt; 'artist',
+				316 =&gt; 'hostcomputer',
+			);
+		}
+		return (isset($TIFFcommentName[$id]) ? $TIFFcommentName[$id] : 'unknown/invalid ('.$id.')');
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.misc.exe.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.misc.exe.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.misc.exe.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,59 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.misc.exe.php                                         //
+// module for analyzing EXE files                              //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_exe
+{
+
+	function getid3_exe(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, $ThisFileInfo['avdataoffset'], SEEK_SET);
+		$EXEheader = fread($fd, 28);
+
+		if (substr($EXEheader, 0, 2) != 'MZ') {
+			$ThisFileInfo['error'][] = 'Expecting &quot;MZ&quot; at offset '.$ThisFileInfo['avdataoffset'].', found &quot;'.substr($EXEheader, 0, 2).'&quot; instead.';
+			return false;
+		}
+
+		$ThisFileInfo['fileformat'] = 'exe';
+		$ThisFileInfo['exe']['mz']['magic'] = 'MZ';
+
+		$ThisFileInfo['exe']['mz']['raw']['last_page_size']          = getid3_lib::LittleEndian2Int(substr($EXEheader,  2, 2));
+		$ThisFileInfo['exe']['mz']['raw']['page_count']              = getid3_lib::LittleEndian2Int(substr($EXEheader,  4, 2));
+		$ThisFileInfo['exe']['mz']['raw']['relocation_count']        = getid3_lib::LittleEndian2Int(substr($EXEheader,  6, 2));
+		$ThisFileInfo['exe']['mz']['raw']['header_paragraphs']       = getid3_lib::LittleEndian2Int(substr($EXEheader,  8, 2));
+		$ThisFileInfo['exe']['mz']['raw']['min_memory_paragraphs']   = getid3_lib::LittleEndian2Int(substr($EXEheader, 10, 2));
+		$ThisFileInfo['exe']['mz']['raw']['max_memory_paragraphs']   = getid3_lib::LittleEndian2Int(substr($EXEheader, 12, 2));
+		$ThisFileInfo['exe']['mz']['raw']['initial_ss']              = getid3_lib::LittleEndian2Int(substr($EXEheader, 14, 2));
+		$ThisFileInfo['exe']['mz']['raw']['initial_sp']              = getid3_lib::LittleEndian2Int(substr($EXEheader, 16, 2));
+		$ThisFileInfo['exe']['mz']['raw']['checksum']                = getid3_lib::LittleEndian2Int(substr($EXEheader, 18, 2));
+		$ThisFileInfo['exe']['mz']['raw']['cs_ip']                   = getid3_lib::LittleEndian2Int(substr($EXEheader, 20, 4));
+		$ThisFileInfo['exe']['mz']['raw']['relocation_table_offset'] = getid3_lib::LittleEndian2Int(substr($EXEheader, 24, 2));
+		$ThisFileInfo['exe']['mz']['raw']['overlay_number']          = getid3_lib::LittleEndian2Int(substr($EXEheader, 26, 2));
+
+		$ThisFileInfo['exe']['mz']['byte_size']          = (($ThisFileInfo['exe']['mz']['raw']['page_count'] - 1)) * 512 + $ThisFileInfo['exe']['mz']['raw']['last_page_size'];
+		$ThisFileInfo['exe']['mz']['header_size']        = $ThisFileInfo['exe']['mz']['raw']['header_paragraphs'] * 16;
+		$ThisFileInfo['exe']['mz']['memory_minimum']     = $ThisFileInfo['exe']['mz']['raw']['min_memory_paragraphs'] * 16;
+		$ThisFileInfo['exe']['mz']['memory_recommended'] = $ThisFileInfo['exe']['mz']['raw']['max_memory_paragraphs'] * 16;
+
+$ThisFileInfo['error'][] = 'EXE parsing not enabled in this version of getID3()';
+return false;
+
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.misc.iso.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.misc.iso.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.misc.iso.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,386 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.misc.iso.php                                         //
+// module for analyzing ISO files                              //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_iso
+{
+
+	function getid3_iso($fd, &amp;$ThisFileInfo) {
+		$ThisFileInfo['fileformat'] = 'iso';
+
+		for ($i = 16; $i &lt;= 19; $i++) {
+			fseek($fd, 2048 * $i, SEEK_SET);
+			$ISOheader = fread($fd, 2048);
+			if (substr($ISOheader, 1, 5) == 'CD001') {
+				switch (ord($ISOheader{0})) {
+					case 1:
+						$ThisFileInfo['iso']['primary_volume_descriptor']['offset'] = 2048 * $i;
+						$this-&gt;ParsePrimaryVolumeDescriptor($ISOheader, $ThisFileInfo);
+						break;
+
+					case 2:
+						$ThisFileInfo['iso']['supplementary_volume_descriptor']['offset'] = 2048 * $i;
+						$this-&gt;ParseSupplementaryVolumeDescriptor($ISOheader, $ThisFileInfo);
+						break;
+
+					default:
+						// skip
+						break;
+				}
+			}
+		}
+
+		$this-&gt;ParsePathTable($fd, $ThisFileInfo);
+
+		$ThisFileInfo['iso']['files'] = array();
+		foreach ($ThisFileInfo['iso']['path_table']['directories'] as $directorynum =&gt; $directorydata) {
+
+			$ThisFileInfo['iso']['directories'][$directorynum] = $this-&gt;ParseDirectoryRecord($fd, $directorydata, $ThisFileInfo);
+
+		}
+
+		return true;
+
+	}
+
+
+	function ParsePrimaryVolumeDescriptor(&amp;$ISOheader, &amp;$ThisFileInfo) {
+		// ISO integer values are stored *BOTH* Little-Endian AND Big-Endian format!!
+		// ie 12345 == 0x3039  is stored as $39 $30 $30 $39 in a 4-byte field
+
+		// shortcuts
+		$ThisFileInfo['iso']['primary_volume_descriptor']['raw'] = array();
+		$thisfile_iso_primaryVD     = &amp;$ThisFileInfo['iso']['primary_volume_descriptor'];
+		$thisfile_iso_primaryVD_raw = &amp;$thisfile_iso_primaryVD['raw'];
+
+		$thisfile_iso_primaryVD_raw['volume_descriptor_type']         = getid3_lib::LittleEndian2Int(substr($ISOheader,    0, 1));
+		$thisfile_iso_primaryVD_raw['standard_identifier']            =                  substr($ISOheader,    1, 5);
+		if ($thisfile_iso_primaryVD_raw['standard_identifier'] != 'CD001') {
+			$ThisFileInfo['error'][] = 'Expected &quot;CD001&quot; at offset ('.($thisfile_iso_primaryVD['offset'] + 1).'), found &quot;'.$thisfile_iso_primaryVD_raw['standard_identifier'].'&quot; instead';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['iso']);
+			return false;
+		}
+
+
+		$thisfile_iso_primaryVD_raw['volume_descriptor_version']     = getid3_lib::LittleEndian2Int(substr($ISOheader,    6, 1));
+		//$thisfile_iso_primaryVD_raw['unused_1']                      =                              substr($ISOheader,    7, 1);
+		$thisfile_iso_primaryVD_raw['system_identifier']             =                              substr($ISOheader,    8, 32);
+		$thisfile_iso_primaryVD_raw['volume_identifier']             =                              substr($ISOheader,   40, 32);
+		//$thisfile_iso_primaryVD_raw['unused_2']                      =                              substr($ISOheader,   72, 8);
+		$thisfile_iso_primaryVD_raw['volume_space_size']             = getid3_lib::LittleEndian2Int(substr($ISOheader,   80, 4));
+		//$thisfile_iso_primaryVD_raw['unused_3']                      =                              substr($ISOheader,   88, 32);
+		$thisfile_iso_primaryVD_raw['volume_set_size']               = getid3_lib::LittleEndian2Int(substr($ISOheader,  120, 2));
+		$thisfile_iso_primaryVD_raw['volume_sequence_number']        = getid3_lib::LittleEndian2Int(substr($ISOheader,  124, 2));
+		$thisfile_iso_primaryVD_raw['logical_block_size']            = getid3_lib::LittleEndian2Int(substr($ISOheader,  128, 2));
+		$thisfile_iso_primaryVD_raw['path_table_size']               = getid3_lib::LittleEndian2Int(substr($ISOheader,  132, 4));
+		$thisfile_iso_primaryVD_raw['path_table_l_location']         = getid3_lib::LittleEndian2Int(substr($ISOheader,  140, 2));
+		$thisfile_iso_primaryVD_raw['path_table_l_opt_location']     = getid3_lib::LittleEndian2Int(substr($ISOheader,  144, 2));
+		$thisfile_iso_primaryVD_raw['path_table_m_location']         = getid3_lib::LittleEndian2Int(substr($ISOheader,  148, 2));
+		$thisfile_iso_primaryVD_raw['path_table_m_opt_location']     = getid3_lib::LittleEndian2Int(substr($ISOheader,  152, 2));
+		$thisfile_iso_primaryVD_raw['root_directory_record']         =                              substr($ISOheader,  156, 34);
+		$thisfile_iso_primaryVD_raw['volume_set_identifier']         =                              substr($ISOheader,  190, 128);
+		$thisfile_iso_primaryVD_raw['publisher_identifier']          =                              substr($ISOheader,  318, 128);
+		$thisfile_iso_primaryVD_raw['data_preparer_identifier']      =                              substr($ISOheader,  446, 128);
+		$thisfile_iso_primaryVD_raw['application_identifier']        =                              substr($ISOheader,  574, 128);
+		$thisfile_iso_primaryVD_raw['copyright_file_identifier']     =                              substr($ISOheader,  702, 37);
+		$thisfile_iso_primaryVD_raw['abstract_file_identifier']      =                              substr($ISOheader,  739, 37);
+		$thisfile_iso_primaryVD_raw['bibliographic_file_identifier'] =                              substr($ISOheader,  776, 37);
+		$thisfile_iso_primaryVD_raw['volume_creation_date_time']     =                              substr($ISOheader,  813, 17);
+		$thisfile_iso_primaryVD_raw['volume_modification_date_time'] =                              substr($ISOheader,  830, 17);
+		$thisfile_iso_primaryVD_raw['volume_expiration_date_time']   =                              substr($ISOheader,  847, 17);
+		$thisfile_iso_primaryVD_raw['volume_effective_date_time']    =                              substr($ISOheader,  864, 17);
+		$thisfile_iso_primaryVD_raw['file_structure_version']        = getid3_lib::LittleEndian2Int(substr($ISOheader,  881, 1));
+		//$thisfile_iso_primaryVD_raw['unused_4']                      = getid3_lib::LittleEndian2Int(substr($ISOheader,  882, 1));
+		$thisfile_iso_primaryVD_raw['application_data']              =                              substr($ISOheader,  883, 512);
+		//$thisfile_iso_primaryVD_raw['unused_5']                      =                              substr($ISOheader, 1395, 653);
+
+		$thisfile_iso_primaryVD['system_identifier']             = trim($thisfile_iso_primaryVD_raw['system_identifier']);
+		$thisfile_iso_primaryVD['volume_identifier']             = trim($thisfile_iso_primaryVD_raw['volume_identifier']);
+		$thisfile_iso_primaryVD['volume_set_identifier']         = trim($thisfile_iso_primaryVD_raw['volume_set_identifier']);
+		$thisfile_iso_primaryVD['publisher_identifier']          = trim($thisfile_iso_primaryVD_raw['publisher_identifier']);
+		$thisfile_iso_primaryVD['data_preparer_identifier']      = trim($thisfile_iso_primaryVD_raw['data_preparer_identifier']);
+		$thisfile_iso_primaryVD['application_identifier']        = trim($thisfile_iso_primaryVD_raw['application_identifier']);
+		$thisfile_iso_primaryVD['copyright_file_identifier']     = trim($thisfile_iso_primaryVD_raw['copyright_file_identifier']);
+		$thisfile_iso_primaryVD['abstract_file_identifier']      = trim($thisfile_iso_primaryVD_raw['abstract_file_identifier']);
+		$thisfile_iso_primaryVD['bibliographic_file_identifier'] = trim($thisfile_iso_primaryVD_raw['bibliographic_file_identifier']);
+		$thisfile_iso_primaryVD['volume_creation_date_time']     = $this-&gt;ISOtimeText2UNIXtime($thisfile_iso_primaryVD_raw['volume_creation_date_time']);
+		$thisfile_iso_primaryVD['volume_modification_date_time'] = $this-&gt;ISOtimeText2UNIXtime($thisfile_iso_primaryVD_raw['volume_modification_date_time']);
+		$thisfile_iso_primaryVD['volume_expiration_date_time']   = $this-&gt;ISOtimeText2UNIXtime($thisfile_iso_primaryVD_raw['volume_expiration_date_time']);
+		$thisfile_iso_primaryVD['volume_effective_date_time']    = $this-&gt;ISOtimeText2UNIXtime($thisfile_iso_primaryVD_raw['volume_effective_date_time']);
+
+		if (($thisfile_iso_primaryVD_raw['volume_space_size'] * 2048) &gt; $ThisFileInfo['filesize']) {
+			$ThisFileInfo['error'][] = 'Volume Space Size ('.($thisfile_iso_primaryVD_raw['volume_space_size'] * 2048).' bytes) is larger than the file size ('.$ThisFileInfo['filesize'].' bytes) (truncated file?)';
+		}
+
+		return true;
+	}
+
+
+	function ParseSupplementaryVolumeDescriptor(&amp;$ISOheader, &amp;$ThisFileInfo) {
+		// ISO integer values are stored Both-Endian format!!
+		// ie 12345 == 0x3039  is stored as $39 $30 $30 $39 in a 4-byte field
+
+		// shortcuts
+		$ThisFileInfo['iso']['supplementary_volume_descriptor']['raw'] = array();
+		$thisfile_iso_supplementaryVD     = &amp;$ThisFileInfo['iso']['supplementary_volume_descriptor'];
+		$thisfile_iso_supplementaryVD_raw = &amp;$thisfile_iso_supplementaryVD['raw'];
+
+		$thisfile_iso_supplementaryVD_raw['volume_descriptor_type'] = getid3_lib::LittleEndian2Int(substr($ISOheader,    0, 1));
+		$thisfile_iso_supplementaryVD_raw['standard_identifier']    =                  substr($ISOheader,    1, 5);
+		if ($thisfile_iso_supplementaryVD_raw['standard_identifier'] != 'CD001') {
+			$ThisFileInfo['error'][] = 'Expected &quot;CD001&quot; at offset ('.($thisfile_iso_supplementaryVD['offset'] + 1).'), found &quot;'.$thisfile_iso_supplementaryVD_raw['standard_identifier'].'&quot; instead';
+			unset($ThisFileInfo['fileformat']);
+			unset($ThisFileInfo['iso']);
+			return false;
+		}
+
+		$thisfile_iso_supplementaryVD_raw['volume_descriptor_version'] = getid3_lib::LittleEndian2Int(substr($ISOheader,    6, 1));
+		//$thisfile_iso_supplementaryVD_raw['unused_1']                  =                              substr($ISOheader,    7, 1);
+		$thisfile_iso_supplementaryVD_raw['system_identifier']         =                              substr($ISOheader,    8, 32);
+		$thisfile_iso_supplementaryVD_raw['volume_identifier']         =                              substr($ISOheader,   40, 32);
+		//$thisfile_iso_supplementaryVD_raw['unused_2']                  =                              substr($ISOheader,   72, 8);
+		$thisfile_iso_supplementaryVD_raw['volume_space_size']         = getid3_lib::LittleEndian2Int(substr($ISOheader,   80, 4));
+		if ($thisfile_iso_supplementaryVD_raw['volume_space_size'] == 0) {
+			// Supplementary Volume Descriptor not used
+			//unset($thisfile_iso_supplementaryVD);
+			//return false;
+		}
+
+		//$thisfile_iso_supplementaryVD_raw['unused_3']                       =                              substr($ISOheader,   88, 32);
+		$thisfile_iso_supplementaryVD_raw['volume_set_size']                = getid3_lib::LittleEndian2Int(substr($ISOheader,  120, 2));
+		$thisfile_iso_supplementaryVD_raw['volume_sequence_number']         = getid3_lib::LittleEndian2Int(substr($ISOheader,  124, 2));
+		$thisfile_iso_supplementaryVD_raw['logical_block_size']             = getid3_lib::LittleEndian2Int(substr($ISOheader,  128, 2));
+		$thisfile_iso_supplementaryVD_raw['path_table_size']                = getid3_lib::LittleEndian2Int(substr($ISOheader,  132, 4));
+		$thisfile_iso_supplementaryVD_raw['path_table_l_location']          = getid3_lib::LittleEndian2Int(substr($ISOheader,  140, 2));
+		$thisfile_iso_supplementaryVD_raw['path_table_l_opt_location']      = getid3_lib::LittleEndian2Int(substr($ISOheader,  144, 2));
+		$thisfile_iso_supplementaryVD_raw['path_table_m_location']          = getid3_lib::LittleEndian2Int(substr($ISOheader,  148, 2));
+		$thisfile_iso_supplementaryVD_raw['path_table_m_opt_location']      = getid3_lib::LittleEndian2Int(substr($ISOheader,  152, 2));
+		$thisfile_iso_supplementaryVD_raw['root_directory_record']          =                              substr($ISOheader,  156, 34);
+		$thisfile_iso_supplementaryVD_raw['volume_set_identifier']          =                              substr($ISOheader,  190, 128);
+		$thisfile_iso_supplementaryVD_raw['publisher_identifier']           =                              substr($ISOheader,  318, 128);
+		$thisfile_iso_supplementaryVD_raw['data_preparer_identifier']       =                              substr($ISOheader,  446, 128);
+		$thisfile_iso_supplementaryVD_raw['application_identifier']         =                              substr($ISOheader,  574, 128);
+		$thisfile_iso_supplementaryVD_raw['copyright_file_identifier']      =                              substr($ISOheader,  702, 37);
+		$thisfile_iso_supplementaryVD_raw['abstract_file_identifier']       =                              substr($ISOheader,  739, 37);
+		$thisfile_iso_supplementaryVD_raw['bibliographic_file_identifier']  =                              substr($ISOheader,  776, 37);
+		$thisfile_iso_supplementaryVD_raw['volume_creation_date_time']      =                              substr($ISOheader,  813, 17);
+		$thisfile_iso_supplementaryVD_raw['volume_modification_date_time']  =                              substr($ISOheader,  830, 17);
+		$thisfile_iso_supplementaryVD_raw['volume_expiration_date_time']    =                              substr($ISOheader,  847, 17);
+		$thisfile_iso_supplementaryVD_raw['volume_effective_date_time']     =                              substr($ISOheader,  864, 17);
+		$thisfile_iso_supplementaryVD_raw['file_structure_version']         = getid3_lib::LittleEndian2Int(substr($ISOheader,  881, 1));
+		//$thisfile_iso_supplementaryVD_raw['unused_4']                       = getid3_lib::LittleEndian2Int(substr($ISOheader,  882, 1));
+		$thisfile_iso_supplementaryVD_raw['application_data']               =                              substr($ISOheader,  883, 512);
+		//$thisfile_iso_supplementaryVD_raw['unused_5']                       =                              substr($ISOheader, 1395, 653);
+
+		$thisfile_iso_supplementaryVD['system_identifier']              = trim($thisfile_iso_supplementaryVD_raw['system_identifier']);
+		$thisfile_iso_supplementaryVD['volume_identifier']              = trim($thisfile_iso_supplementaryVD_raw['volume_identifier']);
+		$thisfile_iso_supplementaryVD['volume_set_identifier']          = trim($thisfile_iso_supplementaryVD_raw['volume_set_identifier']);
+		$thisfile_iso_supplementaryVD['publisher_identifier']           = trim($thisfile_iso_supplementaryVD_raw['publisher_identifier']);
+		$thisfile_iso_supplementaryVD['data_preparer_identifier']       = trim($thisfile_iso_supplementaryVD_raw['data_preparer_identifier']);
+		$thisfile_iso_supplementaryVD['application_identifier']         = trim($thisfile_iso_supplementaryVD_raw['application_identifier']);
+		$thisfile_iso_supplementaryVD['copyright_file_identifier']      = trim($thisfile_iso_supplementaryVD_raw['copyright_file_identifier']);
+		$thisfile_iso_supplementaryVD['abstract_file_identifier']       = trim($thisfile_iso_supplementaryVD_raw['abstract_file_identifier']);
+		$thisfile_iso_supplementaryVD['bibliographic_file_identifier']  = trim($thisfile_iso_supplementaryVD_raw['bibliographic_file_identifier']);
+		$thisfile_iso_supplementaryVD['volume_creation_date_time']      = $this-&gt;ISOtimeText2UNIXtime($thisfile_iso_supplementaryVD_raw['volume_creation_date_time']);
+		$thisfile_iso_supplementaryVD['volume_modification_date_time']  = $this-&gt;ISOtimeText2UNIXtime($thisfile_iso_supplementaryVD_raw['volume_modification_date_time']);
+		$thisfile_iso_supplementaryVD['volume_expiration_date_time']    = $this-&gt;ISOtimeText2UNIXtime($thisfile_iso_supplementaryVD_raw['volume_expiration_date_time']);
+		$thisfile_iso_supplementaryVD['volume_effective_date_time']     = $this-&gt;ISOtimeText2UNIXtime($thisfile_iso_supplementaryVD_raw['volume_effective_date_time']);
+
+		if (($thisfile_iso_supplementaryVD_raw['volume_space_size'] * $thisfile_iso_supplementaryVD_raw['logical_block_size']) &gt; $ThisFileInfo['filesize']) {
+			$ThisFileInfo['error'][] = 'Volume Space Size ('.($thisfile_iso_supplementaryVD_raw['volume_space_size'] * $thisfile_iso_supplementaryVD_raw['logical_block_size']).' bytes) is larger than the file size ('.$ThisFileInfo['filesize'].' bytes) (truncated file?)';
+		}
+
+		return true;
+	}
+
+
+	function ParsePathTable($fd, &amp;$ThisFileInfo) {
+		if (!isset($ThisFileInfo['iso']['supplementary_volume_descriptor']['raw']['path_table_l_location']) &amp;&amp; !isset($ThisFileInfo['iso']['primary_volume_descriptor']['raw']['path_table_l_location'])) {
+			return false;
+		}
+		if (isset($ThisFileInfo['iso']['supplementary_volume_descriptor']['raw']['path_table_l_location'])) {
+			$PathTableLocation = $ThisFileInfo['iso']['supplementary_volume_descriptor']['raw']['path_table_l_location'];
+			$PathTableSize     = $ThisFileInfo['iso']['supplementary_volume_descriptor']['raw']['path_table_size'];
+			$TextEncoding      = 'UTF-16BE'; // Big-Endian Unicode
+		} else {
+			$PathTableLocation = $ThisFileInfo['iso']['primary_volume_descriptor']['raw']['path_table_l_location'];
+			$PathTableSize     = $ThisFileInfo['iso']['primary_volume_descriptor']['raw']['path_table_size'];
+			$TextEncoding      = 'ISO-8859-1'; // Latin-1
+		}
+
+		if (($PathTableLocation * 2048) &gt; $ThisFileInfo['filesize']) {
+			$ThisFileInfo['error'][] = 'Path Table Location specifies an offset ('.($PathTableLocation * 2048).') beyond the end-of-file ('.$ThisFileInfo['filesize'].')';
+			return false;
+		}
+
+		$ThisFileInfo['iso']['path_table']['offset'] = $PathTableLocation * 2048;
+		fseek($fd, $ThisFileInfo['iso']['path_table']['offset'], SEEK_SET);
+		$ThisFileInfo['iso']['path_table']['raw'] = fread($fd, $PathTableSize);
+
+		$offset = 0;
+		$pathcounter = 1;
+		while ($offset &lt; $PathTableSize) {
+			// shortcut
+			$ThisFileInfo['iso']['path_table']['directories'][$pathcounter] = array();
+			$thisfile_iso_pathtable_directories_current = &amp;$ThisFileInfo['iso']['path_table']['directories'][$pathcounter];
+
+			$thisfile_iso_pathtable_directories_current['length']           = getid3_lib::LittleEndian2Int(substr($ThisFileInfo['iso']['path_table']['raw'], $offset, 1));
+			$offset += 1;
+			$thisfile_iso_pathtable_directories_current['extended_length']  = getid3_lib::LittleEndian2Int(substr($ThisFileInfo['iso']['path_table']['raw'], $offset, 1));
+			$offset += 1;
+			$thisfile_iso_pathtable_directories_current['location_logical'] = getid3_lib::LittleEndian2Int(substr($ThisFileInfo['iso']['path_table']['raw'], $offset, 4));
+			$offset += 4;
+			$thisfile_iso_pathtable_directories_current['parent_directory'] = getid3_lib::LittleEndian2Int(substr($ThisFileInfo['iso']['path_table']['raw'], $offset, 2));
+			$offset += 2;
+			$thisfile_iso_pathtable_directories_current['name']             =                  substr($ThisFileInfo['iso']['path_table']['raw'], $offset, $thisfile_iso_pathtable_directories_current['length']);
+			$offset += $thisfile_iso_pathtable_directories_current['length'] + ($thisfile_iso_pathtable_directories_current['length'] % 2);
+
+			$thisfile_iso_pathtable_directories_current['name_ascii']       = getid3_lib::iconv_fallback($TextEncoding, $ThisFileInfo['encoding'], $thisfile_iso_pathtable_directories_current['name']);
+
+			$thisfile_iso_pathtable_directories_current['location_bytes'] = $thisfile_iso_pathtable_directories_current['location_logical'] * 2048;
+			if ($pathcounter == 1) {
+				$thisfile_iso_pathtable_directories_current['full_path'] = '/';
+			} else {
+				$thisfile_iso_pathtable_directories_current['full_path'] = $ThisFileInfo['iso']['path_table']['directories'][$thisfile_iso_pathtable_directories_current['parent_directory']]['full_path'].$thisfile_iso_pathtable_directories_current['name_ascii'].'/';
+			}
+			$FullPathArray[] = $thisfile_iso_pathtable_directories_current['full_path'];
+
+			$pathcounter++;
+		}
+
+		return true;
+	}
+
+
+	function ParseDirectoryRecord(&amp;$fd, $directorydata, &amp;$ThisFileInfo) {
+		if (isset($ThisFileInfo['iso']['supplementary_volume_descriptor'])) {
+			$TextEncoding = 'UTF-16BE';   // Big-Endian Unicode
+		} else {
+			$TextEncoding = 'ISO-8859-1'; // Latin-1
+		}
+
+		fseek($fd, $directorydata['location_bytes'], SEEK_SET);
+		$DirectoryRecordData = fread($fd, 1);
+
+		while (ord($DirectoryRecordData{0}) &gt; 33) {
+
+			$DirectoryRecordData .= fread($fd, ord($DirectoryRecordData{0}) - 1);
+
+			$ThisDirectoryRecord['raw']['length']                    = getid3_lib::LittleEndian2Int(substr($DirectoryRecordData,  0, 1));
+			$ThisDirectoryRecord['raw']['extended_attribute_length'] = getid3_lib::LittleEndian2Int(substr($DirectoryRecordData,  1, 1));
+			$ThisDirectoryRecord['raw']['offset_logical']            = getid3_lib::LittleEndian2Int(substr($DirectoryRecordData,  2, 4));
+			$ThisDirectoryRecord['raw']['filesize']                  = getid3_lib::LittleEndian2Int(substr($DirectoryRecordData, 10, 4));
+			$ThisDirectoryRecord['raw']['recording_date_time']       =                  substr($DirectoryRecordData, 18, 7);
+			$ThisDirectoryRecord['raw']['file_flags']                = getid3_lib::LittleEndian2Int(substr($DirectoryRecordData, 25, 1));
+			$ThisDirectoryRecord['raw']['file_unit_size']            = getid3_lib::LittleEndian2Int(substr($DirectoryRecordData, 26, 1));
+			$ThisDirectoryRecord['raw']['interleave_gap_size']       = getid3_lib::LittleEndian2Int(substr($DirectoryRecordData, 27, 1));
+			$ThisDirectoryRecord['raw']['volume_sequence_number']    = getid3_lib::LittleEndian2Int(substr($DirectoryRecordData, 28, 2));
+			$ThisDirectoryRecord['raw']['file_identifier_length']    = getid3_lib::LittleEndian2Int(substr($DirectoryRecordData, 32, 1));
+			$ThisDirectoryRecord['raw']['file_identifier']           =                  substr($DirectoryRecordData, 33, $ThisDirectoryRecord['raw']['file_identifier_length']);
+
+			$ThisDirectoryRecord['file_identifier_ascii']            = getid3_lib::iconv_fallback($TextEncoding, $ThisFileInfo['encoding'], $ThisDirectoryRecord['raw']['file_identifier']);
+
+			$ThisDirectoryRecord['filesize']                  = $ThisDirectoryRecord['raw']['filesize'];
+			$ThisDirectoryRecord['offset_bytes']              = $ThisDirectoryRecord['raw']['offset_logical'] * 2048;
+			$ThisDirectoryRecord['file_flags']['hidden']      = (bool) ($ThisDirectoryRecord['raw']['file_flags'] &amp; 0x01);
+			$ThisDirectoryRecord['file_flags']['directory']   = (bool) ($ThisDirectoryRecord['raw']['file_flags'] &amp; 0x02);
+			$ThisDirectoryRecord['file_flags']['associated']  = (bool) ($ThisDirectoryRecord['raw']['file_flags'] &amp; 0x04);
+			$ThisDirectoryRecord['file_flags']['extended']    = (bool) ($ThisDirectoryRecord['raw']['file_flags'] &amp; 0x08);
+			$ThisDirectoryRecord['file_flags']['permissions'] = (bool) ($ThisDirectoryRecord['raw']['file_flags'] &amp; 0x10);
+			$ThisDirectoryRecord['file_flags']['multiple']    = (bool) ($ThisDirectoryRecord['raw']['file_flags'] &amp; 0x80);
+			$ThisDirectoryRecord['recording_timestamp']       = $this-&gt;ISOtime2UNIXtime($ThisDirectoryRecord['raw']['recording_date_time']);
+
+			if ($ThisDirectoryRecord['file_flags']['directory']) {
+				$ThisDirectoryRecord['filename'] = $directorydata['full_path'];
+			} else {
+				$ThisDirectoryRecord['filename'] = $directorydata['full_path'].$this-&gt;ISOstripFilenameVersion($ThisDirectoryRecord['file_identifier_ascii']);
+				$ThisFileInfo['iso']['files'] = getid3_lib::array_merge_clobber($ThisFileInfo['iso']['files'], getid3_lib::CreateDeepArray($ThisDirectoryRecord['filename'], '/', $ThisDirectoryRecord['filesize']));
+			}
+
+			$DirectoryRecord[] = $ThisDirectoryRecord;
+			$DirectoryRecordData = fread($fd, 1);
+		}
+
+		return $DirectoryRecord;
+	}
+
+	function ISOstripFilenameVersion($ISOfilename) {
+		// convert 'filename.ext;1' to 'filename.ext'
+		if (!strstr($ISOfilename, ';')) {
+			return $ISOfilename;
+		} else {
+			return substr($ISOfilename, 0, strpos($ISOfilename, ';'));
+		}
+	}
+
+	function ISOtimeText2UNIXtime($ISOtime) {
+
+		$UNIXyear   = (int) substr($ISOtime,  0, 4);
+		$UNIXmonth  = (int) substr($ISOtime,  4, 2);
+		$UNIXday    = (int) substr($ISOtime,  6, 2);
+		$UNIXhour   = (int) substr($ISOtime,  8, 2);
+		$UNIXminute = (int) substr($ISOtime, 10, 2);
+		$UNIXsecond = (int) substr($ISOtime, 12, 2);
+
+		if (!$UNIXyear) {
+			return false;
+		}
+		return mktime($UNIXhour, $UNIXminute, $UNIXsecond, $UNIXmonth, $UNIXday, $UNIXyear);
+	}
+
+	function ISOtime2UNIXtime($ISOtime) {
+		// Represented by seven bytes:
+		// 1: Number of years since 1900
+		// 2: Month of the year from 1 to 12
+		// 3: Day of the Month from 1 to 31
+		// 4: Hour of the day from 0 to 23
+		// 5: Minute of the hour from 0 to 59
+		// 6: second of the minute from 0 to 59
+		// 7: Offset from Greenwich Mean Time in number of 15 minute intervals from -48 (West) to +52 (East)
+
+		$UNIXyear   = ord($ISOtime{0}) + 1900;
+		$UNIXmonth  = ord($ISOtime{1});
+		$UNIXday    = ord($ISOtime{2});
+		$UNIXhour   = ord($ISOtime{3});
+		$UNIXminute = ord($ISOtime{4});
+		$UNIXsecond = ord($ISOtime{5});
+		$GMToffset  = $this-&gt;TwosCompliment2Decimal(ord($ISOtime{5}));
+
+		return mktime($UNIXhour, $UNIXminute, $UNIXsecond, $UNIXmonth, $UNIXday, $UNIXyear);
+	}
+
+	function TwosCompliment2Decimal($BinaryValue) {
+		// <A HREF="http://sandbox.mc.edu/~bennet/cs110/tc/tctod.html">http://sandbox.mc.edu/~bennet/cs110/tc/tctod.html</A>
+		// First check if the number is negative or positive by looking at the sign bit.
+		// If it is positive, simply convert it to decimal.
+		// If it is negative, make it positive by inverting the bits and adding one.
+		// Then, convert the result to decimal.
+		// The negative of this number is the value of the original binary.
+
+		if ($BinaryValue &amp; 0x80) {
+
+			// negative number
+			return (0 - ((~$BinaryValue &amp; 0xFF) + 1));
+		} else {
+			// positive number
+			return $BinaryValue;
+		}
+	}
+
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.apetag.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.apetag.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.apetag.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,284 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.tag.apetag.php                                       //
+// module for analyzing APE tags                               //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+class getid3_apetag
+{
+
+	function getid3_apetag(&amp;$fd, &amp;$ThisFileInfo, $overrideendoffset=0) {
+		$id3v1tagsize     = 128;
+		$apetagheadersize = 32;
+		$lyrics3tagsize   = 10;
+
+		if ($overrideendoffset == 0) {
+
+			fseek($fd, 0 - $id3v1tagsize - $apetagheadersize - $lyrics3tagsize, SEEK_END);
+			$APEfooterID3v1 = fread($fd, $id3v1tagsize + $apetagheadersize + $lyrics3tagsize);
+
+			//if (preg_match('/APETAGEX.{24}TAG.{125}$/i', $APEfooterID3v1)) {
+			if (substr($APEfooterID3v1, strlen($APEfooterID3v1) - $id3v1tagsize - $apetagheadersize, 8) == 'APETAGEX') {
+
+				// APE tag found before ID3v1
+				$ThisFileInfo['ape']['tag_offset_end'] = $ThisFileInfo['filesize'] - $id3v1tagsize;
+
+			//} elseif (preg_match('/APETAGEX.{24}$/i', $APEfooterID3v1)) {
+			} elseif (substr($APEfooterID3v1, strlen($APEfooterID3v1) - $apetagheadersize, 8) == 'APETAGEX') {
+
+				// APE tag found, no ID3v1
+				$ThisFileInfo['ape']['tag_offset_end'] = $ThisFileInfo['filesize'];
+
+			}
+
+		} else {
+
+			fseek($fd, $overrideendoffset - $apetagheadersize, SEEK_SET);
+			if (fread($fd, 8) == 'APETAGEX') {
+				$ThisFileInfo['ape']['tag_offset_end'] = $overrideendoffset;
+			}
+
+		}
+		if (!isset($ThisFileInfo['ape']['tag_offset_end'])) {
+
+			// APE tag not found
+			unset($ThisFileInfo['ape']);
+			return false;
+
+		}
+
+		// shortcut
+		$thisfile_ape = &amp;$ThisFileInfo['ape'];
+
+		fseek($fd, $thisfile_ape['tag_offset_end'] - $apetagheadersize, SEEK_SET);
+		$APEfooterData = fread($fd, 32);
+		if (!($thisfile_ape['footer'] = $this-&gt;parseAPEheaderFooter($APEfooterData))) {
+			$ThisFileInfo['error'][] = 'Error parsing APE footer at offset '.$thisfile_ape['tag_offset_end'];
+			return false;
+		}
+
+		if (isset($thisfile_ape['footer']['flags']['header']) &amp;&amp; $thisfile_ape['footer']['flags']['header']) {
+			fseek($fd, $thisfile_ape['tag_offset_end'] - $thisfile_ape['footer']['raw']['tagsize'] - $apetagheadersize, SEEK_SET);
+			$thisfile_ape['tag_offset_start'] = ftell($fd);
+			$APEtagData = fread($fd, $thisfile_ape['footer']['raw']['tagsize'] + $apetagheadersize);
+		} else {
+			$thisfile_ape['tag_offset_start'] = $thisfile_ape['tag_offset_end'] - $thisfile_ape['footer']['raw']['tagsize'];
+			fseek($fd, $thisfile_ape['tag_offset_start'], SEEK_SET);
+			$APEtagData = fread($fd, $thisfile_ape['footer']['raw']['tagsize']);
+		}
+		$ThisFileInfo['avdataend'] = $thisfile_ape['tag_offset_start'];
+
+		if (isset($ThisFileInfo['id3v1']['tag_offset_start']) &amp;&amp; ($ThisFileInfo['id3v1']['tag_offset_start'] &lt; $thisfile_ape['tag_offset_end'])) {
+			$ThisFileInfo['warning'][] = 'ID3v1 tag information ignored since it appears to be a false synch in APEtag data';
+			unset($ThisFileInfo['id3v1']);
+			foreach ($ThisFileInfo['warning'] as $key =&gt; $value) {
+				if ($value == 'Some ID3v1 fields do not use NULL characters for padding') {
+					unset($ThisFileInfo['warning'][$key]);
+					sort($ThisFileInfo['warning']);
+					break;
+				}
+			}
+		}
+
+		$offset = 0;
+		if (isset($thisfile_ape['footer']['flags']['header']) &amp;&amp; $thisfile_ape['footer']['flags']['header']) {
+			if ($thisfile_ape['header'] = $this-&gt;parseAPEheaderFooter(substr($APEtagData, 0, $apetagheadersize))) {
+				$offset += $apetagheadersize;
+			} else {
+				$ThisFileInfo['error'][] = 'Error parsing APE header at offset '.$thisfile_ape['tag_offset_start'];
+				return false;
+			}
+		}
+
+		// shortcut
+		$ThisFileInfo['replay_gain'] = array();
+		$thisfile_replaygain = &amp;$ThisFileInfo['replay_gain'];
+		
+		for ($i = 0; $i &lt; $thisfile_ape['footer']['raw']['tag_items']; $i++) {
+			$value_size = getid3_lib::LittleEndian2Int(substr($APEtagData, $offset, 4));
+			$offset += 4;
+			$item_flags = getid3_lib::LittleEndian2Int(substr($APEtagData, $offset, 4));
+			$offset += 4;
+			if (strstr(substr($APEtagData, $offset), &quot;\x00&quot;) === false) {
+				$ThisFileInfo['error'][] = 'Cannot find null-byte (0x00) seperator between ItemKey #'.$i.' and value. ItemKey starts '.$offset.' bytes into the APE tag, at file offset '.($thisfile_ape['tag_offset_start'] + $offset);
+				return false;
+			}
+			$ItemKeyLength = strpos($APEtagData, &quot;\x00&quot;, $offset) - $offset;
+			$item_key      = strtolower(substr($APEtagData, $offset, $ItemKeyLength));
+
+			// shortcut
+			$thisfile_ape['items'][$item_key] = array();
+			$thisfile_ape_items_current = &amp;$thisfile_ape['items'][$item_key];
+
+			$offset += ($ItemKeyLength + 1); // skip 0x00 terminator
+			$thisfile_ape_items_current['data'] = substr($APEtagData, $offset, $value_size);
+			$offset += $value_size;
+
+			$thisfile_ape_items_current['flags'] = $this-&gt;parseAPEtagFlags($item_flags);
+			switch ($thisfile_ape_items_current['flags']['item_contents_raw']) {
+				case 0: // UTF-8
+				case 3: // Locator (URL, filename, etc), UTF-8 encoded
+					$thisfile_ape_items_current['data'] = explode(&quot;\x00&quot;, trim($thisfile_ape_items_current['data']));
+					break;
+
+				default: // binary data
+					break;
+			}
+
+			switch (strtolower($item_key)) {
+				case 'replaygain_track_gain':
+					$thisfile_replaygain['track']['adjustment'] = (float) str_replace(',', '.', $thisfile_ape_items_current['data'][0]); // float casting will see &quot;0,95&quot; as zero!
+					$thisfile_replaygain['track']['originator'] = 'unspecified';
+					break;
+
+				case 'replaygain_track_peak':
+					$thisfile_replaygain['track']['peak']       = (float) str_replace(',', '.', $thisfile_ape_items_current['data'][0]); // float casting will see &quot;0,95&quot; as zero!
+					$thisfile_replaygain['track']['originator'] = 'unspecified';
+					if ($thisfile_replaygain['track']['peak'] &lt;= 0) {
+						$ThisFileInfo['warning'][] = 'ReplayGain Track peak from APEtag appears invalid: '.$thisfile_replaygain['track']['peak'].' (original value = &quot;'.$thisfile_ape_items_current['data'][0].'&quot;)';
+					}
+					break;
+
+				case 'replaygain_album_gain':
+					$thisfile_replaygain['album']['adjustment'] = (float) str_replace(',', '.', $thisfile_ape_items_current['data'][0]); // float casting will see &quot;0,95&quot; as zero!
+					$thisfile_replaygain['album']['originator'] = 'unspecified';
+					break;
+
+				case 'replaygain_album_peak':
+					$thisfile_replaygain['album']['peak']       = (float) str_replace(',', '.', $thisfile_ape_items_current['data'][0]); // float casting will see &quot;0,95&quot; as zero!
+					$thisfile_replaygain['album']['originator'] = 'unspecified';
+					if ($thisfile_replaygain['album']['peak'] &lt;= 0) {
+						$ThisFileInfo['warning'][] = 'ReplayGain Album peak from APEtag appears invalid: '.$thisfile_replaygain['album']['peak'].' (original value = &quot;'.$thisfile_ape_items_current['data'][0].'&quot;)';
+					}
+					break;
+
+				case 'mp3gain_undo':
+					list($mp3gain_undo_left, $mp3gain_undo_right, $mp3gain_undo_wrap) = explode(',', $thisfile_ape_items_current['data'][0]);
+					$thisfile_replaygain['mp3gain']['undo_left']  = intval($mp3gain_undo_left);
+					$thisfile_replaygain['mp3gain']['undo_right'] = intval($mp3gain_undo_right);
+					$thisfile_replaygain['mp3gain']['undo_wrap']  = (($mp3gain_undo_wrap == 'Y') ? true : false);
+					break;
+
+				case 'mp3gain_minmax':
+					list($mp3gain_globalgain_min, $mp3gain_globalgain_max) = explode(',', $thisfile_ape_items_current['data'][0]);
+					$thisfile_replaygain['mp3gain']['globalgain_track_min'] = intval($mp3gain_globalgain_min);
+					$thisfile_replaygain['mp3gain']['globalgain_track_max'] = intval($mp3gain_globalgain_max);
+					break;
+
+				case 'mp3gain_album_minmax':
+					list($mp3gain_globalgain_album_min, $mp3gain_globalgain_album_max) = explode(',', $thisfile_ape_items_current['data'][0]);
+					$thisfile_replaygain['mp3gain']['globalgain_album_min'] = intval($mp3gain_globalgain_album_min);
+					$thisfile_replaygain['mp3gain']['globalgain_album_max'] = intval($mp3gain_globalgain_album_max);
+					break;
+
+				case 'tracknumber':
+					foreach ($thisfile_ape_items_current['data'] as $comment) {
+						$thisfile_ape['comments']['track'][] = $comment;
+					}
+					break;
+
+				default:
+					foreach ($thisfile_ape_items_current['data'] as $comment) {
+						$thisfile_ape['comments'][strtolower($item_key)][] = $comment;
+					}
+					break;
+			}
+
+		}
+		if (empty($thisfile_replaygain)) {
+			unset($ThisFileInfo['replay_gain']);
+		}
+
+		return true;
+	}
+
+	function parseAPEheaderFooter($APEheaderFooterData) {
+		// <A HREF="http://www.uni-jena.de/~pfk/mpp/sv8/apeheader.html">http://www.uni-jena.de/~pfk/mpp/sv8/apeheader.html</A>
+
+		// shortcut
+		$headerfooterinfo['raw'] = array();
+		$headerfooterinfo_raw = &amp;$headerfooterinfo['raw'];
+
+		$headerfooterinfo_raw['footer_tag']   =                  substr($APEheaderFooterData,  0, 8);
+		if ($headerfooterinfo_raw['footer_tag'] != 'APETAGEX') {
+			return false;
+		}
+		$headerfooterinfo_raw['version']      = getid3_lib::LittleEndian2Int(substr($APEheaderFooterData,  8, 4));
+		$headerfooterinfo_raw['tagsize']      = getid3_lib::LittleEndian2Int(substr($APEheaderFooterData, 12, 4));
+		$headerfooterinfo_raw['tag_items']    = getid3_lib::LittleEndian2Int(substr($APEheaderFooterData, 16, 4));
+		$headerfooterinfo_raw['global_flags'] = getid3_lib::LittleEndian2Int(substr($APEheaderFooterData, 20, 4));
+		$headerfooterinfo_raw['reserved']     =                              substr($APEheaderFooterData, 24, 8);
+
+		$headerfooterinfo['tag_version']         = $headerfooterinfo_raw['version'] / 1000;
+		if ($headerfooterinfo['tag_version'] &gt;= 2) {
+			$headerfooterinfo['flags'] = $this-&gt;parseAPEtagFlags($headerfooterinfo_raw['global_flags']);
+		}
+		return $headerfooterinfo;
+	}
+
+	function parseAPEtagFlags($rawflagint) {
+		// &quot;Note: APE Tags 1.0 do not use any of the APE Tag flags.
+		// All are set to zero on creation and ignored on reading.&quot;
+		// <A HREF="http://www.uni-jena.de/~pfk/mpp/sv8/apetagflags.html">http://www.uni-jena.de/~pfk/mpp/sv8/apetagflags.html</A>
+		$flags['header']            = (bool) ($rawflagint &amp; 0x80000000);
+		$flags['footer']            = (bool) ($rawflagint &amp; 0x40000000);
+		$flags['this_is_header']    = (bool) ($rawflagint &amp; 0x20000000);
+		$flags['item_contents_raw'] =        ($rawflagint &amp; 0x00000006) &gt;&gt; 1;
+		$flags['read_only']         = (bool) ($rawflagint &amp; 0x00000001);
+
+		$flags['item_contents']     = $this-&gt;APEcontentTypeFlagLookup($flags['item_contents_raw']);
+
+		return $flags;
+	}
+
+	function APEcontentTypeFlagLookup($contenttypeid) {
+		static $APEcontentTypeFlagLookup = array(
+			0 =&gt; 'utf-8',
+			1 =&gt; 'binary',
+			2 =&gt; 'external',
+			3 =&gt; 'reserved'
+		);
+		return (isset($APEcontentTypeFlagLookup[$contenttypeid]) ? $APEcontentTypeFlagLookup[$contenttypeid] : 'invalid');
+	}
+
+	function APEtagItemIsUTF8Lookup($itemkey) {
+		static $APEtagItemIsUTF8Lookup = array(
+			'title',
+			'subtitle',
+			'artist',
+			'album',
+			'debut album',
+			'publisher',
+			'conductor',
+			'track',
+			'composer',
+			'comment',
+			'copyright',
+			'publicationright',
+			'file',
+			'year',
+			'record date',
+			'record location',
+			'genre',
+			'media',
+			'related',
+			'isrc',
+			'abstract',
+			'language',
+			'bibliography'
+		);
+		return in_array(strtolower($itemkey), $APEtagItemIsUTF8Lookup);
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.id3v1.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.id3v1.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.id3v1.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,356 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// module.tag.id3v1.php                                        //
+// module for analyzing ID3v1 tags                             //
+// dependencies: NONE                                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_id3v1
+{
+
+	function getid3_id3v1(&amp;$fd, &amp;$ThisFileInfo) {
+
+		fseek($fd, -256, SEEK_END);
+		$preid3v1 = fread($fd, 128);
+		$id3v1tag = fread($fd, 128);
+
+		if (substr($id3v1tag, 0, 3) == 'TAG') {
+
+			$ThisFileInfo['avdataend'] = $ThisFileInfo['filesize'] - 128;
+
+			$ParsedID3v1['title']   = $this-&gt;cutfield(substr($id3v1tag,   3, 30));
+			$ParsedID3v1['artist']  = $this-&gt;cutfield(substr($id3v1tag,  33, 30));
+			$ParsedID3v1['album']   = $this-&gt;cutfield(substr($id3v1tag,  63, 30));
+			$ParsedID3v1['year']    = $this-&gt;cutfield(substr($id3v1tag,  93,  4));
+			$ParsedID3v1['comment'] =                 substr($id3v1tag,  97, 30);  // can't remove nulls yet, track detection depends on them
+			$ParsedID3v1['genreid'] =             ord(substr($id3v1tag, 127,  1));
+
+			// If second-last byte of comment field is null and last byte of comment field is non-null
+			// then this is ID3v1.1 and the comment field is 28 bytes long and the 30th byte is the track number
+			if (($id3v1tag{125} === &quot;\x00&quot;) &amp;&amp; ($id3v1tag{126} !== &quot;\x00&quot;)) {
+				$ParsedID3v1['track']   = ord(substr($ParsedID3v1['comment'], 29,  1));
+				$ParsedID3v1['comment'] =     substr($ParsedID3v1['comment'],  0, 28);
+			}
+			$ParsedID3v1['comment'] = $this-&gt;cutfield($ParsedID3v1['comment']);
+
+			$ParsedID3v1['genre'] = $this-&gt;LookupGenreName($ParsedID3v1['genreid']);
+			if (!empty($ParsedID3v1['genre'])) {
+				unset($ParsedID3v1['genreid']);
+			}
+			if (empty($ParsedID3v1['genre']) || (@$ParsedID3v1['genre'] == 'Unknown')) {
+				unset($ParsedID3v1['genre']);
+			}
+
+			foreach ($ParsedID3v1 as $key =&gt; $value) {
+				$ParsedID3v1['comments'][$key][0] = $value;
+			}
+
+			// ID3v1 data is supposed to be padded with NULL characters, but some taggers pad with spaces
+			$GoodFormatID3v1tag = $this-&gt;GenerateID3v1Tag(
+											$ParsedID3v1['title'],
+											$ParsedID3v1['artist'],
+											$ParsedID3v1['album'],
+											$ParsedID3v1['year'],
+											$this-&gt;LookupGenreID(@$ParsedID3v1['genre']),
+											$ParsedID3v1['comment'],
+											@$ParsedID3v1['track']);
+			$ParsedID3v1['padding_valid'] = true;
+			if ($id3v1tag !== $GoodFormatID3v1tag) {
+				$ParsedID3v1['padding_valid'] = false;
+				$ThisFileInfo['warning'][] = 'Some ID3v1 fields do not use NULL characters for padding';
+			}
+
+			$ParsedID3v1['tag_offset_end']   = $ThisFileInfo['filesize'];
+			$ParsedID3v1['tag_offset_start'] = $ParsedID3v1['tag_offset_end'] - 128;
+
+			$ThisFileInfo['id3v1'] = $ParsedID3v1;
+		}
+
+		if (substr($preid3v1, 0, 3) == 'TAG') {
+			// The way iTunes handles tags is, well, brain-damaged.
+			// It completely ignores v1 if ID3v2 is present.
+			// This goes as far as adding a new v1 tag *even if there already is one*
+
+			// A suspected double-ID3v1 tag has been detected, but it could be that
+			// the &quot;TAG&quot; identifier is a legitimate part of an APE or Lyrics3 tag
+			if (substr($preid3v1, 96, 8) == 'APETAGEX') {
+				// an APE tag footer was found before the last ID3v1, assume false &quot;TAG&quot; synch
+			} elseif (substr($preid3v1, 119, 6) == 'LYRICS') {
+				// a Lyrics3 tag footer was found before the last ID3v1, assume false &quot;TAG&quot; synch
+			} else {
+				// APE and Lyrics3 footers not found - assume double ID3v1
+				$ThisFileInfo['warning'][] = 'Duplicate ID3v1 tag detected - this has been known to happen with iTunes';
+				$ThisFileInfo['avdataend'] -= 128;
+			}
+		}
+
+		return true;
+	}
+
+	function cutfield($str) {
+		return trim(substr($str, 0, strcspn($str, &quot;\x00&quot;)));
+	}
+
+	function ArrayOfGenres($allowSCMPXextended=false) {
+		static $GenreLookup = array(
+			0    =&gt; 'Blues',
+			1    =&gt; 'Classic Rock',
+			2    =&gt; 'Country',
+			3    =&gt; 'Dance',
+			4    =&gt; 'Disco',
+			5    =&gt; 'Funk',
+			6    =&gt; 'Grunge',
+			7    =&gt; 'Hip-Hop',
+			8    =&gt; 'Jazz',
+			9    =&gt; 'Metal',
+			10   =&gt; 'New Age',
+			11   =&gt; 'Oldies',
+			12   =&gt; 'Other',
+			13   =&gt; 'Pop',
+			14   =&gt; 'R&amp;B',
+			15   =&gt; 'Rap',
+			16   =&gt; 'Reggae',
+			17   =&gt; 'Rock',
+			18   =&gt; 'Techno',
+			19   =&gt; 'Industrial',
+			20   =&gt; 'Alternative',
+			21   =&gt; 'Ska',
+			22   =&gt; 'Death Metal',
+			23   =&gt; 'Pranks',
+			24   =&gt; 'Soundtrack',
+			25   =&gt; 'Euro-Techno',
+			26   =&gt; 'Ambient',
+			27   =&gt; 'Trip-Hop',
+			28   =&gt; 'Vocal',
+			29   =&gt; 'Jazz+Funk',
+			30   =&gt; 'Fusion',
+			31   =&gt; 'Trance',
+			32   =&gt; 'Classical',
+			33   =&gt; 'Instrumental',
+			34   =&gt; 'Acid',
+			35   =&gt; 'House',
+			36   =&gt; 'Game',
+			37   =&gt; 'Sound Clip',
+			38   =&gt; 'Gospel',
+			39   =&gt; 'Noise',
+			40   =&gt; 'Alt. Rock',
+			41   =&gt; 'Bass',
+			42   =&gt; 'Soul',
+			43   =&gt; 'Punk',
+			44   =&gt; 'Space',
+			45   =&gt; 'Meditative',
+			46   =&gt; 'Instrumental Pop',
+			47   =&gt; 'Instrumental Rock',
+			48   =&gt; 'Ethnic',
+			49   =&gt; 'Gothic',
+			50   =&gt; 'Darkwave',
+			51   =&gt; 'Techno-Industrial',
+			52   =&gt; 'Electronic',
+			53   =&gt; 'Pop-Folk',
+			54   =&gt; 'Eurodance',
+			55   =&gt; 'Dream',
+			56   =&gt; 'Southern Rock',
+			57   =&gt; 'Comedy',
+			58   =&gt; 'Cult',
+			59   =&gt; 'Gangsta Rap',
+			60   =&gt; 'Top 40',
+			61   =&gt; 'Christian Rap',
+			62   =&gt; 'Pop/Funk',
+			63   =&gt; 'Jungle',
+			64   =&gt; 'Native American',
+			65   =&gt; 'Cabaret',
+			66   =&gt; 'New Wave',
+			67   =&gt; 'Psychedelic',
+			68   =&gt; 'Rave',
+			69   =&gt; 'Showtunes',
+			70   =&gt; 'Trailer',
+			71   =&gt; 'Lo-Fi',
+			72   =&gt; 'Tribal',
+			73   =&gt; 'Acid Punk',
+			74   =&gt; 'Acid Jazz',
+			75   =&gt; 'Polka',
+			76   =&gt; 'Retro',
+			77   =&gt; 'Musical',
+			78   =&gt; 'Rock &amp; Roll',
+			79   =&gt; 'Hard Rock',
+			80   =&gt; 'Folk',
+			81   =&gt; 'Folk/Rock',
+			82   =&gt; 'National Folk',
+			83   =&gt; 'Swing',
+			84   =&gt; 'Fast-Fusion',
+			85   =&gt; 'Bebob',
+			86   =&gt; 'Latin',
+			87   =&gt; 'Revival',
+			88   =&gt; 'Celtic',
+			89   =&gt; 'Bluegrass',
+			90   =&gt; 'Avantgarde',
+			91   =&gt; 'Gothic Rock',
+			92   =&gt; 'Progressive Rock',
+			93   =&gt; 'Psychedelic Rock',
+			94   =&gt; 'Symphonic Rock',
+			95   =&gt; 'Slow Rock',
+			96   =&gt; 'Big Band',
+			97   =&gt; 'Chorus',
+			98   =&gt; 'Easy Listening',
+			99   =&gt; 'Acoustic',
+			100  =&gt; 'Humour',
+			101  =&gt; 'Speech',
+			102  =&gt; 'Chanson',
+			103  =&gt; 'Opera',
+			104  =&gt; 'Chamber Music',
+			105  =&gt; 'Sonata',
+			106  =&gt; 'Symphony',
+			107  =&gt; 'Booty Bass',
+			108  =&gt; 'Primus',
+			109  =&gt; 'Porn Groove',
+			110  =&gt; 'Satire',
+			111  =&gt; 'Slow Jam',
+			112  =&gt; 'Club',
+			113  =&gt; 'Tango',
+			114  =&gt; 'Samba',
+			115  =&gt; 'Folklore',
+			116  =&gt; 'Ballad',
+			117  =&gt; 'Power Ballad',
+			118  =&gt; 'Rhythmic Soul',
+			119  =&gt; 'Freestyle',
+			120  =&gt; 'Duet',
+			121  =&gt; 'Punk Rock',
+			122  =&gt; 'Drum Solo',
+			123  =&gt; 'A Cappella',
+			124  =&gt; 'Euro-House',
+			125  =&gt; 'Dance Hall',
+			126  =&gt; 'Goa',
+			127  =&gt; 'Drum &amp; Bass',
+			128  =&gt; 'Club-House',
+			129  =&gt; 'Hardcore',
+			130  =&gt; 'Terror',
+			131  =&gt; 'Indie',
+			132  =&gt; 'BritPop',
+			133  =&gt; 'Negerpunk',
+			134  =&gt; 'Polsk Punk',
+			135  =&gt; 'Beat',
+			136  =&gt; 'Christian Gangsta Rap',
+			137  =&gt; 'Heavy Metal',
+			138  =&gt; 'Black Metal',
+			139  =&gt; 'Crossover',
+			140  =&gt; 'Contemporary Christian',
+			141  =&gt; 'Christian Rock',
+			142  =&gt; 'Merengue',
+			143  =&gt; 'Salsa',
+			144  =&gt; 'Trash Metal',
+			145  =&gt; 'Anime',
+			146  =&gt; 'JPop',
+			147  =&gt; 'Synthpop',
+
+			255  =&gt; 'Unknown',
+
+			'CR' =&gt; 'Cover',
+			'RX' =&gt; 'Remix'
+		);
+
+		static $GenreLookupSCMPX = array();
+		if ($allowSCMPXextended &amp;&amp; empty($GenreLookupSCMPX)) {
+			$GenreLookupSCMPX = $GenreLookup;
+			// <A HREF="http://www.geocities.co.jp/SiliconValley-Oakland/3664/alittle.html#GenreExtended">http://www.geocities.co.jp/SiliconValley-Oakland/3664/alittle.html#GenreExtended</A>
+			// Extended ID3v1 genres invented by SCMPX
+			// Note that 255 &quot;Japanese Anime&quot; conflicts with standard &quot;Unknown&quot;
+			$GenreLookupSCMPX[240] = 'Sacred';
+			$GenreLookupSCMPX[241] = 'Northern Europe';
+			$GenreLookupSCMPX[242] = 'Irish &amp; Scottish';
+			$GenreLookupSCMPX[243] = 'Scotland';
+			$GenreLookupSCMPX[244] = 'Ethnic Europe';
+			$GenreLookupSCMPX[245] = 'Enka';
+			$GenreLookupSCMPX[246] = 'Children\'s Song';
+			$GenreLookupSCMPX[247] = 'Japanese Sky';
+			$GenreLookupSCMPX[248] = 'Japanese Heavy Rock';
+			$GenreLookupSCMPX[249] = 'Japanese Doom Rock';
+			$GenreLookupSCMPX[250] = 'Japanese J-POP';
+			$GenreLookupSCMPX[251] = 'Japanese Seiyu';
+			$GenreLookupSCMPX[252] = 'Japanese Ambient Techno';
+			$GenreLookupSCMPX[253] = 'Japanese Moemoe';
+			$GenreLookupSCMPX[254] = 'Japanese Tokusatsu';
+			//$GenreLookupSCMPX[255] = 'Japanese Anime';
+		}
+
+		return ($allowSCMPXextended ? $GenreLookupSCMPX : $GenreLookup);
+	}
+
+	function LookupGenreName($genreid, $allowSCMPXextended=true) {
+		switch ($genreid) {
+			case 'RX':
+			case 'CR':
+				break;
+			default:
+				$genreid = intval($genreid); // to handle 3 or '3' or '03'
+				break;
+		}
+		$GenreLookup = getid3_id3v1::ArrayOfGenres($allowSCMPXextended);
+		return (isset($GenreLookup[$genreid]) ? $GenreLookup[$genreid] : false);
+	}
+
+	function LookupGenreID($genre, $allowSCMPXextended=false) {
+		$GenreLookup = getid3_id3v1::ArrayOfGenres($allowSCMPXextended);
+		$LowerCaseNoSpaceSearchTerm = strtolower(str_replace(' ', '', $genre));
+		foreach ($GenreLookup as $key =&gt; $value) {
+			foreach ($GenreLookup as $key =&gt; $value) {
+				if (strtolower(str_replace(' ', '', $value)) == $LowerCaseNoSpaceSearchTerm) {
+					return $key;
+				}
+			}
+			return false;
+		}
+		return (isset($GenreLookup[$genreid]) ? $GenreLookup[$genreid] : false);
+	}
+
+	function StandardiseID3v1GenreName($OriginalGenre) {
+		if (($GenreID = getid3_id3v1::LookupGenreID($OriginalGenre)) !== false) {
+			return getid3_id3v1::LookupGenreName($GenreID);
+		}
+		return $OriginalGenre;
+	}
+
+	function GenerateID3v1Tag($title, $artist, $album, $year, $genreid, $comment, $track='') {
+		$ID3v1Tag  = 'TAG';
+		$ID3v1Tag .= str_pad(trim(substr($title,  0, 30)), 30, &quot;\x00&quot;, STR_PAD_RIGHT);
+		$ID3v1Tag .= str_pad(trim(substr($artist, 0, 30)), 30, &quot;\x00&quot;, STR_PAD_RIGHT);
+		$ID3v1Tag .= str_pad(trim(substr($album,  0, 30)), 30, &quot;\x00&quot;, STR_PAD_RIGHT);
+		$ID3v1Tag .= str_pad(trim(substr($year,   0,  4)),  4, &quot;\x00&quot;, STR_PAD_LEFT);
+		if (!empty($track) &amp;&amp; ($track &gt; 0) &amp;&amp; ($track &lt;= 255)) {
+			$ID3v1Tag .= str_pad(trim(substr($comment, 0, 28)), 28, &quot;\x00&quot;, STR_PAD_RIGHT);
+			$ID3v1Tag .= &quot;\x00&quot;;
+			if (gettype($track) == 'string') {
+				$track = (int) $track;
+			}
+			$ID3v1Tag .= chr($track);
+		} else {
+			$ID3v1Tag .= str_pad(trim(substr($comment, 0, 30)), 30, &quot;\x00&quot;, STR_PAD_RIGHT);
+		}
+		if (($genreid &lt; 0) || ($genreid &gt; 147)) {
+			$genreid = 255; // 'unknown' genre
+		}
+		switch (gettype($genreid)) {
+			case 'string':
+			case 'integer':
+				$ID3v1Tag .= chr(intval($genreid));
+				break;
+			default:
+				$ID3v1Tag .= chr(255); // 'unknown' genre
+				break;
+		}
+
+		return $ID3v1Tag;
+	}
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.id3v2.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.id3v2.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.id3v2.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,3044 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+///                                                            //
+// module.tag.id3v2.php                                        //
+// module for analyzing ID3v2 tags                             //
+// dependencies: module.tag.id3v1.php                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v1.php', __FILE__, true);
+
+class getid3_id3v2
+{
+
+	function getid3_id3v2(&amp;$fd, &amp;$ThisFileInfo, $StartingOffset=0) {
+		//    Overall tag structure:
+		//        +-----------------------------+
+		//        |      Header (10 bytes)      |
+		//        +-----------------------------+
+		//        |       Extended Header       |
+		//        | (variable length, OPTIONAL) |
+		//        +-----------------------------+
+		//        |   Frames (variable length)  |
+		//        +-----------------------------+
+		//        |           Padding           |
+		//        | (variable length, OPTIONAL) |
+		//        +-----------------------------+
+		//        | Footer (10 bytes, OPTIONAL) |
+		//        +-----------------------------+
+
+		//    Header
+		//        ID3v2/file identifier      &quot;ID3&quot;
+		//        ID3v2 version              $04 00
+		//        ID3v2 flags                (%ab000000 in v2.2, %abc00000 in v2.3, %abcd0000 in v2.4.x)
+		//        ID3v2 size             4 * %0xxxxxxx
+
+
+		// shortcuts
+		$ThisFileInfo['id3v2']['header'] = true;
+		$thisfile_id3v2                  = &amp;$ThisFileInfo['id3v2'];
+		$thisfile_id3v2['flags']         =  array();
+		$thisfile_id3v2_flags            = &amp;$thisfile_id3v2['flags'];
+
+
+		fseek($fd, $StartingOffset, SEEK_SET);
+		$header = fread($fd, 10);
+		if (substr($header, 0, 3) == 'ID3') {
+
+			$thisfile_id3v2['majorversion'] = ord($header{3});
+			$thisfile_id3v2['minorversion'] = ord($header{4});
+
+			// shortcut
+			$id3v2_majorversion = &amp;$thisfile_id3v2['majorversion'];
+
+		} else {
+
+			unset($ThisFileInfo['id3v2']);
+			return false;
+
+		}
+
+		if ($id3v2_majorversion &gt; 4) { // this script probably won't correctly parse ID3v2.5.x and above (if it ever exists)
+
+			$ThisFileInfo['error'][] = 'this script only parses up to ID3v2.4.x - this tag is ID3v2.'.$id3v2_majorversion.'.'.$thisfile_id3v2['minorversion'];
+			return false;
+
+		}
+
+		$id3_flags = ord($header{5});
+		switch ($id3v2_majorversion) {
+			case 2:
+				// %ab000000 in v2.2
+				$thisfile_id3v2_flags['unsynch']     = (bool) ($id3_flags &amp; 0x80); // a - Unsynchronisation
+				$thisfile_id3v2_flags['compression'] = (bool) ($id3_flags &amp; 0x40); // b - Compression
+				break;
+
+			case 3:
+				// %abc00000 in v2.3
+				$thisfile_id3v2_flags['unsynch']     = (bool) ($id3_flags &amp; 0x80); // a - Unsynchronisation
+				$thisfile_id3v2_flags['exthead']     = (bool) ($id3_flags &amp; 0x40); // b - Extended header
+				$thisfile_id3v2_flags['experim']     = (bool) ($id3_flags &amp; 0x20); // c - Experimental indicator
+				break;
+
+			case 4:
+				// %abcd0000 in v2.4
+				$thisfile_id3v2_flags['unsynch']     = (bool) ($id3_flags &amp; 0x80); // a - Unsynchronisation
+				$thisfile_id3v2_flags['exthead']     = (bool) ($id3_flags &amp; 0x40); // b - Extended header
+				$thisfile_id3v2_flags['experim']     = (bool) ($id3_flags &amp; 0x20); // c - Experimental indicator
+				$thisfile_id3v2_flags['isfooter']    = (bool) ($id3_flags &amp; 0x10); // d - Footer present
+				break;
+		}
+
+		$thisfile_id3v2['headerlength'] = getid3_lib::BigEndian2Int(substr($header, 6, 4), 1) + 10; // length of ID3v2 tag in 10-byte header doesn't include 10-byte header length
+
+		$thisfile_id3v2['tag_offset_start'] = $StartingOffset;
+		$thisfile_id3v2['tag_offset_end']   = $thisfile_id3v2['tag_offset_start'] + $thisfile_id3v2['headerlength'];
+
+		//    Extended Header
+		if (isset($thisfile_id3v2_flags['exthead']) &amp;&amp; $thisfile_id3v2_flags['exthead']) {
+			// Extended header size   4 * %0xxxxxxx
+			// Number of flag bytes       $01
+			// Extended Flags             $xx
+			// Where the 'Extended header size' is the size of the whole extended header, stored as a 32 bit synchsafe integer.
+			$thisfile_id3v2['exthead_length'] = getid3_lib::BigEndian2Int(fread($fd, 4), 1);
+
+			$thisfile_id3v2['exthead_flag_bytes'] = ord(fread($fd, 1));
+			if ($thisfile_id3v2['exthead_flag_bytes'] == 1) {
+				// The extended flags field, with its size described by 'number of flag  bytes', is defined as:
+				//     %0bcd0000
+				// b - Tag is an update
+				//     Flag data length       $00
+				// c - CRC data present
+				//     Flag data length       $05
+				//     Total frame CRC    5 * %0xxxxxxx
+				// d - Tag restrictions
+				//     Flag data length       $01
+				$extheaderflags    = fread($fd, $thisfile_id3v2['exthead_flag_bytes']);
+				$id3_exthead_flags = getid3_lib::BigEndian2Bin(substr($header, 5, 1));
+				$thisfile_id3v2['exthead_flags']['update']       = substr($id3_exthead_flags, 1, 1);
+				$thisfile_id3v2['exthead_flags']['CRC']          = substr($id3_exthead_flags, 2, 1);
+				if ($thisfile_id3v2['exthead_flags']['CRC']) {
+					$extheaderrawCRC = fread($fd, 5);
+					$thisfile_id3v2['exthead_flags']['CRC'] = getid3_lib::BigEndian2Int($extheaderrawCRC, 1);
+				}
+				$thisfile_id3v2['exthead_flags']['restrictions'] = substr($id3_exthead_flags, 3, 1);
+				if ($thisfile_id3v2['exthead_flags']['restrictions']) {
+					// Restrictions           %ppqrrstt
+					$extheaderrawrestrictions = fread($fd, 1);
+					$thisfile_id3v2['exthead_flags']['restrictions_tagsize']  = (bindec('11000000') &amp; ord($extheaderrawrestrictions)) &gt;&gt; 6; // p - Tag size restrictions
+					$thisfile_id3v2['exthead_flags']['restrictions_textenc']  = (bindec('00100000') &amp; ord($extheaderrawrestrictions)) &gt;&gt; 5; // q - Text encoding restrictions
+					$thisfile_id3v2['exthead_flags']['restrictions_textsize'] = (bindec('00011000') &amp; ord($extheaderrawrestrictions)) &gt;&gt; 3; // r - Text fields size restrictions
+					$thisfile_id3v2['exthead_flags']['restrictions_imgenc']   = (bindec('00000100') &amp; ord($extheaderrawrestrictions)) &gt;&gt; 2; // s - Image encoding restrictions
+					$thisfile_id3v2['exthead_flags']['restrictions_imgsize']  = (bindec('00000011') &amp; ord($extheaderrawrestrictions)) &gt;&gt; 0; // t - Image size restrictions
+				}
+			} else {
+				$ThisFileInfo['warning'][] = '$thisfile_id3v2[exthead_flag_bytes] = &quot;'.$thisfile_id3v2['exthead_flag_bytes'].'&quot; (expecting &quot;1&quot;)';
+				fseek($fd, $thisfile_id3v2['exthead_length'] - 1, SEEK_CUR);
+				//return false;
+			}
+		} // end extended header
+
+
+		// create 'encoding' key - used by getid3::HandleAllTags()
+		// in ID3v2 every field can have it's own encoding type
+		// so force everything to UTF-8 so it can be handled consistantly
+		$thisfile_id3v2['encoding'] = 'UTF-8';
+
+
+	//    Frames
+
+	//        All ID3v2 frames consists of one frame header followed by one or more
+	//        fields containing the actual information. The header is always 10
+	//        bytes and laid out as follows:
+	//
+	//        Frame ID      $xx xx xx xx  (four characters)
+	//        Size      4 * %0xxxxxxx
+	//        Flags         $xx xx
+
+		$sizeofframes = $thisfile_id3v2['headerlength'] - 10; // not including 10-byte initial header
+		if (@$thisfile_id3v2['exthead_length']) {
+			$sizeofframes -= ($thisfile_id3v2['exthead_length'] + 4);
+		}
+		if (@$thisfile_id3v2_flags['isfooter']) {
+			$sizeofframes -= 10; // footer takes last 10 bytes of ID3v2 header, after frame data, before audio
+		}
+		if ($sizeofframes &gt; 0) {
+
+			$framedata = fread($fd, $sizeofframes); // read all frames from file into $framedata variable
+
+			//    if entire frame data is unsynched, de-unsynch it now (ID3v2.3.x)
+			if (@$thisfile_id3v2_flags['unsynch'] &amp;&amp; ($id3v2_majorversion &lt;= 3)) {
+				$framedata = $this-&gt;DeUnsynchronise($framedata);
+			}
+			//        [in ID3v2.4.0] Unsynchronisation [S:6.1] is done on frame level, instead
+			//        of on tag level, making it easier to skip frames, increasing the streamability
+			//        of the tag. The unsynchronisation flag in the header [S:3.1] indicates that
+			//        there exists an unsynchronised frame, while the new unsynchronisation flag in
+			//        the frame header [S:4.1.2] indicates unsynchronisation.
+
+			$framedataoffset = 10 + (@$thisfile_id3v2['exthead_length'] ? $thisfile_id3v2['exthead_length'] + 4 : 0); // how many bytes into the stream - start from after the 10-byte header (and extended header length+4, if present)
+			while (isset($framedata) &amp;&amp; (strlen($framedata) &gt; 0)) { // cycle through until no more frame data is left to parse
+				if (strlen($framedata) &lt;= $this-&gt;ID3v2HeaderLength($id3v2_majorversion)) {
+					// insufficient room left in ID3v2 header for actual data - must be padding
+					$thisfile_id3v2['padding']['start']  = $framedataoffset;
+					$thisfile_id3v2['padding']['length'] = strlen($framedata);
+					$thisfile_id3v2['padding']['valid']  = true;
+					for ($i = 0; $i &lt; $thisfile_id3v2['padding']['length']; $i++) {
+						if ($framedata{$i} != &quot;\x00&quot;) {
+							$thisfile_id3v2['padding']['valid'] = false;
+							$thisfile_id3v2['padding']['errorpos'] = $thisfile_id3v2['padding']['start'] + $i;
+							$ThisFileInfo['warning'][] = 'Invalid ID3v2 padding found at offset '.$thisfile_id3v2['padding']['errorpos'].' (the remaining '.($thisfile_id3v2['padding']['length'] - $i).' bytes are considered invalid)';
+							break;
+						}
+					}
+					break; // skip rest of ID3v2 header
+				}
+				if ($id3v2_majorversion == 2) {
+					// Frame ID  $xx xx xx (three characters)
+					// Size      $xx xx xx (24-bit integer)
+					// Flags     $xx xx
+
+					$frame_header = substr($framedata, 0, 6); // take next 6 bytes for header
+					$framedata    = substr($framedata, 6);    // and leave the rest in $framedata
+					$frame_name   = substr($frame_header, 0, 3);
+					$frame_size   = getid3_lib::BigEndian2Int(substr($frame_header, 3, 3), 0);
+					$frame_flags  = 0; // not used for anything in ID3v2.2, just set to avoid E_NOTICEs
+
+				} elseif ($id3v2_majorversion &gt; 2) {
+
+					// Frame ID  $xx xx xx xx (four characters)
+					// Size      $xx xx xx xx (32-bit integer in v2.3, 28-bit synchsafe in v2.4+)
+					// Flags     $xx xx
+
+					$frame_header = substr($framedata, 0, 10); // take next 10 bytes for header
+					$framedata    = substr($framedata, 10);    // and leave the rest in $framedata
+
+					$frame_name = substr($frame_header, 0, 4);
+					if ($id3v2_majorversion == 3) {
+						$frame_size = getid3_lib::BigEndian2Int(substr($frame_header, 4, 4), 0); // 32-bit integer
+					} else { // ID3v2.4+
+						$frame_size = getid3_lib::BigEndian2Int(substr($frame_header, 4, 4), 1); // 32-bit synchsafe integer (28-bit value)
+					}
+
+					if ($frame_size &lt; (strlen($framedata) + 4)) {
+						$nextFrameID = substr($framedata, $frame_size, 4);
+						if ($this-&gt;IsValidID3v2FrameName($nextFrameID, $id3v2_majorversion)) {
+							// next frame is OK
+						} elseif (($frame_name == &quot;\x00&quot;.'MP3') || ($frame_name == &quot;\x00\x00&quot;.'MP') || ($frame_name == ' MP3') || ($frame_name == 'MP3e')) {
+							// MP3ext known broken frames - &quot;ok&quot; for the purposes of this test
+						} elseif (($id3v2_majorversion == 4) &amp;&amp; ($this-&gt;IsValidID3v2FrameName(substr($framedata, getid3_lib::BigEndian2Int(substr($frame_header, 4, 4), 0), 4), 3))) {
+							$ThisFileInfo['warning'][] = 'ID3v2 tag written as ID3v2.4, but with non-synchsafe integers (ID3v2.3 style). Older versions of Helium2 (www.helium2.com) is a known culprit of this. Tag has been parsed as ID3v2.3';
+							$id3v2_majorversion = 3;
+							$frame_size = getid3_lib::BigEndian2Int(substr($frame_header, 4, 4), 0); // 32-bit integer
+						}
+					}
+
+
+					$frame_flags = getid3_lib::BigEndian2Int(substr($frame_header, 8, 2));
+				}
+
+				if ((($id3v2_majorversion == 2) &amp;&amp; ($frame_name == &quot;\x00\x00\x00&quot;)) || ($frame_name == &quot;\x00\x00\x00\x00&quot;)) {
+					// padding encountered
+
+					$thisfile_id3v2['padding']['start']  = $framedataoffset;
+					$thisfile_id3v2['padding']['length'] = strlen($framedata);
+					$thisfile_id3v2['padding']['valid']  = true;
+					for ($i = 0; $i &lt; $thisfile_id3v2['padding']['length']; $i++) {
+						if ($framedata{$i} != &quot;\x00&quot;) {
+							$thisfile_id3v2['padding']['valid'] = false;
+							$thisfile_id3v2['padding']['errorpos'] = $thisfile_id3v2['padding']['start'] + $i;
+							$ThisFileInfo['warning'][] = 'Invalid ID3v2 padding found at offset '.$thisfile_id3v2['padding']['errorpos'].' (the remaining '.($thisfile_id3v2['padding']['length'] - $i).' bytes are considered invalid)';
+							break;
+						}
+					}
+					break; // skip rest of ID3v2 header
+				}
+
+				if ($frame_name == 'COM ') {
+					$ThisFileInfo['warning'][] = 'error parsing &quot;'.$frame_name.'&quot; ('.$framedataoffset.' bytes into the ID3v2.'.$id3v2_majorversion.' tag). (ERROR: IsValidID3v2FrameName(&quot;'.str_replace(&quot;\x00&quot;, ' ', $frame_name).'&quot;, '.$id3v2_majorversion.'))). [Note: this particular error has been known to happen with tags edited by iTunes (versions &quot;X v2.0.3&quot;, &quot;v3.0.1&quot; are known-guilty, probably others too)]';
+					$frame_name = 'COMM';
+				}
+				if (($frame_size &lt;= strlen($framedata)) &amp;&amp; ($this-&gt;IsValidID3v2FrameName($frame_name, $id3v2_majorversion))) {
+
+					unset($parsedFrame);
+					$parsedFrame['frame_name']      = $frame_name;
+					$parsedFrame['frame_flags_raw'] = $frame_flags;
+					$parsedFrame['data']            = substr($framedata, 0, $frame_size);
+					$parsedFrame['datalength']      = getid3_lib::CastAsInt($frame_size);
+					$parsedFrame['dataoffset']      = $framedataoffset;
+
+					$this-&gt;ParseID3v2Frame($parsedFrame, $ThisFileInfo);
+					$thisfile_id3v2[$frame_name][] = $parsedFrame;
+
+					$framedata = substr($framedata, $frame_size);
+
+				} else { // invalid frame length or FrameID
+
+					if ($frame_size &lt;= strlen($framedata)) {
+
+						if ($this-&gt;IsValidID3v2FrameName(substr($framedata, $frame_size, 4), $id3v2_majorversion)) {
+
+							// next frame is valid, just skip the current frame
+							$framedata = substr($framedata, $frame_size);
+							$ThisFileInfo['warning'][] = 'Next ID3v2 frame is valid, skipping current frame.';
+
+						} else {
+
+							// next frame is invalid too, abort processing
+							unset($framedata);
+							$ThisFileInfo['error'][] = 'Next ID3v2 frame is also invalid, aborting processing.';
+
+						}
+
+					} elseif ($frame_size == strlen($framedata)) {
+
+						// this is the last frame, just skip
+						$ThisFileInfo['warning'][] = 'This was the last ID3v2 frame.';
+
+					} else {
+
+						// next frame is invalid too, abort processing
+						unset($framedata);
+						$ThisFileInfo['warning'][] = 'Invalid ID3v2 frame size, aborting.';
+
+					}
+					if (!$this-&gt;IsValidID3v2FrameName($frame_name, $id3v2_majorversion)) {
+
+						switch ($frame_name) {
+							case &quot;\x00\x00&quot;.'MP':
+							case &quot;\x00&quot;.'MP3':
+							case ' MP3':
+							case 'MP3e':
+							case &quot;\x00&quot;.'MP':
+							case ' MP':
+							case 'MP3':
+								$ThisFileInfo['warning'][] = 'error parsing &quot;'.$frame_name.'&quot; ('.$framedataoffset.' bytes into the ID3v2.'.$id3v2_majorversion.' tag). (ERROR: !IsValidID3v2FrameName(&quot;'.str_replace(&quot;\x00&quot;, ' ', $frame_name).'&quot;, '.$id3v2_majorversion.'))). [Note: this particular error has been known to happen with tags edited by &quot;MP3ext (www.mutschler.de/mp3ext/)&quot;]';
+								break;
+
+							default:
+								$ThisFileInfo['warning'][] = 'error parsing &quot;'.$frame_name.'&quot; ('.$framedataoffset.' bytes into the ID3v2.'.$id3v2_majorversion.' tag). (ERROR: !IsValidID3v2FrameName(&quot;'.str_replace(&quot;\x00&quot;, ' ', $frame_name).'&quot;, '.$id3v2_majorversion.'))).';
+								break;
+						}
+
+					} elseif ($frame_size &gt; strlen($framedata)){
+
+						$ThisFileInfo['error'][] = 'error parsing &quot;'.$frame_name.'&quot; ('.$framedataoffset.' bytes into the ID3v2.'.$id3v2_majorversion.' tag). (ERROR: $frame_size ('.$frame_size.') &gt; strlen($framedata) ('.strlen($framedata).')).';
+
+					} else {
+
+						$ThisFileInfo['error'][] = 'error parsing &quot;'.$frame_name.'&quot; ('.$framedataoffset.' bytes into the ID3v2.'.$id3v2_majorversion.' tag).';
+
+					}
+
+				}
+				$framedataoffset += ($frame_size + $this-&gt;ID3v2HeaderLength($id3v2_majorversion));
+
+			}
+
+		}
+
+
+	//    Footer
+
+	//    The footer is a copy of the header, but with a different identifier.
+	//        ID3v2 identifier           &quot;3DI&quot;
+	//        ID3v2 version              $04 00
+	//        ID3v2 flags                %abcd0000
+	//        ID3v2 size             4 * %0xxxxxxx
+
+		if (isset($thisfile_id3v2_flags['isfooter']) &amp;&amp; $thisfile_id3v2_flags['isfooter']) {
+			$footer = fread($fd, 10);
+			if (substr($footer, 0, 3) == '3DI') {
+				$thisfile_id3v2['footer'] = true;
+				$thisfile_id3v2['majorversion_footer'] = ord($footer{3});
+				$thisfile_id3v2['minorversion_footer'] = ord($footer{4});
+			}
+			if ($thisfile_id3v2['majorversion_footer'] &lt;= 4) {
+				$id3_flags = ord(substr($footer{5}));
+				$thisfile_id3v2_flags['unsynch_footer']  = (bool) ($id3_flags &amp; 0x80);
+				$thisfile_id3v2_flags['extfoot_footer']  = (bool) ($id3_flags &amp; 0x40);
+				$thisfile_id3v2_flags['experim_footer']  = (bool) ($id3_flags &amp; 0x20);
+				$thisfile_id3v2_flags['isfooter_footer'] = (bool) ($id3_flags &amp; 0x10);
+
+				$thisfile_id3v2['footerlength'] = getid3_lib::BigEndian2Int(substr($footer, 6, 4), 1);
+			}
+		} // end footer
+
+		if (isset($thisfile_id3v2['comments']['genre'])) {
+			foreach ($thisfile_id3v2['comments']['genre'] as $key =&gt; $value) {
+				unset($thisfile_id3v2['comments']['genre'][$key]);
+				$thisfile_id3v2['comments'] = getid3_lib::array_merge_noclobber($thisfile_id3v2['comments'], $this-&gt;ParseID3v2GenreString($value));
+			}
+		}
+
+		if (isset($thisfile_id3v2['comments']['track'])) {
+			foreach ($thisfile_id3v2['comments']['track'] as $key =&gt; $value) {
+				if (strstr($value, '/')) {
+					list($thisfile_id3v2['comments']['tracknum'][$key], $thisfile_id3v2['comments']['totaltracks'][$key]) = explode('/', $thisfile_id3v2['comments']['track'][$key]);
+				}
+			}
+		}
+
+
+		// Set avdataoffset
+		$ThisFileInfo['avdataoffset'] = $thisfile_id3v2['headerlength'];
+		if (isset($thisfile_id3v2['footer'])) {
+			$ThisFileInfo['avdataoffset'] += 10;
+		}
+
+		return true;
+	}
+
+
+	function ParseID3v2GenreString($genrestring) {
+		// Parse genres into arrays of genreName and genreID
+		// ID3v2.2.x, ID3v2.3.x: '(21)' or '(4)Eurodisco' or '(51)(39)' or '(55)((I think...)'
+		// ID3v2.4.x: '21' $00 'Eurodisco' $00
+
+		$genrestring = trim($genrestring);
+		$returnarray = array();
+		if (strpos($genrestring, &quot;\x00&quot;) !== false) {
+			$unprocessed = trim($genrestring); // trailing nulls will cause an infinite loop.
+			$genrestring = '';
+			while (strpos($unprocessed, &quot;\x00&quot;) !== false) {
+				// convert null-seperated v2.4-format into v2.3 ()-seperated format
+				$endpos = strpos($unprocessed, &quot;\x00&quot;);
+				$genrestring .= '('.substr($unprocessed, 0, $endpos).')';
+				$unprocessed = substr($unprocessed, $endpos + 1);
+			}
+			unset($unprocessed);
+		}
+		if (getid3_id3v1::LookupGenreID($genrestring)) {
+
+			$returnarray['genre'][] = $genrestring;
+
+		} else {
+
+			while (strpos($genrestring, '(') !== false) {
+
+				$startpos = strpos($genrestring, '(');
+				$endpos   = strpos($genrestring, ')');
+				if (substr($genrestring, $startpos + 1, 1) == '(') {
+					$genrestring = substr($genrestring, 0, $startpos).substr($genrestring, $startpos + 1);
+					$endpos--;
+				}
+				$element     = substr($genrestring, $startpos + 1, $endpos - ($startpos + 1));
+				$genrestring = substr($genrestring, 0, $startpos).substr($genrestring, $endpos + 1);
+				if (getid3_id3v1::LookupGenreName($element)) { // $element is a valid genre id/abbreviation
+
+					if (empty($returnarray['genre']) || !in_array(getid3_id3v1::LookupGenreName($element), $returnarray['genre'])) { // avoid duplicate entires
+						$returnarray['genre'][] = getid3_id3v1::LookupGenreName($element);
+					}
+
+				} else {
+
+					if (empty($returnarray['genre']) || !in_array($element, $returnarray['genre'])) { // avoid duplicate entires
+						$returnarray['genre'][] = $element;
+					}
+
+				}
+			}
+		}
+		if ($genrestring) {
+			if (empty($returnarray['genre']) || !in_array($genrestring, $returnarray['genre'])) { // avoid duplicate entires
+				$returnarray['genre'][]   = $genrestring;
+			}
+		}
+
+		return $returnarray;
+	}
+
+
+	function ParseID3v2Frame(&amp;$parsedFrame, &amp;$ThisFileInfo) {
+
+		// shortcuts
+		$id3v2_majorversion = $ThisFileInfo['id3v2']['majorversion'];
+
+		$parsedFrame['framenamelong']  = $this-&gt;FrameNameLongLookup($parsedFrame['frame_name']);
+		if (empty($parsedFrame['framenamelong'])) {
+			unset($parsedFrame['framenamelong']);
+		}
+		$parsedFrame['framenameshort'] = $this-&gt;FrameNameShortLookup($parsedFrame['frame_name']);
+		if (empty($parsedFrame['framenameshort'])) {
+			unset($parsedFrame['framenameshort']);
+		}
+
+		if ($id3v2_majorversion &gt;= 3) { // frame flags are not part of the ID3v2.2 standard
+			if ($id3v2_majorversion == 3) {
+				//    Frame Header Flags
+				//    %abc00000 %ijk00000
+				$parsedFrame['flags']['TagAlterPreservation']  = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x8000); // a - Tag alter preservation
+				$parsedFrame['flags']['FileAlterPreservation'] = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x4000); // b - File alter preservation
+				$parsedFrame['flags']['ReadOnly']              = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x2000); // c - Read only
+				$parsedFrame['flags']['compression']           = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x0080); // i - Compression
+				$parsedFrame['flags']['Encryption']            = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x0040); // j - Encryption
+				$parsedFrame['flags']['GroupingIdentity']      = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x0020); // k - Grouping identity
+
+			} elseif ($id3v2_majorversion == 4) {
+				//    Frame Header Flags
+				//    %0abc0000 %0h00kmnp
+				$parsedFrame['flags']['TagAlterPreservation']  = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x4000); // a - Tag alter preservation
+				$parsedFrame['flags']['FileAlterPreservation'] = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x2000); // b - File alter preservation
+				$parsedFrame['flags']['ReadOnly']              = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x1000); // c - Read only
+				$parsedFrame['flags']['GroupingIdentity']      = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x0040); // h - Grouping identity
+				$parsedFrame['flags']['compression']           = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x0008); // k - Compression
+				$parsedFrame['flags']['Encryption']            = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x0004); // m - Encryption
+				$parsedFrame['flags']['Unsynchronisation']     = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x0002); // n - Unsynchronisation
+				$parsedFrame['flags']['DataLengthIndicator']   = (bool) ($parsedFrame['frame_flags_raw'] &amp; 0x0001); // p - Data length indicator
+
+				// Frame-level de-unsynchronisation - ID3v2.4
+				if ($parsedFrame['flags']['Unsynchronisation']) {
+					$parsedFrame['data'] = $this-&gt;DeUnsynchronise($parsedFrame['data']);
+				}
+			}
+
+			//    Frame-level de-compression
+			if ($parsedFrame['flags']['compression']) {
+				$parsedFrame['decompressed_size'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], 0, 4));
+				if (!function_exists('gzuncompress')) {
+					$ThisFileInfo['warning'][] = 'gzuncompress() support required to decompress ID3v2 frame &quot;'.$parsedFrame['frame_name'].'&quot;';
+				} elseif ($decompresseddata = @gzuncompress(substr($parsedFrame['data'], 4))) {
+					$parsedFrame['data'] = $decompresseddata;
+				} else {
+					$ThisFileInfo['warning'][] = 'gzuncompress() failed on compressed contents of ID3v2 frame &quot;'.$parsedFrame['frame_name'].'&quot;';
+				}
+			}
+		}
+
+		if (isset($parsedFrame['datalength']) &amp;&amp; ($parsedFrame['datalength'] == 0)) {
+
+			$warning = 'Frame &quot;'.$parsedFrame['frame_name'].'&quot; at offset '.$parsedFrame['dataoffset'].' has no data portion';
+			switch ($parsedFrame['frame_name']) {
+				case 'WCOM':
+					$warning .= ' (this is known to happen with files tagged by RioPort)';
+					break;
+
+				default:
+					break;
+			}
+			$ThisFileInfo['warning'][] = $warning;
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'UFID')) || // 4.1   UFID Unique file identifier
+			(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'UFI'))) {  // 4.1   UFI  Unique file identifier
+			//   There may be more than one 'UFID' frame in a tag,
+			//   but only one with the same 'Owner identifier'.
+			// &lt;Header for 'Unique file identifier', ID: 'UFID'&gt;
+			// Owner identifier        &lt;text string&gt; $00
+			// Identifier              &lt;up to 64 bytes binary data&gt;
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;);
+			$frame_idstring = substr($parsedFrame['data'], 0, $frame_terminatorpos);
+			$parsedFrame['ownerid'] = $frame_idstring;
+			$parsedFrame['data'] = substr($parsedFrame['data'], $frame_terminatorpos + strlen(&quot;\x00&quot;));
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'TXXX')) || // 4.2.2 TXXX User defined text information frame
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'TXX'))) {    // 4.2.2 TXX  User defined text information frame
+			//   There may be more than one 'TXXX' frame in each tag,
+			//   but only one with the same description.
+			// &lt;Header for 'User defined text information frame', ID: 'TXXX'&gt;
+			// Text encoding     $xx
+			// Description       &lt;text string according to encoding&gt; $00 (00)
+			// Value             &lt;text string according to encoding&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+			$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding), $frame_offset);
+			if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+				$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+			}
+			$frame_description = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_description) === 0) {
+				$frame_description = '';
+			}
+			$parsedFrame['encodingid']  = $frame_textencoding;
+			$parsedFrame['encoding']    = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			$parsedFrame['description'] = $frame_description;
+			$parsedFrame['data'] = substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)));
+			if (!empty($parsedFrame['framenameshort']) &amp;&amp; !empty($parsedFrame['data'])) {
+				$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = trim(getid3_lib::iconv_fallback($parsedFrame['encoding'], $ThisFileInfo['id3v2']['encoding'], $parsedFrame['data']));
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ($parsedFrame['frame_name']{0} == 'T') { // 4.2. T??[?] Text information frame
+			//   There may only be one text information frame of its kind in an tag.
+			// &lt;Header for 'Text information frame', ID: 'T000' - 'TZZZ',
+			// excluding 'TXXX' described in 4.2.6.&gt;
+			// Text encoding                $xx
+			// Information                  &lt;text string(s) according to encoding&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+
+			$parsedFrame['data'] = (string) substr($parsedFrame['data'], $frame_offset);
+
+			$parsedFrame['encodingid'] = $frame_textencoding;
+			$parsedFrame['encoding']   = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			if (!empty($parsedFrame['framenameshort']) &amp;&amp; !empty($parsedFrame['data'])) {
+				$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = getid3_lib::iconv_fallback($parsedFrame['encoding'], $ThisFileInfo['id3v2']['encoding'], $parsedFrame['data']);
+			}
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'WXXX')) || // 4.3.2 WXXX User defined URL link frame
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'WXX'))) {    // 4.3.2 WXX  User defined URL link frame
+			//   There may be more than one 'WXXX' frame in each tag,
+			//   but only one with the same description
+			// &lt;Header for 'User defined URL link frame', ID: 'WXXX'&gt;
+			// Text encoding     $xx
+			// Description       &lt;text string according to encoding&gt; $00 (00)
+			// URL               &lt;text string&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+			$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding), $frame_offset);
+			if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+				$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+			}
+			$frame_description = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+
+			if (ord($frame_description) === 0) {
+				$frame_description = '';
+			}
+			$parsedFrame['data'] = substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)));
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding));
+			if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+				$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+			}
+			if ($frame_terminatorpos) {
+				// there are null bytes after the data - this is not according to spec
+				// only use data up to first null byte
+				$frame_urldata = (string) substr($parsedFrame['data'], 0, $frame_terminatorpos);
+			} else {
+				// no null bytes following data, just use all data
+				$frame_urldata = (string) $parsedFrame['data'];
+			}
+
+			$parsedFrame['encodingid']  = $frame_textencoding;
+			$parsedFrame['encoding']    = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			$parsedFrame['url']         = $frame_urldata;
+			$parsedFrame['description'] = $frame_description;
+			if (!empty($parsedFrame['framenameshort']) &amp;&amp; $parsedFrame['url']) {
+				$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = getid3_lib::iconv_fallback($parsedFrame['encoding'], $ThisFileInfo['id3v2']['encoding'], $parsedFrame['url']);
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ($parsedFrame['frame_name']{0} == 'W') { // 4.3. W??? URL link frames
+			//   There may only be one URL link frame of its kind in a tag,
+			//   except when stated otherwise in the frame description
+			// &lt;Header for 'URL link frame', ID: 'W000' - 'WZZZ', excluding 'WXXX'
+			// described in 4.3.2.&gt;
+			// URL              &lt;text string&gt;
+
+			$parsedFrame['url'] = trim($parsedFrame['data']);
+			if (!empty($parsedFrame['framenameshort']) &amp;&amp; $parsedFrame['url']) {
+				$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = $parsedFrame['url'];
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion == 3) &amp;&amp; ($parsedFrame['frame_name'] == 'IPLS')) || // 4.4  IPLS Involved people list (ID3v2.3 only)
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'IPL'))) {     // 4.4  IPL  Involved people list (ID3v2.2 only)
+			//   There may only be one 'IPL' frame in each tag
+			// &lt;Header for 'User defined URL link frame', ID: 'IPL'&gt;
+			// Text encoding     $xx
+			// People list strings    &lt;textstrings&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+			$parsedFrame['encodingid'] = $frame_textencoding;
+			$parsedFrame['encoding']   = $this-&gt;TextEncodingNameLookup($parsedFrame['encodingid']);
+
+			$parsedFrame['data']       = (string) substr($parsedFrame['data'], $frame_offset);
+			if (!empty($parsedFrame['framenameshort']) &amp;&amp; !empty($parsedFrame['data'])) {
+				$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = getid3_lib::iconv_fallback($parsedFrame['encoding'], $ThisFileInfo['id3v2']['encoding'], $parsedFrame['data']);
+			}
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'MCDI')) || // 4.4   MCDI Music CD identifier
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'MCI'))) {     // 4.5   MCI  Music CD identifier
+			//   There may only be one 'MCDI' frame in each tag
+			// &lt;Header for 'Music CD identifier', ID: 'MCDI'&gt;
+			// CD TOC                &lt;binary data&gt;
+
+			if (!empty($parsedFrame['framenameshort']) &amp;&amp; !empty($parsedFrame['data'])) {
+				$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = $parsedFrame['data'];
+			}
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'ETCO')) || // 4.5   ETCO Event timing codes
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'ETC'))) {     // 4.6   ETC  Event timing codes
+			//   There may only be one 'ETCO' frame in each tag
+			// &lt;Header for 'Event timing codes', ID: 'ETCO'&gt;
+			// Time stamp format    $xx
+			//   Where time stamp format is:
+			// $01  (32-bit value) MPEG frames from beginning of file
+			// $02  (32-bit value) milliseconds from beginning of file
+			//   Followed by a list of key events in the following format:
+			// Type of event   $xx
+			// Time stamp      $xx (xx ...)
+			//   The 'Time stamp' is set to zero if directly at the beginning of the sound
+			//   or after the previous event. All events MUST be sorted in chronological order.
+
+			$frame_offset = 0;
+			$parsedFrame['timestampformat'] = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+
+			while ($frame_offset &lt; strlen($parsedFrame['data'])) {
+				$parsedFrame['typeid']    = substr($parsedFrame['data'], $frame_offset++, 1);
+				$parsedFrame['type']      = $this-&gt;ETCOEventLookup($parsedFrame['typeid']);
+				$parsedFrame['timestamp'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 4));
+				$frame_offset += 4;
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'MLLT')) || // 4.6   MLLT MPEG location lookup table
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'MLL'))) {     // 4.7   MLL MPEG location lookup table
+			//   There may only be one 'MLLT' frame in each tag
+			// &lt;Header for 'Location lookup table', ID: 'MLLT'&gt;
+			// MPEG frames between reference  $xx xx
+			// Bytes between reference        $xx xx xx
+			// Milliseconds between reference $xx xx xx
+			// Bits for bytes deviation       $xx
+			// Bits for milliseconds dev.     $xx
+			//   Then for every reference the following data is included;
+			// Deviation in bytes         %xxx....
+			// Deviation in milliseconds  %xxx....
+
+			$frame_offset = 0;
+			$parsedFrame['framesbetweenreferences'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], 0, 2));
+			$parsedFrame['bytesbetweenreferences']  = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], 2, 3));
+			$parsedFrame['msbetweenreferences']     = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], 5, 3));
+			$parsedFrame['bitsforbytesdeviation']   = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], 8, 1));
+			$parsedFrame['bitsformsdeviation']      = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], 9, 1));
+			$parsedFrame['data'] = substr($parsedFrame['data'], 10);
+			while ($frame_offset &lt; strlen($parsedFrame['data'])) {
+				$deviationbitstream .= getid3_lib::BigEndian2Bin(substr($parsedFrame['data'], $frame_offset++, 1));
+			}
+			$reference_counter = 0;
+			while (strlen($deviationbitstream) &gt; 0) {
+				$parsedFrame[$reference_counter]['bytedeviation'] = bindec(substr($deviationbitstream, 0, $parsedFrame['bitsforbytesdeviation']));
+				$parsedFrame[$reference_counter]['msdeviation']   = bindec(substr($deviationbitstream, $parsedFrame['bitsforbytesdeviation'], $parsedFrame['bitsformsdeviation']));
+				$deviationbitstream = substr($deviationbitstream, $parsedFrame['bitsforbytesdeviation'] + $parsedFrame['bitsformsdeviation']);
+				$reference_counter++;
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'SYTC')) || // 4.7   SYTC Synchronised tempo codes
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'STC'))) {     // 4.8   STC  Synchronised tempo codes
+			//   There may only be one 'SYTC' frame in each tag
+			// &lt;Header for 'Synchronised tempo codes', ID: 'SYTC'&gt;
+			// Time stamp format   $xx
+			// Tempo data          &lt;binary data&gt;
+			//   Where time stamp format is:
+			// $01  (32-bit value) MPEG frames from beginning of file
+			// $02  (32-bit value) milliseconds from beginning of file
+
+			$frame_offset = 0;
+			$parsedFrame['timestampformat'] = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$timestamp_counter = 0;
+			while ($frame_offset &lt; strlen($parsedFrame['data'])) {
+				$parsedFrame[$timestamp_counter]['tempo'] = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+				if ($parsedFrame[$timestamp_counter]['tempo'] == 255) {
+					$parsedFrame[$timestamp_counter]['tempo'] += ord(substr($parsedFrame['data'], $frame_offset++, 1));
+				}
+				$parsedFrame[$timestamp_counter]['timestamp'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 4));
+				$frame_offset += 4;
+				$timestamp_counter++;
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'USLT')) || // 4.8   USLT Unsynchronised lyric/text transcription
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'ULT'))) {     // 4.9   ULT  Unsynchronised lyric/text transcription
+			//   There may be more than one 'Unsynchronised lyrics/text transcription' frame
+			//   in each tag, but only one with the same language and content descriptor.
+			// &lt;Header for 'Unsynchronised lyrics/text transcription', ID: 'USLT'&gt;
+			// Text encoding        $xx
+			// Language             $xx xx xx
+			// Content descriptor   &lt;text string according to encoding&gt; $00 (00)
+			// Lyrics/text          &lt;full text string according to encoding&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+			$frame_language = substr($parsedFrame['data'], $frame_offset, 3);
+			$frame_offset += 3;
+			$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding), $frame_offset);
+			if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+				$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+			}
+			$frame_description = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_description) === 0) {
+				$frame_description = '';
+			}
+			$parsedFrame['data'] = substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)));
+
+			$parsedFrame['encodingid']   = $frame_textencoding;
+			$parsedFrame['encoding']     = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			$parsedFrame['data']         = $parsedFrame['data'];
+			$parsedFrame['language']     = $frame_language;
+			$parsedFrame['languagename'] = $this-&gt;LanguageLookup($frame_language, false);
+			$parsedFrame['description']  = $frame_description;
+			if (!empty($parsedFrame['framenameshort']) &amp;&amp; !empty($parsedFrame['data'])) {
+				$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = getid3_lib::iconv_fallback($parsedFrame['encoding'], $ThisFileInfo['id3v2']['encoding'], $parsedFrame['data']);
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'SYLT')) || // 4.9   SYLT Synchronised lyric/text
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'SLT'))) {     // 4.10  SLT  Synchronised lyric/text
+			//   There may be more than one 'SYLT' frame in each tag,
+			//   but only one with the same language and content descriptor.
+			// &lt;Header for 'Synchronised lyrics/text', ID: 'SYLT'&gt;
+			// Text encoding        $xx
+			// Language             $xx xx xx
+			// Time stamp format    $xx
+			//   $01  (32-bit value) MPEG frames from beginning of file
+			//   $02  (32-bit value) milliseconds from beginning of file
+			// Content type         $xx
+			// Content descriptor   &lt;text string according to encoding&gt; $00 (00)
+			//   Terminated text to be synced (typically a syllable)
+			//   Sync identifier (terminator to above string)   $00 (00)
+			//   Time stamp                                     $xx (xx ...)
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+			$frame_language = substr($parsedFrame['data'], $frame_offset, 3);
+			$frame_offset += 3;
+			$parsedFrame['timestampformat'] = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['contenttypeid']   = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['contenttype']     = $this-&gt;SYTLContentTypeLookup($parsedFrame['contenttypeid']);
+			$parsedFrame['encodingid']      = $frame_textencoding;
+			$parsedFrame['encoding']        = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			$parsedFrame['language']        = $frame_language;
+			$parsedFrame['languagename']    = $this-&gt;LanguageLookup($frame_language, false);
+
+			$timestampindex = 0;
+			$frame_remainingdata = substr($parsedFrame['data'], $frame_offset);
+			while (strlen($frame_remainingdata)) {
+				$frame_offset = 0;
+				$frame_terminatorpos = strpos($frame_remainingdata, $this-&gt;TextEncodingTerminatorLookup($frame_textencoding));
+				if ($frame_terminatorpos === false) {
+					$frame_remainingdata = '';
+				} else {
+					if (ord(substr($frame_remainingdata, $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+						$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+					}
+					$parsedFrame['lyrics'][$timestampindex]['data'] = substr($frame_remainingdata, $frame_offset, $frame_terminatorpos - $frame_offset);
+
+					$frame_remainingdata = substr($frame_remainingdata, $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)));
+					if (($timestampindex == 0) &amp;&amp; (ord($frame_remainingdata{0}) != 0)) {
+						// timestamp probably omitted for first data item
+					} else {
+						$parsedFrame['lyrics'][$timestampindex]['timestamp'] = getid3_lib::BigEndian2Int(substr($frame_remainingdata, 0, 4));
+						$frame_remainingdata = substr($frame_remainingdata, 4);
+					}
+					$timestampindex++;
+				}
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'COMM')) || // 4.10  COMM Comments
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'COM'))) {     // 4.11  COM  Comments
+			//   There may be more than one comment frame in each tag,
+			//   but only one with the same language and content descriptor.
+			// &lt;Header for 'Comment', ID: 'COMM'&gt;
+			// Text encoding          $xx
+			// Language               $xx xx xx
+			// Short content descrip. &lt;text string according to encoding&gt; $00 (00)
+			// The actual text        &lt;full text string according to encoding&gt;
+
+			if (strlen($parsedFrame['data']) &lt; 5) {
+
+				$ThisFileInfo['warning'][] = 'Invalid data (too short) for &quot;'.$parsedFrame['frame_name'].'&quot; frame at offset '.$parsedFrame['dataoffset'];
+
+			} else {
+
+				$frame_offset = 0;
+				$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+				if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+					$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+				}
+				$frame_language = substr($parsedFrame['data'], $frame_offset, 3);
+				$frame_offset += 3;
+				$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding), $frame_offset);
+				if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+					$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+				}
+				$frame_description = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+				if (ord($frame_description) === 0) {
+					$frame_description = '';
+				}
+				$frame_text = (string) substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)));
+
+				$parsedFrame['encodingid']   = $frame_textencoding;
+				$parsedFrame['encoding']     = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+				$parsedFrame['language']     = $frame_language;
+				$parsedFrame['languagename'] = $this-&gt;LanguageLookup($frame_language, false);
+				$parsedFrame['description']  = $frame_description;
+				$parsedFrame['data']         = $frame_text;
+				if (!empty($parsedFrame['framenameshort']) &amp;&amp; !empty($parsedFrame['data'])) {
+					$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = getid3_lib::iconv_fallback($parsedFrame['encoding'], $ThisFileInfo['id3v2']['encoding'], $parsedFrame['data']);
+				}
+
+			}
+
+		} elseif (($id3v2_majorversion &gt;= 4) &amp;&amp; ($parsedFrame['frame_name'] == 'RVA2')) { // 4.11  RVA2 Relative volume adjustment (2) (ID3v2.4+ only)
+			//   There may be more than one 'RVA2' frame in each tag,
+			//   but only one with the same identification string
+			// &lt;Header for 'Relative volume adjustment (2)', ID: 'RVA2'&gt;
+			// Identification          &lt;text string&gt; $00
+			//   The 'identification' string is used to identify the situation and/or
+			//   device where this adjustment should apply. The following is then
+			//   repeated for every channel:
+			// Type of channel         $xx
+			// Volume adjustment       $xx xx
+			// Bits representing peak  $xx
+			// Peak volume             $xx (xx ...)
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;);
+			$frame_idstring = substr($parsedFrame['data'], 0, $frame_terminatorpos);
+			if (ord($frame_idstring) === 0) {
+				$frame_idstring = '';
+			}
+			$frame_remainingdata = substr($parsedFrame['data'], $frame_terminatorpos + strlen(&quot;\x00&quot;));
+			$parsedFrame['description'] = $frame_idstring;
+			while (strlen($frame_remainingdata)) {
+				$frame_offset = 0;
+				$frame_channeltypeid = ord(substr($frame_remainingdata, $frame_offset++, 1));
+				$parsedFrame[$frame_channeltypeid]['channeltypeid']  = $frame_channeltypeid;
+				$parsedFrame[$frame_channeltypeid]['channeltype']    = $this-&gt;RVA2ChannelTypeLookup($frame_channeltypeid);
+				$parsedFrame[$frame_channeltypeid]['volumeadjust']   = getid3_lib::BigEndian2Int(substr($frame_remainingdata, $frame_offset, 2), false, true); // 16-bit signed
+				$frame_offset += 2;
+				$parsedFrame[$frame_channeltypeid]['bitspeakvolume'] = ord(substr($frame_remainingdata, $frame_offset++, 1));
+				$frame_bytespeakvolume = ceil($parsedFrame[$frame_channeltypeid]['bitspeakvolume'] / 8);
+				$parsedFrame[$frame_channeltypeid]['peakvolume']     = getid3_lib::BigEndian2Int(substr($frame_remainingdata, $frame_offset, $frame_bytespeakvolume));
+				$frame_remainingdata = substr($frame_remainingdata, $frame_offset + $frame_bytespeakvolume);
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion == 3) &amp;&amp; ($parsedFrame['frame_name'] == 'RVAD')) || // 4.12  RVAD Relative volume adjustment (ID3v2.3 only)
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'RVA'))) {     // 4.12  RVA  Relative volume adjustment (ID3v2.2 only)
+			//   There may only be one 'RVA' frame in each tag
+			// &lt;Header for 'Relative volume adjustment', ID: 'RVA'&gt;
+			// ID3v2.2 =&gt; Increment/decrement     %000000ba
+			// ID3v2.3 =&gt; Increment/decrement     %00fedcba
+			// Bits used for volume descr.        $xx
+			// Relative volume change, right      $xx xx (xx ...) // a
+			// Relative volume change, left       $xx xx (xx ...) // b
+			// Peak volume right                  $xx xx (xx ...)
+			// Peak volume left                   $xx xx (xx ...)
+			//   ID3v2.3 only, optional (not present in ID3v2.2):
+			// Relative volume change, right back $xx xx (xx ...) // c
+			// Relative volume change, left back  $xx xx (xx ...) // d
+			// Peak volume right back             $xx xx (xx ...)
+			// Peak volume left back              $xx xx (xx ...)
+			//   ID3v2.3 only, optional (not present in ID3v2.2):
+			// Relative volume change, center     $xx xx (xx ...) // e
+			// Peak volume center                 $xx xx (xx ...)
+			//   ID3v2.3 only, optional (not present in ID3v2.2):
+			// Relative volume change, bass       $xx xx (xx ...) // f
+			// Peak volume bass                   $xx xx (xx ...)
+
+			$frame_offset = 0;
+			$frame_incrdecrflags = getid3_lib::BigEndian2Bin(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['incdec']['right'] = (bool) substr($frame_incrdecrflags, 6, 1);
+			$parsedFrame['incdec']['left']  = (bool) substr($frame_incrdecrflags, 7, 1);
+			$parsedFrame['bitsvolume'] = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$frame_bytesvolume = ceil($parsedFrame['bitsvolume'] / 8);
+			$parsedFrame['volumechange']['right'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+			if ($parsedFrame['incdec']['right'] === false) {
+				$parsedFrame['volumechange']['right'] *= -1;
+			}
+			$frame_offset += $frame_bytesvolume;
+			$parsedFrame['volumechange']['left'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+			if ($parsedFrame['incdec']['left'] === false) {
+				$parsedFrame['volumechange']['left'] *= -1;
+			}
+			$frame_offset += $frame_bytesvolume;
+			$parsedFrame['peakvolume']['right'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+			$frame_offset += $frame_bytesvolume;
+			$parsedFrame['peakvolume']['left']  = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+			$frame_offset += $frame_bytesvolume;
+			if ($id3v2_majorversion == 3) {
+				$parsedFrame['data'] = substr($parsedFrame['data'], $frame_offset);
+				if (strlen($parsedFrame['data']) &gt; 0) {
+					$parsedFrame['incdec']['rightrear'] = (bool) substr($frame_incrdecrflags, 4, 1);
+					$parsedFrame['incdec']['leftrear']  = (bool) substr($frame_incrdecrflags, 5, 1);
+					$parsedFrame['volumechange']['rightrear'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+					if ($parsedFrame['incdec']['rightrear'] === false) {
+						$parsedFrame['volumechange']['rightrear'] *= -1;
+					}
+					$frame_offset += $frame_bytesvolume;
+					$parsedFrame['volumechange']['leftrear'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+					if ($parsedFrame['incdec']['leftrear'] === false) {
+						$parsedFrame['volumechange']['leftrear'] *= -1;
+					}
+					$frame_offset += $frame_bytesvolume;
+					$parsedFrame['peakvolume']['rightrear'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+					$frame_offset += $frame_bytesvolume;
+					$parsedFrame['peakvolume']['leftrear']  = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+					$frame_offset += $frame_bytesvolume;
+				}
+				$parsedFrame['data'] = substr($parsedFrame['data'], $frame_offset);
+				if (strlen($parsedFrame['data']) &gt; 0) {
+					$parsedFrame['incdec']['center'] = (bool) substr($frame_incrdecrflags, 3, 1);
+					$parsedFrame['volumechange']['center'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+					if ($parsedFrame['incdec']['center'] === false) {
+						$parsedFrame['volumechange']['center'] *= -1;
+					}
+					$frame_offset += $frame_bytesvolume;
+					$parsedFrame['peakvolume']['center'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+					$frame_offset += $frame_bytesvolume;
+				}
+				$parsedFrame['data'] = substr($parsedFrame['data'], $frame_offset);
+				if (strlen($parsedFrame['data']) &gt; 0) {
+					$parsedFrame['incdec']['bass'] = (bool) substr($frame_incrdecrflags, 2, 1);
+					$parsedFrame['volumechange']['bass'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+					if ($parsedFrame['incdec']['bass'] === false) {
+						$parsedFrame['volumechange']['bass'] *= -1;
+					}
+					$frame_offset += $frame_bytesvolume;
+					$parsedFrame['peakvolume']['bass'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesvolume));
+					$frame_offset += $frame_bytesvolume;
+				}
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif (($id3v2_majorversion &gt;= 4) &amp;&amp; ($parsedFrame['frame_name'] == 'EQU2')) { // 4.12  EQU2 Equalisation (2) (ID3v2.4+ only)
+			//   There may be more than one 'EQU2' frame in each tag,
+			//   but only one with the same identification string
+			// &lt;Header of 'Equalisation (2)', ID: 'EQU2'&gt;
+			// Interpolation method  $xx
+			//   $00  Band
+			//   $01  Linear
+			// Identification        &lt;text string&gt; $00
+			//   The following is then repeated for every adjustment point
+			// Frequency          $xx xx
+			// Volume adjustment  $xx xx
+
+			$frame_offset = 0;
+			$frame_interpolationmethod = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_idstring = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_idstring) === 0) {
+				$frame_idstring = '';
+			}
+			$parsedFrame['description'] = $frame_idstring;
+			$frame_remainingdata = substr($parsedFrame['data'], $frame_terminatorpos + strlen(&quot;\x00&quot;));
+			while (strlen($frame_remainingdata)) {
+				$frame_frequency = getid3_lib::BigEndian2Int(substr($frame_remainingdata, 0, 2)) / 2;
+				$parsedFrame['data'][$frame_frequency] = getid3_lib::BigEndian2Int(substr($frame_remainingdata, 2, 2), false, true);
+				$frame_remainingdata = substr($frame_remainingdata, 4);
+			}
+			$parsedFrame['interpolationmethod'] = $frame_interpolationmethod;
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion == 3) &amp;&amp; ($parsedFrame['frame_name'] == 'EQUA')) || // 4.12  EQUA Equalisation (ID3v2.3 only)
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'EQU'))) {     // 4.13  EQU  Equalisation (ID3v2.2 only)
+			//   There may only be one 'EQUA' frame in each tag
+			// &lt;Header for 'Relative volume adjustment', ID: 'EQU'&gt;
+			// Adjustment bits    $xx
+			//   This is followed by 2 bytes + ('adjustment bits' rounded up to the
+			//   nearest byte) for every equalisation band in the following format,
+			//   giving a frequency range of 0 - 32767Hz:
+			// Increment/decrement   %x (MSB of the Frequency)
+			// Frequency             (lower 15 bits)
+			// Adjustment            $xx (xx ...)
+
+			$frame_offset = 0;
+			$parsedFrame['adjustmentbits'] = substr($parsedFrame['data'], $frame_offset++, 1);
+			$frame_adjustmentbytes = ceil($parsedFrame['adjustmentbits'] / 8);
+
+			$frame_remainingdata = (string) substr($parsedFrame['data'], $frame_offset);
+			while (strlen($frame_remainingdata) &gt; 0) {
+				$frame_frequencystr = getid3_lib::BigEndian2Bin(substr($frame_remainingdata, 0, 2));
+				$frame_incdec    = (bool) substr($frame_frequencystr, 0, 1);
+				$frame_frequency = bindec(substr($frame_frequencystr, 1, 15));
+				$parsedFrame[$frame_frequency]['incdec'] = $frame_incdec;
+				$parsedFrame[$frame_frequency]['adjustment'] = getid3_lib::BigEndian2Int(substr($frame_remainingdata, 2, $frame_adjustmentbytes));
+				if ($parsedFrame[$frame_frequency]['incdec'] === false) {
+					$parsedFrame[$frame_frequency]['adjustment'] *= -1;
+				}
+				$frame_remainingdata = substr($frame_remainingdata, 2 + $frame_adjustmentbytes);
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'RVRB')) || // 4.13  RVRB Reverb
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'REV'))) {     // 4.14  REV  Reverb
+			//   There may only be one 'RVRB' frame in each tag.
+			// &lt;Header for 'Reverb', ID: 'RVRB'&gt;
+			// Reverb left (ms)                 $xx xx
+			// Reverb right (ms)                $xx xx
+			// Reverb bounces, left             $xx
+			// Reverb bounces, right            $xx
+			// Reverb feedback, left to left    $xx
+			// Reverb feedback, left to right   $xx
+			// Reverb feedback, right to right  $xx
+			// Reverb feedback, right to left   $xx
+			// Premix left to right             $xx
+			// Premix right to left             $xx
+
+			$frame_offset = 0;
+			$parsedFrame['left']  = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 2));
+			$frame_offset += 2;
+			$parsedFrame['right'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 2));
+			$frame_offset += 2;
+			$parsedFrame['bouncesL']      = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['bouncesR']      = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['feedbackLL']    = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['feedbackLR']    = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['feedbackRR']    = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['feedbackRL']    = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['premixLR']      = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['premixRL']      = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'APIC')) || // 4.14  APIC Attached picture
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'PIC'))) {     // 4.15  PIC  Attached picture
+			//   There may be several pictures attached to one file,
+			//   each in their individual 'APIC' frame, but only one
+			//   with the same content descriptor
+			// &lt;Header for 'Attached picture', ID: 'APIC'&gt;
+			// Text encoding      $xx
+			// ID3v2.3+ =&gt; MIME type          &lt;text string&gt; $00
+			// ID3v2.2  =&gt; Image format       $xx xx xx
+			// Picture type       $xx
+			// Description        &lt;text string according to encoding&gt; $00 (00)
+			// Picture data       &lt;binary data&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+
+			if ($id3v2_majorversion == 2) {
+				$frame_imagetype = substr($parsedFrame['data'], $frame_offset, 3);
+				if (strtolower($frame_imagetype) == 'ima') {
+					// complete hack for mp3Rage (www.chaoticsoftware.com) that puts ID3v2.3-formatted
+					// MIME type instead of 3-char ID3v2.2-format image type  (thanks xbhoff&#216;pacbell*net)
+					$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+					$frame_mimetype = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+					if (ord($frame_mimetype) === 0) {
+						$frame_mimetype = '';
+					}
+					$frame_imagetype = strtoupper(str_replace('image/', '', strtolower($frame_mimetype)));
+					if ($frame_imagetype == 'JPEG') {
+						$frame_imagetype = 'JPG';
+					}
+					$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+				} else {
+					$frame_offset += 3;
+				}
+			}
+			if ($id3v2_majorversion &gt; 2) {
+				$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+				$frame_mimetype = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+				if (ord($frame_mimetype) === 0) {
+					$frame_mimetype = '';
+				}
+				$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+			}
+
+			$frame_picturetype = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding), $frame_offset);
+			if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+				$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+			}
+			$frame_description = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_description) === 0) {
+				$frame_description = '';
+			}
+			$parsedFrame['encodingid']       = $frame_textencoding;
+			$parsedFrame['encoding']         = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			if ($id3v2_majorversion == 2) {
+				$parsedFrame['imagetype']    = $frame_imagetype;
+			} else {
+				$parsedFrame['mime']         = $frame_mimetype;
+			}
+			$parsedFrame['picturetypeid']    = $frame_picturetype;
+			$parsedFrame['picturetype']      = $this-&gt;APICPictureTypeLookup($frame_picturetype);
+			$parsedFrame['description']      = $frame_description;
+			$parsedFrame['data']             = substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)));
+
+			$imagechunkcheck = getid3_lib::GetDataImageSize($parsedFrame['data']);
+			if (($imagechunkcheck[2] &gt;= 1) &amp;&amp; ($imagechunkcheck[2] &lt;= 3)) {
+				$parsedFrame['image_mime']       = 'image/'.getid3_lib::ImageTypesLookup($imagechunkcheck[2]);
+				if ($imagechunkcheck[0]) {
+					$parsedFrame['image_width']  = $imagechunkcheck[0];
+				}
+				if ($imagechunkcheck[1]) {
+					$parsedFrame['image_height'] = $imagechunkcheck[1];
+				}
+				$parsedFrame['image_bytes']      = strlen($parsedFrame['data']);
+			}
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'GEOB')) || // 4.15  GEOB General encapsulated object
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'GEO'))) {     // 4.16  GEO  General encapsulated object
+			//   There may be more than one 'GEOB' frame in each tag,
+			//   but only one with the same content descriptor
+			// &lt;Header for 'General encapsulated object', ID: 'GEOB'&gt;
+			// Text encoding          $xx
+			// MIME type              &lt;text string&gt; $00
+			// Filename               &lt;text string according to encoding&gt; $00 (00)
+			// Content description    &lt;text string according to encoding&gt; $00 (00)
+			// Encapsulated object    &lt;binary data&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_mimetype = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_mimetype) === 0) {
+				$frame_mimetype = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding), $frame_offset);
+			if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+				$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+			}
+			$frame_filename = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_filename) === 0) {
+				$frame_filename = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding));
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding), $frame_offset);
+			if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+				$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+			}
+			$frame_description = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_description) === 0) {
+				$frame_description = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding));
+
+			$parsedFrame['objectdata']  = (string) substr($parsedFrame['data'], $frame_offset);
+			$parsedFrame['encodingid']  = $frame_textencoding;
+			$parsedFrame['encoding']    = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			$parsedFrame['mime']        = $frame_mimetype;
+			$parsedFrame['filename']    = $frame_filename;
+			$parsedFrame['description'] = $frame_description;
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'PCNT')) || // 4.16  PCNT Play counter
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'CNT'))) {     // 4.17  CNT  Play counter
+			//   There may only be one 'PCNT' frame in each tag.
+			//   When the counter reaches all one's, one byte is inserted in
+			//   front of the counter thus making the counter eight bits bigger
+			// &lt;Header for 'Play counter', ID: 'PCNT'&gt;
+			// Counter        $xx xx xx xx (xx ...)
+
+			$parsedFrame['data']          = getid3_lib::BigEndian2Int($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'POPM')) || // 4.17  POPM Popularimeter
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'POP'))) {     // 4.18  POP  Popularimeter
+			//   There may be more than one 'POPM' frame in each tag,
+			//   but only one with the same email address
+			// &lt;Header for 'Popularimeter', ID: 'POPM'&gt;
+			// Email to user   &lt;text string&gt; $00
+			// Rating          $xx
+			// Counter         $xx xx xx xx (xx ...)
+
+			$frame_offset = 0;
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_emailaddress = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_emailaddress) === 0) {
+				$frame_emailaddress = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+			$frame_rating = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['data'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset));
+			$parsedFrame['email']  = $frame_emailaddress;
+			$parsedFrame['rating'] = $frame_rating;
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'RBUF')) || // 4.18  RBUF Recommended buffer size
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'BUF'))) {     // 4.19  BUF  Recommended buffer size
+			//   There may only be one 'RBUF' frame in each tag
+			// &lt;Header for 'Recommended buffer size', ID: 'RBUF'&gt;
+			// Buffer size               $xx xx xx
+			// Embedded info flag        %0000000x
+			// Offset to next tag        $xx xx xx xx
+
+			$frame_offset = 0;
+			$parsedFrame['buffersize'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 3));
+			$frame_offset += 3;
+
+			$frame_embeddedinfoflags = getid3_lib::BigEndian2Bin(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['flags']['embededinfo'] = (bool) substr($frame_embeddedinfoflags, 7, 1);
+			$parsedFrame['nexttagoffset'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 4));
+			unset($parsedFrame['data']);
+
+
+		} elseif (($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'CRM')) { // 4.20  Encrypted meta frame (ID3v2.2 only)
+			//   There may be more than one 'CRM' frame in a tag,
+			//   but only one with the same 'owner identifier'
+			// &lt;Header for 'Encrypted meta frame', ID: 'CRM'&gt;
+			// Owner identifier      &lt;textstring&gt; $00 (00)
+			// Content/explanation   &lt;textstring&gt; $00 (00)
+			// Encrypted datablock   &lt;binary data&gt;
+
+			$frame_offset = 0;
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_ownerid = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_description = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_description) === 0) {
+				$frame_description = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+
+			$parsedFrame['ownerid']     = $frame_ownerid;
+			$parsedFrame['data']        = (string) substr($parsedFrame['data'], $frame_offset);
+			$parsedFrame['description'] = $frame_description;
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'AENC')) || // 4.19  AENC Audio encryption
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'CRA'))) {     // 4.21  CRA  Audio encryption
+			//   There may be more than one 'AENC' frames in a tag,
+			//   but only one with the same 'Owner identifier'
+			// &lt;Header for 'Audio encryption', ID: 'AENC'&gt;
+			// Owner identifier   &lt;text string&gt; $00
+			// Preview start      $xx xx
+			// Preview length     $xx xx
+			// Encryption info    &lt;binary data&gt;
+
+			$frame_offset = 0;
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_ownerid = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_ownerid) === 0) {
+				$frame_ownerid == '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+			$parsedFrame['ownerid'] = $frame_ownerid;
+			$parsedFrame['previewstart'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 2));
+			$frame_offset += 2;
+			$parsedFrame['previewlength'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 2));
+			$frame_offset += 2;
+			$parsedFrame['encryptioninfo'] = (string) substr($parsedFrame['data'], $frame_offset);
+			unset($parsedFrame['data']);
+
+
+		} elseif ((($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'LINK')) || // 4.20  LINK Linked information
+				(($id3v2_majorversion == 2) &amp;&amp; ($parsedFrame['frame_name'] == 'LNK'))) {     // 4.22  LNK  Linked information
+			//   There may be more than one 'LINK' frame in a tag,
+			//   but only one with the same contents
+			// &lt;Header for 'Linked information', ID: 'LINK'&gt;
+			// ID3v2.3+ =&gt; Frame identifier   $xx xx xx xx
+			// ID3v2.2  =&gt; Frame identifier   $xx xx xx
+			// URL                            &lt;text string&gt; $00
+			// ID and additional data         &lt;text string(s)&gt;
+
+			$frame_offset = 0;
+			if ($id3v2_majorversion == 2) {
+				$parsedFrame['frameid'] = substr($parsedFrame['data'], $frame_offset, 3);
+				$frame_offset += 3;
+			} else {
+				$parsedFrame['frameid'] = substr($parsedFrame['data'], $frame_offset, 4);
+				$frame_offset += 4;
+			}
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_url = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_url) === 0) {
+				$frame_url = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+			$parsedFrame['url'] = $frame_url;
+
+			$parsedFrame['additionaldata'] = (string) substr($parsedFrame['data'], $frame_offset);
+			if (!empty($parsedFrame['framenameshort']) &amp;&amp; $parsedFrame['url']) {
+				$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = getid3_lib::iconv_fallback($parsedFrame['encoding'], $ThisFileInfo['id3v2']['encoding'], $parsedFrame['url']);
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif (($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'POSS')) { // 4.21  POSS Position synchronisation frame (ID3v2.3+ only)
+			//   There may only be one 'POSS' frame in each tag
+			// &lt;Head for 'Position synchronisation', ID: 'POSS'&gt;
+			// Time stamp format         $xx
+			// Position                  $xx (xx ...)
+
+			$frame_offset = 0;
+			$parsedFrame['timestampformat'] = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['position']        = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset));
+			unset($parsedFrame['data']);
+
+
+		} elseif (($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'USER')) { // 4.22  USER Terms of use (ID3v2.3+ only)
+			//   There may be more than one 'Terms of use' frame in a tag,
+			//   but only one with the same 'Language'
+			// &lt;Header for 'Terms of use frame', ID: 'USER'&gt;
+			// Text encoding        $xx
+			// Language             $xx xx xx
+			// The actual text      &lt;text string according to encoding&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+			$frame_language = substr($parsedFrame['data'], $frame_offset, 3);
+			$frame_offset += 3;
+			$parsedFrame['language']     = $frame_language;
+			$parsedFrame['languagename'] = $this-&gt;LanguageLookup($frame_language, false);
+			$parsedFrame['encodingid']   = $frame_textencoding;
+			$parsedFrame['encoding']     = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			$parsedFrame['data']         = (string) substr($parsedFrame['data'], $frame_offset);
+			if (!empty($parsedFrame['framenameshort']) &amp;&amp; !empty($parsedFrame['data'])) {
+				$ThisFileInfo['id3v2']['comments'][$parsedFrame['framenameshort']][] = getid3_lib::iconv_fallback($parsedFrame['encoding'], $ThisFileInfo['id3v2']['encoding'], $parsedFrame['data']);
+			}
+			unset($parsedFrame['data']);
+
+
+		} elseif (($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'OWNE')) { // 4.23  OWNE Ownership frame (ID3v2.3+ only)
+			//   There may only be one 'OWNE' frame in a tag
+			// &lt;Header for 'Ownership frame', ID: 'OWNE'&gt;
+			// Text encoding     $xx
+			// Price paid        &lt;text string&gt; $00
+			// Date of purch.    &lt;text string&gt;
+			// Seller            &lt;text string according to encoding&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+			$parsedFrame['encodingid'] = $frame_textencoding;
+			$parsedFrame['encoding']   = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_pricepaid = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+
+			$parsedFrame['pricepaid']['currencyid'] = substr($frame_pricepaid, 0, 3);
+			$parsedFrame['pricepaid']['currency']   = $this-&gt;LookupCurrencyUnits($parsedFrame['pricepaid']['currencyid']);
+			$parsedFrame['pricepaid']['value']      = substr($frame_pricepaid, 3);
+
+			$parsedFrame['purchasedate'] = substr($parsedFrame['data'], $frame_offset, 8);
+			if (!$this-&gt;IsValidDateStampString($parsedFrame['purchasedate'])) {
+				$parsedFrame['purchasedateunix'] = mktime (0, 0, 0, substr($parsedFrame['purchasedate'], 4, 2), substr($parsedFrame['purchasedate'], 6, 2), substr($parsedFrame['purchasedate'], 0, 4));
+			}
+			$frame_offset += 8;
+
+			$parsedFrame['seller'] = (string) substr($parsedFrame['data'], $frame_offset);
+			unset($parsedFrame['data']);
+
+
+		} elseif (($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'COMR')) { // 4.24  COMR Commercial frame (ID3v2.3+ only)
+			//   There may be more than one 'commercial frame' in a tag,
+			//   but no two may be identical
+			// &lt;Header for 'Commercial frame', ID: 'COMR'&gt;
+			// Text encoding      $xx
+			// Price string       &lt;text string&gt; $00
+			// Valid until        &lt;text string&gt;
+			// Contact URL        &lt;text string&gt; $00
+			// Received as        $xx
+			// Name of seller     &lt;text string according to encoding&gt; $00 (00)
+			// Description        &lt;text string according to encoding&gt; $00 (00)
+			// Picture MIME type  &lt;string&gt; $00
+			// Seller logo        &lt;binary data&gt;
+
+			$frame_offset = 0;
+			$frame_textencoding = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			if ((($id3v2_majorversion &lt;= 3) &amp;&amp; ($frame_textencoding &gt; 1)) || (($id3v2_majorversion == 4) &amp;&amp; ($frame_textencoding &gt; 3))) {
+				$ThisFileInfo['warning'][] = 'Invalid text encoding byte ('.$frame_textencoding.') in frame &quot;'.$parsedFrame['frame_name'].'&quot; - defaulting to ISO-8859-1 encoding';
+			}
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_pricestring = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+			$frame_rawpricearray = explode('/', $frame_pricestring);
+			foreach ($frame_rawpricearray as $key =&gt; $val) {
+				$frame_currencyid = substr($val, 0, 3);
+				$parsedFrame['price'][$frame_currencyid]['currency'] = $this-&gt;LookupCurrencyUnits($frame_currencyid);
+				$parsedFrame['price'][$frame_currencyid]['value']    = substr($val, 3);
+			}
+
+			$frame_datestring = substr($parsedFrame['data'], $frame_offset, 8);
+			$frame_offset += 8;
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_contacturl = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+
+			$frame_receivedasid = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding), $frame_offset);
+			if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+				$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+			}
+			$frame_sellername = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_sellername) === 0) {
+				$frame_sellername = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding));
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], $this-&gt;TextEncodingTerminatorLookup($frame_textencoding), $frame_offset);
+			if (ord(substr($parsedFrame['data'], $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding)), 1)) === 0) {
+				$frame_terminatorpos++; // strpos() fooled because 2nd byte of Unicode chars are often 0x00
+			}
+			$frame_description = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_description) === 0) {
+				$frame_description = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen($this-&gt;TextEncodingTerminatorLookup($frame_textencoding));
+
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_mimetype = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+
+			$frame_sellerlogo = substr($parsedFrame['data'], $frame_offset);
+
+			$parsedFrame['encodingid']        = $frame_textencoding;
+			$parsedFrame['encoding']          = $this-&gt;TextEncodingNameLookup($frame_textencoding);
+
+			$parsedFrame['pricevaliduntil']   = $frame_datestring;
+			$parsedFrame['contacturl']        = $frame_contacturl;
+			$parsedFrame['receivedasid']      = $frame_receivedasid;
+			$parsedFrame['receivedas']        = $this-&gt;COMRReceivedAsLookup($frame_receivedasid);
+			$parsedFrame['sellername']        = $frame_sellername;
+			$parsedFrame['description']       = $frame_description;
+			$parsedFrame['mime']              = $frame_mimetype;
+			$parsedFrame['logo']              = $frame_sellerlogo;
+			unset($parsedFrame['data']);
+
+
+		} elseif (($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'ENCR')) { // 4.25  ENCR Encryption method registration (ID3v2.3+ only)
+			//   There may be several 'ENCR' frames in a tag,
+			//   but only one containing the same symbol
+			//   and only one containing the same owner identifier
+			// &lt;Header for 'Encryption method registration', ID: 'ENCR'&gt;
+			// Owner identifier    &lt;text string&gt; $00
+			// Method symbol       $xx
+			// Encryption data     &lt;binary data&gt;
+
+			$frame_offset = 0;
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_ownerid = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_ownerid) === 0) {
+				$frame_ownerid = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+
+			$parsedFrame['ownerid']      = $frame_ownerid;
+			$parsedFrame['methodsymbol'] = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['data']         = (string) substr($parsedFrame['data'], $frame_offset);
+
+
+		} elseif (($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'GRID')) { // 4.26  GRID Group identification registration (ID3v2.3+ only)
+
+			//   There may be several 'GRID' frames in a tag,
+			//   but only one containing the same symbol
+			//   and only one containing the same owner identifier
+			// &lt;Header for 'Group ID registration', ID: 'GRID'&gt;
+			// Owner identifier      &lt;text string&gt; $00
+			// Group symbol          $xx
+			// Group dependent data  &lt;binary data&gt;
+
+			$frame_offset = 0;
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_ownerid = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_ownerid) === 0) {
+				$frame_ownerid = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+
+			$parsedFrame['ownerid']       = $frame_ownerid;
+			$parsedFrame['groupsymbol']   = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['data']          = (string) substr($parsedFrame['data'], $frame_offset);
+
+
+		} elseif (($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'PRIV')) { // 4.27  PRIV Private frame (ID3v2.3+ only)
+			//   The tag may contain more than one 'PRIV' frame
+			//   but only with different contents
+			// &lt;Header for 'Private frame', ID: 'PRIV'&gt;
+			// Owner identifier      &lt;text string&gt; $00
+			// The private data      &lt;binary data&gt;
+
+			$frame_offset = 0;
+			$frame_terminatorpos = strpos($parsedFrame['data'], &quot;\x00&quot;, $frame_offset);
+			$frame_ownerid = substr($parsedFrame['data'], $frame_offset, $frame_terminatorpos - $frame_offset);
+			if (ord($frame_ownerid) === 0) {
+				$frame_ownerid = '';
+			}
+			$frame_offset = $frame_terminatorpos + strlen(&quot;\x00&quot;);
+
+			$parsedFrame['ownerid'] = $frame_ownerid;
+			$parsedFrame['data']    = (string) substr($parsedFrame['data'], $frame_offset);
+
+
+		} elseif (($id3v2_majorversion &gt;= 4) &amp;&amp; ($parsedFrame['frame_name'] == 'SIGN')) { // 4.28  SIGN Signature frame (ID3v2.4+ only)
+			//   There may be more than one 'signature frame' in a tag,
+			//   but no two may be identical
+			// &lt;Header for 'Signature frame', ID: 'SIGN'&gt;
+			// Group symbol      $xx
+			// Signature         &lt;binary data&gt;
+
+			$frame_offset = 0;
+			$parsedFrame['groupsymbol'] = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$parsedFrame['data']        = (string) substr($parsedFrame['data'], $frame_offset);
+
+
+		} elseif (($id3v2_majorversion &gt;= 4) &amp;&amp; ($parsedFrame['frame_name'] == 'SEEK')) { // 4.29  SEEK Seek frame (ID3v2.4+ only)
+			//   There may only be one 'seek frame' in a tag
+			// &lt;Header for 'Seek frame', ID: 'SEEK'&gt;
+			// Minimum offset to next tag       $xx xx xx xx
+
+			$frame_offset = 0;
+			$parsedFrame['data']          = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 4));
+
+
+		} elseif (($id3v2_majorversion &gt;= 4) &amp;&amp; ($parsedFrame['frame_name'] == 'ASPI')) { // 4.30  ASPI Audio seek point index (ID3v2.4+ only)
+			//   There may only be one 'audio seek point index' frame in a tag
+			// &lt;Header for 'Seek Point Index', ID: 'ASPI'&gt;
+			// Indexed data start (S)         $xx xx xx xx
+			// Indexed data length (L)        $xx xx xx xx
+			// Number of index points (N)     $xx xx
+			// Bits per index point (b)       $xx
+			//   Then for every index point the following data is included:
+			// Fraction at index (Fi)          $xx (xx)
+
+			$frame_offset = 0;
+			$parsedFrame['datastart'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 4));
+			$frame_offset += 4;
+			$parsedFrame['indexeddatalength'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 4));
+			$frame_offset += 4;
+			$parsedFrame['indexpoints'] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, 2));
+			$frame_offset += 2;
+			$parsedFrame['bitsperpoint'] = ord(substr($parsedFrame['data'], $frame_offset++, 1));
+			$frame_bytesperpoint = ceil($parsedFrame['bitsperpoint'] / 8);
+			for ($i = 0; $i &lt; $frame_indexpoints; $i++) {
+				$parsedFrame['indexes'][$i] = getid3_lib::BigEndian2Int(substr($parsedFrame['data'], $frame_offset, $frame_bytesperpoint));
+				$frame_offset += $frame_bytesperpoint;
+			}
+			unset($parsedFrame['data']);
+
+		} elseif (($id3v2_majorversion &gt;= 3) &amp;&amp; ($parsedFrame['frame_name'] == 'RGAD')) { // Replay Gain Adjustment
+			// <A HREF="http://privatewww.essex.ac.uk/~djmrob/replaygain/file_format_id3v2.html">http://privatewww.essex.ac.uk/~djmrob/replaygain/file_format_id3v2.html</A>
+			//   There may only be one 'RGAD' frame in a tag
+			// &lt;Header for 'Replay Gain Adjustment', ID: 'RGAD'&gt;
+			// Peak Amplitude                      $xx $xx $xx $xx
+			// Radio Replay Gain Adjustment        %aaabbbcd %dddddddd
+			// Audiophile Replay Gain Adjustment   %aaabbbcd %dddddddd
+			//   a - name code
+			//   b - originator code
+			//   c - sign bit
+			//   d - replay gain adjustment
+
+			$frame_offset = 0;
+			$parsedFrame['peakamplitude'] = getid3_lib::BigEndian2Float(substr($parsedFrame['data'], $frame_offset, 4));
+			$frame_offset += 4;
+			$rg_track_adjustment = getid3_lib::Dec2Bin(substr($parsedFrame['data'], $frame_offset, 2));
+			$frame_offset += 2;
+			$rg_album_adjustment = getid3_lib::Dec2Bin(substr($parsedFrame['data'], $frame_offset, 2));
+			$frame_offset += 2;
+			$parsedFrame['raw']['track']['name']       = getid3_lib::Bin2Dec(substr($rg_track_adjustment, 0, 3));
+			$parsedFrame['raw']['track']['originator'] = getid3_lib::Bin2Dec(substr($rg_track_adjustment, 3, 3));
+			$parsedFrame['raw']['track']['signbit']    = getid3_lib::Bin2Dec(substr($rg_track_adjustment, 6, 1));
+			$parsedFrame['raw']['track']['adjustment'] = getid3_lib::Bin2Dec(substr($rg_track_adjustment, 7, 9));
+			$parsedFrame['raw']['album']['name']       = getid3_lib::Bin2Dec(substr($rg_album_adjustment, 0, 3));
+			$parsedFrame['raw']['album']['originator'] = getid3_lib::Bin2Dec(substr($rg_album_adjustment, 3, 3));
+			$parsedFrame['raw']['album']['signbit']    = getid3_lib::Bin2Dec(substr($rg_album_adjustment, 6, 1));
+			$parsedFrame['raw']['album']['adjustment'] = getid3_lib::Bin2Dec(substr($rg_album_adjustment, 7, 9));
+			$parsedFrame['track']['name']       = getid3_lib::RGADnameLookup($parsedFrame['raw']['track']['name']);
+			$parsedFrame['track']['originator'] = getid3_lib::RGADoriginatorLookup($parsedFrame['raw']['track']['originator']);
+			$parsedFrame['track']['adjustment'] = getid3_lib::RGADadjustmentLookup($parsedFrame['raw']['track']['adjustment'], $parsedFrame['raw']['track']['signbit']);
+			$parsedFrame['album']['name']       = getid3_lib::RGADnameLookup($parsedFrame['raw']['album']['name']);
+			$parsedFrame['album']['originator'] = getid3_lib::RGADoriginatorLookup($parsedFrame['raw']['album']['originator']);
+			$parsedFrame['album']['adjustment'] = getid3_lib::RGADadjustmentLookup($parsedFrame['raw']['album']['adjustment'], $parsedFrame['raw']['album']['signbit']);
+
+			$ThisFileInfo['replay_gain']['track']['peak']       = $parsedFrame['peakamplitude'];
+			$ThisFileInfo['replay_gain']['track']['originator'] = $parsedFrame['track']['originator'];
+			$ThisFileInfo['replay_gain']['track']['adjustment'] = $parsedFrame['track']['adjustment'];
+			$ThisFileInfo['replay_gain']['album']['originator'] = $parsedFrame['album']['originator'];
+			$ThisFileInfo['replay_gain']['album']['adjustment'] = $parsedFrame['album']['adjustment'];
+
+			unset($parsedFrame['data']);
+
+		}
+
+		return true;
+	}
+
+
+	function DeUnsynchronise($data) {
+		return str_replace(&quot;\xFF\x00&quot;, &quot;\xFF&quot;, $data);
+	}
+
+	function LookupCurrencyUnits($currencyid) {
+
+		$begin = __LINE__;
+
+		/** This is not a comment!
+
+
+			AED	Dirhams
+			AFA	Afghanis
+			ALL	Leke
+			AMD	Drams
+			ANG	Guilders
+			AOA	Kwanza
+			ARS	Pesos
+			ATS	Schillings
+			AUD	Dollars
+			AWG	Guilders
+			AZM	Manats
+			BAM	Convertible Marka
+			BBD	Dollars
+			BDT	Taka
+			BEF	Francs
+			BGL	Leva
+			BHD	Dinars
+			BIF	Francs
+			BMD	Dollars
+			BND	Dollars
+			BOB	Bolivianos
+			BRL	Brazil Real
+			BSD	Dollars
+			BTN	Ngultrum
+			BWP	Pulas
+			BYR	Rubles
+			BZD	Dollars
+			CAD	Dollars
+			CDF	Congolese Francs
+			CHF	Francs
+			CLP	Pesos
+			CNY	Yuan Renminbi
+			COP	Pesos
+			CRC	Colones
+			CUP	Pesos
+			CVE	Escudos
+			CYP	Pounds
+			CZK	Koruny
+			DEM	Deutsche Marks
+			DJF	Francs
+			DKK	Kroner
+			DOP	Pesos
+			DZD	Algeria Dinars
+			EEK	Krooni
+			EGP	Pounds
+			ERN	Nakfa
+			ESP	Pesetas
+			ETB	Birr
+			EUR	Euro
+			FIM	Markkaa
+			FJD	Dollars
+			FKP	Pounds
+			FRF	Francs
+			GBP	Pounds
+			GEL	Lari
+			GGP	Pounds
+			GHC	Cedis
+			GIP	Pounds
+			GMD	Dalasi
+			GNF	Francs
+			GRD	Drachmae
+			GTQ	Quetzales
+			GYD	Dollars
+			HKD	Dollars
+			HNL	Lempiras
+			HRK	Kuna
+			HTG	Gourdes
+			HUF	Forints
+			IDR	Rupiahs
+			IEP	Pounds
+			ILS	New Shekels
+			IMP	Pounds
+			INR	Rupees
+			IQD	Dinars
+			IRR	Rials
+			ISK	Kronur
+			ITL	Lire
+			JEP	Pounds
+			JMD	Dollars
+			JOD	Dinars
+			JPY	Yen
+			KES	Shillings
+			KGS	Soms
+			KHR	Riels
+			KMF	Francs
+			KPW	Won
+			KWD	Dinars
+			KYD	Dollars
+			KZT	Tenge
+			LAK	Kips
+			LBP	Pounds
+			LKR	Rupees
+			LRD	Dollars
+			LSL	Maloti
+			LTL	Litai
+			LUF	Francs
+			LVL	Lati
+			LYD	Dinars
+			MAD	Dirhams
+			MDL	Lei
+			MGF	Malagasy Francs
+			MKD	Denars
+			MMK	Kyats
+			MNT	Tugriks
+			MOP	Patacas
+			MRO	Ouguiyas
+			MTL	Liri
+			MUR	Rupees
+			MVR	Rufiyaa
+			MWK	Kwachas
+			MXN	Pesos
+			MYR	Ringgits
+			MZM	Meticais
+			NAD	Dollars
+			NGN	Nairas
+			NIO	Gold Cordobas
+			NLG	Guilders
+			NOK	Krone
+			NPR	Nepal Rupees
+			NZD	Dollars
+			OMR	Rials
+			PAB	Balboa
+			PEN	Nuevos Soles
+			PGK	Kina
+			PHP	Pesos
+			PKR	Rupees
+			PLN	Zlotych
+			PTE	Escudos
+			PYG	Guarani
+			QAR	Rials
+			ROL	Lei
+			RUR	Rubles
+			RWF	Rwanda Francs
+			SAR	Riyals
+			SBD	Dollars
+			SCR	Rupees
+			SDD	Dinars
+			SEK	Kronor
+			SGD	Dollars
+			SHP	Pounds
+			SIT	Tolars
+			SKK	Koruny
+			SLL	Leones
+			SOS	Shillings
+			SPL	Luigini
+			SRG	Guilders
+			STD	Dobras
+			SVC	Colones
+			SYP	Pounds
+			SZL	Emalangeni
+			THB	Baht
+			TJR	Rubles
+			TMM	Manats
+			TND	Dinars
+			TOP	Pa'anga
+			TRL	Liras
+			TTD	Dollars
+			TVD	Tuvalu Dollars
+			TWD	New Dollars
+			TZS	Shillings
+			UAH	Hryvnia
+			UGX	Shillings
+			USD	Dollars
+			UYU	Pesos
+			UZS	Sums
+			VAL	Lire
+			VEB	Bolivares
+			VND	Dong
+			VUV	Vatu
+			WST	Tala
+			XAF	Francs
+			XAG	Ounces
+			XAU	Ounces
+			XCD	Dollars
+			XDR	Special Drawing Rights
+			XPD	Ounces
+			XPF	Francs
+			XPT	Ounces
+			YER	Rials
+			YUM	New Dinars
+			ZAR	Rand
+			ZMK	Kwacha
+			ZWD	Zimbabwe Dollars
+
+		*/
+
+		return getid3_lib::EmbeddedLookup($currencyid, $begin, __LINE__, __FILE__, 'id3v2-currency-units');
+	}
+
+
+	function LookupCurrencyCountry($currencyid) {
+
+		$begin = __LINE__;
+
+		/** This is not a comment!
+
+			AED	United Arab Emirates
+			AFA	Afghanistan
+			ALL	Albania
+			AMD	Armenia
+			ANG	Netherlands Antilles
+			AOA	Angola
+			ARS	Argentina
+			ATS	Austria
+			AUD	Australia
+			AWG	Aruba
+			AZM	Azerbaijan
+			BAM	Bosnia and Herzegovina
+			BBD	Barbados
+			BDT	Bangladesh
+			BEF	Belgium
+			BGL	Bulgaria
+			BHD	Bahrain
+			BIF	Burundi
+			BMD	Bermuda
+			BND	Brunei Darussalam
+			BOB	Bolivia
+			BRL	Brazil
+			BSD	Bahamas
+			BTN	Bhutan
+			BWP	Botswana
+			BYR	Belarus
+			BZD	Belize
+			CAD	Canada
+			CDF	Congo/Kinshasa
+			CHF	Switzerland
+			CLP	Chile
+			CNY	China
+			COP	Colombia
+			CRC	Costa Rica
+			CUP	Cuba
+			CVE	Cape Verde
+			CYP	Cyprus
+			CZK	Czech Republic
+			DEM	Germany
+			DJF	Djibouti
+			DKK	Denmark
+			DOP	Dominican Republic
+			DZD	Algeria
+			EEK	Estonia
+			EGP	Egypt
+			ERN	Eritrea
+			ESP	Spain
+			ETB	Ethiopia
+			EUR	Euro Member Countries
+			FIM	Finland
+			FJD	Fiji
+			FKP	Falkland Islands (Malvinas)
+			FRF	France
+			GBP	United Kingdom
+			GEL	Georgia
+			GGP	Guernsey
+			GHC	Ghana
+			GIP	Gibraltar
+			GMD	Gambia
+			GNF	Guinea
+			GRD	Greece
+			GTQ	Guatemala
+			GYD	Guyana
+			HKD	Hong Kong
+			HNL	Honduras
+			HRK	Croatia
+			HTG	Haiti
+			HUF	Hungary
+			IDR	Indonesia
+			IEP	Ireland (Eire)
+			ILS	Israel
+			IMP	Isle of Man
+			INR	India
+			IQD	Iraq
+			IRR	Iran
+			ISK	Iceland
+			ITL	Italy
+			JEP	Jersey
+			JMD	Jamaica
+			JOD	Jordan
+			JPY	Japan
+			KES	Kenya
+			KGS	Kyrgyzstan
+			KHR	Cambodia
+			KMF	Comoros
+			KPW	Korea
+			KWD	Kuwait
+			KYD	Cayman Islands
+			KZT	Kazakstan
+			LAK	Laos
+			LBP	Lebanon
+			LKR	Sri Lanka
+			LRD	Liberia
+			LSL	Lesotho
+			LTL	Lithuania
+			LUF	Luxembourg
+			LVL	Latvia
+			LYD	Libya
+			MAD	Morocco
+			MDL	Moldova
+			MGF	Madagascar
+			MKD	Macedonia
+			MMK	Myanmar (Burma)
+			MNT	Mongolia
+			MOP	Macau
+			MRO	Mauritania
+			MTL	Malta
+			MUR	Mauritius
+			MVR	Maldives (Maldive Islands)
+			MWK	Malawi
+			MXN	Mexico
+			MYR	Malaysia
+			MZM	Mozambique
+			NAD	Namibia
+			NGN	Nigeria
+			NIO	Nicaragua
+			NLG	Netherlands (Holland)
+			NOK	Norway
+			NPR	Nepal
+			NZD	New Zealand
+			OMR	Oman
+			PAB	Panama
+			PEN	Peru
+			PGK	Papua New Guinea
+			PHP	Philippines
+			PKR	Pakistan
+			PLN	Poland
+			PTE	Portugal
+			PYG	Paraguay
+			QAR	Qatar
+			ROL	Romania
+			RUR	Russia
+			RWF	Rwanda
+			SAR	Saudi Arabia
+			SBD	Solomon Islands
+			SCR	Seychelles
+			SDD	Sudan
+			SEK	Sweden
+			SGD	Singapore
+			SHP	Saint Helena
+			SIT	Slovenia
+			SKK	Slovakia
+			SLL	Sierra Leone
+			SOS	Somalia
+			SPL	Seborga
+			SRG	Suriname
+			STD	S&#227;o Tome and Principe
+			SVC	El Salvador
+			SYP	Syria
+			SZL	Swaziland
+			THB	Thailand
+			TJR	Tajikistan
+			TMM	Turkmenistan
+			TND	Tunisia
+			TOP	Tonga
+			TRL	Turkey
+			TTD	Trinidad and Tobago
+			TVD	Tuvalu
+			TWD	Taiwan
+			TZS	Tanzania
+			UAH	Ukraine
+			UGX	Uganda
+			USD	United States of America
+			UYU	Uruguay
+			UZS	Uzbekistan
+			VAL	Vatican City
+			VEB	Venezuela
+			VND	Viet Nam
+			VUV	Vanuatu
+			WST	Samoa
+			XAF	Communaut&#233; Financi&#232;re Africaine
+			XAG	Silver
+			XAU	Gold
+			XCD	East Caribbean
+			XDR	International Monetary Fund
+			XPD	Palladium
+			XPF	Comptoirs Fran&#231;ais du Pacifique
+			XPT	Platinum
+			YER	Yemen
+			YUM	Yugoslavia
+			ZAR	South Africa
+			ZMK	Zambia
+			ZWD	Zimbabwe
+
+		*/
+
+		return getid3_lib::EmbeddedLookup($currencyid, $begin, __LINE__, __FILE__, 'id3v2-currency-country');
+	}
+
+
+
+	function LanguageLookup($languagecode, $casesensitive=false) {
+
+		if (!$casesensitive) {
+			$languagecode = strtolower($languagecode);
+		}
+
+		// <A HREF="http://www.id3.org/id3v2.4.0-structure.txt">http://www.id3.org/id3v2.4.0-structure.txt</A>
+		// [4.   ID3v2 frame overview]
+		// The three byte language field, present in several frames, is used to
+		// describe the language of the frame's content, according to ISO-639-2
+		// [ISO-639-2]. The language should be represented in lower case. If the
+		// language is not known the string &quot;XXX&quot; should be used.
+
+
+		// ISO 639-2 - <A HREF="http://www.id3.org/iso639-2.html">http://www.id3.org/iso639-2.html</A>
+
+		$begin = __LINE__;
+
+		/** This is not a comment!
+
+			XXX	unknown
+			xxx	unknown
+			aar	Afar
+			abk	Abkhazian
+			ace	Achinese
+			ach	Acoli
+			ada	Adangme
+			afa	Afro-Asiatic (Other)
+			afh	Afrihili
+			afr	Afrikaans
+			aka	Akan
+			akk	Akkadian
+			alb	Albanian
+			ale	Aleut
+			alg	Algonquian Languages
+			amh	Amharic
+			ang	English, Old (ca. 450-1100)
+			apa	Apache Languages
+			ara	Arabic
+			arc	Aramaic
+			arm	Armenian
+			arn	Araucanian
+			arp	Arapaho
+			art	Artificial (Other)
+			arw	Arawak
+			asm	Assamese
+			ath	Athapascan Languages
+			ava	Avaric
+			ave	Avestan
+			awa	Awadhi
+			aym	Aymara
+			aze	Azerbaijani
+			bad	Banda
+			bai	Bamileke Languages
+			bak	Bashkir
+			bal	Baluchi
+			bam	Bambara
+			ban	Balinese
+			baq	Basque
+			bas	Basa
+			bat	Baltic (Other)
+			bej	Beja
+			bel	Byelorussian
+			bem	Bemba
+			ben	Bengali
+			ber	Berber (Other)
+			bho	Bhojpuri
+			bih	Bihari
+			bik	Bikol
+			bin	Bini
+			bis	Bislama
+			bla	Siksika
+			bnt	Bantu (Other)
+			bod	Tibetan
+			bra	Braj
+			bre	Breton
+			bua	Buriat
+			bug	Buginese
+			bul	Bulgarian
+			bur	Burmese
+			cad	Caddo
+			cai	Central American Indian (Other)
+			car	Carib
+			cat	Catalan
+			cau	Caucasian (Other)
+			ceb	Cebuano
+			cel	Celtic (Other)
+			ces	Czech
+			cha	Chamorro
+			chb	Chibcha
+			che	Chechen
+			chg	Chagatai
+			chi	Chinese
+			chm	Mari
+			chn	Chinook jargon
+			cho	Choctaw
+			chr	Cherokee
+			chu	Church Slavic
+			chv	Chuvash
+			chy	Cheyenne
+			cop	Coptic
+			cor	Cornish
+			cos	Corsican
+			cpe	Creoles and Pidgins, English-based (Other)
+			cpf	Creoles and Pidgins, French-based (Other)
+			cpp	Creoles and Pidgins, Portuguese-based (Other)
+			cre	Cree
+			crp	Creoles and Pidgins (Other)
+			cus	Cushitic (Other)
+			cym	Welsh
+			cze	Czech
+			dak	Dakota
+			dan	Danish
+			del	Delaware
+			deu	German
+			din	Dinka
+			div	Divehi
+			doi	Dogri
+			dra	Dravidian (Other)
+			dua	Duala
+			dum	Dutch, Middle (ca. 1050-1350)
+			dut	Dutch
+			dyu	Dyula
+			dzo	Dzongkha
+			efi	Efik
+			egy	Egyptian (Ancient)
+			eka	Ekajuk
+			ell	Greek, Modern (1453-)
+			elx	Elamite
+			eng	English
+			enm	English, Middle (ca. 1100-1500)
+			epo	Esperanto
+			esk	Eskimo (Other)
+			esl	Spanish
+			est	Estonian
+			eus	Basque
+			ewe	Ewe
+			ewo	Ewondo
+			fan	Fang
+			fao	Faroese
+			fas	Persian
+			fat	Fanti
+			fij	Fijian
+			fin	Finnish
+			fiu	Finno-Ugrian (Other)
+			fon	Fon
+			fra	French
+			fre	French
+			frm	French, Middle (ca. 1400-1600)
+			fro	French, Old (842- ca. 1400)
+			fry	Frisian
+			ful	Fulah
+			gaa	Ga
+			gae	Gaelic (Scots)
+			gai	Irish
+			gay	Gayo
+			gdh	Gaelic (Scots)
+			gem	Germanic (Other)
+			geo	Georgian
+			ger	German
+			gez	Geez
+			gil	Gilbertese
+			glg	Gallegan
+			gmh	German, Middle High (ca. 1050-1500)
+			goh	German, Old High (ca. 750-1050)
+			gon	Gondi
+			got	Gothic
+			grb	Grebo
+			grc	Greek, Ancient (to 1453)
+			gre	Greek, Modern (1453-)
+			grn	Guarani
+			guj	Gujarati
+			hai	Haida
+			hau	Hausa
+			haw	Hawaiian
+			heb	Hebrew
+			her	Herero
+			hil	Hiligaynon
+			him	Himachali
+			hin	Hindi
+			hmo	Hiri Motu
+			hun	Hungarian
+			hup	Hupa
+			hye	Armenian
+			iba	Iban
+			ibo	Igbo
+			ice	Icelandic
+			ijo	Ijo
+			iku	Inuktitut
+			ilo	Iloko
+			ina	Interlingua (International Auxiliary language Association)
+			inc	Indic (Other)
+			ind	Indonesian
+			ine	Indo-European (Other)
+			ine	Interlingue
+			ipk	Inupiak
+			ira	Iranian (Other)
+			iri	Irish
+			iro	Iroquoian uages
+			isl	Icelandic
+			ita	Italian
+			jav	Javanese
+			jaw	Javanese
+			jpn	Japanese
+			jpr	Judeo-Persian
+			jrb	Judeo-Arabic
+			kaa	Kara-Kalpak
+			kab	Kabyle
+			kac	Kachin
+			kal	Greenlandic
+			kam	Kamba
+			kan	Kannada
+			kar	Karen
+			kas	Kashmiri
+			kat	Georgian
+			kau	Kanuri
+			kaw	Kawi
+			kaz	Kazakh
+			kha	Khasi
+			khi	Khoisan (Other)
+			khm	Khmer
+			kho	Khotanese
+			kik	Kikuyu
+			kin	Kinyarwanda
+			kir	Kirghiz
+			kok	Konkani
+			kom	Komi
+			kon	Kongo
+			kor	Korean
+			kpe	Kpelle
+			kro	Kru
+			kru	Kurukh
+			kua	Kuanyama
+			kum	Kumyk
+			kur	Kurdish
+			kus	Kusaie
+			kut	Kutenai
+			lad	Ladino
+			lah	Lahnda
+			lam	Lamba
+			lao	Lao
+			lat	Latin
+			lav	Latvian
+			lez	Lezghian
+			lin	Lingala
+			lit	Lithuanian
+			lol	Mongo
+			loz	Lozi
+			ltz	Letzeburgesch
+			lub	Luba-Katanga
+			lug	Ganda
+			lui	Luiseno
+			lun	Lunda
+			luo	Luo (Kenya and Tanzania)
+			mac	Macedonian
+			mad	Madurese
+			mag	Magahi
+			mah	Marshall
+			mai	Maithili
+			mak	Macedonian
+			mak	Makasar
+			mal	Malayalam
+			man	Mandingo
+			mao	Maori
+			map	Austronesian (Other)
+			mar	Marathi
+			mas	Masai
+			max	Manx
+			may	Malay
+			men	Mende
+			mga	Irish, Middle (900 - 1200)
+			mic	Micmac
+			min	Minangkabau
+			mis	Miscellaneous (Other)
+			mkh	Mon-Kmer (Other)
+			mlg	Malagasy
+			mlt	Maltese
+			mni	Manipuri
+			mno	Manobo Languages
+			moh	Mohawk
+			mol	Moldavian
+			mon	Mongolian
+			mos	Mossi
+			mri	Maori
+			msa	Malay
+			mul	Multiple Languages
+			mun	Munda Languages
+			mus	Creek
+			mwr	Marwari
+			mya	Burmese
+			myn	Mayan Languages
+			nah	Aztec
+			nai	North American Indian (Other)
+			nau	Nauru
+			nav	Navajo
+			nbl	Ndebele, South
+			nde	Ndebele, North
+			ndo	Ndongo
+			nep	Nepali
+			new	Newari
+			nic	Niger-Kordofanian (Other)
+			niu	Niuean
+			nla	Dutch
+			nno	Norwegian (Nynorsk)
+			non	Norse, Old
+			nor	Norwegian
+			nso	Sotho, Northern
+			nub	Nubian Languages
+			nya	Nyanja
+			nym	Nyamwezi
+			nyn	Nyankole
+			nyo	Nyoro
+			nzi	Nzima
+			oci	Langue d'Oc (post 1500)
+			oji	Ojibwa
+			ori	Oriya
+			orm	Oromo
+			osa	Osage
+			oss	Ossetic
+			ota	Turkish, Ottoman (1500 - 1928)
+			oto	Otomian Languages
+			paa	Papuan-Australian (Other)
+			pag	Pangasinan
+			pal	Pahlavi
+			pam	Pampanga
+			pan	Panjabi
+			pap	Papiamento
+			pau	Palauan
+			peo	Persian, Old (ca 600 - 400 B.C.)
+			per	Persian
+			phn	Phoenician
+			pli	Pali
+			pol	Polish
+			pon	Ponape
+			por	Portuguese
+			pra	Prakrit uages
+			pro	Provencal, Old (to 1500)
+			pus	Pushto
+			que	Quechua
+			raj	Rajasthani
+			rar	Rarotongan
+			roa	Romance (Other)
+			roh	Rhaeto-Romance
+			rom	Romany
+			ron	Romanian
+			rum	Romanian
+			run	Rundi
+			rus	Russian
+			sad	Sandawe
+			sag	Sango
+			sah	Yakut
+			sai	South American Indian (Other)
+			sal	Salishan Languages
+			sam	Samaritan Aramaic
+			san	Sanskrit
+			sco	Scots
+			scr	Serbo-Croatian
+			sel	Selkup
+			sem	Semitic (Other)
+			sga	Irish, Old (to 900)
+			shn	Shan
+			sid	Sidamo
+			sin	Singhalese
+			sio	Siouan Languages
+			sit	Sino-Tibetan (Other)
+			sla	Slavic (Other)
+			slk	Slovak
+			slo	Slovak
+			slv	Slovenian
+			smi	Sami Languages
+			smo	Samoan
+			sna	Shona
+			snd	Sindhi
+			sog	Sogdian
+			som	Somali
+			son	Songhai
+			sot	Sotho, Southern
+			spa	Spanish
+			sqi	Albanian
+			srd	Sardinian
+			srr	Serer
+			ssa	Nilo-Saharan (Other)
+			ssw	Siswant
+			ssw	Swazi
+			suk	Sukuma
+			sun	Sudanese
+			sus	Susu
+			sux	Sumerian
+			sve	Swedish
+			swa	Swahili
+			swe	Swedish
+			syr	Syriac
+			tah	Tahitian
+			tam	Tamil
+			tat	Tatar
+			tel	Telugu
+			tem	Timne
+			ter	Tereno
+			tgk	Tajik
+			tgl	Tagalog
+			tha	Thai
+			tib	Tibetan
+			tig	Tigre
+			tir	Tigrinya
+			tiv	Tivi
+			tli	Tlingit
+			tmh	Tamashek
+			tog	Tonga (Nyasa)
+			ton	Tonga (Tonga Islands)
+			tru	Truk
+			tsi	Tsimshian
+			tsn	Tswana
+			tso	Tsonga
+			tuk	Turkmen
+			tum	Tumbuka
+			tur	Turkish
+			tut	Altaic (Other)
+			twi	Twi
+			tyv	Tuvinian
+			uga	Ugaritic
+			uig	Uighur
+			ukr	Ukrainian
+			umb	Umbundu
+			und	Undetermined
+			urd	Urdu
+			uzb	Uzbek
+			vai	Vai
+			ven	Venda
+			vie	Vietnamese
+			vol	Volap&#252;k
+			vot	Votic
+			wak	Wakashan Languages
+			wal	Walamo
+			war	Waray
+			was	Washo
+			wel	Welsh
+			wen	Sorbian Languages
+			wol	Wolof
+			xho	Xhosa
+			yao	Yao
+			yap	Yap
+			yid	Yiddish
+			yor	Yoruba
+			zap	Zapotec
+			zen	Zenaga
+			zha	Zhuang
+			zho	Chinese
+			zul	Zulu
+			zun	Zuni
+
+		*/
+
+		return getid3_lib::EmbeddedLookup($languagecode, $begin, __LINE__, __FILE__, 'id3v2-languagecode');
+	}
+
+
+	function ETCOEventLookup($index) {
+        if (($index &gt;= 0x17) &amp;&amp; ($index &lt;= 0xDF)) {
+		    return 'reserved for future use';
+	    }
+		if (($index &gt;= 0xE0) &amp;&amp; ($index &lt;= 0xEF)) {
+			return 'not predefined synch 0-F';
+		}
+		if (($index &gt;= 0xF0) &amp;&amp; ($index &lt;= 0xFC)) {
+			return 'reserved for future use';
+		}
+
+		static $EventLookup = array(
+			0x00 =&gt; 'padding (has no meaning)',
+			0x01 =&gt; 'end of initial silence',
+			0x02 =&gt; 'intro start',
+			0x03 =&gt; 'main part start',
+			0x04 =&gt; 'outro start',
+			0x05 =&gt; 'outro end',
+			0x06 =&gt; 'verse start',
+			0x07 =&gt; 'refrain start',
+			0x08 =&gt; 'interlude start',
+			0x09 =&gt; 'theme start',
+			0x0A =&gt; 'variation start',
+			0x0B =&gt; 'key change',
+			0x0C =&gt; 'time change',
+			0x0D =&gt; 'momentary unwanted noise (Snap, Crackle &amp; Pop)',
+			0x0E =&gt; 'sustained noise',
+			0x0F =&gt; 'sustained noise end',
+			0x10 =&gt; 'intro end',
+			0x11 =&gt; 'main part end',
+			0x12 =&gt; 'verse end',
+			0x13 =&gt; 'refrain end',
+			0x14 =&gt; 'theme end',
+			0x15 =&gt; 'profanity',
+			0x16 =&gt; 'profanity end',
+			0xFD =&gt; 'audio end (start of silence)',
+			0xFE =&gt; 'audio file ends',
+			0xFF =&gt; 'one more byte of events follows'
+		);
+
+		return (isset($EventLookup[$index]) ? $EventLookup[$index] : '');
+	}
+
+	function SYTLContentTypeLookup($index) {
+		static $SYTLContentTypeLookup = array(
+			0x00 =&gt; 'other',
+			0x01 =&gt; 'lyrics',
+			0x02 =&gt; 'text transcription',
+			0x03 =&gt; 'movement/part name', // (e.g. 'Adagio')
+			0x04 =&gt; 'events',             // (e.g. 'Don Quijote enters the stage')
+			0x05 =&gt; 'chord',              // (e.g. 'Bb F Fsus')
+			0x06 =&gt; 'trivia/\'pop up\' information',
+			0x07 =&gt; 'URLs to webpages',
+			0x08 =&gt; 'URLs to images'
+		);
+
+		return (isset($SYTLContentTypeLookup[$index]) ? $SYTLContentTypeLookup[$index] : '');
+	}
+
+	function APICPictureTypeLookup($index, $returnarray=false) {
+		static $APICPictureTypeLookup = array(
+			0x00 =&gt; 'Other',
+			0x01 =&gt; '32x32 pixels \'file icon\' (PNG only)',
+			0x02 =&gt; 'Other file icon',
+			0x03 =&gt; 'Cover (front)',
+			0x04 =&gt; 'Cover (back)',
+			0x05 =&gt; 'Leaflet page',
+			0x06 =&gt; 'Media (e.g. label side of CD)',
+			0x07 =&gt; 'Lead artist/lead performer/soloist',
+			0x08 =&gt; 'Artist/performer',
+			0x09 =&gt; 'Conductor',
+			0x0A =&gt; 'Band/Orchestra',
+			0x0B =&gt; 'Composer',
+			0x0C =&gt; 'Lyricist/text writer',
+			0x0D =&gt; 'Recording Location',
+			0x0E =&gt; 'During recording',
+			0x0F =&gt; 'During performance',
+			0x10 =&gt; 'Movie/video screen capture',
+			0x11 =&gt; 'A bright coloured fish',
+			0x12 =&gt; 'Illustration',
+			0x13 =&gt; 'Band/artist logotype',
+			0x14 =&gt; 'Publisher/Studio logotype'
+		);
+		if ($returnarray) {
+			return $APICPictureTypeLookup;
+		}
+		return (isset($APICPictureTypeLookup[$index]) ? $APICPictureTypeLookup[$index] : '');
+	}
+
+	function COMRReceivedAsLookup($index) {
+		static $COMRReceivedAsLookup = array(
+			0x00 =&gt; 'Other',
+			0x01 =&gt; 'Standard CD album with other songs',
+			0x02 =&gt; 'Compressed audio on CD',
+			0x03 =&gt; 'File over the Internet',
+			0x04 =&gt; 'Stream over the Internet',
+			0x05 =&gt; 'As note sheets',
+			0x06 =&gt; 'As note sheets in a book with other sheets',
+			0x07 =&gt; 'Music on other media',
+			0x08 =&gt; 'Non-musical merchandise'
+		);
+
+		return (isset($COMRReceivedAsLookup[$index]) ? $COMRReceivedAsLookup[$index] : '');
+	}
+
+	function RVA2ChannelTypeLookup($index) {
+		static $RVA2ChannelTypeLookup = array(
+			0x00 =&gt; 'Other',
+			0x01 =&gt; 'Master volume',
+			0x02 =&gt; 'Front right',
+			0x03 =&gt; 'Front left',
+			0x04 =&gt; 'Back right',
+			0x05 =&gt; 'Back left',
+			0x06 =&gt; 'Front centre',
+			0x07 =&gt; 'Back centre',
+			0x08 =&gt; 'Subwoofer'
+		);
+
+		return (isset($RVA2ChannelTypeLookup[$index]) ? $RVA2ChannelTypeLookup[$index] : '');
+	}
+
+	function FrameNameLongLookup($framename) {
+
+		$begin = __LINE__;
+
+		/** This is not a comment!
+
+			AENC	Audio encryption
+			APIC	Attached picture
+			ASPI	Audio seek point index
+			BUF	Recommended buffer size
+			CNT	Play counter
+			COM	Comments
+			COMM	Comments
+			COMR	Commercial frame
+			CRA	Audio encryption
+			CRM	Encrypted meta frame
+			ENCR	Encryption method registration
+			EQU	Equalisation
+			EQU2	Equalisation (2)
+			EQUA	Equalisation
+			ETC	Event timing codes
+			ETCO	Event timing codes
+			GEO	General encapsulated object
+			GEOB	General encapsulated object
+			GRID	Group identification registration
+			IPL	Involved people list
+			IPLS	Involved people list
+			LINK	Linked information
+			LNK	Linked information
+			MCDI	Music CD identifier
+			MCI	Music CD Identifier
+			MLL	MPEG location lookup table
+			MLLT	MPEG location lookup table
+			OWNE	Ownership frame
+			PCNT	Play counter
+			PIC	Attached picture
+			POP	Popularimeter
+			POPM	Popularimeter
+			POSS	Position synchronisation frame
+			PRIV	Private frame
+			RBUF	Recommended buffer size
+			REV	Reverb
+			RVA	Relative volume adjustment
+			RVA2	Relative volume adjustment (2)
+			RVAD	Relative volume adjustment
+			RVRB	Reverb
+			SEEK	Seek frame
+			SIGN	Signature frame
+			SLT	Synchronised lyric/text
+			STC	Synced tempo codes
+			SYLT	Synchronised lyric/text
+			SYTC	Synchronised tempo codes
+			TAL	Album/Movie/Show title
+			TALB	Album/Movie/Show title
+			TBP	BPM (Beats Per Minute)
+			TBPM	BPM (beats per minute)
+			TCM	Composer
+			TCO	Content type
+			TCOM	Composer
+			TCON	Content type
+			TCOP	Copyright message
+			TCR	Copyright message
+			TDA	Date
+			TDAT	Date
+			TDEN	Encoding time
+			TDLY	Playlist delay
+			TDOR	Original release time
+			TDRC	Recording time
+			TDRL	Release time
+			TDTG	Tagging time
+			TDY	Playlist delay
+			TEN	Encoded by
+			TENC	Encoded by
+			TEXT	Lyricist/Text writer
+			TFLT	File type
+			TFT	File type
+			TIM	Time
+			TIME	Time
+			TIPL	Involved people list
+			TIT1	Content group description
+			TIT2	Title/songname/content description
+			TIT3	Subtitle/Description refinement
+			TKE	Initial key
+			TKEY	Initial key
+			TLA	Language(s)
+			TLAN	Language(s)
+			TLE	Length
+			TLEN	Length
+			TMCL	Musician credits list
+			TMED	Media type
+			TMOO	Mood
+			TMT	Media type
+			TOA	Original artist(s)/performer(s)
+			TOAL	Original album/movie/show title
+			TOF	Original filename
+			TOFN	Original filename
+			TOL	Original Lyricist(s)/text writer(s)
+			TOLY	Original lyricist(s)/text writer(s)
+			TOPE	Original artist(s)/performer(s)
+			TOR	Original release year
+			TORY	Original release year
+			TOT	Original album/Movie/Show title
+			TOWN	File owner/licensee
+			TP1	Lead artist(s)/Lead performer(s)/Soloist(s)/Performing group
+			TP2	Band/Orchestra/Accompaniment
+			TP3	Conductor/Performer refinement
+			TP4	Interpreted, remixed, or otherwise modified by
+			TPA	Part of a set
+			TPB	Publisher
+			TPE1	Lead performer(s)/Soloist(s)
+			TPE2	Band/orchestra/accompaniment
+			TPE3	Conductor/performer refinement
+			TPE4	Interpreted, remixed, or otherwise modified by
+			TPOS	Part of a set
+			TPRO	Produced notice
+			TPUB	Publisher
+			TRC	ISRC (International Standard Recording Code)
+			TRCK	Track number/Position in set
+			TRD	Recording dates
+			TRDA	Recording dates
+			TRK	Track number/Position in set
+			TRSN	Internet radio station name
+			TRSO	Internet radio station owner
+			TSI	Size
+			TSIZ	Size
+			TSOA	Album sort order
+			TSOP	Performer sort order
+			TSOT	Title sort order
+			TSRC	ISRC (international standard recording code)
+			TSS	Software/hardware and settings used for encoding
+			TSSE	Software/Hardware and settings used for encoding
+			TSST	Set subtitle
+			TT1	Content group description
+			TT2	Title/Songname/Content description
+			TT3	Subtitle/Description refinement
+			TXT	Lyricist/text writer
+			TXX	User defined text information frame
+			TXXX	User defined text information frame
+			TYE	Year
+			TYER	Year
+			UFI	Unique file identifier
+			UFID	Unique file identifier
+			ULT	Unsychronised lyric/text transcription
+			USER	Terms of use
+			USLT	Unsynchronised lyric/text transcription
+			WAF	Official audio file webpage
+			WAR	Official artist/performer webpage
+			WAS	Official audio source webpage
+			WCM	Commercial information
+			WCOM	Commercial information
+			WCOP	Copyright/Legal information
+			WCP	Copyright/Legal information
+			WOAF	Official audio file webpage
+			WOAR	Official artist/performer webpage
+			WOAS	Official audio source webpage
+			WORS	Official Internet radio station homepage
+			WPAY	Payment
+			WPB	Publishers official webpage
+			WPUB	Publishers official webpage
+			WXX	User defined URL link frame
+			WXXX	User defined URL link frame
+			TFEA	Featured Artist
+			TSTU	Recording Studio
+			rgad	Replay Gain Adjustment
+
+		*/
+
+		return getid3_lib::EmbeddedLookup($framename, $begin, __LINE__, __FILE__, 'id3v2-framename_long');
+
+		// Last three:
+		// from Helium2 [www.helium2.com]
+		// from <A HREF="http://privatewww.essex.ac.uk/~djmrob/replaygain/file_format_id3v2.html">http://privatewww.essex.ac.uk/~djmrob/replaygain/file_format_id3v2.html</A>
+	}
+
+
+	function FrameNameShortLookup($framename) {
+
+		$begin = __LINE__;
+
+		/** This is not a comment!
+
+			COM	comment
+			COMM	comment
+			TAL	album
+			TALB	album
+			TBP	bpm
+			TBPM	bpm
+			TCM	composer
+			TCO	genre
+			TCOM	composer
+			TCON	genre
+			TCOP	copyright
+			TCR	copyright
+			TEN	encoded_by
+			TENC	encoded_by
+			TEXT	lyricist
+			TIT1	description
+			TIT2	title
+			TIT3	subtitle
+			TLA	language
+			TLAN	language
+			TLE	length
+			TLEN	length
+			TMOO	mood
+			TOA	original_artist
+			TOAL	original_album
+			TOF	original_filename
+			TOFN	original_filename
+			TOL	original_lyricist
+			TOLY	original_lyricist
+			TOPE	original_artist
+			TOT	original_album
+			TP1	artist
+			TP2	band
+			TP3	conductor
+			TP4	remixer
+			TPB	publisher
+			TPE1	artist
+			TPE2	band
+			TPE3	conductor
+			TPE4	remixer
+			TPUB	publisher
+			TRC	isrc
+			TRCK	track
+			TRK	track
+			TSI	size
+			TSIZ	size
+			TSRC	isrc
+			TSS	encoder_settings
+			TSSE	encoder_settings
+			TSST	subtitle
+			TT1	description
+			TT2	title
+			TT3	subtitle
+			TXT	lyricist
+			TXX	text
+			TXXX	text
+			TYE	year
+			TYER	year
+			UFI	unique_file_identifier
+			UFID	unique_file_identifier
+			ULT	unsychronised_lyric
+			USER	terms_of_use
+			USLT	unsynchronised lyric
+			WAF	url_file
+			WAR	url_artist
+			WAS	url_source
+			WCOP	copyright
+			WCP	copyright
+			WOAF	url_file
+			WOAR	url_artist
+			WOAS	url_source
+			WORS	url_station
+			WPB	url_publisher
+			WPUB	url_publisher
+			WXX	url_user
+			WXXX	url_user
+			TFEA	featured_artist
+			TSTU	studio
+
+		*/
+
+		return getid3_lib::EmbeddedLookup($framename, $begin, __LINE__, __FILE__, 'id3v2-framename_short');
+	}
+
+	function TextEncodingTerminatorLookup($encoding) {
+		// <A HREF="http://www.id3.org/id3v2.4.0-structure.txt">http://www.id3.org/id3v2.4.0-structure.txt</A>
+		// Frames that allow different types of text encoding contains a text encoding description byte. Possible encodings:
+		// $00  ISO-8859-1. Terminated with $00.
+		// $01  UTF-16 encoded Unicode with BOM. All strings in the same frame SHALL have the same byteorder. Terminated with $00 00.
+		// $02  UTF-16BE encoded Unicode without BOM. Terminated with $00 00.
+		// $03  UTF-8 encoded Unicode. Terminated with $00.
+
+		static $TextEncodingTerminatorLookup = array(0=&gt;&quot;\x00&quot;, 1=&gt;&quot;\x00\x00&quot;, 2=&gt;&quot;\x00\x00&quot;, 3=&gt;&quot;\x00&quot;, 255=&gt;&quot;\x00\x00&quot;);
+
+		return @$TextEncodingTerminatorLookup[$encoding];
+	}
+
+	function TextEncodingNameLookup($encoding) {
+		// <A HREF="http://www.id3.org/id3v2.4.0-structure.txt">http://www.id3.org/id3v2.4.0-structure.txt</A>
+		static $TextEncodingNameLookup = array(0=&gt;'ISO-8859-1', 1=&gt;'UTF-16', 2=&gt;'UTF-16BE', 3=&gt;'UTF-8', 255=&gt;'UTF-16BE');
+		return (isset($TextEncodingNameLookup[$encoding]) ? $TextEncodingNameLookup[$encoding] : 'ISO-8859-1');
+	}
+
+	function IsValidID3v2FrameName($framename, $id3v2majorversion) {
+		switch ($id3v2majorversion) {
+			case 2:
+				return ereg('[A-Z][A-Z0-9]{2}', $framename);
+				break;
+
+			case 3:
+			case 4:
+				return ereg('[A-Z][A-Z0-9]{3}', $framename);
+				break;
+		}
+		return false;
+	}
+
+	function IsANumber($numberstring, $allowdecimal=false, $allownegative=false) {
+		for ($i = 0; $i &lt; strlen($numberstring); $i++) {
+			if ((chr($numberstring{$i}) &lt; chr('0')) || (chr($numberstring{$i}) &gt; chr('9'))) {
+				if (($numberstring{$i} == '.') &amp;&amp; $allowdecimal) {
+					// allowed
+				} elseif (($numberstring{$i} == '-') &amp;&amp; $allownegative &amp;&amp; ($i == 0)) {
+					// allowed
+				} else {
+					return false;
+				}
+			}
+		}
+		return true;
+	}
+
+	function IsValidDateStampString($datestamp) {
+		if (strlen($datestamp) != 8) {
+			return false;
+		}
+		if (!$this-&gt;IsANumber($datestamp, false)) {
+			return false;
+		}
+		$year  = substr($datestamp, 0, 4);
+		$month = substr($datestamp, 4, 2);
+		$day   = substr($datestamp, 6, 2);
+		if (($year == 0) || ($month == 0) || ($day == 0)) {
+			return false;
+		}
+		if ($month &gt; 12) {
+			return false;
+		}
+		if ($day &gt; 31) {
+			return false;
+		}
+		if (($day &gt; 30) &amp;&amp; (($month == 4) || ($month == 6) || ($month == 9) || ($month == 11))) {
+			return false;
+		}
+		if (($day &gt; 29) &amp;&amp; ($month == 2)) {
+			return false;
+		}
+		return true;
+	}
+
+	function ID3v2HeaderLength($majorversion) {
+		return (($majorversion == 2) ? 6 : 10);
+	}
+
+}
+
+?&gt;

Added: node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.lyrics3.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.lyrics3.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/module.tag.lyrics3.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,271 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+///                                                            //
+// module.tag.lyrics3.php                                      //
+// module for analyzing Lyrics3 tags                           //
+// dependencies: module.tag.apetag.php (optional)              //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_lyrics3
+{
+
+	function getid3_lyrics3(&amp;$fd, &amp;$ThisFileInfo) {
+		// <A HREF="http://www.volweb.cz/str/tags.htm">http://www.volweb.cz/str/tags.htm</A>
+
+		fseek($fd, (0 - 128 - 9 - 6), SEEK_END);          // end - ID3v1 - LYRICSEND - [Lyrics3size]
+		$lyrics3_id3v1 = fread($fd, 128 + 9 + 6);
+		$lyrics3lsz    = substr($lyrics3_id3v1,  0,   6); // Lyrics3size
+		$lyrics3end    = substr($lyrics3_id3v1,  6,   9); // LYRICSEND or LYRICS200
+		$id3v1tag      = substr($lyrics3_id3v1, 15, 128); // ID3v1
+
+		if ($lyrics3end == 'LYRICSEND') {
+			// Lyrics3v1, ID3v1, no APE
+
+			$lyrics3size    = 5100;
+			$lyrics3offset  = $ThisFileInfo['filesize'] - 128 - $lyrics3size;
+			$lyrics3version = 1;
+
+		} elseif ($lyrics3end == 'LYRICS200') {
+			// Lyrics3v2, ID3v1, no APE
+
+			// LSZ = lyrics + 'LYRICSBEGIN'; add 6-byte size field; add 'LYRICS200'
+			$lyrics3size    = $lyrics3lsz + 6 + strlen('LYRICS200');
+			$lyrics3offset  = $ThisFileInfo['filesize'] - 128 - $lyrics3size;
+			$lyrics3version = 2;
+
+		} elseif (substr(strrev($lyrics3_id3v1), 0, 9) == strrev('LYRICSEND')) {
+			// Lyrics3v1, no ID3v1, no APE
+
+			$lyrics3size    = 5100;
+			$lyrics3offset  = $ThisFileInfo['filesize'] - $lyrics3size;
+			$lyrics3version = 1;
+			$lyrics3offset  = $ThisFileInfo['filesize'] - $lyrics3size;
+
+		} elseif (substr(strrev($lyrics3_id3v1), 0, 9) == strrev('LYRICS200')) {
+
+			// Lyrics3v2, no ID3v1, no APE
+
+			$lyrics3size    = strrev(substr(strrev($lyrics3_id3v1), 9, 6)) + 6 + strlen('LYRICS200'); // LSZ = lyrics + 'LYRICSBEGIN'; add 6-byte size field; add 'LYRICS200'
+			$lyrics3offset  = $ThisFileInfo['filesize'] - $lyrics3size;
+			$lyrics3version = 2;
+
+		} else {
+
+			if (isset($ThisFileInfo['ape']['tag_offset_start']) &amp;&amp; ($ThisFileInfo['ape']['tag_offset_start'] &gt; 15)) {
+
+				fseek($fd, $ThisFileInfo['ape']['tag_offset_start'] - 15, SEEK_SET);
+				$lyrics3lsz = fread($fd, 6);
+				$lyrics3end = fread($fd, 9);
+
+				if ($lyrics3end == 'LYRICSEND') {
+					// Lyrics3v1, APE, maybe ID3v1
+
+					$lyrics3size    = 5100;
+					$lyrics3offset  = $ThisFileInfo['ape']['tag_offset_start'] - $lyrics3size;
+					$ThisFileInfo['avdataend'] = $lyrics3offset;
+					$lyrics3version = 1;
+					$ThisFileInfo['warning'][] = 'APE tag located after Lyrics3, will probably break Lyrics3 compatability';
+
+				} elseif ($lyrics3end == 'LYRICS200') {
+					// Lyrics3v2, APE, maybe ID3v1
+
+					$lyrics3size    = $lyrics3lsz + 6 + strlen('LYRICS200'); // LSZ = lyrics + 'LYRICSBEGIN'; add 6-byte size field; add 'LYRICS200'
+					$lyrics3offset  = $ThisFileInfo['ape']['tag_offset_start'] - $lyrics3size;
+					$lyrics3version = 2;
+					$ThisFileInfo['warning'][] = 'APE tag located after Lyrics3, will probably break Lyrics3 compatability';
+
+				}
+
+			}
+
+		}
+
+		if (isset($lyrics3offset)) {
+			$ThisFileInfo['avdataend'] = $lyrics3offset;
+			$this-&gt;getLyrics3Data($ThisFileInfo, $fd, $lyrics3offset, $lyrics3version, $lyrics3size);
+
+			if (!isset($ThisFileInfo['ape'])) {
+				$GETID3_ERRORARRAY = &amp;$ThisFileInfo['warning'];
+				if (getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.apetag.php', __FILE__, false)) {
+					$tag = new getid3_apetag($fd, $ThisFileInfo, $ThisFileInfo['lyrics3']['tag_offset_start']);
+				}
+			}
+
+		}
+
+		return true;
+	}
+
+	function getLyrics3Data(&amp;$ThisFileInfo, &amp;$fd, $endoffset, $version, $length) {
+		// <A HREF="http://www.volweb.cz/str/tags.htm">http://www.volweb.cz/str/tags.htm</A>
+
+		fseek($fd, $endoffset, SEEK_SET);
+		if ($length &lt;= 0) {
+			return false;
+		}
+		$rawdata = fread($fd, $length);
+
+		if (substr($rawdata, 0, 11) != 'LYRICSBEGIN') {
+			if (strpos($rawdata, 'LYRICSBEGIN') !== false) {
+
+				$ThisFileInfo['warning'][] = '&quot;LYRICSBEGIN&quot; expected at '.$endoffset.' but actually found at '.($endoffset + strpos($rawdata, 'LYRICSBEGIN')).' - this is invalid for Lyrics3 v'.$version;
+				$ThisFileInfo['avdataend'] = $endoffset + strpos($rawdata, 'LYRICSBEGIN');
+				$ParsedLyrics3['tag_offset_start'] = $ThisFileInfo['avdataend'];
+				$rawdata = substr($rawdata, strpos($rawdata, 'LYRICSBEGIN'));
+				$length = strlen($rawdata);
+
+			} else {
+
+				$ThisFileInfo['error'][] = '&quot;LYRICSBEGIN&quot; expected at '.$endoffset.' but found &quot;'.substr($rawdata, 0, 11).'&quot; instead';
+				return false;
+
+			}
+
+		}
+
+		$ParsedLyrics3['raw']['lyrics3version'] = $version;
+		$ParsedLyrics3['raw']['lyrics3tagsize'] = $length;
+		$ParsedLyrics3['tag_offset_start']      = $endoffset;
+		$ParsedLyrics3['tag_offset_end']        = $endoffset + $length;
+
+		switch ($version) {
+
+			case 1:
+				if (substr($rawdata, strlen($rawdata) - 9, 9) == 'LYRICSEND') {
+					$ParsedLyrics3['raw']['LYR'] = trim(substr($rawdata, 11, strlen($rawdata) - 11 - 9));
+					$this-&gt;Lyrics3LyricsTimestampParse($ParsedLyrics3);
+				} else {
+					$ThisFileInfo['error'][] = '&quot;LYRICSEND&quot; expected at '.(ftell($fd) - 11 + $length - 9).' but found &quot;'.substr($rawdata, strlen($rawdata) - 9, 9).'&quot; instead';
+					return false;
+				}
+				break;
+
+			case 2:
+				if (substr($rawdata, strlen($rawdata) - 9, 9) == 'LYRICS200') {
+					$ParsedLyrics3['raw']['unparsed'] = substr($rawdata, 11, strlen($rawdata) - 11 - 9 - 6); // LYRICSBEGIN + LYRICS200 + LSZ
+					$rawdata = $ParsedLyrics3['raw']['unparsed'];
+					while (strlen($rawdata) &gt; 0) {
+						$fieldname = substr($rawdata, 0, 3);
+						$fieldsize = (int) substr($rawdata, 3, 5);
+						$ParsedLyrics3['raw'][$fieldname] = substr($rawdata, 8, $fieldsize);
+						$rawdata = substr($rawdata, 3 + 5 + $fieldsize);
+					}
+
+					if (isset($ParsedLyrics3['raw']['IND'])) {
+						$i = 0;
+						$flagnames = array('lyrics', 'timestamps', 'inhibitrandom');
+						foreach ($flagnames as $flagname) {
+							if (strlen($ParsedLyrics3['raw']['IND']) &gt; ++$i) {
+								$ParsedLyrics3['flags'][$flagname] = $this-&gt;IntString2Bool(substr($ParsedLyrics3['raw']['IND'], $i, 1));
+							}
+						}
+					}
+
+					$fieldnametranslation = array('ETT'=&gt;'title', 'EAR'=&gt;'artist', 'EAL'=&gt;'album', 'INF'=&gt;'comment', 'AUT'=&gt;'author');
+					foreach ($fieldnametranslation as $key =&gt; $value) {
+						if (isset($ParsedLyrics3['raw'][$key])) {
+							$ParsedLyrics3['comments'][$value][] = trim($ParsedLyrics3['raw'][$key]);
+						}
+					}
+
+					if (isset($ParsedLyrics3['raw']['IMG'])) {
+						$imagestrings = explode(&quot;\r\n&quot;, $ParsedLyrics3['raw']['IMG']);
+						foreach ($imagestrings as $key =&gt; $imagestring) {
+							if (strpos($imagestring, '||') !== false) {
+								$imagearray = explode('||', $imagestring);
+								$ParsedLyrics3['images'][$key]['filename']     = $imagearray[0];
+								$ParsedLyrics3['images'][$key]['description']  = $imagearray[1];
+								$ParsedLyrics3['images'][$key]['timestamp']    = $this-&gt;Lyrics3Timestamp2Seconds($imagearray[2]);
+							}
+						}
+					}
+					if (isset($ParsedLyrics3['raw']['LYR'])) {
+						$this-&gt;Lyrics3LyricsTimestampParse($ParsedLyrics3);
+					}
+				} else {
+					$ThisFileInfo['error'][] = '&quot;LYRICS200&quot; expected at '.(ftell($fd) - 11 + $length - 9).' but found &quot;'.substr($rawdata, strlen($rawdata) - 9, 9).'&quot; instead';
+					return false;
+				}
+				break;
+
+			default:
+				$ThisFileInfo['error'][] = 'Cannot process Lyrics3 version '.$version.' (only v1 and v2)';
+				return false;
+				break;
+		}
+
+
+		if (isset($ThisFileInfo['id3v1']['tag_offset_start']) &amp;&amp; ($ThisFileInfo['id3v1']['tag_offset_start'] &lt; $ParsedLyrics3['tag_offset_end'])) {
+			$ThisFileInfo['warning'][] = 'ID3v1 tag information ignored since it appears to be a false synch in Lyrics3 tag data';
+			unset($ThisFileInfo['id3v1']);
+			foreach ($ThisFileInfo['warning'] as $key =&gt; $value) {
+				if ($value == 'Some ID3v1 fields do not use NULL characters for padding') {
+					unset($ThisFileInfo['warning'][$key]);
+					sort($ThisFileInfo['warning']);
+					break;
+				}
+			}
+		}
+
+		$ThisFileInfo['lyrics3'] = $ParsedLyrics3;
+
+		return true;
+	}
+
+	function Lyrics3Timestamp2Seconds($rawtimestamp) {
+		if (ereg('^\\[([0-9]{2}):([0-9]{2})\\]$', $rawtimestamp, $regs)) {
+			return (int) (($regs[1] * 60) + $regs[2]);
+		}
+		return false;
+	}
+
+	function Lyrics3LyricsTimestampParse(&amp;$Lyrics3data) {
+		$lyricsarray = explode(&quot;\r\n&quot;, $Lyrics3data['raw']['LYR']);
+		foreach ($lyricsarray as $key =&gt; $lyricline) {
+			$regs = array();
+			unset($thislinetimestamps);
+			while (ereg('^(\\[[0-9]{2}:[0-9]{2}\\])', $lyricline, $regs)) {
+				$thislinetimestamps[] = $this-&gt;Lyrics3Timestamp2Seconds($regs[0]);
+				$lyricline = str_replace($regs[0], '', $lyricline);
+			}
+			$notimestamplyricsarray[$key] = $lyricline;
+			if (isset($thislinetimestamps) &amp;&amp; is_array($thislinetimestamps)) {
+				sort($thislinetimestamps);
+				foreach ($thislinetimestamps as $timestampkey =&gt; $timestamp) {
+					if (isset($Lyrics3data['synchedlyrics'][$timestamp])) {
+						// timestamps only have a 1-second resolution, it's possible that multiple lines
+						// could have the same timestamp, if so, append
+						$Lyrics3data['synchedlyrics'][$timestamp] .= &quot;\r\n&quot;.$lyricline;
+					} else {
+						$Lyrics3data['synchedlyrics'][$timestamp] = $lyricline;
+					}
+				}
+			}
+		}
+		$Lyrics3data['unsynchedlyrics'] = implode(&quot;\r\n&quot;, $notimestamplyricsarray);
+		if (isset($Lyrics3data['synchedlyrics']) &amp;&amp; is_array($Lyrics3data['synchedlyrics'])) {
+			ksort($Lyrics3data['synchedlyrics']);
+		}
+		return true;
+	}
+
+	function IntString2Bool($char) {
+		if ($char == '1') {
+			return true;
+		} elseif ($char == '0') {
+			return false;
+		}
+		return null;
+	}
+}
+
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/write.apetag.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/write.apetag.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/write.apetag.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,227 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// write.apetag.php                                            //
+// module for writing APE tags                                 //
+// dependencies: module.tag.apetag.php                         //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.apetag.php', __FILE__, true);
+
+class getid3_write_apetag
+{
+
+	var $filename;
+	var $tag_data;
+	var $always_preserve_replaygain = true;  // ReplayGain / MP3gain tags will be copied from old tag even if not passed in data
+	var $warnings = array();                 // any non-critical errors will be stored here
+	var $errors   = array();                 // any critical errors will be stored here
+
+	function getid3_write_apetag() {
+		return true;
+	}
+
+	function WriteAPEtag() {
+		// NOTE: All data passed to this function must be UTF-8 format
+
+		$getID3 = new getID3;
+		$ThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+
+		if (isset($ThisFileInfo['ape']['tag_offset_start']) &amp;&amp; isset($ThisFileInfo['lyrics3']['tag_offset_end'])) {
+			if ($ThisFileInfo['ape']['tag_offset_start'] &gt;= $ThisFileInfo['lyrics3']['tag_offset_end']) {
+				// Current APE tag between Lyrics3 and ID3v1/EOF
+				// This break Lyrics3 functionality
+				if (!$this-&gt;DeleteAPEtag()) {
+					return false;
+				}
+				$ThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+			}
+		}
+
+		if ($this-&gt;always_preserve_replaygain) {
+			$ReplayGainTagsToPreserve = array('mp3gain_minmax', 'mp3gain_album_minmax', 'mp3gain_undo', 'replaygain_track_peak', 'replaygain_track_gain', 'replaygain_album_peak', 'replaygain_album_gain');
+			foreach ($ReplayGainTagsToPreserve as $rg_key) {
+				if (isset($ThisFileInfo['ape']['items'][strtolower($rg_key)]['data'][0]) &amp;&amp; !isset($this-&gt;tag_data[strtoupper($rg_key)][0])) {
+					$this-&gt;tag_data[strtoupper($rg_key)][0] = $ThisFileInfo['ape']['items'][strtolower($rg_key)]['data'][0];
+				}
+			}
+		}
+
+		if ($APEtag = $this-&gt;GenerateAPEtag()) {
+			if ($fp = @fopen($this-&gt;filename, 'a+b')) {
+				$oldignoreuserabort = ignore_user_abort(true);
+				flock($fp, LOCK_EX);
+
+				$PostAPEdataOffset = $ThisFileInfo['avdataend'];
+				if (isset($ThisFileInfo['ape']['tag_offset_end'])) {
+					$PostAPEdataOffset = max($PostAPEdataOffset, $ThisFileInfo['ape']['tag_offset_end']);
+				}
+				if (isset($ThisFileInfo['lyrics3']['tag_offset_start'])) {
+					$PostAPEdataOffset = max($PostAPEdataOffset, $ThisFileInfo['lyrics3']['tag_offset_start']);
+				}
+				fseek($fp, $PostAPEdataOffset, SEEK_SET);
+				$PostAPEdata = '';
+				if ($ThisFileInfo['filesize'] &gt; $PostAPEdataOffset) {
+					$PostAPEdata = fread($fp, $ThisFileInfo['filesize'] - $PostAPEdataOffset);
+				}
+
+				fseek($fp, $PostAPEdataOffset, SEEK_SET);
+				if (isset($ThisFileInfo['ape']['tag_offset_start'])) {
+					fseek($fp, $ThisFileInfo['ape']['tag_offset_start'], SEEK_SET);
+				}
+				ftruncate($fp, ftell($fp));
+				fwrite($fp, $APEtag, strlen($APEtag));
+				if (!empty($PostAPEdata)) {
+					fwrite($fp, $PostAPEdata, strlen($PostAPEdata));
+				}
+				flock($fp, LOCK_UN);
+				fclose($fp);
+				ignore_user_abort($oldignoreuserabort);
+				return true;
+
+			}
+			return false;
+		}
+		return false;
+	}
+
+	function DeleteAPEtag() {
+		$getID3 = new getID3;
+		$ThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+		if (isset($ThisFileInfo['ape']['tag_offset_start']) &amp;&amp; isset($ThisFileInfo['ape']['tag_offset_end'])) {
+			if ($fp = @fopen($this-&gt;filename, 'a+b')) {
+
+				flock($fp, LOCK_EX);
+				$oldignoreuserabort = ignore_user_abort(true);
+
+				fseek($fp, $ThisFileInfo['ape']['tag_offset_end'], SEEK_SET);
+				$DataAfterAPE = '';
+				if ($ThisFileInfo['filesize'] &gt; $ThisFileInfo['ape']['tag_offset_end']) {
+					$DataAfterAPE = fread($fp, $ThisFileInfo['filesize'] - $ThisFileInfo['ape']['tag_offset_end']);
+				}
+
+				ftruncate($fp, $ThisFileInfo['ape']['tag_offset_start']);
+				fseek($fp, $ThisFileInfo['ape']['tag_offset_start'], SEEK_SET);
+
+				if (!empty($DataAfterAPE)) {
+					fwrite($fp, $DataAfterAPE, strlen($DataAfterAPE));
+				}
+
+				flock($fp, LOCK_UN);
+				fclose($fp);
+				ignore_user_abort($oldignoreuserabort);
+
+				return true;
+
+			}
+		}
+		return false;
+	}
+
+
+	function GenerateAPEtag() {
+		// NOTE: All data passed to this function must be UTF-8 format
+
+		$items = array();
+		if (!is_array($this-&gt;tag_data)) {
+			return false;
+		}
+		foreach ($this-&gt;tag_data as $key =&gt; $arrayofvalues) {
+			if (!is_array($arrayofvalues)) {
+				return false;
+			}
+
+			$valuestring = '';
+			foreach ($arrayofvalues as $value) {
+				$valuestring .= str_replace(&quot;\x00&quot;, '', $value).&quot;\x00&quot;;
+			}
+			$valuestring = rtrim($valuestring, &quot;\x00&quot;);
+
+			// Length of the assigned value in bytes
+			$tagitem  = getid3_lib::LittleEndian2String(strlen($valuestring), 4);
+
+			//$tagitem .= $this-&gt;GenerateAPEtagFlags(true, true, false, 0, false);
+			$tagitem .= &quot;\x00\x00\x00\x00&quot;;
+
+			$tagitem .= $this-&gt;CleanAPEtagItemKey($key).&quot;\x00&quot;;
+			$tagitem .= $valuestring;
+
+			$items[] = $tagitem;
+
+		}
+
+		return $this-&gt;GenerateAPEtagHeaderFooter($items, true).implode('', $items).$this-&gt;GenerateAPEtagHeaderFooter($items, false);
+	}
+
+	function GenerateAPEtagHeaderFooter(&amp;$items, $isheader=false) {
+		$tagdatalength = 0;
+		foreach ($items as $itemdata) {
+			$tagdatalength += strlen($itemdata);
+		}
+
+		$APEheader  = 'APETAGEX';
+		$APEheader .= getid3_lib::LittleEndian2String(2000, 4);
+		$APEheader .= getid3_lib::LittleEndian2String(32 + $tagdatalength, 4);
+		$APEheader .= getid3_lib::LittleEndian2String(count($items), 4);
+		$APEheader .= $this-&gt;GenerateAPEtagFlags(true, true, $isheader, 0, false);
+		$APEheader .= str_repeat(&quot;\x00&quot;, 8);
+
+		return $APEheader;
+	}
+
+	function GenerateAPEtagFlags($header=true, $footer=true, $isheader=false, $encodingid=0, $readonly=false) {
+		$APEtagFlags = array_fill(0, 4, 0);
+		if ($header) {
+			$APEtagFlags[0] |= 0x80; // Tag contains a header
+		}
+		if (!$footer) {
+			$APEtagFlags[0] |= 0x40; // Tag contains no footer
+		}
+		if ($isheader) {
+			$APEtagFlags[0] |= 0x20; // This is the header, not the footer
+		}
+
+		// 0: Item contains text information coded in UTF-8
+		// 1: Item contains binary information &#176;)
+		// 2: Item is a locator of external stored information &#176;&#176;)
+		// 3: reserved
+		$APEtagFlags[3] |= ($encodingid &lt;&lt; 1);
+
+		if ($readonly) {
+			$APEtagFlags[3] |= 0x01; // Tag or Item is Read Only
+		}
+
+		return chr($APEtagFlags[3]).chr($APEtagFlags[2]).chr($APEtagFlags[1]).chr($APEtagFlags[0]);
+	}
+
+	function CleanAPEtagItemKey($itemkey) {
+		$itemkey = eregi_replace(&quot;[^\x20-\x7E]&quot;, '', $itemkey);
+
+		// <A HREF="http://www.personal.uni-jena.de/~pfk/mpp/sv8/apekey.html">http://www.personal.uni-jena.de/~pfk/mpp/sv8/apekey.html</A>
+		switch (strtoupper($itemkey)) {
+			case 'EAN/UPC':
+			case 'ISBN':
+			case 'LC':
+			case 'ISRC':
+				$itemkey = strtoupper($itemkey);
+				break;
+
+			default:
+				$itemkey = ucwords($itemkey);
+				break;
+		}
+		return $itemkey;
+
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/write.id3v1.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/write.id3v1.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/write.id3v1.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,104 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// write.id3v1.php                                             //
+// module for writing ID3v1 tags                               //
+// dependencies: module.tag.id3v1.php                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v1.php', __FILE__, true);
+
+class getid3_write_id3v1
+{
+	var $filename;
+	var $tag_data;
+	var $warnings = array(); // any non-critical errors will be stored here
+	var $errors   = array(); // any critical errors will be stored here
+
+	function getid3_write_id3v1() {
+		return true;
+	}
+
+	function WriteID3v1() {
+		// File MUST be writeable - CHMOD(646) at least
+		if (is_writeable($this-&gt;filename)) {
+			if ($fp_source = @fopen($this-&gt;filename, 'r+b')) {
+
+				fseek($fp_source, -128, SEEK_END);
+				if (fread($fp_source, 3) == 'TAG') {
+					fseek($fp_source, -128, SEEK_END); // overwrite existing ID3v1 tag
+				} else {
+					fseek($fp_source, 0, SEEK_END);    // append new ID3v1 tag
+				}
+
+				$new_id3v1_tag_data = getid3_id3v1::GenerateID3v1Tag(
+														@$this-&gt;tag_data['title'],
+														@$this-&gt;tag_data['artist'],
+														@$this-&gt;tag_data['album'],
+														@$this-&gt;tag_data['year'],
+														@$this-&gt;tag_data['genreid'],
+														@$this-&gt;tag_data['comment'],
+														@$this-&gt;tag_data['track']);
+				fwrite($fp_source, $new_id3v1_tag_data, 128);
+				fclose($fp_source);
+				return true;
+
+			} else {
+				$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;r+b&quot;';
+				return false;
+			}
+		}
+		$this-&gt;errors[] = 'File is not writeable: '.$this-&gt;filename;
+		return false;
+	}
+
+	function FixID3v1Padding() {
+		// ID3v1 data is supposed to be padded with NULL characters, but some taggers incorrectly use spaces
+		// This function rewrites the ID3v1 tag with correct padding
+
+		// Initialize getID3 engine
+		$getID3 = new getID3;
+		$ThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+		if (isset($ThisFileInfo['tags']['id3v1'])) {
+			foreach ($ThisFileInfo['tags']['id3v1'] as $key =&gt; $value) {
+				$id3v1data[$key] = implode(',', $value);
+			}
+			$this-&gt;tag_data = $id3v1data;
+			return $this-&gt;WriteID3v1();
+		}
+		return false;
+	}
+
+	function RemoveID3v1() {
+		// File MUST be writeable - CHMOD(646) at least
+		if (is_writeable($this-&gt;filename)) {
+			if ($fp_source = @fopen($this-&gt;filename, 'r+b')) {
+
+				fseek($fp_source, -128, SEEK_END);
+				if (fread($fp_source, 3) == 'TAG') {
+					ftruncate($fp_source, filesize($this-&gt;filename) - 128);
+				} else {
+					// no ID3v1 tag to begin with - do nothing
+				}
+				fclose($fp_source);
+				return true;
+
+			} else {
+				$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;r+b&quot;';
+			}
+		} else {
+			$this-&gt;errors[] = $this-&gt;filename.' is not writeable';
+		}
+		return false;
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/write.id3v2.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/write.id3v2.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/write.id3v2.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,2030 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+///                                                            //
+// write.id3v2.php                                             //
+// module for writing ID3v2 tags                               //
+// dependencies: module.tag.id3v2.php                          //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'module.tag.id3v2.php', __FILE__, true);
+
+class getid3_write_id3v2
+{
+	var $filename;
+	var $tag_data;
+	var $paddedlength                = 4096;     // minimum length of ID3v2 tag in bytes
+	var $majorversion                = 3;        // ID3v2 major version (2, 3 (recommended), 4)
+	var $minorversion                = 0;        // ID3v2 minor version - always 0
+	var $merge_existing_data         = false;    // if true, merge new data with existing tags; if false, delete old tag data and only write new tags
+	var $id3v2_default_encodingid    = 0;        // default text encoding (ISO-8859-1) if not explicitly passed
+	var $id3v2_use_unsynchronisation = false;    // the specs say it should be TRUE, but most other ID3v2-aware programs are broken if unsynchronization is used, so by default don't use it.
+	var $warnings                    = array();  // any non-critical errors will be stored here
+	var $errors                      = array();  // any critical errors will be stored here
+
+	function getid3_write_id3v2() {
+		return true;
+	}
+
+	function WriteID3v2() {
+		// File MUST be writeable - CHMOD(646) at least. It's best if the
+		// directory is also writeable, because that method is both faster and less susceptible to errors.
+
+		if (is_writeable($this-&gt;filename) || (!file_exists($this-&gt;filename) &amp;&amp; is_writeable(dirname($this-&gt;filename)))) {
+			// Initialize getID3 engine
+			$getID3 = new getID3;
+			$OldThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+			if ($this-&gt;merge_existing_data) {
+				// merge with existing data
+				if (!empty($OldThisFileInfo['id3v2'])) {
+					$this-&gt;tag_data = $this-&gt;array_join_merge($OldThisFileInfo['id3v2'], $this-&gt;tag_data);
+				}
+			}
+			$this-&gt;paddedlength = max(@$OldThisFileInfo['id3v2']['headerlength'], $this-&gt;paddedlength);
+
+			if ($NewID3v2Tag = $this-&gt;GenerateID3v2Tag()) {
+
+				if (file_exists($this-&gt;filename) &amp;&amp; is_writeable($this-&gt;filename) &amp;&amp; isset($OldThisFileInfo['id3v2']['headerlength']) &amp;&amp; ($OldThisFileInfo['id3v2']['headerlength'] == strlen($NewID3v2Tag))) {
+
+					// best and fastest method - insert-overwrite existing tag (padded to length of old tag if neccesary)
+					if (file_exists($this-&gt;filename)) {
+
+						ob_start();
+						if ($fp = fopen($this-&gt;filename, 'r+b')) {
+							rewind($fp);
+							fwrite($fp, $NewID3v2Tag, strlen($NewID3v2Tag));
+							fclose($fp);
+						} else {
+							$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;r+b&quot; - '.strip_tags(ob_get_contents());
+						}
+						ob_end_clean();
+
+					} else {
+
+						ob_start();
+						if ($fp = fopen($this-&gt;filename, 'wb')) {
+							rewind($fp);
+							fwrite($fp, $NewID3v2Tag, strlen($NewID3v2Tag));
+							fclose($fp);
+						} else {
+							$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;wb&quot; - '.strip_tags(ob_get_contents());
+						}
+						ob_end_clean();
+
+					}
+
+				} else {
+
+					if ($tempfilename = tempnam('*', 'getID3')) {
+						ob_start();
+						if ($fp_source = fopen($this-&gt;filename, 'rb')) {
+							if ($fp_temp = fopen($tempfilename, 'wb')) {
+
+								fwrite($fp_temp, $NewID3v2Tag, strlen($NewID3v2Tag));
+
+								rewind($fp_source);
+								if (!empty($OldThisFileInfo['avdataoffset'])) {
+									fseek($fp_source, $OldThisFileInfo['avdataoffset'], SEEK_SET);
+								}
+
+								while ($buffer = fread($fp_source, GETID3_FREAD_BUFFER_SIZE)) {
+									fwrite($fp_temp, $buffer, strlen($buffer));
+								}
+
+								fclose($fp_temp);
+								fclose($fp_source);
+								copy($tempfilename, $this-&gt;filename);
+								unlink($tempfilename);
+								ob_end_clean();
+								return true;
+
+							} else {
+
+								$this-&gt;errors[] = 'Could not open '.$tempfilename.' mode &quot;wb&quot; - '.strip_tags(ob_get_contents());
+
+							}
+							fclose($fp_source);
+
+						} else {
+
+							$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;rb&quot; - '.strip_tags(ob_get_contents());
+
+						}
+						ob_end_clean();
+					}
+					return false;
+
+				}
+
+			} else {
+
+				$this-&gt;errors[] = '$this-&gt;GenerateID3v2Tag() failed';
+
+			}
+
+			if (!empty($this-&gt;errors)) {
+				return false;
+			}
+			return true;
+		} else {
+			$this-&gt;errors[] = '!is_writeable('.$this-&gt;filename.')';
+		}
+		return false;
+	}
+
+	function RemoveID3v2() {
+
+		// File MUST be writeable - CHMOD(646) at least. It's best if the
+		// directory is also writeable, because that method is both faster and less susceptible to errors.
+		if (is_writeable(dirname($this-&gt;filename))) {
+
+			// preferred method - only one copying operation, minimal chance of corrupting
+			// original file if script is interrupted, but required directory to be writeable
+			if ($fp_source = @fopen($this-&gt;filename, 'rb')) {
+				// Initialize getID3 engine
+				$getID3 = new getID3;
+				$OldThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+				rewind($fp_source);
+				if ($OldThisFileInfo['avdataoffset'] !== false) {
+					fseek($fp_source, $OldThisFileInfo['avdataoffset'], SEEK_SET);
+				}
+				if ($fp_temp = @fopen($this-&gt;filename.'getid3tmp', 'w+b')) {
+					while ($buffer = fread($fp_source, GETID3_FREAD_BUFFER_SIZE)) {
+						fwrite($fp_temp, $buffer, strlen($buffer));
+					}
+					fclose($fp_temp);
+				} else {
+					$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.'getid3tmp mode &quot;w+b&quot;';
+				}
+				fclose($fp_source);
+			} else {
+				$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;rb&quot;';
+			}
+			if (file_exists($this-&gt;filename)) {
+				unlink($this-&gt;filename);
+			}
+			rename($this-&gt;filename.'getid3tmp', $this-&gt;filename);
+
+		} elseif (is_writable($this-&gt;filename)) {
+
+			// less desirable alternate method - double-copies the file, overwrites original file
+			// and could corrupt source file if the script is interrupted or an error occurs.
+			if ($fp_source = @fopen($this-&gt;filename, 'rb')) {
+				// Initialize getID3 engine
+				$getID3 = new getID3;
+				$OldThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+				rewind($fp_source);
+				if ($OldThisFileInfo['avdataoffset'] !== false) {
+					fseek($fp_source, $OldThisFileInfo['avdataoffset'], SEEK_SET);
+				}
+				if ($fp_temp = tmpfile()) {
+					while ($buffer = fread($fp_source, GETID3_FREAD_BUFFER_SIZE)) {
+						fwrite($fp_temp, $buffer, strlen($buffer));
+					}
+					fclose($fp_source);
+					if ($fp_source = @fopen($this-&gt;filename, 'wb')) {
+						rewind($fp_temp);
+						while ($buffer = fread($fp_temp, GETID3_FREAD_BUFFER_SIZE)) {
+							fwrite($fp_source, $buffer, strlen($buffer));
+						}
+						fseek($fp_temp, -128, SEEK_END);
+						fclose($fp_source);
+					} else {
+						$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;wb&quot;';
+					}
+					fclose($fp_temp);
+				} else {
+					$this-&gt;errors[] = 'Could not create tmpfile()';
+				}
+			} else {
+				$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;rb&quot;';
+			}
+
+		} else {
+
+			$this-&gt;errors[] = 'Directory and file both not writeable';
+
+		}
+
+		if (!empty($this-&gt;errors)) {
+			return false;
+		}
+		return true;
+	}
+
+
+	function GenerateID3v2TagFlags($flags) {
+		switch ($this-&gt;majorversion) {
+			case 4:
+				// %abcd0000
+				$flag  = (@$flags['unsynchronisation'] ? '1' : '0'); // a - Unsynchronisation
+				$flag .= (@$flags['extendedheader']    ? '1' : '0'); // b - Extended header
+				$flag .= (@$flags['experimental']      ? '1' : '0'); // c - Experimental indicator
+				$flag .= (@$flags['footer']            ? '1' : '0'); // d - Footer present
+				$flag .= '0000';
+				break;
+
+			case 3:
+				// %abc00000
+				$flag  = (@$flags['unsynchronisation'] ? '1' : '0'); // a - Unsynchronisation
+				$flag .= (@$flags['extendedheader']    ? '1' : '0'); // b - Extended header
+				$flag .= (@$flags['experimental']      ? '1' : '0'); // c - Experimental indicator
+				$flag .= '00000';
+				break;
+
+			case 2:
+				// %ab000000
+				$flag  = (@$flags['unsynchronisation'] ? '1' : '0'); // a - Unsynchronisation
+				$flag .= (@$flags['compression']       ? '1' : '0'); // b - Compression
+				$flag .= '000000';
+				break;
+
+			default:
+				return false;
+				break;
+		}
+		return chr(bindec($flag));
+	}
+
+
+	function GenerateID3v2FrameFlags($TagAlter=false, $FileAlter=false, $ReadOnly=false, $Compression=false, $Encryption=false, $GroupingIdentity=false, $Unsynchronisation=false, $DataLengthIndicator=false) {
+		switch ($this-&gt;majorversion) {
+			case 4:
+				// %0abc0000 %0h00kmnp
+				$flag1  = '0';
+				$flag1 .= $TagAlter  ? '1' : '0'; // a - Tag alter preservation (true == discard)
+				$flag1 .= $FileAlter ? '1' : '0'; // b - File alter preservation (true == discard)
+				$flag1 .= $ReadOnly  ? '1' : '0'; // c - Read only (true == read only)
+				$flag1 .= '0000';
+
+				$flag2  = '0';
+				$flag2 .= $GroupingIdentity    ? '1' : '0'; // h - Grouping identity (true == contains group information)
+				$flag2 .= '00';
+				$flag2 .= $Compression         ? '1' : '0'; // k - Compression (true == compressed)
+				$flag2 .= $Encryption          ? '1' : '0'; // m - Encryption (true == encrypted)
+				$flag2 .= $Unsynchronisation   ? '1' : '0'; // n - Unsynchronisation (true == unsynchronised)
+				$flag2 .= $DataLengthIndicator ? '1' : '0'; // p - Data length indicator (true == data length indicator added)
+				break;
+
+			case 3:
+				// %abc00000 %ijk00000
+				$flag1  = $TagAlter  ? '1' : '0';  // a - Tag alter preservation (true == discard)
+				$flag1 .= $FileAlter ? '1' : '0';  // b - File alter preservation (true == discard)
+				$flag1 .= $ReadOnly  ? '1' : '0';  // c - Read only (true == read only)
+				$flag1 .= '00000';
+
+				$flag2  = $Compression      ? '1' : '0';      // i - Compression (true == compressed)
+				$flag2 .= $Encryption       ? '1' : '0';      // j - Encryption (true == encrypted)
+				$flag2 .= $GroupingIdentity ? '1' : '0';      // k - Grouping identity (true == contains group information)
+				$flag2 .= '00000';
+				break;
+
+			default:
+				return false;
+				break;
+
+		}
+		return chr(bindec($flag1)).chr(bindec($flag2));
+	}
+
+	function GenerateID3v2FrameData($frame_name, $source_data_array) {
+		if (!getid3_id3v2::IsValidID3v2FrameName($frame_name, $this-&gt;majorversion)) {
+			return false;
+		}
+		$framedata = '';
+
+		if (($this-&gt;majorversion &lt; 3) || ($this-&gt;majorversion &gt; 4)) {
+
+			$this-&gt;errors[] = 'Only ID3v2.3 and ID3v2.4 are supported in GenerateID3v2FrameData()';
+
+		} else { // $this-&gt;majorversion 3 or 4
+
+			switch ($frame_name) {
+				case 'UFID':
+					// 4.1   UFID Unique file identifier
+					// Owner identifier        &lt;text string&gt; $00
+					// Identifier              &lt;up to 64 bytes binary data&gt;
+					if (strlen($source_data_array['data']) &gt; 64) {
+						$this-&gt;errors[] = 'Identifier not allowed to be longer than 64 bytes in '.$frame_name.' (supplied data was '.strlen($source_data_array['data']).' bytes long)';
+					} else {
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['ownerid']).&quot;\x00&quot;;
+						$framedata .= substr($source_data_array['data'], 0, 64); // max 64 bytes - truncate anything longer
+					}
+					break;
+
+				case 'TXXX':
+					// 4.2.2 TXXX User defined text information frame
+					// Text encoding     $xx
+					// Description       &lt;text string according to encoding&gt; $00 (00)
+					// Value             &lt;text string according to encoding&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'], $this-&gt;majorversion)) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].') for ID3v2.'.$this-&gt;majorversion;
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= $source_data_array['description'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'WXXX':
+					// 4.3.2 WXXX User defined URL link frame
+					// Text encoding     $xx
+					// Description       &lt;text string according to encoding&gt; $00 (00)
+					// URL               &lt;text string&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'], $this-&gt;majorversion)) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].') for ID3v2.'.$this-&gt;majorversion;
+					} elseif (!isset($source_data_array['data']) || !$this-&gt;IsValidURL($source_data_array['data'], false, false)) {
+						$this-&gt;errors[] = 'Invalid URL in '.$frame_name.' ('.$source_data_array['data'].')';
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= $source_data_array['description'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'IPLS':
+					// 4.4  IPLS Involved people list (ID3v2.3 only)
+					// Text encoding     $xx
+					// People list strings    &lt;textstrings&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'], $this-&gt;majorversion)) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].') for ID3v2.'.$this-&gt;majorversion;
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'MCDI':
+					// 4.4   MCDI Music CD identifier
+					// CD TOC                &lt;binary data&gt;
+					$framedata .= $source_data_array['data'];
+					break;
+
+				case 'ETCO':
+					// 4.5   ETCO Event timing codes
+					// Time stamp format    $xx
+					//   Where time stamp format is:
+					// $01  (32-bit value) MPEG frames from beginning of file
+					// $02  (32-bit value) milliseconds from beginning of file
+					//   Followed by a list of key events in the following format:
+					// Type of event   $xx
+					// Time stamp      $xx (xx ...)
+					//   The 'Time stamp' is set to zero if directly at the beginning of the sound
+					//   or after the previous event. All events MUST be sorted in chronological order.
+					if (($source_data_array['timestampformat'] &gt; 2) || ($source_data_array['timestampformat'] &lt; 1)) {
+						$this-&gt;errors[] = 'Invalid Time Stamp Format byte in '.$frame_name.' ('.$source_data_array['timestampformat'].')';
+					} else {
+						$framedata .= chr($source_data_array['timestampformat']);
+						foreach ($source_data_array as $key =&gt; $val) {
+							if (!$this-&gt;ID3v2IsValidETCOevent($val['typeid'])) {
+								$this-&gt;errors[] = 'Invalid Event Type byte in '.$frame_name.' ('.$val['typeid'].')';
+							} elseif (($key != 'timestampformat') &amp;&amp; ($key != 'flags')) {
+								if (($val['timestamp'] &gt; 0) &amp;&amp; ($previousETCOtimestamp &gt;= $val['timestamp'])) {
+									//   The 'Time stamp' is set to zero if directly at the beginning of the sound
+									//   or after the previous event. All events MUST be sorted in chronological order.
+									$this-&gt;errors[] = 'Out-of-order timestamp in '.$frame_name.' ('.$val['timestamp'].') for Event Type ('.$val['typeid'].')';
+								} else {
+									$framedata .= chr($val['typeid']);
+									$framedata .= getid3_lib::BigEndian2String($val['timestamp'], 4, false);
+								}
+							}
+						}
+					}
+					break;
+
+				case 'MLLT':
+					// 4.6   MLLT MPEG location lookup table
+					// MPEG frames between reference  $xx xx
+					// Bytes between reference        $xx xx xx
+					// Milliseconds between reference $xx xx xx
+					// Bits for bytes deviation       $xx
+					// Bits for milliseconds dev.     $xx
+					//   Then for every reference the following data is included;
+					// Deviation in bytes         %xxx....
+					// Deviation in milliseconds  %xxx....
+					if (($source_data_array['framesbetweenreferences'] &gt; 0) &amp;&amp; ($source_data_array['framesbetweenreferences'] &lt;= 65535)) {
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['framesbetweenreferences'], 2, false);
+					} else {
+						$this-&gt;errors[] = 'Invalid MPEG Frames Between References in '.$frame_name.' ('.$source_data_array['framesbetweenreferences'].')';
+					}
+					if (($source_data_array['bytesbetweenreferences'] &gt; 0) &amp;&amp; ($source_data_array['bytesbetweenreferences'] &lt;= 16777215)) {
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['bytesbetweenreferences'], 3, false);
+					} else {
+						$this-&gt;errors[] = 'Invalid bytes Between References in '.$frame_name.' ('.$source_data_array['bytesbetweenreferences'].')';
+					}
+					if (($source_data_array['msbetweenreferences'] &gt; 0) &amp;&amp; ($source_data_array['msbetweenreferences'] &lt;= 16777215)) {
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['msbetweenreferences'], 3, false);
+					} else {
+						$this-&gt;errors[] = 'Invalid Milliseconds Between References in '.$frame_name.' ('.$source_data_array['msbetweenreferences'].')';
+					}
+					if (!$this-&gt;IsWithinBitRange($source_data_array['bitsforbytesdeviation'], 8, false)) {
+						if (($source_data_array['bitsforbytesdeviation'] % 4) == 0) {
+							$framedata .= chr($source_data_array['bitsforbytesdeviation']);
+						} else {
+							$this-&gt;errors[] = 'Bits For Bytes Deviation in '.$frame_name.' ('.$source_data_array['bitsforbytesdeviation'].') must be a multiple of 4.';
+						}
+					} else {
+						$this-&gt;errors[] = 'Invalid Bits For Bytes Deviation in '.$frame_name.' ('.$source_data_array['bitsforbytesdeviation'].')';
+					}
+					if (!$this-&gt;IsWithinBitRange($source_data_array['bitsformsdeviation'], 8, false)) {
+						if (($source_data_array['bitsformsdeviation'] % 4) == 0) {
+							$framedata .= chr($source_data_array['bitsformsdeviation']);
+						} else {
+							$this-&gt;errors[] = 'Bits For Milliseconds Deviation in '.$frame_name.' ('.$source_data_array['bitsforbytesdeviation'].') must be a multiple of 4.';
+						}
+					} else {
+						$this-&gt;errors[] = 'Invalid Bits For Milliseconds Deviation in '.$frame_name.' ('.$source_data_array['bitsformsdeviation'].')';
+					}
+					foreach ($source_data_array as $key =&gt; $val) {
+						if (($key != 'framesbetweenreferences') &amp;&amp; ($key != 'bytesbetweenreferences') &amp;&amp; ($key != 'msbetweenreferences') &amp;&amp; ($key != 'bitsforbytesdeviation') &amp;&amp; ($key != 'bitsformsdeviation') &amp;&amp; ($key != 'flags')) {
+							$unwrittenbitstream .= str_pad(getid3_lib::Dec2Bin($val['bytedeviation']), $source_data_array['bitsforbytesdeviation'], '0', STR_PAD_LEFT);
+							$unwrittenbitstream .= str_pad(getid3_lib::Dec2Bin($val['msdeviation']),   $source_data_array['bitsformsdeviation'],    '0', STR_PAD_LEFT);
+						}
+					}
+					for ($i = 0; $i &lt; strlen($unwrittenbitstream); $i += 8) {
+						$highnibble = bindec(substr($unwrittenbitstream, $i, 4)) &lt;&lt; 4;
+						$lownibble  = bindec(substr($unwrittenbitstream, $i + 4, 4));
+						$framedata .= chr($highnibble &amp; $lownibble);
+					}
+					break;
+
+				case 'SYTC':
+					// 4.7   SYTC Synchronised tempo codes
+					// Time stamp format   $xx
+					// Tempo data          &lt;binary data&gt;
+					//   Where time stamp format is:
+					// $01  (32-bit value) MPEG frames from beginning of file
+					// $02  (32-bit value) milliseconds from beginning of file
+					if (($source_data_array['timestampformat'] &gt; 2) || ($source_data_array['timestampformat'] &lt; 1)) {
+						$this-&gt;errors[] = 'Invalid Time Stamp Format byte in '.$frame_name.' ('.$source_data_array['timestampformat'].')';
+					} else {
+						$framedata .= chr($source_data_array['timestampformat']);
+						foreach ($source_data_array as $key =&gt; $val) {
+							if (!$this-&gt;ID3v2IsValidETCOevent($val['typeid'])) {
+								$this-&gt;errors[] = 'Invalid Event Type byte in '.$frame_name.' ('.$val['typeid'].')';
+							} elseif (($key != 'timestampformat') &amp;&amp; ($key != 'flags')) {
+								if (($val['tempo'] &lt; 0) || ($val['tempo'] &gt; 510)) {
+									$this-&gt;errors[] = 'Invalid Tempo (max = 510) in '.$frame_name.' ('.$val['tempo'].') at timestamp ('.$val['timestamp'].')';
+								} else {
+									if ($val['tempo'] &gt; 255) {
+										$framedata .= chr(255);
+										$val['tempo'] -= 255;
+									}
+									$framedata .= chr($val['tempo']);
+									$framedata .= getid3_lib::BigEndian2String($val['timestamp'], 4, false);
+								}
+							}
+						}
+					}
+					break;
+
+				case 'USLT':
+					// 4.8   USLT Unsynchronised lyric/text transcription
+					// Text encoding        $xx
+					// Language             $xx xx xx
+					// Content descriptor   &lt;text string according to encoding&gt; $00 (00)
+					// Lyrics/text          &lt;full text string according to encoding&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'])) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].') for ID3v2.'.$this-&gt;majorversion;
+					} elseif (getid3_id3v2::LanguageLookup($source_data_array['language'], true) == '') {
+						$this-&gt;errors[] = 'Invalid Language in '.$frame_name.' ('.$source_data_array['language'].')';
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= strtolower($source_data_array['language']);
+						$framedata .= $source_data_array['description'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'SYLT':
+					// 4.9   SYLT Synchronised lyric/text
+					// Text encoding        $xx
+					// Language             $xx xx xx
+					// Time stamp format    $xx
+					//   $01  (32-bit value) MPEG frames from beginning of file
+					//   $02  (32-bit value) milliseconds from beginning of file
+					// Content type         $xx
+					// Content descriptor   &lt;text string according to encoding&gt; $00 (00)
+					//   Terminated text to be synced (typically a syllable)
+					//   Sync identifier (terminator to above string)   $00 (00)
+					//   Time stamp                                     $xx (xx ...)
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'])) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].') for ID3v2.'.$this-&gt;majorversion;
+					} elseif (getid3_id3v2::LanguageLookup($source_data_array['language'], true) == '') {
+						$this-&gt;errors[] = 'Invalid Language in '.$frame_name.' ('.$source_data_array['language'].')';
+					} elseif (($source_data_array['timestampformat'] &gt; 2) || ($source_data_array['timestampformat'] &lt; 1)) {
+						$this-&gt;errors[] = 'Invalid Time Stamp Format byte in '.$frame_name.' ('.$source_data_array['timestampformat'].')';
+					} elseif (!$this-&gt;ID3v2IsValidSYLTtype($source_data_array['contenttypeid'])) {
+						$this-&gt;errors[] = 'Invalid Content Type byte in '.$frame_name.' ('.$source_data_array['contenttypeid'].')';
+					} elseif (!is_array($source_data_array['data'])) {
+						$this-&gt;errors[] = 'Invalid Lyric/Timestamp data in '.$frame_name.' (must be an array)';
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= strtolower($source_data_array['language']);
+						$framedata .= chr($source_data_array['timestampformat']);
+						$framedata .= chr($source_data_array['contenttypeid']);
+						$framedata .= $source_data_array['description'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						ksort($source_data_array['data']);
+						foreach ($source_data_array['data'] as $key =&gt; $val) {
+							$framedata .= $val['data'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+							$framedata .= getid3_lib::BigEndian2String($val['timestamp'], 4, false);
+						}
+					}
+					break;
+
+				case 'COMM':
+					// 4.10  COMM Comments
+					// Text encoding          $xx
+					// Language               $xx xx xx
+					// Short content descrip. &lt;text string according to encoding&gt; $00 (00)
+					// The actual text        &lt;full text string according to encoding&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'])) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].') for ID3v2.'.$this-&gt;majorversion;
+					} elseif (getid3_id3v2::LanguageLookup($source_data_array['language'], true) == '') {
+						$this-&gt;errors[] = 'Invalid Language in '.$frame_name.' ('.$source_data_array['language'].')';
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= strtolower($source_data_array['language']);
+						$framedata .= $source_data_array['description'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'RVA2':
+					// 4.11  RVA2 Relative volume adjustment (2) (ID3v2.4+ only)
+					// Identification          &lt;text string&gt; $00
+					//   The 'identification' string is used to identify the situation and/or
+					//   device where this adjustment should apply. The following is then
+					//   repeated for every channel:
+					// Type of channel         $xx
+					// Volume adjustment       $xx xx
+					// Bits representing peak  $xx
+					// Peak volume             $xx (xx ...)
+					$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['description']).&quot;\x00&quot;;
+					foreach ($source_data_array as $key =&gt; $val) {
+						if ($key != 'description') {
+							$framedata .= chr($val['channeltypeid']);
+							$framedata .= getid3_lib::BigEndian2String($val['volumeadjust'], 2, false, true); // signed 16-bit
+							if (!$this-&gt;IsWithinBitRange($source_data_array['bitspeakvolume'], 8, false)) {
+								$framedata .= chr($val['bitspeakvolume']);
+								if ($val['bitspeakvolume'] &gt; 0) {
+									$framedata .= getid3_lib::BigEndian2String($val['peakvolume'], ceil($val['bitspeakvolume'] / 8), false, false);
+								}
+							} else {
+								$this-&gt;errors[] = 'Invalid Bits Representing Peak Volume in '.$frame_name.' ('.$val['bitspeakvolume'].') (range = 0 to 255)';
+							}
+						}
+					}
+					break;
+
+				case 'RVAD':
+					// 4.12  RVAD Relative volume adjustment (ID3v2.3 only)
+					// Increment/decrement     %00fedcba
+					// Bits used for volume descr.        $xx
+					// Relative volume change, right      $xx xx (xx ...) // a
+					// Relative volume change, left       $xx xx (xx ...) // b
+					// Peak volume right                  $xx xx (xx ...)
+					// Peak volume left                   $xx xx (xx ...)
+					// Relative volume change, right back $xx xx (xx ...) // c
+					// Relative volume change, left back  $xx xx (xx ...) // d
+					// Peak volume right back             $xx xx (xx ...)
+					// Peak volume left back              $xx xx (xx ...)
+					// Relative volume change, center     $xx xx (xx ...) // e
+					// Peak volume center                 $xx xx (xx ...)
+					// Relative volume change, bass       $xx xx (xx ...) // f
+					// Peak volume bass                   $xx xx (xx ...)
+					if (!$this-&gt;IsWithinBitRange($source_data_array['bitsvolume'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Bits For Volume Description byte in '.$frame_name.' ('.$source_data_array['bitsvolume'].') (range = 1 to 255)';
+					} else {
+						$incdecflag .= '00';
+						$incdecflag .= $source_data_array['incdec']['right']     ? '1' : '0';     // a - Relative volume change, right
+						$incdecflag .= $source_data_array['incdec']['left']      ? '1' : '0';      // b - Relative volume change, left
+						$incdecflag .= $source_data_array['incdec']['rightrear'] ? '1' : '0'; // c - Relative volume change, right back
+						$incdecflag .= $source_data_array['incdec']['leftrear']  ? '1' : '0';  // d - Relative volume change, left back
+						$incdecflag .= $source_data_array['incdec']['center']    ? '1' : '0';    // e - Relative volume change, center
+						$incdecflag .= $source_data_array['incdec']['bass']      ? '1' : '0';      // f - Relative volume change, bass
+						$framedata .= chr(bindec($incdecflag));
+						$framedata .= chr($source_data_array['bitsvolume']);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['volumechange']['right'], ceil($source_data_array['bitsvolume'] / 8), false);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['volumechange']['left'],  ceil($source_data_array['bitsvolume'] / 8), false);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['peakvolume']['right'], ceil($source_data_array['bitsvolume'] / 8), false);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['peakvolume']['left'],  ceil($source_data_array['bitsvolume'] / 8), false);
+						if ($source_data_array['volumechange']['rightrear'] || $source_data_array['volumechange']['leftrear'] ||
+							$source_data_array['peakvolume']['rightrear'] || $source_data_array['peakvolume']['leftrear'] ||
+							$source_data_array['volumechange']['center'] || $source_data_array['peakvolume']['center'] ||
+							$source_data_array['volumechange']['bass'] || $source_data_array['peakvolume']['bass']) {
+								$framedata .= getid3_lib::BigEndian2String($source_data_array['volumechange']['rightrear'], ceil($source_data_array['bitsvolume']/8), false);
+								$framedata .= getid3_lib::BigEndian2String($source_data_array['volumechange']['leftrear'],  ceil($source_data_array['bitsvolume']/8), false);
+								$framedata .= getid3_lib::BigEndian2String($source_data_array['peakvolume']['rightrear'], ceil($source_data_array['bitsvolume']/8), false);
+								$framedata .= getid3_lib::BigEndian2String($source_data_array['peakvolume']['leftrear'],  ceil($source_data_array['bitsvolume']/8), false);
+						}
+						if ($source_data_array['volumechange']['center'] || $source_data_array['peakvolume']['center'] ||
+							$source_data_array['volumechange']['bass'] || $source_data_array['peakvolume']['bass']) {
+								$framedata .= getid3_lib::BigEndian2String($source_data_array['volumechange']['center'], ceil($source_data_array['bitsvolume']/8), false);
+								$framedata .= getid3_lib::BigEndian2String($source_data_array['peakvolume']['center'], ceil($source_data_array['bitsvolume']/8), false);
+						}
+						if ($source_data_array['volumechange']['bass'] || $source_data_array['peakvolume']['bass']) {
+								$framedata .= getid3_lib::BigEndian2String($source_data_array['volumechange']['bass'], ceil($source_data_array['bitsvolume']/8), false);
+								$framedata .= getid3_lib::BigEndian2String($source_data_array['peakvolume']['bass'], ceil($source_data_array['bitsvolume']/8), false);
+						}
+					}
+					break;
+
+				case 'EQU2':
+					// 4.12  EQU2 Equalisation (2) (ID3v2.4+ only)
+					// Interpolation method  $xx
+					//   $00  Band
+					//   $01  Linear
+					// Identification        &lt;text string&gt; $00
+					//   The following is then repeated for every adjustment point
+					// Frequency          $xx xx
+					// Volume adjustment  $xx xx
+					if (($source_data_array['interpolationmethod'] &lt; 0) || ($source_data_array['interpolationmethod'] &gt; 1)) {
+						$this-&gt;errors[] = 'Invalid Interpolation Method byte in '.$frame_name.' ('.$source_data_array['interpolationmethod'].') (valid = 0 or 1)';
+					} else {
+						$framedata .= chr($source_data_array['interpolationmethod']);
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['description']).&quot;\x00&quot;;
+						foreach ($source_data_array['data'] as $key =&gt; $val) {
+							$framedata .= getid3_lib::BigEndian2String(intval(round($key * 2)), 2, false);
+							$framedata .= getid3_lib::BigEndian2String($val, 2, false, true); // signed 16-bit
+						}
+					}
+					break;
+
+				case 'EQUA':
+					// 4.12  EQUA Equalisation (ID3v2.3 only)
+					// Adjustment bits    $xx
+					//   This is followed by 2 bytes + ('adjustment bits' rounded up to the
+					//   nearest byte) for every equalisation band in the following format,
+					//   giving a frequency range of 0 - 32767Hz:
+					// Increment/decrement   %x (MSB of the Frequency)
+					// Frequency             (lower 15 bits)
+					// Adjustment            $xx (xx ...)
+					if (!$this-&gt;IsWithinBitRange($source_data_array['bitsvolume'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Adjustment Bits byte in '.$frame_name.' ('.$source_data_array['bitsvolume'].') (range = 1 to 255)';
+					} else {
+						$framedata .= chr($source_data_array['adjustmentbits']);
+						foreach ($source_data_array as $key =&gt; $val) {
+							if ($key != 'bitsvolume') {
+								if (($key &gt; 32767) || ($key &lt; 0)) {
+									$this-&gt;errors[] = 'Invalid Frequency in '.$frame_name.' ('.$key.') (range = 0 to 32767)';
+								} else {
+									if ($val &gt;= 0) {
+										// put MSB of frequency to 1 if increment, 0 if decrement
+										$key |= 0x8000;
+									}
+									$framedata .= getid3_lib::BigEndian2String($key, 2, false);
+									$framedata .= getid3_lib::BigEndian2String($val, ceil($source_data_array['adjustmentbits'] / 8), false);
+								}
+							}
+						}
+					}
+					break;
+
+				case 'RVRB':
+					// 4.13  RVRB Reverb
+					// Reverb left (ms)                 $xx xx
+					// Reverb right (ms)                $xx xx
+					// Reverb bounces, left             $xx
+					// Reverb bounces, right            $xx
+					// Reverb feedback, left to left    $xx
+					// Reverb feedback, left to right   $xx
+					// Reverb feedback, right to right  $xx
+					// Reverb feedback, right to left   $xx
+					// Premix left to right             $xx
+					// Premix right to left             $xx
+					if (!$this-&gt;IsWithinBitRange($source_data_array['left'], 16, false)) {
+						$this-&gt;errors[] = 'Invalid Reverb Left in '.$frame_name.' ('.$source_data_array['left'].') (range = 0 to 65535)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['right'], 16, false)) {
+						$this-&gt;errors[] = 'Invalid Reverb Left in '.$frame_name.' ('.$source_data_array['right'].') (range = 0 to 65535)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['bouncesL'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Reverb Bounces, Left in '.$frame_name.' ('.$source_data_array['bouncesL'].') (range = 0 to 255)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['bouncesR'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Reverb Bounces, Right in '.$frame_name.' ('.$source_data_array['bouncesR'].') (range = 0 to 255)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['feedbackLL'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Reverb Feedback, Left-To-Left in '.$frame_name.' ('.$source_data_array['feedbackLL'].') (range = 0 to 255)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['feedbackLR'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Reverb Feedback, Left-To-Right in '.$frame_name.' ('.$source_data_array['feedbackLR'].') (range = 0 to 255)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['feedbackRR'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Reverb Feedback, Right-To-Right in '.$frame_name.' ('.$source_data_array['feedbackRR'].') (range = 0 to 255)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['feedbackRL'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Reverb Feedback, Right-To-Left in '.$frame_name.' ('.$source_data_array['feedbackRL'].') (range = 0 to 255)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['premixLR'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Premix, Left-To-Right in '.$frame_name.' ('.$source_data_array['premixLR'].') (range = 0 to 255)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['premixRL'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Premix, Right-To-Left in '.$frame_name.' ('.$source_data_array['premixRL'].') (range = 0 to 255)';
+					} else {
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['left'], 2, false);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['right'], 2, false);
+						$framedata .= chr($source_data_array['bouncesL']);
+						$framedata .= chr($source_data_array['bouncesR']);
+						$framedata .= chr($source_data_array['feedbackLL']);
+						$framedata .= chr($source_data_array['feedbackLR']);
+						$framedata .= chr($source_data_array['feedbackRR']);
+						$framedata .= chr($source_data_array['feedbackRL']);
+						$framedata .= chr($source_data_array['premixLR']);
+						$framedata .= chr($source_data_array['premixRL']);
+					}
+					break;
+
+				case 'APIC':
+					// 4.14  APIC Attached picture
+					// Text encoding      $xx
+					// MIME type          &lt;text string&gt; $00
+					// Picture type       $xx
+					// Description        &lt;text string according to encoding&gt; $00 (00)
+					// Picture data       &lt;binary data&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'])) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].') for ID3v2.'.$this-&gt;majorversion;
+					} elseif (!$this-&gt;ID3v2IsValidAPICpicturetype($source_data_array['picturetypeid'])) {
+						$this-&gt;errors[] = 'Invalid Picture Type byte in '.$frame_name.' ('.$source_data_array['picturetypeid'].') for ID3v2.'.$this-&gt;majorversion;
+					} elseif (($this-&gt;majorversion &gt;= 3) &amp;&amp; (!$this-&gt;ID3v2IsValidAPICimageformat($source_data_array['mime']))) {
+						$this-&gt;errors[] = 'Invalid MIME Type in '.$frame_name.' ('.$source_data_array['mime'].') for ID3v2.'.$this-&gt;majorversion;
+					} elseif (($source_data_array['mime'] == '--&gt;') &amp;&amp; (!$this-&gt;IsValidURL($source_data_array['data'], false, false))) {
+						$this-&gt;errors[] = 'Invalid URL in '.$frame_name.' ('.$source_data_array['data'].')';
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['mime']).&quot;\x00&quot;;
+						$framedata .= chr($source_data_array['picturetypeid']);
+						$framedata .= @$source_data_array['description'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'GEOB':
+					// 4.15  GEOB General encapsulated object
+					// Text encoding          $xx
+					// MIME type              &lt;text string&gt; $00
+					// Filename               &lt;text string according to encoding&gt; $00 (00)
+					// Content description    &lt;text string according to encoding&gt; $00 (00)
+					// Encapsulated object    &lt;binary data&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'])) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].') for ID3v2.'.$this-&gt;majorversion;
+					} elseif (!$this-&gt;IsValidMIMEstring($source_data_array['mime'])) {
+						$this-&gt;errors[] = 'Invalid MIME Type in '.$frame_name.' ('.$source_data_array['mime'].')';
+					} elseif (!$source_data_array['description']) {
+						$this-&gt;errors[] = 'Missing Description in '.$frame_name;
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['mime']).&quot;\x00&quot;;
+						$framedata .= $source_data_array['filename'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						$framedata .= $source_data_array['description'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'PCNT':
+					// 4.16  PCNT Play counter
+					//   When the counter reaches all one's, one byte is inserted in
+					//   front of the counter thus making the counter eight bits bigger
+					// Counter        $xx xx xx xx (xx ...)
+					$framedata .= getid3_lib::BigEndian2String($source_data_array['data'], 4, false);
+					break;
+
+				case 'POPM':
+					// 4.17  POPM Popularimeter
+					//   When the counter reaches all one's, one byte is inserted in
+					//   front of the counter thus making the counter eight bits bigger
+					// Email to user   &lt;text string&gt; $00
+					// Rating          $xx
+					// Counter         $xx xx xx xx (xx ...)
+					if (!$this-&gt;IsWithinBitRange($source_data_array['rating'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Rating byte in '.$frame_name.' ('.$source_data_array['rating'].') (range = 0 to 255)';
+					} elseif (!IsValidEmail($source_data_array['email'])) {
+						$this-&gt;errors[] = 'Invalid Email in '.$frame_name.' ('.$source_data_array['email'].')';
+					} else {
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['email']).&quot;\x00&quot;;
+						$framedata .= chr($source_data_array['rating']);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['data'], 4, false);
+					}
+					break;
+
+				case 'RBUF':
+					// 4.18  RBUF Recommended buffer size
+					// Buffer size               $xx xx xx
+					// Embedded info flag        %0000000x
+					// Offset to next tag        $xx xx xx xx
+					if (!$this-&gt;IsWithinBitRange($source_data_array['buffersize'], 24, false)) {
+						$this-&gt;errors[] = 'Invalid Buffer Size in '.$frame_name;
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['nexttagoffset'], 32, false)) {
+						$this-&gt;errors[] = 'Invalid Offset To Next Tag in '.$frame_name;
+					} else {
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['buffersize'], 3, false);
+						$flag .= '0000000';
+						$flag .= $source_data_array['flags']['embededinfo'] ? '1' : '0';
+						$framedata .= chr(bindec($flag));
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['nexttagoffset'], 4, false);
+					}
+					break;
+
+				case 'AENC':
+					// 4.19  AENC Audio encryption
+					// Owner identifier   &lt;text string&gt; $00
+					// Preview start      $xx xx
+					// Preview length     $xx xx
+					// Encryption info    &lt;binary data&gt;
+					if (!$this-&gt;IsWithinBitRange($source_data_array['previewstart'], 16, false)) {
+						$this-&gt;errors[] = 'Invalid Preview Start in '.$frame_name.' ('.$source_data_array['previewstart'].')';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['previewlength'], 16, false)) {
+						$this-&gt;errors[] = 'Invalid Preview Length in '.$frame_name.' ('.$source_data_array['previewlength'].')';
+					} else {
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['ownerid']).&quot;\x00&quot;;
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['previewstart'], 2, false);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['previewlength'], 2, false);
+						$framedata .= $source_data_array['encryptioninfo'];
+					}
+					break;
+
+				case 'LINK':
+					// 4.20  LINK Linked information
+					// Frame identifier               $xx xx xx xx
+					// URL                            &lt;text string&gt; $00
+					// ID and additional data         &lt;text string(s)&gt;
+					if (!getid3_id3v2::IsValidID3v2FrameName($source_data_array['frameid'], $this-&gt;majorversion)) {
+						$this-&gt;errors[] = 'Invalid Frame Identifier in '.$frame_name.' ('.$source_data_array['frameid'].')';
+					} elseif (!$this-&gt;IsValidURL($source_data_array['data'], true, false)) {
+						$this-&gt;errors[] = 'Invalid URL in '.$frame_name.' ('.$source_data_array['data'].')';
+					} elseif ((($source_data_array['frameid'] == 'AENC') || ($source_data_array['frameid'] == 'APIC') || ($source_data_array['frameid'] == 'GEOB') || ($source_data_array['frameid'] == 'TXXX')) &amp;&amp; ($source_data_array['additionaldata'] == '')) {
+						$this-&gt;errors[] = 'Content Descriptor must be specified as additional data for Frame Identifier of '.$source_data_array['frameid'].' in '.$frame_name;
+					} elseif (($source_data_array['frameid'] == 'USER') &amp;&amp; (getid3_id3v2::LanguageLookup($source_data_array['additionaldata'], true) == '')) {
+						$this-&gt;errors[] = 'Language must be specified as additional data for Frame Identifier of '.$source_data_array['frameid'].' in '.$frame_name;
+					} elseif (($source_data_array['frameid'] == 'PRIV') &amp;&amp; ($source_data_array['additionaldata'] == '')) {
+						$this-&gt;errors[] = 'Owner Identifier must be specified as additional data for Frame Identifier of '.$source_data_array['frameid'].' in '.$frame_name;
+					} elseif ((($source_data_array['frameid'] == 'COMM') || ($source_data_array['frameid'] == 'SYLT') || ($source_data_array['frameid'] == 'USLT')) &amp;&amp; ((getid3_id3v2::LanguageLookup(substr($source_data_array['additionaldata'], 0, 3), true) == '') || (substr($source_data_array['additionaldata'], 3) == ''))) {
+						$this-&gt;errors[] = 'Language followed by Content Descriptor must be specified as additional data for Frame Identifier of '.$source_data_array['frameid'].' in '.$frame_name;
+					} else {
+						$framedata .= $source_data_array['frameid'];
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['data']).&quot;\x00&quot;;
+						switch ($source_data_array['frameid']) {
+							case 'COMM':
+							case 'SYLT':
+							case 'USLT':
+							case 'PRIV':
+							case 'USER':
+							case 'AENC':
+							case 'APIC':
+							case 'GEOB':
+							case 'TXXX':
+								$framedata .= $source_data_array['additionaldata'];
+								break;
+							case 'ASPI':
+							case 'ETCO':
+							case 'EQU2':
+							case 'MCID':
+							case 'MLLT':
+							case 'OWNE':
+							case 'RVA2':
+							case 'RVRB':
+							case 'SYTC':
+							case 'IPLS':
+							case 'RVAD':
+							case 'EQUA':
+								// no additional data required
+								break;
+							case 'RBUF':
+								if ($this-&gt;majorversion == 3) {
+									// no additional data required
+								} else {
+									$this-&gt;errors[] = $source_data_array['frameid'].' is not a valid Frame Identifier in '.$frame_name.' (in ID3v2.'.$this-&gt;majorversion.')';
+								}
+
+							default:
+								if ((substr($source_data_array['frameid'], 0, 1) == 'T') || (substr($source_data_array['frameid'], 0, 1) == 'W')) {
+									// no additional data required
+								} else {
+									$this-&gt;errors[] = $source_data_array['frameid'].' is not a valid Frame Identifier in '.$frame_name.' (in ID3v2.'.$this-&gt;majorversion.')';
+								}
+								break;
+						}
+					}
+					break;
+
+				case 'POSS':
+					// 4.21  POSS Position synchronisation frame (ID3v2.3+ only)
+					// Time stamp format         $xx
+					// Position                  $xx (xx ...)
+					if (($source_data_array['timestampformat'] &lt; 1) || ($source_data_array['timestampformat'] &gt; 2)) {
+						$this-&gt;errors[] = 'Invalid Time Stamp Format in '.$frame_name.' ('.$source_data_array['timestampformat'].') (valid = 1 or 2)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['position'], 32, false)) {
+						$this-&gt;errors[] = 'Invalid Position in '.$frame_name.' ('.$source_data_array['position'].') (range = 0 to 4294967295)';
+					} else {
+						$framedata .= chr($source_data_array['timestampformat']);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['position'], 4, false);
+					}
+					break;
+
+				case 'USER':
+					// 4.22  USER Terms of use (ID3v2.3+ only)
+					// Text encoding        $xx
+					// Language             $xx xx xx
+					// The actual text      &lt;text string according to encoding&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'])) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].')';
+					} elseif (getid3_id3v2::LanguageLookup($source_data_array['language'], true) == '') {
+						$this-&gt;errors[] = 'Invalid Language in '.$frame_name.' ('.$source_data_array['language'].')';
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= strtolower($source_data_array['language']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'OWNE':
+					// 4.23  OWNE Ownership frame (ID3v2.3+ only)
+					// Text encoding     $xx
+					// Price paid        &lt;text string&gt; $00
+					// Date of purch.    &lt;text string&gt;
+					// Seller            &lt;text string according to encoding&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'])) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].')';
+					} elseif (!$this-&gt;IsANumber($source_data_array['pricepaid']['value'], false)) {
+						$this-&gt;errors[] = 'Invalid Price Paid in '.$frame_name.' ('.$source_data_array['pricepaid']['value'].')';
+					} elseif (!$this-&gt;IsValidDateStampString($source_data_array['purchasedate'])) {
+						$this-&gt;errors[] = 'Invalid Date Of Purchase in '.$frame_name.' ('.$source_data_array['purchasedate'].') (format = YYYYMMDD)';
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['pricepaid']['value']).&quot;\x00&quot;;
+						$framedata .= $source_data_array['purchasedate'];
+						$framedata .= $source_data_array['seller'];
+					}
+					break;
+
+				case 'COMR':
+					// 4.24  COMR Commercial frame (ID3v2.3+ only)
+					// Text encoding      $xx
+					// Price string       &lt;text string&gt; $00
+					// Valid until        &lt;text string&gt;
+					// Contact URL        &lt;text string&gt; $00
+					// Received as        $xx
+					// Name of seller     &lt;text string according to encoding&gt; $00 (00)
+					// Description        &lt;text string according to encoding&gt; $00 (00)
+					// Picture MIME type  &lt;string&gt; $00
+					// Seller logo        &lt;binary data&gt;
+					$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+					if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'])) {
+						$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].')';
+					} elseif (!$this-&gt;IsValidDateStampString($source_data_array['pricevaliduntil'])) {
+						$this-&gt;errors[] = 'Invalid Valid Until date in '.$frame_name.' ('.$source_data_array['pricevaliduntil'].') (format = YYYYMMDD)';
+					} elseif (!$this-&gt;IsValidURL($source_data_array['contacturl'], false, true)) {
+						$this-&gt;errors[] = 'Invalid Contact URL in '.$frame_name.' ('.$source_data_array['contacturl'].') (allowed schemes: http, https, ftp, mailto)';
+					} elseif (!$this-&gt;ID3v2IsValidCOMRreceivedAs($source_data_array['receivedasid'])) {
+						$this-&gt;errors[] = 'Invalid Received As byte in '.$frame_name.' ('.$source_data_array['contacturl'].') (range = 0 to 8)';
+					} elseif (!$this-&gt;IsValidMIMEstring($source_data_array['mime'])) {
+						$this-&gt;errors[] = 'Invalid MIME Type in '.$frame_name.' ('.$source_data_array['mime'].')';
+					} else {
+						$framedata .= chr($source_data_array['encodingid']);
+						unset($pricestring);
+						foreach ($source_data_array['price'] as $key =&gt; $val) {
+							if ($this-&gt;ID3v2IsValidPriceString($key.$val['value'])) {
+								$pricestrings[] = $key.$val['value'];
+							} else {
+								$this-&gt;errors[] = 'Invalid Price String in '.$frame_name.' ('.$key.$val['value'].')';
+							}
+						}
+						$framedata .= implode('/', $pricestrings);
+						$framedata .= $source_data_array['pricevaliduntil'];
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['contacturl']).&quot;\x00&quot;;
+						$framedata .= chr($source_data_array['receivedasid']);
+						$framedata .= $source_data_array['sellername'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						$framedata .= $source_data_array['description'].getid3_id3v2::TextEncodingTerminatorLookup($source_data_array['encodingid']);
+						$framedata .= $source_data_array['mime'].&quot;\x00&quot;;
+						$framedata .= $source_data_array['logo'];
+					}
+					break;
+
+				case 'ENCR':
+					// 4.25  ENCR Encryption method registration (ID3v2.3+ only)
+					// Owner identifier    &lt;text string&gt; $00
+					// Method symbol       $xx
+					// Encryption data     &lt;binary data&gt;
+					if (!$this-&gt;IsWithinBitRange($source_data_array['methodsymbol'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Group Symbol in '.$frame_name.' ('.$source_data_array['methodsymbol'].') (range = 0 to 255)';
+					} else {
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['ownerid']).&quot;\x00&quot;;
+						$framedata .= ord($source_data_array['methodsymbol']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'GRID':
+					// 4.26  GRID Group identification registration (ID3v2.3+ only)
+					// Owner identifier      &lt;text string&gt; $00
+					// Group symbol          $xx
+					// Group dependent data  &lt;binary data&gt;
+					if (!$this-&gt;IsWithinBitRange($source_data_array['groupsymbol'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Group Symbol in '.$frame_name.' ('.$source_data_array['groupsymbol'].') (range = 0 to 255)';
+					} else {
+						$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['ownerid']).&quot;\x00&quot;;
+						$framedata .= ord($source_data_array['groupsymbol']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'PRIV':
+					// 4.27  PRIV Private frame (ID3v2.3+ only)
+					// Owner identifier      &lt;text string&gt; $00
+					// The private data      &lt;binary data&gt;
+					$framedata .= str_replace(&quot;\x00&quot;, '', $source_data_array['ownerid']).&quot;\x00&quot;;
+					$framedata .= $source_data_array['data'];
+					break;
+
+				case 'SIGN':
+					// 4.28  SIGN Signature frame (ID3v2.4+ only)
+					// Group symbol      $xx
+					// Signature         &lt;binary data&gt;
+					if (!$this-&gt;IsWithinBitRange($source_data_array['groupsymbol'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Group Symbol in '.$frame_name.' ('.$source_data_array['groupsymbol'].') (range = 0 to 255)';
+					} else {
+						$framedata .= ord($source_data_array['groupsymbol']);
+						$framedata .= $source_data_array['data'];
+					}
+					break;
+
+				case 'SEEK':
+					// 4.29  SEEK Seek frame (ID3v2.4+ only)
+					// Minimum offset to next tag       $xx xx xx xx
+					if (!$this-&gt;IsWithinBitRange($source_data_array['data'], 32, false)) {
+						$this-&gt;errors[] = 'Invalid Minimum Offset in '.$frame_name.' ('.$source_data_array['data'].') (range = 0 to 4294967295)';
+					} else {
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['data'], 4, false);
+					}
+					break;
+
+				case 'ASPI':
+					// 4.30  ASPI Audio seek point index (ID3v2.4+ only)
+					// Indexed data start (S)         $xx xx xx xx
+					// Indexed data length (L)        $xx xx xx xx
+					// Number of index points (N)     $xx xx
+					// Bits per index point (b)       $xx
+					//   Then for every index point the following data is included:
+					// Fraction at index (Fi)          $xx (xx)
+					if (!$this-&gt;IsWithinBitRange($source_data_array['datastart'], 32, false)) {
+						$this-&gt;errors[] = 'Invalid Indexed Data Start in '.$frame_name.' ('.$source_data_array['datastart'].') (range = 0 to 4294967295)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['datalength'], 32, false)) {
+						$this-&gt;errors[] = 'Invalid Indexed Data Length in '.$frame_name.' ('.$source_data_array['datalength'].') (range = 0 to 4294967295)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['indexpoints'], 16, false)) {
+						$this-&gt;errors[] = 'Invalid Number Of Index Points in '.$frame_name.' ('.$source_data_array['indexpoints'].') (range = 0 to 65535)';
+					} elseif (!$this-&gt;IsWithinBitRange($source_data_array['bitsperpoint'], 8, false)) {
+						$this-&gt;errors[] = 'Invalid Bits Per Index Point in '.$frame_name.' ('.$source_data_array['bitsperpoint'].') (range = 0 to 255)';
+					} elseif ($source_data_array['indexpoints'] != count($source_data_array['indexes'])) {
+						$this-&gt;errors[] = 'Number Of Index Points does not match actual supplied data in '.$frame_name;
+					} else {
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['datastart'], 4, false);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['datalength'], 4, false);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['indexpoints'], 2, false);
+						$framedata .= getid3_lib::BigEndian2String($source_data_array['bitsperpoint'], 1, false);
+						foreach ($source_data_array['indexes'] as $key =&gt; $val) {
+							$framedata .= getid3_lib::BigEndian2String($val, ceil($source_data_array['bitsperpoint'] / 8), false);
+						}
+					}
+					break;
+
+				case 'RGAD':
+					//   RGAD Replay Gain Adjustment
+					//   <A HREF="http://privatewww.essex.ac.uk/~djmrob/replaygain/">http://privatewww.essex.ac.uk/~djmrob/replaygain/</A>
+					// Peak Amplitude                     $xx $xx $xx $xx
+					// Radio Replay Gain Adjustment        %aaabbbcd %dddddddd
+					// Audiophile Replay Gain Adjustment   %aaabbbcd %dddddddd
+					//   a - name code
+					//   b - originator code
+					//   c - sign bit
+					//   d - replay gain adjustment
+
+					if (($source_data_array['track_adjustment'] &gt; 51) || ($source_data_array['track_adjustment'] &lt; -51)) {
+						$this-&gt;errors[] = 'Invalid Track Adjustment in '.$frame_name.' ('.$source_data_array['track_adjustment'].') (range = -51.0 to +51.0)';
+					} elseif (($source_data_array['album_adjustment'] &gt; 51) || ($source_data_array['album_adjustment'] &lt; -51)) {
+						$this-&gt;errors[] = 'Invalid Album Adjustment in '.$frame_name.' ('.$source_data_array['album_adjustment'].') (range = -51.0 to +51.0)';
+					} elseif (!$this-&gt;ID3v2IsValidRGADname($source_data_array['raw']['track_name'])) {
+						$this-&gt;errors[] = 'Invalid Track Name Code in '.$frame_name.' ('.$source_data_array['raw']['track_name'].') (range = 0 to 2)';
+					} elseif (!$this-&gt;ID3v2IsValidRGADname($source_data_array['raw']['album_name'])) {
+						$this-&gt;errors[] = 'Invalid Album Name Code in '.$frame_name.' ('.$source_data_array['raw']['album_name'].') (range = 0 to 2)';
+					} elseif (!$this-&gt;ID3v2IsValidRGADoriginator($source_data_array['raw']['track_originator'])) {
+						$this-&gt;errors[] = 'Invalid Track Originator Code in '.$frame_name.' ('.$source_data_array['raw']['track_originator'].') (range = 0 to 3)';
+					} elseif (!$this-&gt;ID3v2IsValidRGADoriginator($source_data_array['raw']['album_originator'])) {
+						$this-&gt;errors[] = 'Invalid Album Originator Code in '.$frame_name.' ('.$source_data_array['raw']['album_originator'].') (range = 0 to 3)';
+					} else {
+						$framedata .= getid3_lib::Float2String($source_data_array['peakamplitude'], 32);
+						$framedata .= getid3_lib::RGADgainString($source_data_array['raw']['track_name'], $source_data_array['raw']['track_originator'], $source_data_array['track_adjustment']);
+						$framedata .= getid3_lib::RGADgainString($source_data_array['raw']['album_name'], $source_data_array['raw']['album_originator'], $source_data_array['album_adjustment']);
+					}
+					break;
+
+				default:
+					if ($frame_name{0} == 'T') {
+						// 4.2. T???  Text information frames
+						// Text encoding                $xx
+						// Information                  &lt;text string(s) according to encoding&gt;
+						$source_data_array['encodingid'] = (isset($source_data_array['encodingid']) ? $source_data_array['encodingid'] : $this-&gt;id3v2_default_encodingid);
+						if (!$this-&gt;ID3v2IsValidTextEncoding($source_data_array['encodingid'])) {
+							$this-&gt;errors[] = 'Invalid Text Encoding in '.$frame_name.' ('.$source_data_array['encodingid'].') for ID3v2.'.$this-&gt;majorversion;
+						} else {
+							$framedata .= chr($source_data_array['encodingid']);
+							$framedata .= $source_data_array['data'];
+						}
+					} elseif ($frame_name{0} == 'W') {
+						// 4.3. W???  URL link frames
+						// URL              &lt;text string&gt;
+						if (!$this-&gt;IsValidURL($source_data_array['data'], false, false)) {
+							$this-&gt;errors[] = 'Invalid URL in '.$frame_name.' ('.$source_data_array['data'].')';
+						} else {
+							$framedata .= $source_data_array['data'];
+						}
+					} else {
+						$this-&gt;errors[] = $frame_name.' not yet supported in $this-&gt;GenerateID3v2FrameData()';
+					}
+					break;
+			}
+		}
+		if (!empty($this-&gt;errors)) {
+			return false;
+		}
+		return $framedata;
+	}
+
+	function ID3v2FrameIsAllowed($frame_name, $source_data_array) {
+		static $PreviousFrames = array();
+
+		if ($frame_name === null) {
+			// if the writing functions are called multiple times, the static array needs to be
+			// cleared - this can be done by calling $this-&gt;ID3v2FrameIsAllowed(null, '')
+			$PreviousFrames = array();
+			return true;
+		}
+
+		if ($this-&gt;majorversion == 4) {
+			switch ($frame_name) {
+				case 'UFID':
+				case 'AENC':
+				case 'ENCR':
+				case 'GRID':
+					if (!isset($source_data_array['ownerid'])) {
+						$this-&gt;errors[] = '[ownerid] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['ownerid'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same OwnerID ('.$source_data_array['ownerid'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['ownerid'];
+					}
+					break;
+
+				case 'TXXX':
+				case 'WXXX':
+				case 'RVA2':
+				case 'EQU2':
+				case 'APIC':
+				case 'GEOB':
+					if (!isset($source_data_array['description'])) {
+						$this-&gt;errors[] = '[description] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['description'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Description ('.$source_data_array['description'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['description'];
+					}
+					break;
+
+				case 'USER':
+					if (!isset($source_data_array['language'])) {
+						$this-&gt;errors[] = '[language] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['language'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Language ('.$source_data_array['language'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['language'];
+					}
+					break;
+
+				case 'USLT':
+				case 'SYLT':
+				case 'COMM':
+					if (!isset($source_data_array['language'])) {
+						$this-&gt;errors[] = '[language] not specified for '.$frame_name;
+					} elseif (!isset($source_data_array['description'])) {
+						$this-&gt;errors[] = '[description] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['language'].$source_data_array['description'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Language + Description ('.$source_data_array['language'].' + '.$source_data_array['description'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['language'].$source_data_array['description'];
+					}
+					break;
+
+				case 'POPM':
+					if (!isset($source_data_array['email'])) {
+						$this-&gt;errors[] = '[email] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['email'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Email ('.$source_data_array['email'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['email'];
+					}
+					break;
+
+				case 'IPLS':
+				case 'MCDI':
+				case 'ETCO':
+				case 'MLLT':
+				case 'SYTC':
+				case 'RVRB':
+				case 'PCNT':
+				case 'RBUF':
+				case 'POSS':
+				case 'OWNE':
+				case 'SEEK':
+				case 'ASPI':
+				case 'RGAD':
+					if (in_array($frame_name, $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed';
+					} else {
+						$PreviousFrames[] = $frame_name;
+					}
+					break;
+
+				case 'LINK':
+					// this isn't implemented quite right (yet) - it should check the target frame data for compliance
+					// but right now it just allows one linked frame of each type, to be safe.
+					if (!isset($source_data_array['frameid'])) {
+						$this-&gt;errors[] = '[frameid] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['frameid'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same FrameID ('.$source_data_array['frameid'].')';
+					} elseif (in_array($source_data_array['frameid'], $PreviousFrames)) {
+						// no links to singleton tags
+						$this-&gt;errors[] = 'Cannot specify a '.$frame_name.' tag to a singleton tag that already exists ('.$source_data_array['frameid'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['frameid']; // only one linked tag of this type
+						$PreviousFrames[] = $source_data_array['frameid'];             // no non-linked singleton tags of this type
+					}
+					break;
+
+				case 'COMR':
+					//   There may be more than one 'commercial frame' in a tag, but no two may be identical
+					// Checking isn't implemented at all (yet) - just assumes that it's OK.
+					break;
+
+				case 'PRIV':
+				case 'SIGN':
+					if (!isset($source_data_array['ownerid'])) {
+						$this-&gt;errors[] = '[ownerid] not specified for '.$frame_name;
+					} elseif (!isset($source_data_array['data'])) {
+						$this-&gt;errors[] = '[data] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['ownerid'].$source_data_array['data'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same OwnerID + Data ('.$source_data_array['ownerid'].' + '.$source_data_array['data'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['ownerid'].$source_data_array['data'];
+					}
+					break;
+
+				default:
+					if (($frame_name{0} != 'T') &amp;&amp; ($frame_name{0} != 'W')) {
+						$this-&gt;errors[] = 'Frame not allowed in ID3v2.'.$this-&gt;majorversion.': '.$frame_name;
+					}
+					break;
+			}
+
+		} elseif ($this-&gt;majorversion == 3) {
+
+			switch ($frame_name) {
+				case 'UFID':
+				case 'AENC':
+				case 'ENCR':
+				case 'GRID':
+					if (!isset($source_data_array['ownerid'])) {
+						$this-&gt;errors[] = '[ownerid] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['ownerid'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same OwnerID ('.$source_data_array['ownerid'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['ownerid'];
+					}
+					break;
+
+				case 'TXXX':
+				case 'WXXX':
+				case 'APIC':
+				case 'GEOB':
+					if (!isset($source_data_array['description'])) {
+						$this-&gt;errors[] = '[description] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['description'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Description ('.$source_data_array['description'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['description'];
+					}
+					break;
+
+				case 'USER':
+					if (!isset($source_data_array['language'])) {
+						$this-&gt;errors[] = '[language] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['language'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Language ('.$source_data_array['language'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['language'];
+					}
+					break;
+
+				case 'USLT':
+				case 'SYLT':
+				case 'COMM':
+					if (!isset($source_data_array['language'])) {
+						$this-&gt;errors[] = '[language] not specified for '.$frame_name;
+					} elseif (!isset($source_data_array['description'])) {
+						$this-&gt;errors[] = '[description] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['language'].$source_data_array['description'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Language + Description ('.$source_data_array['language'].' + '.$source_data_array['description'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['language'].$source_data_array['description'];
+					}
+					break;
+
+				case 'POPM':
+					if (!isset($source_data_array['email'])) {
+						$this-&gt;errors[] = '[email] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['email'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Email ('.$source_data_array['email'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['email'];
+					}
+					break;
+
+				case 'IPLS':
+				case 'MCDI':
+				case 'ETCO':
+				case 'MLLT':
+				case 'SYTC':
+				case 'RVAD':
+				case 'EQUA':
+				case 'RVRB':
+				case 'PCNT':
+				case 'RBUF':
+				case 'POSS':
+				case 'OWNE':
+				case 'RGAD':
+					if (in_array($frame_name, $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed';
+					} else {
+						$PreviousFrames[] = $frame_name;
+					}
+					break;
+
+				case 'LINK':
+					// this isn't implemented quite right (yet) - it should check the target frame data for compliance
+					// but right now it just allows one linked frame of each type, to be safe.
+					if (!isset($source_data_array['frameid'])) {
+						$this-&gt;errors[] = '[frameid] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['frameid'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same FrameID ('.$source_data_array['frameid'].')';
+					} elseif (in_array($source_data_array['frameid'], $PreviousFrames)) {
+						// no links to singleton tags
+						$this-&gt;errors[] = 'Cannot specify a '.$frame_name.' tag to a singleton tag that already exists ('.$source_data_array['frameid'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['frameid']; // only one linked tag of this type
+						$PreviousFrames[] = $source_data_array['frameid'];             // no non-linked singleton tags of this type
+					}
+					break;
+
+				case 'COMR':
+					//   There may be more than one 'commercial frame' in a tag, but no two may be identical
+					// Checking isn't implemented at all (yet) - just assumes that it's OK.
+					break;
+
+				case 'PRIV':
+					if (!isset($source_data_array['ownerid'])) {
+						$this-&gt;errors[] = '[ownerid] not specified for '.$frame_name;
+					} elseif (!isset($source_data_array['data'])) {
+						$this-&gt;errors[] = '[data] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['ownerid'].$source_data_array['data'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same OwnerID + Data ('.$source_data_array['ownerid'].' + '.$source_data_array['data'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['ownerid'].$source_data_array['data'];
+					}
+					break;
+
+				default:
+					if (($frame_name{0} != 'T') &amp;&amp; ($frame_name{0} != 'W')) {
+						$this-&gt;errors[] = 'Frame not allowed in ID3v2.'.$this-&gt;majorversion.': '.$frame_name;
+					}
+					break;
+			}
+
+		} elseif ($this-&gt;majorversion == 2) {
+
+			switch ($frame_name) {
+				case 'UFI':
+				case 'CRM':
+				case 'CRA':
+					if (!isset($source_data_array['ownerid'])) {
+						$this-&gt;errors[] = '[ownerid] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['ownerid'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same OwnerID ('.$source_data_array['ownerid'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['ownerid'];
+					}
+					break;
+
+				case 'TXX':
+				case 'WXX':
+				case 'PIC':
+				case 'GEO':
+					if (!isset($source_data_array['description'])) {
+						$this-&gt;errors[] = '[description] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['description'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Description ('.$source_data_array['description'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['description'];
+					}
+					break;
+
+				case 'ULT':
+				case 'SLT':
+				case 'COM':
+					if (!isset($source_data_array['language'])) {
+						$this-&gt;errors[] = '[language] not specified for '.$frame_name;
+					} elseif (!isset($source_data_array['description'])) {
+						$this-&gt;errors[] = '[description] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['language'].$source_data_array['description'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Language + Description ('.$source_data_array['language'].' + '.$source_data_array['description'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['language'].$source_data_array['description'];
+					}
+					break;
+
+				case 'POP':
+					if (!isset($source_data_array['email'])) {
+						$this-&gt;errors[] = '[email] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['email'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same Email ('.$source_data_array['email'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['email'];
+					}
+					break;
+
+				case 'IPL':
+				case 'MCI':
+				case 'ETC':
+				case 'MLL':
+				case 'STC':
+				case 'RVA':
+				case 'EQU':
+				case 'REV':
+				case 'CNT':
+				case 'BUF':
+					if (in_array($frame_name, $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed';
+					} else {
+						$PreviousFrames[] = $frame_name;
+					}
+					break;
+
+				case 'LNK':
+					// this isn't implemented quite right (yet) - it should check the target frame data for compliance
+					// but right now it just allows one linked frame of each type, to be safe.
+					if (!isset($source_data_array['frameid'])) {
+						$this-&gt;errors[] = '[frameid] not specified for '.$frame_name;
+					} elseif (in_array($frame_name.$source_data_array['frameid'], $PreviousFrames)) {
+						$this-&gt;errors[] = 'Only one '.$frame_name.' tag allowed with the same FrameID ('.$source_data_array['frameid'].')';
+					} elseif (in_array($source_data_array['frameid'], $PreviousFrames)) {
+						// no links to singleton tags
+						$this-&gt;errors[] = 'Cannot specify a '.$frame_name.' tag to a singleton tag that already exists ('.$source_data_array['frameid'].')';
+					} else {
+						$PreviousFrames[] = $frame_name.$source_data_array['frameid']; // only one linked tag of this type
+						$PreviousFrames[] = $source_data_array['frameid'];             // no non-linked singleton tags of this type
+					}
+					break;
+
+				default:
+					if (($frame_name{0} != 'T') &amp;&amp; ($frame_name{0} != 'W')) {
+						$this-&gt;errors[] = 'Frame not allowed in ID3v2.'.$this-&gt;majorversion.': '.$frame_name;
+					}
+					break;
+			}
+		}
+
+		if (!empty($this-&gt;errors)) {
+			return false;
+		}
+		return true;
+	}
+
+	function GenerateID3v2Tag($noerrorsonly=true) {
+		$this-&gt;ID3v2FrameIsAllowed(null, ''); // clear static array in case this isn't the first call to $this-&gt;GenerateID3v2Tag()
+
+		$tagstring = '';
+		if (is_array($this-&gt;tag_data)) {
+			foreach ($this-&gt;tag_data as $frame_name =&gt; $frame_rawinputdata) {
+				foreach ($frame_rawinputdata as $irrelevantindex =&gt; $source_data_array) {
+					if (getid3_id3v2::IsValidID3v2FrameName($frame_name, $this-&gt;majorversion)) {
+						unset($frame_length);
+						unset($frame_flags);
+						$frame_data = false;
+						if ($this-&gt;ID3v2FrameIsAllowed($frame_name, $source_data_array)) {
+							if ($frame_data = $this-&gt;GenerateID3v2FrameData($frame_name, $source_data_array)) {
+								$FrameUnsynchronisation = false;
+								if ($this-&gt;majorversion &gt;= 4) {
+									// frame-level unsynchronisation
+									$unsynchdata = $frame_data;
+									if ($this-&gt;id3v2_use_unsynchronisation) {
+										$unsynchdata = $this-&gt;Unsynchronise($frame_data);
+									}
+									if (strlen($unsynchdata) != strlen($frame_data)) {
+										// unsynchronisation needed
+										$FrameUnsynchronisation = true;
+										$frame_data = $unsynchdata;
+										if (isset($TagUnsynchronisation) &amp;&amp; $TagUnsynchronisation === false) {
+											// only set to true if ALL frames are unsynchronised
+										} else {
+											$TagUnsynchronisation = true;
+										}
+									} else {
+										if (isset($TagUnsynchronisation)) {
+											$TagUnsynchronisation = false;
+										}
+									}
+									unset($unsynchdata);
+
+									$frame_length = getid3_lib::BigEndian2String(strlen($frame_data), 4, true);
+								} else {
+									$frame_length = getid3_lib::BigEndian2String(strlen($frame_data), 4, false);
+								}
+								$frame_flags  = $this-&gt;GenerateID3v2FrameFlags($this-&gt;ID3v2FrameFlagsLookupTagAlter($frame_name), $this-&gt;ID3v2FrameFlagsLookupFileAlter($frame_name), false, false, false, false, $FrameUnsynchronisation, false);
+							}
+						} else {
+							$this-&gt;errors[] = 'Frame &quot;'.$frame_name.'&quot; is NOT allowed';
+						}
+						if ($frame_data === false) {
+							$this-&gt;errors[] = '$this-&gt;GenerateID3v2FrameData() failed for &quot;'.$frame_name.'&quot;';
+							if ($noerrorsonly) {
+								return false;
+							} else {
+								unset($frame_name);
+							}
+						}
+					} else {
+						// ignore any invalid frame names, including 'title', 'header', etc
+						$this-&gt;warnings[] = 'Ignoring invalid ID3v2 frame type: &quot;'.$frame_name.'&quot;';
+						unset($frame_name);
+						unset($frame_length);
+						unset($frame_flags);
+						unset($frame_data);
+					}
+					if (isset($frame_name) &amp;&amp; isset($frame_length) &amp;&amp; isset($frame_flags) &amp;&amp; isset($frame_data)) {
+						$tagstring .= $frame_name.$frame_length.$frame_flags.$frame_data;
+					}
+				}
+			}
+
+			if (!isset($TagUnsynchronisation)) {
+				$TagUnsynchronisation = false;
+			}
+			if (($this-&gt;majorversion &lt;= 3) &amp;&amp; $this-&gt;id3v2_use_unsynchronisation) {
+				// tag-level unsynchronisation
+				$unsynchdata = $this-&gt;Unsynchronise($tagstring);
+				if (strlen($unsynchdata) != strlen($tagstring)) {
+					// unsynchronisation needed
+					$TagUnsynchronisation = true;
+					$tagstring = $unsynchdata;
+				}
+			}
+
+			while ($this-&gt;paddedlength &lt; (strlen($tagstring) + getid3_id3v2::ID3v2HeaderLength($this-&gt;majorversion))) {
+				$this-&gt;paddedlength += 1024;
+			}
+
+			$footer = false; // ID3v2 footers not yet supported in getID3()
+			if (!$footer &amp;&amp; ($this-&gt;paddedlength &gt; (strlen($tagstring) + getid3_id3v2::ID3v2HeaderLength($this-&gt;majorversion)))) {
+				// pad up to $paddedlength bytes if unpadded tag is shorter than $paddedlength
+				// &quot;Furthermore it MUST NOT have any padding when a tag footer is added to the tag.&quot;
+				$tagstring .= @str_repeat(&quot;\x00&quot;, $this-&gt;paddedlength - strlen($tagstring) - getid3_id3v2::ID3v2HeaderLength($this-&gt;majorversion));
+			}
+			if ($this-&gt;id3v2_use_unsynchronisation &amp;&amp; (substr($tagstring, strlen($tagstring) - 1, 1) == &quot;\xFF&quot;)) {
+				// special unsynchronisation case:
+				// if last byte == $FF then appended a $00
+				$TagUnsynchronisation = true;
+				$tagstring .= &quot;\x00&quot;;
+			}
+
+			$tagheader  = 'ID3';
+			$tagheader .= chr($this-&gt;majorversion);
+			$tagheader .= chr($this-&gt;minorversion);
+			$tagheader .= $this-&gt;GenerateID3v2TagFlags(array('unsynchronisation'=&gt;$TagUnsynchronisation));
+			$tagheader .= getid3_lib::BigEndian2String(strlen($tagstring), 4, true);
+
+			return $tagheader.$tagstring;
+		}
+		$this-&gt;errors[] = 'tag_data is not an array in GenerateID3v2Tag()';
+		return false;
+	}
+
+	function ID3v2IsValidPriceString($pricestring) {
+		if (getid3_id3v2::LanguageLookup(substr($pricestring, 0, 3), true) == '') {
+			return false;
+		} elseif (!$this-&gt;IsANumber(substr($pricestring, 3), true)) {
+			return false;
+		}
+		return true;
+	}
+
+	function ID3v2FrameFlagsLookupTagAlter($framename) {
+		// unfinished
+		switch ($framename) {
+			case 'RGAD':
+				$allow = true;
+			default:
+				$allow = false;
+				break;
+		}
+		return $allow;
+	}
+
+	function ID3v2FrameFlagsLookupFileAlter($framename) {
+		// unfinished
+		switch ($framename) {
+			case 'RGAD':
+				return false;
+				break;
+
+			default:
+				return false;
+				break;
+		}
+	}
+
+	function ID3v2IsValidETCOevent($eventid) {
+		if (($eventid &lt; 0) || ($eventid &gt; 0xFF)) {
+			// outside range of 1 byte
+			return false;
+		} elseif (($eventid &gt;= 0xF0) &amp;&amp; ($eventid &lt;= 0xFC)) {
+			// reserved for future use
+			return false;
+		} elseif (($eventid &gt;= 0x17) &amp;&amp; ($eventid &lt;= 0xDF)) {
+			// reserved for future use
+			return false;
+		} elseif (($eventid &gt;= 0x0E) &amp;&amp; ($eventid &lt;= 0x16) &amp;&amp; ($this-&gt;majorversion == 2)) {
+			// not defined in ID3v2.2
+			return false;
+		} elseif (($eventid &gt;= 0x15) &amp;&amp; ($eventid &lt;= 0x16) &amp;&amp; ($this-&gt;majorversion == 3)) {
+			// not defined in ID3v2.3
+			return false;
+		}
+		return true;
+	}
+
+	function ID3v2IsValidSYLTtype($contenttype) {
+		if (($contenttype &gt;= 0) &amp;&amp; ($contenttype &lt;= 8) &amp;&amp; ($this-&gt;majorversion == 4)) {
+			return true;
+		} elseif (($contenttype &gt;= 0) &amp;&amp; ($contenttype &lt;= 6) &amp;&amp; ($this-&gt;majorversion == 3)) {
+			return true;
+		}
+		return false;
+	}
+
+	function ID3v2IsValidRVA2channeltype($channeltype) {
+		if (($channeltype &gt;= 0) &amp;&amp; ($channeltype &lt;= 8) &amp;&amp; ($this-&gt;majorversion == 4)) {
+			return true;
+		}
+		return false;
+	}
+
+	function ID3v2IsValidAPICpicturetype($picturetype) {
+		if (($picturetype &gt;= 0) &amp;&amp; ($picturetype &lt;= 0x14) &amp;&amp; ($this-&gt;majorversion &gt;= 2) &amp;&amp; ($this-&gt;majorversion &lt;= 4)) {
+			return true;
+		}
+		return false;
+	}
+
+	function ID3v2IsValidAPICimageformat($imageformat) {
+		if ($imageformat == '--&gt;') {
+			return true;
+		} elseif ($this-&gt;majorversion == 2) {
+			if ((strlen($imageformat) == 3) &amp;&amp; ($imageformat == strtoupper($imageformat))) {
+				return true;
+			}
+		} elseif (($this-&gt;majorversion == 3) || ($this-&gt;majorversion == 4)) {
+			if ($this-&gt;IsValidMIMEstring($imageformat)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	function ID3v2IsValidCOMRreceivedAs($receivedas) {
+		if (($this-&gt;majorversion &gt;= 3) &amp;&amp; ($receivedas &gt;= 0) &amp;&amp; ($receivedas &lt;= 8)) {
+			return true;
+		}
+		return false;
+	}
+
+	function ID3v2IsValidRGADname($RGADname) {
+		if (($RGADname &gt;= 0) &amp;&amp; ($RGADname &lt;= 2)) {
+			return true;
+		}
+		return false;
+	}
+
+	function ID3v2IsValidRGADoriginator($RGADoriginator) {
+		if (($RGADoriginator &gt;= 0) &amp;&amp; ($RGADoriginator &lt;= 3)) {
+			return true;
+		}
+		return false;
+	}
+
+	function ID3v2IsValidTextEncoding($textencodingbyte) {
+		static $ID3v2IsValidTextEncoding_cache = array(
+			2 =&gt; array(true, true),
+			3 =&gt; array(true, true),
+			4 =&gt; array(true, true, true, true));
+		return isset($ID3v2IsValidTextEncoding_cache[$this-&gt;majorversion][$textencodingbyte]);
+	}
+
+	function Unsynchronise($data) {
+		// Whenever a false synchronisation is found within the tag, one zeroed
+		// byte is inserted after the first false synchronisation byte. The
+		// format of a correct sync that should be altered by ID3 encoders is as
+		// follows:
+		//      %11111111 111xxxxx
+		// And should be replaced with:
+		//      %11111111 00000000 111xxxxx
+		// This has the side effect that all $FF 00 combinations have to be
+		// altered, so they won't be affected by the decoding process. Therefore
+		// all the $FF 00 combinations have to be replaced with the $FF 00 00
+		// combination during the unsynchronisation.
+
+		$data = str_replace(&quot;\xFF\x00&quot;, &quot;\xFF\x00\x00&quot;, $data);
+		$unsyncheddata = '';
+		$datalength = strlen($data);
+		for ($i = 0; $i &lt; $datalength; $i++) {
+			$thischar = $data{$i};
+			$unsyncheddata .= $thischar;
+			if ($thischar == &quot;\xFF&quot;) {
+				$nextchar = ord($data{$i + 1});
+				if (($nextchar &amp; 0xE0) == 0xE0) {
+					// previous byte = 11111111, this byte = 111?????
+					$unsyncheddata .= &quot;\x00&quot;;
+				}
+			}
+		}
+		return $unsyncheddata;
+	}
+
+	function is_hash($var) {
+		// written by dev-null&#216;christophe*vg
+		// taken from <A HREF="http://www.php.net/manual/en/function.array-merge-recursive.php">http://www.php.net/manual/en/function.array-merge-recursive.php</A>
+		if (is_array($var)) {
+			$keys = array_keys($var);
+			$all_num = true;
+			for ($i = 0; $i &lt; count($keys); $i++) {
+				if (is_string($keys[$i])) {
+					return true;
+				}
+			}
+		}
+		return false;
+	}
+
+	function array_join_merge($arr1, $arr2) {
+		// written by dev-null&#216;christophe*vg
+		// taken from <A HREF="http://www.php.net/manual/en/function.array-merge-recursive.php">http://www.php.net/manual/en/function.array-merge-recursive.php</A>
+		if (is_array($arr1) &amp;&amp; is_array($arr2)) {
+			// the same -&gt; merge
+			$new_array = array();
+
+			if ($this-&gt;is_hash($arr1) &amp;&amp; $this-&gt;is_hash($arr2)) {
+				// hashes -&gt; merge based on keys
+				$keys = array_merge(array_keys($arr1), array_keys($arr2));
+				foreach ($keys as $key) {
+					$new_array[$key] = $this-&gt;array_join_merge(@$arr1[$key], @$arr2[$key]);
+				}
+			} else {
+				// two real arrays -&gt; merge
+				$new_array = array_reverse(array_unique(array_reverse(array_merge($arr1, $arr2))));
+			}
+			return $new_array;
+		} else {
+			// not the same ... take new one if defined, else the old one stays
+			return $arr2 ? $arr2 : $arr1;
+		}
+	}
+
+	function IsValidMIMEstring($mimestring) {
+		if ((strlen($mimestring) &gt;= 3) &amp;&amp; (strpos($mimestring, '/') &gt; 0) &amp;&amp; (strpos($mimestring, '/') &lt; (strlen($mimestring) - 1))) {
+			return true;
+		}
+		return false;
+	}
+
+	function IsWithinBitRange($number, $maxbits, $signed=false) {
+		if ($signed) {
+			if (($number &gt; (0 - pow(2, $maxbits - 1))) &amp;&amp; ($number &lt;= pow(2, $maxbits - 1))) {
+				return true;
+			}
+		} else {
+			if (($number &gt;= 0) &amp;&amp; ($number &lt;= pow(2, $maxbits))) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	function safe_parse_url($url) {
+		$parts = @parse_url($url);
+		$parts['scheme'] = (isset($parts['scheme']) ? $parts['scheme'] : '');
+		$parts['host']   = (isset($parts['host'])   ? $parts['host']   : '');
+		$parts['user']   = (isset($parts['user'])   ? $parts['user']   : '');
+		$parts['pass']   = (isset($parts['pass'])   ? $parts['pass']   : '');
+		$parts['path']   = (isset($parts['path'])   ? $parts['path']   : '');
+		$parts['query']  = (isset($parts['query'])  ? $parts['query']  : '');
+		return $parts;
+	}
+
+	function IsValidURL($url, $allowUserPass=false) {
+		if ($url == '') {
+			return false;
+		}
+		if ($allowUserPass !== true) {
+			if (strstr($url, '@')) {
+				// in the format <A HREF="http://user:pass@example.com">http://user:pass@example.com</A>  or <A HREF="http://user@example.com">http://user@example.com</A>
+				// but could easily be somebody incorrectly entering an email address in place of a URL
+				return false;
+			}
+		}
+		if ($parts = $this-&gt;safe_parse_url($url)) {
+			if (($parts['scheme'] != 'http') &amp;&amp; ($parts['scheme'] != 'https') &amp;&amp; ($parts['scheme'] != 'ftp') &amp;&amp; ($parts['scheme'] != 'gopher')) {
+				return false;
+			} elseif (!eregi(&quot;^[[:alnum:]]([-.]?[0-9a-z])*\.[a-z]{2,3}$&quot;, $parts['host'], $regs) &amp;&amp; !IsValidDottedIP($parts['host'])) {
+				return false;
+			} elseif (!eregi(&quot;^([[:alnum:]-]|[\_])*$&quot;, $parts['user'], $regs)) {
+				return false;
+			} elseif (!eregi(&quot;^([[:alnum:]-]|[\_])*$&quot;, $parts['pass'], $regs)) {
+				return false;
+			} elseif (!eregi(&quot;^[[:alnum:]/_\.@~-]*$&quot;, $parts['path'], $regs)) {
+				return false;
+			} elseif (!eregi(&quot;^[[:alnum:]?&amp;=+:;_()%#/,\.-]*$&quot;, $parts['query'], $regs)) {
+				return false;
+			} else {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	function ID3v2ShortFrameNameLookup($majorversion, $long_description) {
+		$long_description = str_replace(' ', '_', strtolower(trim($long_description)));
+		static $ID3v2ShortFrameNameLookup = array();
+		if (empty($ID3v2ShortFrameNameLookup)) {
+
+			// The following are unique to ID3v2.2
+			$ID3v2ShortFrameNameLookup[2]['comment']                                          = 'COM';
+			$ID3v2ShortFrameNameLookup[2]['album']                                            = 'TAL';
+			$ID3v2ShortFrameNameLookup[2]['beats_per_minute']                                 = 'TBP';
+			$ID3v2ShortFrameNameLookup[2]['composer']                                         = 'TCM';
+			$ID3v2ShortFrameNameLookup[2]['genre']                                            = 'TCO';
+			$ID3v2ShortFrameNameLookup[2]['copyright']                                        = 'TCR';
+			$ID3v2ShortFrameNameLookup[2]['encoded_by']                                       = 'TEN';
+			$ID3v2ShortFrameNameLookup[2]['language']                                         = 'TLA';
+			$ID3v2ShortFrameNameLookup[2]['length']                                           = 'TLE';
+			$ID3v2ShortFrameNameLookup[2]['original_artist']                                  = 'TOA';
+			$ID3v2ShortFrameNameLookup[2]['original_filename']                                = 'TOF';
+			$ID3v2ShortFrameNameLookup[2]['original_lyricist']                                = 'TOL';
+			$ID3v2ShortFrameNameLookup[2]['original_album_title']                             = 'TOT';
+			$ID3v2ShortFrameNameLookup[2]['artist']                                           = 'TP1';
+			$ID3v2ShortFrameNameLookup[2]['band']                                             = 'TP2';
+			$ID3v2ShortFrameNameLookup[2]['conductor']                                        = 'TP3';
+			$ID3v2ShortFrameNameLookup[2]['remixer']                                          = 'TP4';
+			$ID3v2ShortFrameNameLookup[2]['publisher']                                        = 'TPB';
+			$ID3v2ShortFrameNameLookup[2]['isrc']                                             = 'TRC';
+			$ID3v2ShortFrameNameLookup[2]['tracknumber']                                      = 'TRK';
+			$ID3v2ShortFrameNameLookup[2]['size']                                             = 'TSI';
+			$ID3v2ShortFrameNameLookup[2]['encoder_settings']                                 = 'TSS';
+			$ID3v2ShortFrameNameLookup[2]['description']                                      = 'TT1';
+			$ID3v2ShortFrameNameLookup[2]['title']                                            = 'TT2';
+			$ID3v2ShortFrameNameLookup[2]['subtitle']                                         = 'TT3';
+			$ID3v2ShortFrameNameLookup[2]['lyricist']                                         = 'TXT';
+			$ID3v2ShortFrameNameLookup[2]['user_text']                                        = 'TXX';
+			$ID3v2ShortFrameNameLookup[2]['year']                                             = 'TYE';
+			$ID3v2ShortFrameNameLookup[2]['unique_file_identifier']                           = 'UFI';
+			$ID3v2ShortFrameNameLookup[2]['unsynchronised_lyrics']                            = 'ULT';
+			$ID3v2ShortFrameNameLookup[2]['url_file']                                         = 'WAF';
+			$ID3v2ShortFrameNameLookup[2]['url_artist']                                       = 'WAR';
+			$ID3v2ShortFrameNameLookup[2]['url_source']                                       = 'WAS';
+			$ID3v2ShortFrameNameLookup[2]['copyright_information']                            = 'WCP';
+			$ID3v2ShortFrameNameLookup[2]['url_publisher']                                    = 'WPB';
+			$ID3v2ShortFrameNameLookup[2]['url_user']                                         = 'WXX';
+
+			// The following are common to ID3v2.3 and ID3v2.4
+			$ID3v2ShortFrameNameLookup[3]['audio_encryption']                                 = 'AENC';
+			$ID3v2ShortFrameNameLookup[3]['attached_picture']                                 = 'APIC';
+			$ID3v2ShortFrameNameLookup[3]['comment']                                          = 'COMM';
+			$ID3v2ShortFrameNameLookup[3]['commercial']                                       = 'COMR';
+			$ID3v2ShortFrameNameLookup[3]['encryption_method_registration']                   = 'ENCR';
+			$ID3v2ShortFrameNameLookup[3]['event_timing_codes']                               = 'ETCO';
+			$ID3v2ShortFrameNameLookup[3]['general_encapsulated_object']                      = 'GEOB';
+			$ID3v2ShortFrameNameLookup[3]['group_identification_registration']                = 'GRID';
+			$ID3v2ShortFrameNameLookup[3]['linked_information']                               = 'LINK';
+			$ID3v2ShortFrameNameLookup[3]['music_cd_identifier']                              = 'MCDI';
+			$ID3v2ShortFrameNameLookup[3]['mpeg_location_lookup_table']                       = 'MLLT';
+			$ID3v2ShortFrameNameLookup[3]['ownership']                                        = 'OWNE';
+			$ID3v2ShortFrameNameLookup[3]['play_counter']                                     = 'PCNT';
+			$ID3v2ShortFrameNameLookup[3]['popularimeter']                                    = 'POPM';
+			$ID3v2ShortFrameNameLookup[3]['position_synchronisation']                         = 'POSS';
+			$ID3v2ShortFrameNameLookup[3]['private']                                          = 'PRIV';
+			$ID3v2ShortFrameNameLookup[3]['recommended_buffer_size']                          = 'RBUF';
+			$ID3v2ShortFrameNameLookup[3]['reverb']                                           = 'RVRB';
+			$ID3v2ShortFrameNameLookup[3]['synchronised_lyrics']                              = 'SYLT';
+			$ID3v2ShortFrameNameLookup[3]['synchronised_tempo_codes']                         = 'SYTC';
+			$ID3v2ShortFrameNameLookup[3]['album']                                            = 'TALB';
+			$ID3v2ShortFrameNameLookup[3]['beats_per_minute']                                 = 'TBPM';
+			$ID3v2ShortFrameNameLookup[3]['composer']                                         = 'TCOM';
+			$ID3v2ShortFrameNameLookup[3]['genre']                                            = 'TCON';
+			$ID3v2ShortFrameNameLookup[3]['copyright']                                        = 'TCOP';
+			$ID3v2ShortFrameNameLookup[3]['playlist_delay']                                   = 'TDLY';
+			$ID3v2ShortFrameNameLookup[3]['encoded_by']                                       = 'TENC';
+			$ID3v2ShortFrameNameLookup[3]['lyricist']                                         = 'TEXT';
+			$ID3v2ShortFrameNameLookup[3]['file_type']                                        = 'TFLT';
+			$ID3v2ShortFrameNameLookup[3]['content_group_description']                        = 'TIT1';
+			$ID3v2ShortFrameNameLookup[3]['title']                                            = 'TIT2';
+			$ID3v2ShortFrameNameLookup[3]['subtitle']                                         = 'TIT3';
+			$ID3v2ShortFrameNameLookup[3]['initial_key']                                      = 'TKEY';
+			$ID3v2ShortFrameNameLookup[3]['language']                                         = 'TLAN';
+			$ID3v2ShortFrameNameLookup[3]['length']                                           = 'TLEN';
+			$ID3v2ShortFrameNameLookup[3]['media_type']                                       = 'TMED';
+			$ID3v2ShortFrameNameLookup[3]['original_album_title']                             = 'TOAL';
+			$ID3v2ShortFrameNameLookup[3]['original_filename']                                = 'TOFN';
+			$ID3v2ShortFrameNameLookup[3]['original_lyricist']                                = 'TOLY';
+			$ID3v2ShortFrameNameLookup[3]['original_artist']                                  = 'TOPE';
+			$ID3v2ShortFrameNameLookup[3]['file_owner']                                       = 'TOWN';
+			$ID3v2ShortFrameNameLookup[3]['artist']                                           = 'TPE1';
+			$ID3v2ShortFrameNameLookup[3]['band']                                             = 'TPE2';
+			$ID3v2ShortFrameNameLookup[3]['conductor']                                        = 'TPE3';
+			$ID3v2ShortFrameNameLookup[3]['remixer']                                          = 'TPE4';
+			$ID3v2ShortFrameNameLookup[3]['part_of_set']                                      = 'TPOS';
+			$ID3v2ShortFrameNameLookup[3]['publisher']                                        = 'TPUB';
+			$ID3v2ShortFrameNameLookup[3]['tracknumber']                                      = 'TRCK';
+			$ID3v2ShortFrameNameLookup[3]['internet_radio_station_name']                      = 'TRSN';
+			$ID3v2ShortFrameNameLookup[3]['internet_radio_station_owner']                     = 'TRSO';
+			$ID3v2ShortFrameNameLookup[3]['isrc']                                             = 'TSRC';
+			$ID3v2ShortFrameNameLookup[3]['encoder_settings']                                 = 'TSSE';
+			$ID3v2ShortFrameNameLookup[3]['user_text']                                        = 'TXXX';
+			$ID3v2ShortFrameNameLookup[3]['unique_file_identifier']                           = 'UFID';
+			$ID3v2ShortFrameNameLookup[3]['terms_of_use']                                     = 'USER';
+			$ID3v2ShortFrameNameLookup[3]['unsynchronised_lyrics']                            = 'USLT';
+			$ID3v2ShortFrameNameLookup[3]['commercial']                                       = 'WCOM';
+			$ID3v2ShortFrameNameLookup[3]['copyright_information']                            = 'WCOP';
+			$ID3v2ShortFrameNameLookup[3]['url_file']                                         = 'WOAF';
+			$ID3v2ShortFrameNameLookup[3]['url_artist']                                       = 'WOAR';
+			$ID3v2ShortFrameNameLookup[3]['url_source']                                       = 'WOAS';
+			$ID3v2ShortFrameNameLookup[3]['url_station']                                      = 'WORS';
+			$ID3v2ShortFrameNameLookup[3]['payment']                                          = 'WPAY';
+			$ID3v2ShortFrameNameLookup[3]['url_publisher']                                    = 'WPUB';
+			$ID3v2ShortFrameNameLookup[3]['url_user']                                         = 'WXXX';
+
+			// The above are common to ID3v2.3 and ID3v2.4
+			// so copy them to ID3v2.4 before adding specifics for 2.3 and 2.4
+			$ID3v2ShortFrameNameLookup[4] = $ID3v2ShortFrameNameLookup[3];
+
+			// The following are unique to ID3v2.3
+			$ID3v2ShortFrameNameLookup[3]['equalisation']                                     = 'EQUA';
+			$ID3v2ShortFrameNameLookup[3]['involved_people_list']                             = 'IPLS';
+			$ID3v2ShortFrameNameLookup[3]['relative_volume_adjustment']                       = 'RVAD';
+			$ID3v2ShortFrameNameLookup[3]['date']                                             = 'TDAT';
+			$ID3v2ShortFrameNameLookup[3]['time']                                             = 'TIME';
+			$ID3v2ShortFrameNameLookup[3]['original_release_year']                            = 'TORY';
+			$ID3v2ShortFrameNameLookup[3]['recording_dates']                                  = 'TRDA';
+			$ID3v2ShortFrameNameLookup[3]['size']                                             = 'TSIZ';
+			$ID3v2ShortFrameNameLookup[3]['year']                                             = 'TYER';
+
+
+			// The following are unique to ID3v2.4
+			$ID3v2ShortFrameNameLookup[4]['audio_seek_point_index']                           = 'ASPI';
+			$ID3v2ShortFrameNameLookup[4]['equalisation']                                     = 'EQU2';
+			$ID3v2ShortFrameNameLookup[4]['relative_volume_adjustment']                       = 'RVA2';
+			$ID3v2ShortFrameNameLookup[4]['seek']                                             = 'SEEK';
+			$ID3v2ShortFrameNameLookup[4]['signature']                                        = 'SIGN';
+			$ID3v2ShortFrameNameLookup[4]['encoding_time']                                    = 'TDEN';
+			$ID3v2ShortFrameNameLookup[4]['original_release_time']                            = 'TDOR';
+			$ID3v2ShortFrameNameLookup[4]['recording_time']                                   = 'TDRC';
+			$ID3v2ShortFrameNameLookup[4]['release_time']                                     = 'TDRL';
+			$ID3v2ShortFrameNameLookup[4]['tagging_time']                                     = 'TDTG';
+			$ID3v2ShortFrameNameLookup[4]['involved_people_list']                             = 'TIPL';
+			$ID3v2ShortFrameNameLookup[4]['musician_credits_list']                            = 'TMCL';
+			$ID3v2ShortFrameNameLookup[4]['mood']                                             = 'TMOO';
+			$ID3v2ShortFrameNameLookup[4]['produced_notice']                                  = 'TPRO';
+			$ID3v2ShortFrameNameLookup[4]['album_sort_order']                                 = 'TSOA';
+			$ID3v2ShortFrameNameLookup[4]['performer_sort_order']                             = 'TSOP';
+			$ID3v2ShortFrameNameLookup[4]['title_sort_order']                                 = 'TSOT';
+			$ID3v2ShortFrameNameLookup[4]['set_subtitle']                                     = 'TSST';
+		}
+		return @$ID3v2ShortFrameNameLookup[$majorversion][strtolower($long_description)];
+
+	}
+
+}
+
+?&gt;

Added: node/branches/video_test/code/getid3-1.7.5/getid3/write.lyrics3.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/write.lyrics3.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/write.lyrics3.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,78 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// write.lyrics3.php                                           //
+// module for writing Lyrics3 tags                             //
+// dependencies: module.tag.lyrics3.php                        //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_write_lyrics3
+{
+	var $filename;
+	var $tag_data;
+	//var $lyrics3_version = 2;       // 1 or 2
+	var $warnings        = array(); // any non-critical errors will be stored here
+	var $errors          = array(); // any critical errors will be stored here
+
+	function getid3_write_lyrics3() {
+		return true;
+	}
+
+	function WriteLyrics3() {
+		$this-&gt;errors[] = 'WriteLyrics3() not yet functional - cannot write Lyrics3';
+		return false;
+	}
+
+	function DeleteLyrics3() {
+		// Initialize getID3 engine
+		$getID3 = new getID3;
+		$ThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+		if (isset($ThisFileInfo['lyrics3']['tag_offset_start']) &amp;&amp; isset($ThisFileInfo['lyrics3']['tag_offset_end'])) {
+			if ($fp = @fopen($this-&gt;filename, 'a+b')) {
+
+				flock($fp, LOCK_EX);
+				$oldignoreuserabort = ignore_user_abort(true);
+
+				fseek($fp, $ThisFileInfo['lyrics3']['tag_offset_end'], SEEK_SET);
+				$DataAfterLyrics3 = '';
+				if ($ThisFileInfo['filesize'] &gt; $ThisFileInfo['lyrics3']['tag_offset_end']) {
+					$DataAfterLyrics3 = fread($fp, $ThisFileInfo['filesize'] - $ThisFileInfo['lyrics3']['tag_offset_end']);
+				}
+
+				ftruncate($fp, $ThisFileInfo['lyrics3']['tag_offset_start']);
+
+				if (!empty($DataAfterLyrics3)) {
+					fseek($fp, $ThisFileInfo['lyrics3']['tag_offset_start'], SEEK_SET);
+					fwrite($fp, $DataAfterLyrics3, strlen($DataAfterLyrics3));
+				}
+
+				flock($fp, LOCK_UN);
+				fclose($fp);
+				ignore_user_abort($oldignoreuserabort);
+
+				return true;
+
+			} else {
+
+				$this-&gt;errors[] = 'Cannot open &quot;'.$this-&gt;filename.'&quot; in &quot;a+b&quot; mode';
+				return false;
+
+			}
+		}
+		// no Lyrics3 present
+		return true;
+	}
+
+
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/write.metaflac.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/write.metaflac.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/write.metaflac.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,167 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// write.metaflac.php                                          //
+// module for writing metaflac tags                            //
+// dependencies: /helperapps/metaflac.exe                      //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_write_metaflac
+{
+
+	var $filename;
+	var $tag_data;
+	var $warnings = array(); // any non-critical errors will be stored here
+	var $errors   = array(); // any critical errors will be stored here
+
+	function getid3_write_metaflac() {
+		return true;
+	}
+
+	function WriteMetaFLAC() {
+
+		if (!ini_get('safe_mode')) {
+
+			// Create file with new comments
+			$tempcommentsfilename = tempnam('*', 'getID3');
+			if ($fpcomments = @fopen($tempcommentsfilename, 'wb')) {
+
+				foreach ($this-&gt;tag_data as $key =&gt; $value) {
+					foreach ($value as $commentdata) {
+						fwrite($fpcomments, $this-&gt;CleanmetaflacName($key).'='.$commentdata.&quot;\n&quot;);
+					}
+				}
+				fclose($fpcomments);
+
+			} else {
+
+				$this-&gt;errors[] = 'failed to open temporary tags file &quot;'.$tempcommentsfilename.'&quot;, tags not written';
+				return false;
+
+			}
+
+			$oldignoreuserabort = ignore_user_abort(true);
+			if (GETID3_OS_ISWINDOWS) {
+
+				if (file_exists(GETID3_HELPERAPPSDIR.'metaflac.exe')) {
+					//$commandline = '&quot;'.GETID3_HELPERAPPSDIR.'metaflac.exe&quot; --no-utf8-convert --remove-vc-all --import-vc-from=&quot;'.$tempcommentsfilename.'&quot; &quot;'.str_replace('/', '\\', $this-&gt;filename).'&quot;';
+					//  metaflac works fine if you copy-paste the above commandline into a command prompt,
+					//  but refuses to work with `backtick` if there are &quot;doublequotes&quot; present around BOTH
+					//  the metaflac pathname and the target filename. For whatever reason...??
+					//  The solution is simply ensure that the metaflac pathname has no spaces,
+					//  and therefore does not need to be quoted
+
+					// On top of that, if error messages are not always captured properly under Windows
+					// To at least see if there was a problem, compare file modification timestamps before and after writing
+					clearstatcache();
+					$timestampbeforewriting = filemtime($this-&gt;filename);
+
+					$commandline = GETID3_HELPERAPPSDIR.'metaflac.exe --no-utf8-convert --remove-vc-all --import-vc-from=&quot;'.$tempcommentsfilename.'&quot; &quot;'.$this-&gt;filename.'&quot; 2&gt;&amp;1';
+					$metaflacError = `$commandline`;
+
+					if (empty($metaflacError)) {
+						clearstatcache();
+						if ($timestampbeforewriting == filemtime($this-&gt;filename)) {
+							$metaflacError = 'File modification timestamp has not changed - it looks like the tags were not written';
+						}
+					}
+				} else {
+					$metaflacError = 'metaflac.exe not found in '.GETID3_HELPERAPPSDIR;
+				}
+
+			} else {
+
+				// It's simpler on *nix
+				$commandline = 'metaflac --no-utf8-convert --remove-vc-all --import-vc-from='.$tempcommentsfilename.' &quot;'.$this-&gt;filename.'&quot; 2&gt;&amp;1';
+				$metaflacError = `$commandline`;
+
+			}
+
+			// Remove temporary comments file
+			unlink($tempcommentsfilename);
+			ignore_user_abort($oldignoreuserabort);
+
+			if (!empty($metaflacError)) {
+
+				$this-&gt;errors[] = 'System call to metaflac failed with this message returned: '.&quot;\n\n&quot;.$metaflacError;
+				return false;
+
+			}
+
+			return true;
+		}
+
+		$this-&gt;errors[] = 'PHP running in Safe Mode (backtick operator not available) - cannot call metaflac, tags not written';
+		return false;
+	}
+
+
+	function DeleteMetaFLAC() {
+
+		if (!ini_get('safe_mode')) {
+
+			$oldignoreuserabort = ignore_user_abort(true);
+			if (GETID3_OS_ISWINDOWS) {
+
+				if (file_exists(GETID3_HELPERAPPSDIR.'metaflac.exe')) {
+					// To at least see if there was a problem, compare file modification timestamps before and after writing
+					clearstatcache();
+					$timestampbeforewriting = filemtime($this-&gt;filename);
+
+					$commandline = GETID3_HELPERAPPSDIR.'metaflac.exe --remove-vc-all &quot;'.$this-&gt;filename.'&quot; 2&gt;&amp;1';
+					$metaflacError = `$commandline`;
+
+					if (empty($metaflacError)) {
+						clearstatcache();
+						if ($timestampbeforewriting == filemtime($this-&gt;filename)) {
+							$metaflacError = 'File modification timestamp has not changed - it looks like the tags were not deleted';
+						}
+					}
+				} else {
+					$metaflacError = 'metaflac.exe not found in '.GETID3_HELPERAPPSDIR;
+				}
+
+			} else {
+
+				// It's simpler on *nix
+				$commandline = 'metaflac --remove-vc-all &quot;'.$this-&gt;filename.'&quot; 2&gt;&amp;1';
+				$metaflacError = `$commandline`;
+
+			}
+
+			ignore_user_abort($oldignoreuserabort);
+
+			if (!empty($metaflacError)) {
+				$this-&gt;errors[] = 'System call to metaflac failed with this message returned: '.&quot;\n\n&quot;.$metaflacError;
+				return false;
+			}
+			return true;
+		}
+		$this-&gt;errors[] = 'PHP running in Safe Mode (backtick operator not available) - cannot call metaflac, tags not deleted';
+		return false;
+	}
+
+
+	function CleanmetaflacName($originalcommentname) {
+		// A case-insensitive field name that may consist of ASCII 0x20 through 0x7D, 0x3D ('=') excluded.
+		// ASCII 0x41 through 0x5A inclusive (A-Z) is to be considered equivalent to ASCII 0x61 through
+		// 0x7A inclusive (a-z).
+
+		// replace invalid chars with a space, return uppercase text
+		// Thanks Chris Bolt &lt;chris-getid3&#216;bolt*cx&gt; for improving this function
+		// note: ereg_replace() replaces nulls with empty string (not space)
+		return strtoupper(ereg_replace('[^ -&lt;&gt;-}]', ' ', str_replace(&quot;\x00&quot;, ' ', $originalcommentname)));
+
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/write.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/write.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/write.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,591 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+///                                                            //
+// write.php                                                   //
+// module for writing tags (APEv2, ID3v1, ID3v2)               //
+// dependencies: getid3.lib.php                                //
+//               write.apetag.php (optional)                   //
+//               write.id3v1.php (optional)                    //
+//               write.id3v2.php (optional)                    //
+//               write.vorbiscomment.php (optional)            //
+//               write.metaflac.php (optional)                 //
+//               write.lyrics3.php (optional)                  //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+if (!defined('GETID3_INCLUDEPATH')) {
+	die('getid3.php MUST be included before calling getid3_writetags');
+}
+if (!include_once(GETID3_INCLUDEPATH.'getid3.lib.php')) {
+	die('write.php depends on getid3.lib.php, which is missing.');
+}
+
+
+// NOTES:
+//
+// You should pass data here with standard field names as follows:
+// * TITLE
+// * ARTIST
+// * ALBUM
+// * TRACKNUMBER
+// * COMMENT
+// * GENRE
+// * YEAR
+// * ATTACHED_PICTURE (ID3v2 only)
+//
+// <A HREF="http://www.personal.uni-jena.de/~pfk/mpp/sv8/apekey.html">http://www.personal.uni-jena.de/~pfk/mpp/sv8/apekey.html</A>
+// The APEv2 Tag Items Keys definition says &quot;TRACK&quot; is correct but foobar2000 uses &quot;TRACKNUMBER&quot; instead
+// Pass data here as &quot;TRACKNUMBER&quot; for compatability with all formats
+
+
+class getid3_writetags
+{
+	// public
+	var $filename;                            // absolute filename of file to write tags to
+	var $tagformats         = array();        // array of tag formats to write ('id3v1', 'id3v2.2', 'id2v2.3', 'id3v2.4', 'ape', 'vorbiscomment', 'metaflac', 'real')
+	var $tag_data           = array(array()); // 2-dimensional array of tag data (ex: $data['ARTIST'][0] = 'Elvis')
+	var $tag_encoding       = 'ISO-8859-1';   // text encoding used for tag data ('ISO-8859-1', 'UTF-8', 'UTF-16', 'UTF-16LE', 'UTF-16BE', )
+	var $overwrite_tags     = true;           // if true will erase existing tag data and write only passed data; if false will merge passed data with existing tag data
+	var $remove_other_tags  = false;          // if true will erase remove all existing tags and only write those passed in $tagformats; if false will ignore any tags not mentioned in $tagformats
+
+	var $id3v2_tag_language = 'eng';          // ISO-639-2 3-character language code needed for some ID3v2 frames (<A HREF="http://www.id3.org/iso639-2.html">http://www.id3.org/iso639-2.html</A>)
+	var $id3v2_paddedlength = 4096;           // minimum length of ID3v2 tags (will be padded to this length if tag data is shorter)
+
+	var $warnings           = array();        // any non-critical errors will be stored here
+	var $errors             = array();        // any critical errors will be stored here
+
+	// private
+	var $ThisFileInfo; // analysis of file before writing
+
+	function getid3_writetags() {
+		return true;
+	}
+
+
+	function WriteTags() {
+
+		if (empty($this-&gt;filename)) {
+			$this-&gt;errors[] = 'filename is undefined in getid3_writetags';
+			return false;
+		} elseif (!file_exists($this-&gt;filename)) {
+			$this-&gt;errors[] = 'filename set to non-existant file &quot;'.$this-&gt;filename.'&quot; in getid3_writetags';
+			return false;
+		}
+
+		if (!is_array($this-&gt;tagformats)) {
+			$this-&gt;errors[] = 'tagformats must be an array in getid3_writetags';
+			return false;
+		}
+
+		if (filesize($this-&gt;filename) == 0) {
+
+			// empty file special case - allow any tag format, don't check existing format
+			// could be useful if you want to generate tag data for a non-existant file
+			$this-&gt;ThisFileInfo = array('fileformat'=&gt;'');
+			$AllowedTagFormats = array('id3v1', 'id3v2.2', 'id3v2.3', 'id3v2.4', 'ape', 'lyrics3');
+
+		} else {
+
+			$getID3 = new getID3;
+			$getID3-&gt;encoding = $this-&gt;tag_encoding;
+			$this-&gt;ThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+
+			// check for what file types are allowed on this fileformat
+			switch (@$this-&gt;ThisFileInfo['fileformat']) {
+				case 'mp3':
+				case 'mp2':
+				case 'mp1':
+					$AllowedTagFormats = array('id3v1', 'id3v2.2', 'id3v2.3', 'id3v2.4', 'ape', 'lyrics3');
+					break;
+
+				case 'mpc':
+					$AllowedTagFormats = array('ape');
+					break;
+
+				case 'flac':
+					$AllowedTagFormats = array('metaflac');
+					break;
+
+				case 'real':
+					$AllowedTagFormats = array('real');
+					break;
+
+				case 'ogg':
+					switch (@$this-&gt;ThisFileInfo['audio']['dataformat']) {
+						case 'flac':
+							//$AllowedTagFormats = array('metaflac');
+							$this-&gt;errors[] = 'metaflac is not (yet) compatible with OggFLAC files';
+							return false;
+							break;
+						case 'vorbis':
+							$AllowedTagFormats = array('vorbiscomment');
+							break;
+						default:
+							$this-&gt;errors[] = 'metaflac is not (yet) compatible with Ogg files other than OggVorbis';
+							return false;
+							break;
+					}
+					break;
+
+				default:
+					$AllowedTagFormats = array();
+					break;
+			}
+			foreach ($this-&gt;tagformats as $requested_tag_format) {
+				if (!in_array($requested_tag_format, $AllowedTagFormats)) {
+					$errormessage = 'Tag format &quot;'.$requested_tag_format.'&quot; is not allowed on &quot;'.@$this-&gt;ThisFileInfo['fileformat'];
+					if (@$this-&gt;ThisFileInfo['fileformat'] != @$this-&gt;ThisFileInfo['audio']['dataformat']) {
+						$errormessage .= '.'.@$this-&gt;ThisFileInfo['audio']['dataformat'];
+					}
+					$errormessage .= '&quot; files';
+					$this-&gt;errors[] = $errormessage;
+					return false;
+				}
+			}
+
+			// List of other tag formats, removed if requested
+			$TagFormatsToRemove = array();
+			if ($this-&gt;remove_other_tags) {
+				foreach ($AllowedTagFormats as $AllowedTagFormat) {
+					switch ($AllowedTagFormat) {
+						case 'id3v2.2':
+						case 'id3v2.3':
+						case 'id3v2.4':
+							if (!in_array('id3v2', $TagFormatsToRemove) &amp;&amp; !in_array('id3v2.2', $this-&gt;tagformats) &amp;&amp; !in_array('id3v2.3', $this-&gt;tagformats) &amp;&amp; !in_array('id3v2.4', $this-&gt;tagformats)) {
+								$TagFormatsToRemove[] = 'id3v2';
+							}
+							break;
+
+						default:
+							if (!in_array($AllowedTagFormat, $this-&gt;tagformats)) {
+								$TagFormatsToRemove[] = $AllowedTagFormat;
+							}
+							break;
+					}
+				}
+			}
+		}
+
+		$WritingFilesToInclude = array_merge($this-&gt;tagformats, $TagFormatsToRemove);
+
+		// Check for required include files and include them
+		foreach ($WritingFilesToInclude as $tagformat) {
+			switch ($tagformat) {
+				case 'ape':
+					$GETID3_ERRORARRAY = &amp;$this-&gt;errors;
+					if (!getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'write.apetag.php', __FILE__, false)) {
+						return false;
+					}
+					break;
+
+				case 'id3v1':
+				case 'lyrics3':
+				case 'vorbiscomment':
+				case 'metaflac':
+				case 'real':
+					$GETID3_ERRORARRAY = &amp;$this-&gt;errors;
+					if (!getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'write.'.$tagformat.'.php', __FILE__, false)) {
+						return false;
+					}
+					break;
+
+				case 'id3v2.2':
+				case 'id3v2.3':
+				case 'id3v2.4':
+				case 'id3v2':
+					$GETID3_ERRORARRAY = &amp;$this-&gt;errors;
+					if (!getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'write.id3v2.php', __FILE__, false)) {
+						return false;
+					}
+					break;
+
+				default:
+					$this-&gt;errors[] = 'unknown tag format &quot;'.$tagformat.'&quot; in $tagformats in WriteTags()';
+					return false;
+					break;
+			}
+
+		}
+
+		// Validation of supplied data
+		if (!is_array($this-&gt;tag_data)) {
+			$this-&gt;errors[] = '$tag_data is not an array in WriteTags()';
+			return false;
+		}
+		// convert supplied data array keys to upper case, if they're not already
+		foreach ($this-&gt;tag_data as $tag_key =&gt; $tag_array) {
+			if (strtoupper($tag_key) !== $tag_key) {
+				$this-&gt;tag_data[strtoupper($tag_key)] = $this-&gt;tag_data[$tag_key];
+				unset($this-&gt;tag_data[$tag_key]);
+			}
+		}
+		// convert source data array keys to upper case, if they're not already
+		if (!empty($this-&gt;ThisFileInfo['tags'])) {
+			foreach ($this-&gt;ThisFileInfo['tags'] as $tag_format =&gt; $tag_data_array) {
+				foreach ($tag_data_array as $tag_key =&gt; $tag_array) {
+					if (strtoupper($tag_key) !== $tag_key) {
+						$this-&gt;ThisFileInfo['tags'][$tag_format][strtoupper($tag_key)] = $this-&gt;ThisFileInfo['tags'][$tag_format][$tag_key];
+						unset($this-&gt;ThisFileInfo['tags'][$tag_format][$tag_key]);
+					}
+				}
+			}
+		}
+
+		// Convert &quot;TRACK&quot; to &quot;TRACKNUMBER&quot; (if needed) for compatability with all formats
+		if (isset($this-&gt;tag_data['TRACK']) &amp;&amp; !isset($this-&gt;tag_data['TRACKNUMBER'])) {
+			$this-&gt;tag_data['TRACKNUMBER'] = $this-&gt;tag_data['TRACK'];
+			unset($this-&gt;tag_data['TRACK']);
+		}
+
+		// Remove all other tag formats, if requested
+		if ($this-&gt;remove_other_tags) {
+			$this-&gt;DeleteTags($TagFormatsToRemove);
+		}
+
+		// Write data for each tag format
+		foreach ($this-&gt;tagformats as $tagformat) {
+			$success = false; // overridden if tag writing is successful
+			switch ($tagformat) {
+				case 'ape':
+					$ape_writer = new getid3_write_apetag;
+					if (($ape_writer-&gt;tag_data = $this-&gt;FormatDataForAPE()) !== false) {
+						$ape_writer-&gt;filename = $this-&gt;filename;
+						if (($success = $ape_writer-&gt;WriteAPEtag()) === false) {
+							$this-&gt;errors[] = 'WriteAPEtag() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $ape_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+						}
+					} else {
+						$this-&gt;errors[] = 'FormatDataForAPE() failed';
+					}
+					break;
+
+				case 'id3v1':
+					$id3v1_writer = new getid3_write_id3v1;
+					if (($id3v1_writer-&gt;tag_data = $this-&gt;FormatDataForID3v1()) !== false) {
+						$id3v1_writer-&gt;filename = $this-&gt;filename;
+						if (($success = $id3v1_writer-&gt;WriteID3v1()) === false) {
+							$this-&gt;errors[] = 'WriteID3v1() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $id3v1_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+						}
+					} else {
+						$this-&gt;errors[] = 'FormatDataForID3v1() failed';
+					}
+					break;
+
+				case 'id3v2.2':
+				case 'id3v2.3':
+				case 'id3v2.4':
+					$id3v2_writer = new getid3_write_id3v2;
+					$id3v2_writer-&gt;majorversion = intval(substr($tagformat, -1));
+					$id3v2_writer-&gt;paddedlength = $this-&gt;id3v2_paddedlength;
+					if (($id3v2_writer-&gt;tag_data = $this-&gt;FormatDataForID3v2($id3v2_writer-&gt;majorversion)) !== false) {
+						$id3v2_writer-&gt;filename = $this-&gt;filename;
+						if (($success = $id3v2_writer-&gt;WriteID3v2()) === false) {
+							$this-&gt;errors[] = 'WriteID3v2() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $id3v2_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+						}
+					} else {
+						$this-&gt;errors[] = 'FormatDataForID3v2() failed';
+					}
+					break;
+
+				case 'vorbiscomment':
+					$vorbiscomment_writer = new getid3_write_vorbiscomment;
+					if (($vorbiscomment_writer-&gt;tag_data = $this-&gt;FormatDataForVorbisComment()) !== false) {
+						$vorbiscomment_writer-&gt;filename = $this-&gt;filename;
+						if (($success = $vorbiscomment_writer-&gt;WriteVorbisComment()) === false) {
+							$this-&gt;errors[] = 'WriteVorbisComment() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $vorbiscomment_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+						}
+					} else {
+						$this-&gt;errors[] = 'WriteVorbisComment() failed';
+					}
+					break;
+
+				case 'metaflac':
+					$metaflac_writer = new getid3_write_metaflac;
+					if (($metaflac_writer-&gt;tag_data = $this-&gt;FormatDataForMetaFLAC()) !== false) {
+						$metaflac_writer-&gt;filename = $this-&gt;filename;
+						if (($success = $metaflac_writer-&gt;WriteMetaFLAC()) === false) {
+							$this-&gt;errors[] = 'WriteMetaFLAC() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $metaflac_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+						}
+					} else {
+						$this-&gt;errors[] = 'FormatDataForMetaFLAC() failed';
+					}
+					break;
+
+				case 'real':
+					$real_writer = new getid3_write_real;
+					if (($real_writer-&gt;tag_data = $this-&gt;FormatDataForReal()) !== false) {
+						$real_writer-&gt;filename = $this-&gt;filename;
+						if (($success = $real_writer-&gt;WriteReal()) === false) {
+							$this-&gt;errors[] = 'WriteReal() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $real_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+						}
+					} else {
+						$this-&gt;errors[] = 'FormatDataForReal() failed';
+					}
+					break;
+
+				default:
+					$this-&gt;errors[] = 'Invalid tag format to write: &quot;'.$tagformat.'&quot;';
+					return false;
+					break;
+			}
+			if (!$success) {
+				return false;
+			}
+		}
+		return true;
+
+	}
+
+
+	function DeleteTags($TagFormatsToDelete) {
+		foreach ($TagFormatsToDelete as $DeleteTagFormat) {
+			$success = false; // overridden if tag deletion is successful
+			switch ($DeleteTagFormat) {
+				case 'id3v1':
+					$id3v1_writer = new getid3_write_id3v1;
+					$id3v1_writer-&gt;filename = $this-&gt;filename;
+					if (($success = $id3v1_writer-&gt;RemoveID3v1()) === false) {
+						$this-&gt;errors[] = 'RemoveID3v1() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $id3v1_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+					}
+					break;
+
+				case 'id3v2':
+					$id3v2_writer = new getid3_write_id3v2;
+					$id3v2_writer-&gt;filename = $this-&gt;filename;
+					if (($success = $id3v2_writer-&gt;RemoveID3v2()) === false) {
+						$this-&gt;errors[] = 'RemoveID3v2() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $id3v2_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+					}
+					break;
+
+				case 'ape':
+					$ape_writer = new getid3_write_apetag;
+					$ape_writer-&gt;filename = $this-&gt;filename;
+					if (($success = $ape_writer-&gt;DeleteAPEtag()) === false) {
+						$this-&gt;errors[] = 'DeleteAPEtag() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $ape_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+					}
+					break;
+
+				case 'vorbiscomment':
+					$vorbiscomment_writer = new getid3_write_vorbiscomment;
+					$vorbiscomment_writer-&gt;filename = $this-&gt;filename;
+					if (($success = $vorbiscomment_writer-&gt;DeleteVorbisComment()) === false) {
+						$this-&gt;errors[] = 'DeleteVorbisComment() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $vorbiscomment_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+					}
+					break;
+
+				case 'metaflac':
+					$metaflac_writer = new getid3_write_metaflac;
+					$metaflac_writer-&gt;filename = $this-&gt;filename;
+					if (($success = $metaflac_writer-&gt;DeleteMetaFLAC()) === false) {
+						$this-&gt;errors[] = 'DeleteMetaFLAC() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $metaflac_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+					}
+					break;
+
+				case 'lyrics3':
+					$lyrics3_writer = new getid3_write_lyrics3;
+					$lyrics3_writer-&gt;filename = $this-&gt;filename;
+					if (($success = $lyrics3_writer-&gt;DeleteLyrics3()) === false) {
+						$this-&gt;errors[] = 'DeleteLyrics3() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $lyrics3_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+					}
+					break;
+
+				case 'real':
+					$real_writer = new getid3_write_real;
+					$real_writer-&gt;filename = $this-&gt;filename;
+					if (($success = $real_writer-&gt;RemoveReal()) === false) {
+						$this-&gt;errors[] = 'RemoveReal() failed with message(s):&lt;PRE&gt;&lt;UL&gt;&lt;LI&gt;'.trim(implode('&lt;/LI&gt;&lt;LI&gt;', $real_writer-&gt;errors)).'&lt;/LI&gt;&lt;/UL&gt;&lt;/PRE&gt;';
+					}
+					break;
+
+				default:
+					$this-&gt;errors[] = 'Invalid tag format to delete: &quot;'.$tagformat.'&quot;';
+					return false;
+					break;
+			}
+			if (!$success) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+
+	function MergeExistingTagData($TagFormat, &amp;$tag_data) {
+		// Merge supplied data with existing data, if requested
+		if ($this-&gt;overwrite_tags) {
+			// do nothing - ignore previous data
+		} else {
+			if (!isset($this-&gt;ThisFileInfo['tags'][$TagFormat])) {
+				return false;
+			}
+			$tag_data = array_merge_recursive($tag_data, $this-&gt;ThisFileInfo['tags'][$TagFormat]);
+		}
+		return true;
+	}
+
+	function FormatDataForAPE() {
+		$ape_tag_data = array();
+		foreach ($this-&gt;tag_data as $tag_key =&gt; $valuearray) {
+			switch ($tag_key) {
+				case 'ATTACHED_PICTURE':
+					// ATTACHED_PICTURE is ID3v2 only - ignore
+					$this-&gt;warnings[] = '$data['.$tag_key.'] is assumed to be ID3v2 APIC data - NOT written to APE tag';
+					break;
+
+				default:
+					foreach ($valuearray as $key =&gt; $value) {
+						if (is_string($value) || is_numeric($value)) {
+							$ape_tag_data[$tag_key][$key] = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'UTF-8', $value);
+						} else {
+							$this-&gt;warnings[] = '$data['.$tag_key.']['.$key.'] is not a string value - all of $data['.$tag_key.'] NOT written to APE tag';
+							unset($ape_tag_data[$tag_key]);
+							break;
+						}
+					}
+					break;
+			}
+		}
+		$this-&gt;MergeExistingTagData('ape', $ape_tag_data);
+		return $ape_tag_data;
+	}
+
+
+	function FormatDataForID3v1() {
+		$tag_data_id3v1['genreid'] = 255;
+		if (!empty($this-&gt;tag_data['GENRE'])) {
+			foreach ($this-&gt;tag_data['GENRE'] as $key =&gt; $value) {
+				if (getid3_id3v1::LookupGenreID($value) !== false) {
+					$tag_data_id3v1['genreid'] = getid3_id3v1::LookupGenreID($value);
+					break;
+				}
+			}
+		}
+
+		$tag_data_id3v1['title']   = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['TITLE']));
+		$tag_data_id3v1['artist']  = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['ARTIST']));
+		$tag_data_id3v1['album']   = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['ALBUM']));
+		$tag_data_id3v1['year']    = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['YEAR']));
+		$tag_data_id3v1['comment'] = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['COMMENT']));
+
+		$tag_data_id3v1['track']   = intval(getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['TRACKNUMBER'])));
+		if ($tag_data_id3v1['track'] &lt;= 0) {
+			$tag_data_id3v1['track'] = '';
+		}
+
+		$this-&gt;MergeExistingTagData('id3v1', $tag_data_id3v1);
+		return $tag_data_id3v1;
+	}
+
+	function FormatDataForID3v2($id3v2_majorversion) {
+		$tag_data_id3v2 = array();
+
+		$ID3v2_text_encoding_lookup[2] = array('ISO-8859-1'=&gt;0, 'UTF-16'=&gt;1);
+		$ID3v2_text_encoding_lookup[3] = array('ISO-8859-1'=&gt;0, 'UTF-16'=&gt;1);
+		$ID3v2_text_encoding_lookup[4] = array('ISO-8859-1'=&gt;0, 'UTF-16'=&gt;1, 'UTF-16BE'=&gt;2, 'UTF-8'=&gt;3);
+		foreach ($this-&gt;tag_data as $tag_key =&gt; $valuearray) {
+			$ID3v2_framename = getid3_write_id3v2::ID3v2ShortFrameNameLookup($id3v2_majorversion, $tag_key);
+			switch ($ID3v2_framename) {
+				case 'APIC':
+					foreach ($valuearray as $key =&gt; $apic_data_array) {
+						if (isset($apic_data_array['data']) &amp;&amp;
+							isset($apic_data_array['picturetypeid']) &amp;&amp;
+							isset($apic_data_array['description']) &amp;&amp;
+							isset($apic_data_array['mime'])) {
+								$tag_data_id3v2['APIC'][] = $apic_data_array;
+						} else {
+							$this-&gt;errors[] = 'ID3v2 APIC data is not properly structured';
+							return false;
+						}
+					}
+					break;
+
+				case '':
+					$this-&gt;errors[] = 'ID3v2: Skipping &quot;'.$tag_key.'&quot; because cannot match it to a known ID3v2 frame type';
+					// some other data type, don't know how to handle it, ignore it
+					break;
+
+				default:
+					// most other (text) frames can be copied over as-is
+					foreach ($valuearray as $key =&gt; $value) {
+						if (isset($ID3v2_text_encoding_lookup[$id3v2_majorversion][$this-&gt;tag_encoding])) {
+							// source encoding is valid in ID3v2 - use it with no conversion
+							$tag_data_id3v2[$ID3v2_framename][$key]['encodingid'] = $ID3v2_text_encoding_lookup[$id3v2_majorversion][$this-&gt;tag_encoding];
+							$tag_data_id3v2[$ID3v2_framename][$key]['data']       = $value;
+						} else {
+							// source encoding is NOT valid in ID3v2 - convert it to an ID3v2-valid encoding first
+							if ($id3v2_majorversion &lt; 4) {
+								// convert data from other encoding to UTF-16
+								$tag_data_id3v2[$ID3v2_framename][$key]['encodingid'] = 1;
+								$tag_data_id3v2[$ID3v2_framename][$key]['data']       = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'UTF-16', $value);
+
+							} else {
+								// convert data from other encoding to UTF-8
+								$tag_data_id3v2[$ID3v2_framename][$key]['encodingid'] = 3;
+								$tag_data_id3v2[$ID3v2_framename][$key]['data']       = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'UTF-8', $value);
+							}
+						}
+
+						// These values are not needed for all frame types, but if they're not used no matter
+						$tag_data_id3v2[$ID3v2_framename][$key]['description'] = '';
+						$tag_data_id3v2[$ID3v2_framename][$key]['language']    = $this-&gt;id3v2_tag_language;
+					}
+					break;
+			}
+		}
+		$this-&gt;MergeExistingTagData('id3v2', $tag_data_id3v2);
+		return $tag_data_id3v2;
+	}
+
+	function FormatDataForVorbisComment() {
+		$tag_data_vorbiscomment = $this-&gt;tag_data;
+
+		// check for multi-line comment values - split out to multiple comments if neccesary
+		// and convert data to UTF-8 strings
+		foreach ($tag_data_vorbiscomment as $tag_key =&gt; $valuearray) {
+			foreach ($valuearray as $key =&gt; $value) {
+				str_replace(&quot;\r&quot;, &quot;\n&quot;, $value);
+				if (strstr($value, &quot;\n&quot;)) {
+					unset($tag_data_vorbiscomment[$tag_key][$key]);
+					$multilineexploded = explode(&quot;\n&quot;, $value);
+					foreach ($multilineexploded as $newcomment) {
+						if (strlen(trim($newcomment)) &gt; 0) {
+							$tag_data_vorbiscomment[$tag_key][] = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'UTF-8', $newcomment);
+						}
+					}
+				} elseif (is_string($value) || is_numeric($value)) {
+					$tag_data_vorbiscomment[$tag_key][$key] = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'UTF-8', $value);
+				} else {
+					$this-&gt;warnings[] = '$data['.$tag_key.']['.$key.'] is not a string value - all of $data['.$tag_key.'] NOT written to VorbisComment tag';
+					unset($tag_data_vorbiscomment[$tag_key]);
+					break;
+				}
+			}
+		}
+		$this-&gt;MergeExistingTagData('vorbiscomment', $tag_data_vorbiscomment);
+		return $tag_data_vorbiscomment;
+	}
+
+	function FormatDataForMetaFLAC() {
+		// FLAC &amp; OggFLAC use VorbisComments same as OggVorbis
+		// but require metaflac to do the writing rather than vorbiscomment
+		return $this-&gt;FormatDataForVorbisComment();
+	}
+
+	function FormatDataForReal() {
+		$tag_data_real['title']     = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['TITLE']));
+		$tag_data_real['artist']    = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['ARTIST']));
+		$tag_data_real['copyright'] = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['COPYRIGHT']));
+		$tag_data_real['comment']   = getid3_lib::iconv_fallback($this-&gt;tag_encoding, 'ISO-8859-1', @implode(' ', @$this-&gt;tag_data['COMMENT']));
+
+		$this-&gt;MergeExistingTagData('real', $tag_data_real);
+		return $tag_data_real;
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/write.real.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/write.real.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/write.real.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,295 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// write.real.php                                              //
+// module for writing RealAudio/RealVideo tags                 //
+// dependencies: module.tag.real.php                           //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+class getid3_write_real
+{
+	var $filename;
+	var $tag_data     = array();
+	var $warnings     = array(); // any non-critical errors will be stored here
+	var $errors       = array(); // any critical errors will be stored here
+	var $paddedlength = 512;     // minimum length of CONT tag in bytes
+
+	function getid3_write_real() {
+		return true;
+	}
+
+	function WriteReal() {
+		// File MUST be writeable - CHMOD(646) at least
+		if (is_writeable($this-&gt;filename)) {
+			if ($fp_source = @fopen($this-&gt;filename, 'r+b')) {
+
+				// Initialize getID3 engine
+				$getID3 = new getID3;
+				$OldThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+				if (empty($OldThisFileInfo['real']['chunks']) &amp;&amp; !empty($OldThisFileInfo['real']['old_ra_header'])) {
+					$this-&gt;errors[] = 'Cannot write Real tags on old-style file format';
+					fclose($fp_source);
+					return false;
+				}
+
+				if (empty($OldThisFileInfo['real']['chunks'])) {
+					$this-&gt;errors[] = 'Cannot write Real tags because cannot find DATA chunk in file';
+					fclose($fp_source);
+					return false;
+				}
+				foreach ($OldThisFileInfo['real']['chunks'] as $chunknumber =&gt; $chunkarray) {
+					$oldChunkInfo[$chunkarray['name']] = $chunkarray;
+				}
+				if (!empty($oldChunkInfo['CONT']['length'])) {
+					$this-&gt;paddedlength = max($oldChunkInfo['CONT']['length'], $this-&gt;paddedlength);
+				}
+
+				$new_CONT_tag_data = $this-&gt;GenerateCONTchunk();
+				$new_PROP_tag_data = $this-&gt;GeneratePROPchunk($OldThisFileInfo['real']['chunks'], $new_CONT_tag_data);
+				$new__RMF_tag_data = $this-&gt;GenerateRMFchunk($OldThisFileInfo['real']['chunks']);
+
+				if (@$oldChunkInfo['.RMF']['length'] == strlen($new__RMF_tag_data)) {
+					fseek($fp_source, $oldChunkInfo['.RMF']['offset'], SEEK_SET);
+					fwrite($fp_source, $new__RMF_tag_data);
+				} else {
+					$this-&gt;errors[] = 'new .RMF tag ('.strlen($new__RMF_tag_data).' bytes) different length than old .RMF tag ('.$oldChunkInfo['.RMF']['length'].' bytes)';
+					fclose($fp_source);
+					return false;
+				}
+
+				if (@$oldChunkInfo['PROP']['length'] == strlen($new_PROP_tag_data)) {
+					fseek($fp_source, $oldChunkInfo['PROP']['offset'], SEEK_SET);
+					fwrite($fp_source, $new_PROP_tag_data);
+				} else {
+					$this-&gt;errors[] = 'new PROP tag ('.strlen($new_PROP_tag_data).' bytes) different length than old PROP tag ('.$oldChunkInfo['PROP']['length'].' bytes)';
+					fclose($fp_source);
+					return false;
+				}
+
+				if (@$oldChunkInfo['CONT']['length'] == strlen($new_CONT_tag_data)) {
+
+					// new data length is same as old data length - just overwrite
+					fseek($fp_source, $oldChunkInfo['CONT']['offset'], SEEK_SET);
+					fwrite($fp_source, $new_CONT_tag_data);
+					fclose($fp_source);
+					return true;
+
+				} else {
+
+					if (empty($oldChunkInfo['CONT'])) {
+						// no existing CONT chunk
+						$BeforeOffset = $oldChunkInfo['DATA']['offset'];
+						$AfterOffset  = $oldChunkInfo['DATA']['offset'];
+					} else {
+						// new data is longer than old data
+						$BeforeOffset = $oldChunkInfo['CONT']['offset'];
+						$AfterOffset  = $oldChunkInfo['CONT']['offset'] + $oldChunkInfo['CONT']['length'];
+					}
+					if ($tempfilename = tempnam('*', 'getID3')) {
+						ob_start();
+						if ($fp_temp = fopen($tempfilename, 'wb')) {
+
+							rewind($fp_source);
+							fwrite($fp_temp, fread($fp_source, $BeforeOffset));
+							fwrite($fp_temp, $new_CONT_tag_data);
+							fseek($fp_source, $AfterOffset, SEEK_SET);
+							while ($buffer = fread($fp_source, GETID3_FREAD_BUFFER_SIZE)) {
+								fwrite($fp_temp, $buffer, strlen($buffer));
+							}
+							fclose($fp_temp);
+
+							if (copy($tempfilename, $this-&gt;filename)) {
+								unlink($tempfilename);
+								fclose($fp_source);
+								return true;
+							}
+							unlink($tempfilename);
+							$this-&gt;errors[] = 'FAILED: copy('.$tempfilename.', '.$this-&gt;filename.') - '.strip_tags(ob_get_contents());
+
+						} else {
+
+							$this-&gt;errors[] = 'Could not open '.$tempfilename.' mode &quot;wb&quot; - '.strip_tags(ob_get_contents());
+
+						}
+						ob_end_clean();
+					}
+					fclose($fp_source);
+					return false;
+
+				}
+
+
+			} else {
+				$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;r+b&quot;';
+				return false;
+			}
+		}
+		$this-&gt;errors[] = 'File is not writeable: '.$this-&gt;filename;
+		return false;
+	}
+
+	function GenerateRMFchunk(&amp;$chunks) {
+		$oldCONTexists = false;
+		foreach ($chunks as $key =&gt; $chunk) {
+			$chunkNameKeys[$chunk['name']] = $key;
+			if ($chunk['name'] == 'CONT') {
+				$oldCONTexists = true;
+			}
+		}
+		$newHeadersCount = $chunks[$chunkNameKeys['.RMF']]['headers_count'] + ($oldCONTexists ? 0 : 1);
+
+		$RMFchunk  = &quot;\x00\x00&quot;; // object version
+		$RMFchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['.RMF']]['file_version'], 4);
+		$RMFchunk .= getid3_lib::BigEndian2String($newHeadersCount,                                4);
+
+		$RMFchunk  = '.RMF'.getid3_lib::BigEndian2String(strlen($RMFchunk) + 8, 4).$RMFchunk; // .RMF chunk identifier + chunk length
+		return $RMFchunk;
+	}
+
+	function GeneratePROPchunk(&amp;$chunks, &amp;$new_CONT_tag_data) {
+		$old_CONT_length = 0;
+		$old_DATA_offset = 0;
+		$old_INDX_offset = 0;
+		foreach ($chunks as $key =&gt; $chunk) {
+			$chunkNameKeys[$chunk['name']] = $key;
+			if ($chunk['name'] == 'CONT') {
+				$old_CONT_length = $chunk['length'];
+			} elseif ($chunk['name'] == 'DATA') {
+				if (!$old_DATA_offset) {
+					$old_DATA_offset = $chunk['offset'];
+				}
+			} elseif ($chunk['name'] == 'INDX') {
+				if (!$old_INDX_offset) {
+					$old_INDX_offset = $chunk['offset'];
+				}
+			}
+		}
+		$CONTdelta = strlen($new_CONT_tag_data) - $old_CONT_length;
+
+		$PROPchunk  = &quot;\x00\x00&quot;; // object version
+		$PROPchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['PROP']]['max_bit_rate'],    4);
+		$PROPchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['PROP']]['avg_bit_rate'],    4);
+		$PROPchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['PROP']]['max_packet_size'], 4);
+		$PROPchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['PROP']]['avg_packet_size'], 4);
+		$PROPchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['PROP']]['num_packets'],     4);
+		$PROPchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['PROP']]['duration'],        4);
+		$PROPchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['PROP']]['preroll'],         4);
+		$PROPchunk .= getid3_lib::BigEndian2String(max(0, $old_INDX_offset + $CONTdelta),              4);
+		$PROPchunk .= getid3_lib::BigEndian2String(max(0, $old_DATA_offset + $CONTdelta),              4);
+		$PROPchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['PROP']]['num_streams'],     2);
+		$PROPchunk .= getid3_lib::BigEndian2String($chunks[$chunkNameKeys['PROP']]['flags_raw'],       2);
+
+		$PROPchunk  = 'PROP'.getid3_lib::BigEndian2String(strlen($PROPchunk) + 8, 4).$PROPchunk; // PROP chunk identifier + chunk length
+		return $PROPchunk;
+	}
+
+	function GenerateCONTchunk() {
+		foreach ($this-&gt;tag_data as $key =&gt; $value) {
+			// limit each value to 0xFFFF bytes
+			$this-&gt;tag_data[$key] = substr($value, 0, 65535);
+		}
+
+		$CONTchunk  = &quot;\x00\x00&quot;; // object version
+
+		$CONTchunk .= getid3_lib::BigEndian2String(strlen(@$this-&gt;tag_data['title']), 2);
+		$CONTchunk .= @$this-&gt;tag_data['title'];
+
+		$CONTchunk .= getid3_lib::BigEndian2String(strlen(@$this-&gt;tag_data['artist']), 2);
+		$CONTchunk .= @$this-&gt;tag_data['artist'];
+
+		$CONTchunk .= getid3_lib::BigEndian2String(strlen(@$this-&gt;tag_data['copyright']), 2);
+		$CONTchunk .= @$this-&gt;tag_data['copyright'];
+
+		$CONTchunk .= getid3_lib::BigEndian2String(strlen(@$this-&gt;tag_data['comment']), 2);
+		$CONTchunk .= @$this-&gt;tag_data['comment'];
+
+		if ($this-&gt;paddedlength &gt; (strlen($CONTchunk) + 8)) {
+			$CONTchunk .= str_repeat(&quot;\x00&quot;, $this-&gt;paddedlength - strlen($CONTchunk) - 8);
+		}
+
+		$CONTchunk  = 'CONT'.getid3_lib::BigEndian2String(strlen($CONTchunk) + 8, 4).$CONTchunk; // CONT chunk identifier + chunk length
+
+		return $CONTchunk;
+	}
+
+	function RemoveReal() {
+		// File MUST be writeable - CHMOD(646) at least
+		if (is_writeable($this-&gt;filename)) {
+			if ($fp_source = @fopen($this-&gt;filename, 'r+b')) {
+
+				// Initialize getID3 engine
+				$getID3 = new getID3;
+				$OldThisFileInfo = $getID3-&gt;analyze($this-&gt;filename);
+				if (empty($OldThisFileInfo['real']['chunks']) &amp;&amp; !empty($OldThisFileInfo['real']['old_ra_header'])) {
+					$this-&gt;errors[] = 'Cannot remove Real tags from old-style file format';
+					fclose($fp_source);
+					return false;
+				}
+
+				if (empty($OldThisFileInfo['real']['chunks'])) {
+					$this-&gt;errors[] = 'Cannot remove Real tags because cannot find DATA chunk in file';
+					fclose($fp_source);
+					return false;
+				}
+				foreach ($OldThisFileInfo['real']['chunks'] as $chunknumber =&gt; $chunkarray) {
+					$oldChunkInfo[$chunkarray['name']] = $chunkarray;
+				}
+
+				if (empty($oldChunkInfo['CONT'])) {
+					// no existing CONT chunk
+					fclose($fp_source);
+					return true;
+				}
+
+				$BeforeOffset = $oldChunkInfo['CONT']['offset'];
+				$AfterOffset  = $oldChunkInfo['CONT']['offset'] + $oldChunkInfo['CONT']['length'];
+				if ($tempfilename = tempnam('*', 'getID3')) {
+					ob_start();
+					if ($fp_temp = fopen($tempfilename, 'wb')) {
+
+						rewind($fp_source);
+						fwrite($fp_temp, fread($fp_source, $BeforeOffset));
+						fseek($fp_source, $AfterOffset, SEEK_SET);
+						while ($buffer = fread($fp_source, GETID3_FREAD_BUFFER_SIZE)) {
+							fwrite($fp_temp, $buffer, strlen($buffer));
+						}
+						fclose($fp_temp);
+
+						if (copy($tempfilename, $this-&gt;filename)) {
+							unlink($tempfilename);
+							fclose($fp_source);
+							return true;
+						}
+						unlink($tempfilename);
+						$this-&gt;errors[] = 'FAILED: copy('.$tempfilename.', '.$this-&gt;filename.') - '.strip_tags(ob_get_contents());
+
+					} else {
+
+						$this-&gt;errors[] = 'Could not open '.$tempfilename.' mode &quot;wb&quot; - '.strip_tags(ob_get_contents());
+
+					}
+					ob_end_clean();
+				}
+				fclose($fp_source);
+				return false;
+
+
+			} else {
+				$this-&gt;errors[] = 'Could not open '.$this-&gt;filename.' mode &quot;r+b&quot;';
+				return false;
+			}
+		}
+		$this-&gt;errors[] = 'File is not writeable: '.$this-&gt;filename;
+		return false;
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/getid3/write.vorbiscomment.php
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/getid3/write.vorbiscomment.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/getid3/write.vorbiscomment.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,124 @@
+&lt;?php
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+// See readme.txt for more details                             //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// write.vorbiscomment.php                                     //
+// module for writing VorbisComment tags                       //
+// dependencies: /helperapps/vorbiscomment.exe                 //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+
+class getid3_write_vorbiscomment
+{
+
+	var $filename;
+	var $tag_data;
+	var $warnings = array(); // any non-critical errors will be stored here
+	var $errors   = array(); // any critical errors will be stored here
+
+	function getid3_write_vorbiscomment() {
+		return true;
+	}
+
+	function WriteVorbisComment() {
+
+		if (!ini_get('safe_mode')) {
+
+			// Create file with new comments
+			$tempcommentsfilename = tempnam('*', 'getID3');
+			if ($fpcomments = @fopen($tempcommentsfilename, 'wb')) {
+
+				foreach ($this-&gt;tag_data as $key =&gt; $value) {
+					foreach ($value as $commentdata) {
+						fwrite($fpcomments, $this-&gt;CleanVorbisCommentName($key).'='.$commentdata.&quot;\n&quot;);
+					}
+				}
+				fclose($fpcomments);
+
+			} else {
+
+				$this-&gt;errors[] = 'failed to open temporary tags file &quot;'.$tempcommentsfilename.'&quot;, tags not written';
+				return false;
+
+			}
+
+			$oldignoreuserabort = ignore_user_abort(true);
+			if (GETID3_OS_ISWINDOWS) {
+
+				if (file_exists(GETID3_HELPERAPPSDIR.'vorbiscomment.exe')) {
+					//$commandline = '&quot;'.GETID3_HELPERAPPSDIR.'vorbiscomment.exe&quot; -w --raw -c &quot;'.$tempcommentsfilename.'&quot; &quot;'.str_replace('/', '\\', $this-&gt;filename).'&quot;';
+					//  vorbiscomment works fine if you copy-paste the above commandline into a command prompt,
+					//  but refuses to work with `backtick` if there are &quot;doublequotes&quot; present around BOTH
+					//  the metaflac pathname and the target filename. For whatever reason...??
+					//  The solution is simply ensure that the metaflac pathname has no spaces,
+					//  and therefore does not need to be quoted
+
+					// On top of that, if error messages are not always captured properly under Windows
+					// To at least see if there was a problem, compare file modification timestamps before and after writing
+					clearstatcache();
+					$timestampbeforewriting = filemtime($this-&gt;filename);
+
+					$commandline = GETID3_HELPERAPPSDIR.'vorbiscomment.exe -w --raw -c &quot;'.$tempcommentsfilename.'&quot; &quot;'.$this-&gt;filename.'&quot; 2&gt;&amp;1';
+					$VorbiscommentError = `$commandline`;
+
+					if (empty($VorbiscommentError)) {
+						clearstatcache();
+						if ($timestampbeforewriting == filemtime($this-&gt;filename)) {
+							$VorbiscommentError = 'File modification timestamp has not changed - it looks like the tags were not written';
+						}
+					}
+				} else {
+					$VorbiscommentError = 'vorbiscomment.exe not found in '.GETID3_HELPERAPPSDIR;
+				}
+
+			} else {
+
+				$commandline = 'vorbiscomment -w --raw -c &quot;'.$tempcommentsfilename.'&quot; &quot;'.$this-&gt;filename.'&quot; 2&gt;&amp;1';
+				$VorbiscommentError = `$commandline`;
+
+			}
+
+			// Remove temporary comments file
+			unlink($tempcommentsfilename);
+			ignore_user_abort($oldignoreuserabort);
+
+			if (!empty($VorbiscommentError)) {
+
+				$this-&gt;errors[] = 'system call to vorbiscomment failed with message: '.&quot;\n\n&quot;.$VorbiscommentError;
+				return false;
+
+			}
+
+			return true;
+		}
+
+		$this-&gt;errors[] = 'PHP running in Safe Mode (backtick operator not available) - cannot call vorbiscomment, tags not written';
+		return false;
+	}
+
+	function DeleteVorbisComment() {
+		$this-&gt;tag_data = array(array());
+		return $this-&gt;WriteVorbisComment();
+	}
+
+	function CleanVorbisCommentName($originalcommentname) {
+		// A case-insensitive field name that may consist of ASCII 0x20 through 0x7D, 0x3D ('=') excluded.
+		// ASCII 0x41 through 0x5A inclusive (A-Z) is to be considered equivalent to ASCII 0x61 through
+		// 0x7A inclusive (a-z).
+
+		// replace invalid chars with a space, return uppercase text
+		// Thanks Chris Bolt &lt;chris-getid3&#216;bolt*cx&gt; for improving this function
+		// note: ereg_replace() replaces nulls with empty string (not space)
+		return strtoupper(ereg_replace('[^ -&lt;&gt;-}]', ' ', str_replace(&quot;\x00&quot;, ' ', $originalcommentname)));
+
+	}
+
+}
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/helperapps/readme.txt
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/helperapps/readme.txt	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/helperapps/readme.txt	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,55 @@
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// /helperapps/readme.txt - part of getID3()                   //
+// List of binary files required under Windows for some        //
+// features and/or file formats                                //
+// See /readme.txt for more details                            //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+This directory should contain binaries of various helper applications
+that getID3() depends on to handle some file formats under Windows.
+
+The location of this directory is configurable in /getid3/getid3.php
+as GETID3_HELPERAPPSDIR
+
+If this directory is empty, or you are missing any files, please
+download the latest version of the &quot;getID3()-WindowsSupport&quot; package
+from the usual download location (<A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>)
+
+
+
+Included files:
+=====================================================
+
+Taken from <A HREF="http://www.cygwin.com/">http://www.cygwin.com/</A>
+* cygwin1.dll
+
+Taken from <A HREF="http://unxutils.sourceforge.net/">http://unxutils.sourceforge.net/</A>
+* head.exe
+* md5sum.exe
+* tail.exe
+
+Taken from <A HREF="http://ebible.org/mpj/software.htm">http://ebible.org/mpj/software.htm</A>
+* sha1sum.exe
+
+Taken from <A HREF="http://www.vorbis.com/download.psp">http://www.vorbis.com/download.psp</A>
+* vorbiscomment.exe
+
+Taken from <A HREF="http://flac.sourceforge.net/download.html">http://flac.sourceforge.net/download.html</A>
+* metaflac.exe
+
+Taken from <A HREF="http://www.etree.org/shncom.html">http://www.etree.org/shncom.html</A>
+* shorten.exe
+
+
+/////////////////////////////////////////////////////////////////
+
+Changelog:
+
+2003.12.29:
+  * Initial release
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/license.txt
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/license.txt	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/license.txt	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,340 @@
+            GNU GENERAL PUBLIC LICENSE
+               Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+              59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+            GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The &quot;Program&quot;, below,
+refers to any such program or work, and a &quot;work based on the Program&quot;
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and &quot;any
+later version&quot;, you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+             END OF TERMS AND CONDITIONS
+
+        How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the &quot;copyright&quot; line and a pointer to where the full notice is found.
+
+    &lt;one line to give the program's name and a brief idea of what it does.&gt;
+    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  &lt;signature of Ty Coon&gt;, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: node/branches/video_test/code/getid3-1.7.5/readme.txt
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/readme.txt	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/readme.txt	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,338 @@
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                        ///
+/////////////////////////////////////////////////////////////////
+
+        This code is released under the GNU GPL:
+          <A HREF="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</A>
+
+     +---------------------------------------------+
+     | If you do use this code somewhere, send me  |
+     | an email and tell me how/where you used it. |
+     |                                             |
+     | If you want to donate, there is a link on   |
+     | <A HREF="http://www.getid3.org">http://www.getid3.org</A> for PayPal donations. |
+     +---------------------------------------------+
+
+Quick Start
+===========
+
+Q: How can I check that getID3() works on my server/files?
+A: Unzip getID3() to a directory, then access /demos/demo.browse.php
+
+
+Mailing List
+============
+
+It's highly recommended that you sign up for the getID3()-Announce
+mailing list to be notified when new versions are released, as they
+may contain important bugfixes (as well as new features, of course).
+Sign up for the mailing list from <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>
+
+
+What does getID3() do?
+======================
+
+Reads &amp; parses (to varying degrees):
+ &#164; tags:
+  * APE (v1 and v2)
+  * ID3v1 (&amp; ID3v1.1)
+  * ID3v2 (v2.4, v2.3, v2.2)
+  * Lyrics3 (v1 &amp; v2)
+
+ &#164; audio-lossy:
+  * MP3/MP2/MP1
+  * MPC / Musepack
+  * Ogg (Vorbis, OggFLAC, Speex)
+  * RealAudio
+  * Speex
+  * VQF
+
+ &#164; audio-lossless:
+  * AIFF
+  * AU
+  * Bonk
+  * CD-audio (*.cda)
+  * FLAC
+  * LA (Lossless Audio)
+  * LPAC
+  * MIDI
+  * Monkey's Audio
+  * OptimFROG
+  * RKAU
+  * VOC
+  * WAV (RIFF)
+  * WavPack
+
+ &#164; audio-video:
+  * ASF: ASF, Windows Media Audio (WMA), Windows Media Video (WMV)
+  * AVI (RIFF)
+  * Flash
+  * MPEG-1 / MPEG-2
+  * NSV (Nullsoft Streaming Video)
+  * Quicktime
+  * RealVideo
+
+ &#164; still image:
+  * BMP
+  * GIF
+  * JPEG
+  * PNG
+
+ &#164; data:
+  * ISO-9660 CD-ROM image (directory structure)
+  * SZIP (limited support)
+  * ZIP (directory structure)
+
+
+Writes:
+  * ID3v1 (&amp; ID3v1.1)
+  * ID3v2 (v2.3 &amp; v2.4)
+  * VorbisComment on OggVorbis
+  * VorbisComment on FLAC (not OggFLAC)
+  * APE v2
+  * Lyrics3 (delete only)
+
+
+Requirements
+============
+
+* PHP 4.1.0 (or higher)
+* at least 4MB memory for PHP. 8MB is highly recommended.
+  12MB is required with all modules loaded.
+
+
+Usage
+=====
+
+require_once('/path/getid3.php');
+$getID3 = new getID3;
+$fileinfo = $getID3-&gt;analyze($filename);
+
+See getid3.structure.txt for the returned data structure.
+
+
+*&gt;  For an example of a complete directory-browsing,       &lt;*
+*&gt;  file-scanning implementation of getID3(), please run   &lt;*
+*&gt;  /demos/demo.browse.php                                 &lt;*
+
+
+See /demos/demo.basic.php for a very basic use of getID3() with no
+fancy output, just scanning one file.
+
+See /demos/demo.mysql.php for a sample recursive scanning code that
+scans every file in a given directory, and all sub-directories, stores
+the results in a database and allows various analysis / maintenance
+operations
+
+See /demos/demo.simple.php for a simple example script that scans all
+files in one directory and output artist, title, bitrate and playtime
+
+See /demos/demo.mimeonly.php for a simple example script that scans a
+single file and returns only the MIME information
+
+To analyze remote files over HTTP or FTP you need to copy the file
+locally first before running getID3(). Your code would look something
+like this:
+
+// Copy remote file locally to scan with getID3()
+$remotefilename = '<A HREF="http://www.example.com/filename.mp3">http://www.example.com/filename.mp3</A>';
+if ($fp_remote = fopen($remotefilename, 'rb')) {
+    $localtempfilename = tempnam('/tmp', 'getID3');
+    if ($fp_local = fopen($localtempfilename, 'wb')) {
+        while ($buffer = fread($fp_remote, 8192)) {
+            fwrite($fp_local, $buffer);
+        }
+        fclose($fp_local);
+
+		// Initialize getID3 engine
+		$getID3 = new getID3;
+
+		$ThisFileInfo = $getID3-&gt;analyze($filename);
+
+        // Delete temporary file
+        unlink($localtempfilename);
+    }
+    fclose($fp_remote);
+}
+
+
+// Writing tags:
+require_once('getid3.php');
+$getID3 = new getID3;
+getid3_lib::IncludeDependency(GETID3_INCLUDEPATH.'write.php', __FILE__);
+$tagwriter = new getid3_writetags;
+$tagwriter-&gt;filename   = $Filename;
+$tagwriter-&gt;tagformats = array('id3v2.3', 'ape');
+$TagData['title'][]  = 'Song Title';
+$TagData['artist'][] = 'Artist Name';
+$tagwriter-&gt;tag_data = array(;
+if ($tagwriter-&gt;WriteTags()) {
+	echo 'success';
+} else {
+	echo 'failure';
+}
+
+
+
+What does the returned data structure look like?
+================================================
+
+See getid3.structure.txt
+
+It is recommended that you look at the output of
+/demos/demo.browse.php scanning the file(s) you're interested in to
+confirm what data is actually returned for any particular filetype in
+general, and your files in particular, as the actual data returned
+may vary considerably depending on what information is available in
+the file itself.
+
+
+Notes
+=====
+
+If the format parser encounters a critical problem, it will return
+something in $fileinfo['error'], describing the encountered error. If
+a less critical error or notice is generated it will appear in
+$fileinfo['warning']. Both keys may contain more than one warning or
+error. If something is returned in ['error'] then the file was not
+correctly parsed and returned data may or may not be correct and/or
+complete. If something is returned in ['warning'] (and not ['error'])
+then the data that is returned is OK - usually getID3() is reporting
+errors in the file that have been worked around due to known bugs in
+other programs. Some warnings may indicate that the data that is
+returned is OK but that some data could not be extracted due to
+errors in the file.
+
+
+Known Bugs/Issues
+=================
+
+See the end of getid3.changelog.txt for notes on known issues with
+getID3(), encoders, players, etc.
+
+
+Disclaimer
+==========
+
+getID3() has been tested on many systems, on many types of files,
+under many operating systems, and is generally believe to be stable
+and safe. That being said, there is still the chance there is an
+undiscovered and/or unfixed bug that may potentially corrupt your
+file, especially within the writing functions. By using getID3() you
+agree that it's not my fault if any of your files are corrupted.
+In fact, I'm not liable for anything :)
+
+
+/////////////////////////////////////////////////////////////////////
+
+GNU General Public License - see license.txt
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to:
+Free Software Foundation, Inc.
+59 Temple Place - Suite 330
+Boston, MA  02111-1307, USA.
+
+
+/////////////////////////////////////////////////////////////////////
+
+Reference material:
+[www.id3.org material now mirrored at <A HREF="http://id3lib.sourceforge.net/id3/">http://id3lib.sourceforge.net/id3/</A>]
+* <A HREF="http://www.id3.org/id3v2.4.0-structure.txt">http://www.id3.org/id3v2.4.0-structure.txt</A>
+* <A HREF="http://www.id3.org/id3v2.4.0-frames.txt">http://www.id3.org/id3v2.4.0-frames.txt</A>
+* <A HREF="http://www.id3.org/id3v2.4.0-changes.txt">http://www.id3.org/id3v2.4.0-changes.txt</A>
+* <A HREF="http://www.id3.org/id3v2.3.0.txt">http://www.id3.org/id3v2.3.0.txt</A>
+* <A HREF="http://www.id3.org/id3v2-00.txt">http://www.id3.org/id3v2-00.txt</A>
+* <A HREF="http://www.id3.org/mp3frame.html">http://www.id3.org/mp3frame.html</A>
+* <A HREF="http://minnie.tuhs.org/pipermail/mp3encoder/2001-January/001800.html">http://minnie.tuhs.org/pipermail/mp3encoder/2001-January/001800.html</A> &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">mathewhendry at hotmail.com</A>&gt;
+* <A HREF="http://www.dv.co.yu/mpgscript/mpeghdr.htm">http://www.dv.co.yu/mpgscript/mpeghdr.htm</A>
+* <A HREF="http://www.mp3-tech.org/programmer/frame_header.html">http://www.mp3-tech.org/programmer/frame_header.html</A>
+* <A HREF="http://users.belgacom.net/gc247244/extra/tag.html">http://users.belgacom.net/gc247244/extra/tag.html</A>
+* <A HREF="http://gabriel.mp3-tech.org/mp3infotag.html">http://gabriel.mp3-tech.org/mp3infotag.html</A>
+* <A HREF="http://www.id3.org/iso4217.html">http://www.id3.org/iso4217.html</A>
+* <A HREF="http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-1.TXT">http://www.unicode.org/Public/MAPPINGS/ISO8859/8859-1.TXT</A>
+* <A HREF="http://www.xiph.org/ogg/vorbis/doc/framing.html">http://www.xiph.org/ogg/vorbis/doc/framing.html</A>
+* <A HREF="http://www.xiph.org/ogg/vorbis/doc/v-comment.html">http://www.xiph.org/ogg/vorbis/doc/v-comment.html</A>
+* <A HREF="http://leknor.com/code/php/class.ogg.php.txt">http://leknor.com/code/php/class.ogg.php.txt</A>
+* <A HREF="http://www.id3.org/iso639-2.html">http://www.id3.org/iso639-2.html</A>
+* <A HREF="http://www.id3.org/lyrics3.html">http://www.id3.org/lyrics3.html</A>
+* <A HREF="http://www.id3.org/lyrics3200.html">http://www.id3.org/lyrics3200.html</A>
+* <A HREF="http://www.psc.edu/general/software/packages/ieee/ieee.html">http://www.psc.edu/general/software/packages/ieee/ieee.html</A>
+* <A HREF="http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/ieee-expl.html">http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/ieee-expl.html</A>
+* <A HREF="http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/binary.html">http://www.scri.fsu.edu/~jac/MAD3401/Backgrnd/binary.html</A>
+* <A HREF="http://www.jmcgowan.com/avi.html">http://www.jmcgowan.com/avi.html</A>
+* <A HREF="http://www.wotsit.org/">http://www.wotsit.org/</A>
+* <A HREF="http://www.herdsoft.com/ti/davincie/davp3xo2.htm">http://www.herdsoft.com/ti/davincie/davp3xo2.htm</A>
+* <A HREF="http://www.mathdogs.com/vorbis-illuminated/bitstream-appendix.html">http://www.mathdogs.com/vorbis-illuminated/bitstream-appendix.html</A>
+* &quot;Standard MIDI File Format&quot; by Dustin Caldwell (from www.wotsit.org)
+* <A HREF="http://midistudio.com/Help/GMSpecs_Patches.htm">http://midistudio.com/Help/GMSpecs_Patches.htm</A>
+* <A HREF="http://www.xiph.org/archives/vorbis/200109/0459.html">http://www.xiph.org/archives/vorbis/200109/0459.html</A>
+* <A HREF="http://www.replaygain.org/">http://www.replaygain.org/</A>
+* <A HREF="http://www.lossless-audio.com/">http://www.lossless-audio.com/</A>
+* <A HREF="http://download.microsoft.com/download/winmediatech40/Doc/1.0/WIN98MeXP/EN-US/ASF_Specification_v.1.0.exe">http://download.microsoft.com/download/winmediatech40/Doc/1.0/WIN98MeXP/EN-US/ASF_Specification_v.1.0.exe</A>
+* <A HREF="http://mediaxw.sourceforge.net/files/doc/Active%20Streaming%20Format%20(ASF">http://mediaxw.sourceforge.net/files/doc/Active%20Streaming%20Format%20(ASF</A>)%201.0%20Specification.pdf
+* <A HREF="http://www.uni-jena.de/~pfk/mpp/sv8/">http://www.uni-jena.de/~pfk/mpp/sv8/</A>
+* <A HREF="http://jfaul.de/atl/">http://jfaul.de/atl/</A>
+* <A HREF="http://www.uni-jena.de/~pfk/mpp/">http://www.uni-jena.de/~pfk/mpp/</A>
+* <A HREF="http://www.libpng.org/pub/png/spec/png-1.2-pdg.html">http://www.libpng.org/pub/png/spec/png-1.2-pdg.html</A>
+* <A HREF="http://www.real.com/devzone/library/creating/rmsdk/doc/rmff.htm">http://www.real.com/devzone/library/creating/rmsdk/doc/rmff.htm</A>
+* <A HREF="http://www.fastgraph.com/help/bmp_os2_header_format.html">http://www.fastgraph.com/help/bmp_os2_header_format.html</A>
+* <A HREF="http://netghost.narod.ru/gff/graphics/summary/os2bmp.htm">http://netghost.narod.ru/gff/graphics/summary/os2bmp.htm</A>
+* <A HREF="http://flac.sourceforge.net/format.html">http://flac.sourceforge.net/format.html</A>
+* <A HREF="http://www.research.att.com/projects/mpegaudio/mpeg2.html">http://www.research.att.com/projects/mpegaudio/mpeg2.html</A>
+* <A HREF="http://www.audiocoding.com/wiki/index.php?page=AAC">http://www.audiocoding.com/wiki/index.php?page=AAC</A>
+* <A HREF="http://libmpeg.org/mpeg4/doc/w2203tfs.pdf">http://libmpeg.org/mpeg4/doc/w2203tfs.pdf</A>
+* <A HREF="http://www.geocities.com/xhelmboyx/quicktime/formats/qtm-layout.txt">http://www.geocities.com/xhelmboyx/quicktime/formats/qtm-layout.txt</A>
+* <A HREF="http://developer.apple.com/techpubs/quicktime/qtdevdocs/RM/frameset.htm">http://developer.apple.com/techpubs/quicktime/qtdevdocs/RM/frameset.htm</A>
+* <A HREF="http://www.nullsoft.com/nsv/">http://www.nullsoft.com/nsv/</A>
+* <A HREF="http://www.wotsit.org/download.asp?f=iso9660">http://www.wotsit.org/download.asp?f=iso9660</A>
+* <A HREF="http://sandbox.mc.edu/~bennet/cs110/tc/tctod.html">http://sandbox.mc.edu/~bennet/cs110/tc/tctod.html</A>
+* <A HREF="http://www.cdroller.com/htm/readdata.html">http://www.cdroller.com/htm/readdata.html</A>
+* <A HREF="http://www.speex.org/manual/node10.html">http://www.speex.org/manual/node10.html</A>
+* <A HREF="http://www.harmony-central.com/Computer/Programming/aiff-file-format.doc">http://www.harmony-central.com/Computer/Programming/aiff-file-format.doc</A>
+* <A HREF="http://www.faqs.org/rfcs/rfc2361.html">http://www.faqs.org/rfcs/rfc2361.html</A>
+* <A HREF="http://ghido.shelter.ro/">http://ghido.shelter.ro/</A>
+* <A HREF="http://www.ebu.ch/tech_t3285.pdf">http://www.ebu.ch/tech_t3285.pdf</A>
+* <A HREF="http://www.sr.se/utveckling/tu/bwf">http://www.sr.se/utveckling/tu/bwf</A>
+* <A HREF="http://ftp.aessc.org/pub/aes46-2002.pdf">http://ftp.aessc.org/pub/aes46-2002.pdf</A>
+* <A HREF="http://cartchunk.org:8080/">http://cartchunk.org:8080/</A>
+* <A HREF="http://www.broadcastpapers.com/radio/cartchunk01.htm">http://www.broadcastpapers.com/radio/cartchunk01.htm</A>
+* <A HREF="http://www.hr/josip/DSP/AudioFile2.html">http://www.hr/josip/DSP/AudioFile2.html</A>
+* <A HREF="http://home.attbi.com/~chris.bagwell/AudioFormats-11.html">http://home.attbi.com/~chris.bagwell/AudioFormats-11.html</A>
+* <A HREF="http://www.pure-mac.com/extkey.html">http://www.pure-mac.com/extkey.html</A>
+* <A HREF="http://cesnet.dl.sourceforge.net/sourceforge/bonkenc/bonk-binary-format-0.9.txt">http://cesnet.dl.sourceforge.net/sourceforge/bonkenc/bonk-binary-format-0.9.txt</A>
+* <A HREF="http://www.headbands.com/gspot/">http://www.headbands.com/gspot/</A>
+* <A HREF="http://www.openswf.org/spec/SWFfileformat.html">http://www.openswf.org/spec/SWFfileformat.html</A>
+* <A HREF="http://j-faul.virtualave.net/">http://j-faul.virtualave.net/</A>
+* <A HREF="http://www.btinternet.com/~AnthonyJ/Atari/programming/avr_format.html">http://www.btinternet.com/~AnthonyJ/Atari/programming/avr_format.html</A>
+* <A HREF="http://cui.unige.ch/OSG/info/AudioFormats/ap11.html">http://cui.unige.ch/OSG/info/AudioFormats/ap11.html</A>
+* <A HREF="http://sswf.sourceforge.net/SWFalexref.html">http://sswf.sourceforge.net/SWFalexref.html</A>
+* <A HREF="http://www.geocities.com/xhelmboyx/quicktime/formats/qti-layout.txt">http://www.geocities.com/xhelmboyx/quicktime/formats/qti-layout.txt</A>
+* <A HREF="http://www-lehre.informatik.uni-osnabrueck.de/~fbstark/diplom/docs/swf/Flash_Uncovered.htm">http://www-lehre.informatik.uni-osnabrueck.de/~fbstark/diplom/docs/swf/Flash_Uncovered.htm</A>
+* <A HREF="http://developer.apple.com/quicktime/icefloe/dispatch012.html">http://developer.apple.com/quicktime/icefloe/dispatch012.html</A>
+* <A HREF="http://www.csdn.net/Dev/Format/graphics/PCD.htm">http://www.csdn.net/Dev/Format/graphics/PCD.htm</A>
+* <A HREF="http://tta.iszf.irk.ru/">http://tta.iszf.irk.ru/</A>
+* <A HREF="http://www.atsc.org/standards/a_52a.pdf">http://www.atsc.org/standards/a_52a.pdf</A>
+* <A HREF="http://www.alanwood.net/unicode/">http://www.alanwood.net/unicode/</A>
+* <A HREF="http://www.freelists.org/archives/matroska-devel/07-2003/msg00010.html">http://www.freelists.org/archives/matroska-devel/07-2003/msg00010.html</A>
+* <A HREF="http://www.its.msstate.edu/net/real/reports/config/tags.stats">http://www.its.msstate.edu/net/real/reports/config/tags.stats</A>
+* <A HREF="http://homepages.slingshot.co.nz/~helmboy/quicktime/formats/qtm-layout.txt">http://homepages.slingshot.co.nz/~helmboy/quicktime/formats/qtm-layout.txt</A>
+* <A HREF="http://brennan.young.net/Comp/LiveStage/things.html">http://brennan.young.net/Comp/LiveStage/things.html</A>
+* <A HREF="http://www.multiweb.cz/twoinches/MP3inside.htm">http://www.multiweb.cz/twoinches/MP3inside.htm</A>
+* <A HREF="http://www.geocities.co.jp/SiliconValley-Oakland/3664/alittle.html#GenreExtended">http://www.geocities.co.jp/SiliconValley-Oakland/3664/alittle.html#GenreExtended</A>
+* <A HREF="http://www.mactech.com/articles/mactech/Vol.06/06.01/SANENormalized/">http://www.mactech.com/articles/mactech/Vol.06/06.01/SANENormalized/</A>
+* <A HREF="http://www.unicode.org/unicode/faq/utf_bom.html">http://www.unicode.org/unicode/faq/utf_bom.html</A>
+* <A HREF="http://tta.corecodec.org/?menu=format">http://tta.corecodec.org/?menu=format</A>
+* <A HREF="http://www.scvi.net/nsvformat.htm">http://www.scvi.net/nsvformat.htm</A>
\ No newline at end of file

Added: node/branches/video_test/code/getid3-1.7.5/structure.txt
===================================================================
--- node/branches/video_test/code/getid3-1.7.5/structure.txt	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/getid3-1.7.5/structure.txt	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,2251 @@
+/////////////////////////////////////////////////////////////////
+/// getID3() by James Heinrich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/sotf-general">info at getid3.org</A>&gt;               //
+//  available at <A HREF="http://getid3.sourceforge.net">http://getid3.sourceforge.net</A>                 //
+//            or <A HREF="http://www.getid3.org">http://www.getid3.org</A>                         //
+/////////////////////////////////////////////////////////////////
+//                                                             //
+// changelog.txt - part of getID3()                            //
+// See readme.txt for more details                             //
+//                                                            ///
+/////////////////////////////////////////////////////////////////
+
+What does the returned data structure look like?
+================================================
+
+Hint: If you take a look at the nicely-formatted output of
+/demos/demo.browse.php you can generally see where the data you want
+is returned.
+
+Note that what is described below is only a rough guide to what data
+is actually returned by getID3(), since the actual data returned
+depends entirely on what data is in your file, what type of file it
+is, what kind of data is in the tags, etc. In addition, some formats
+(Quicktime for example) use a freeform recursive structure that is
+impossible to document completely.
+
+In the vast majority of cases, all the data you'll need is located
+in the root of the array or the special arrays described below in
+Section 1 (['audio'], ['video'], ['tags_html'], ['replay_gain']).
+
+It is suggested that for most applications you should use tag data
+from the root ['tags_html'] array, as this is the only location
+where data is stored in a consistant format: HTML-compatible
+character entities (ie &#1234;) for characters outside the 0x20-0x7F
+range (printable ISO-8859-1 characters). This data can be used as-is
+for output in HTML, and can be converted to whatever character set
+you wish to use if the output is not HTML.
+
+If you want to merge all available tags (for example, ID3v2 + ID3v1)
+into one array, you can call
+getid3_lib::CopyTagsToComments($ThisFileInfo)
+and you'll then have ['comments'] and ['comments_html'] which are
+identical to ['tags'] and ['tags_html'] except the array is one
+dimension shorter (no tag type array keys). For example, artist is:
+['tags_html']['id3v1']['artist'][0] or ['comments_html']['artist'][0]
+
+
+Some commonly-used information is found in these locations:
+
+File type:        ['fileformat']                  // ex 'mp3'
+Song length:      ['playtime_string']             // ex '3:45'    (minutes:seconds)
+                  ['playtime_seconds']            // ex 225.13    (seconds)
+Overall bitrate:  ['bitrate']                     // ex 113485.71 (bits-per-second - divide by 1000 for kbps)
+Audio frequency:  ['audio']['sample_rate']        // ex 44100     (Hertz)
+Artist name:      ['comments_html']['artist'][0]  // ex 'Elvis'   (if CopyTagsToComments() is used - see above)
+                                                  //   more than one artist may be present, you may want to use implode:
+                                                  //   implode(' &amp; ', ['comments_html']['artist'])
+
+
+/////////////////////////////////////////////////////////////////
+
+array() {
+                                         // SECTION 1: Values that are present for most or all file types
+
+    ['getID3version']=&gt;string()          // version of getID3() that scanned this file (ex: '1.6.2')
+    ['error']=&gt;array()                   // if present, contains one or more fatal error messages
+    ['warning']=&gt;array()                 // if present, contains one or more non-fatal warning messages
+    ['exist']=&gt;boolean()                 // does this file actually exist?
+    ['fileformat']=&gt;string()             // one of the standard filetype abbreviations ('mp3', 'riff', 'quicktime', etc)
+    ['filename']=&gt;string()               // filename only, no path
+    ['filenamepath']=&gt;string()           // full filename with path
+    ['filepath']=&gt;string()               // path to file, not including filename
+    ['filesize']=&gt;integer()              // filesize in bytes
+    ['md5_file']=&gt;string()               // md5 hash of entire file
+    ['md5_data']=&gt;string()               // md5 hash of portion of file excluding prepended and appeneded metainformation tags (ID3, APE, etc) - may be identical to ['md5_file']
+    ['md5_data_source']=&gt;string()        // md5 hash of original source file before compression (currently used by FLAC, OptimFROG, WavPack v4+)
+    ['sha1_file']=&gt;string()              // sha1 hash of entire file
+    ['sha1_data']=&gt;string()              // sha1 hash of portion of file excluding prepended and appeneded metainformation tags (ID3, APE, etc) - may be identical to ['md5_file']
+    ['avdataoffset']=&gt;integer()          // offset in bytes where audio/video data starts and prepended tags end
+    ['avdataend']=&gt;integer()             // offset in bytes where audio/video data ends and appended tags start
+    ['bitrate']=&gt;double()                // average bitrate for entire file (all audio/video streams), in bits per second
+    ['mime_type']=&gt;string()              // if present, MIME type of scanned file
+    ['playtime_seconds']=&gt;double()       // playing time of file, in seconds
+    ['playtime_string']=&gt;string()        // playing time of file, formatted as &lt;minutes&gt;:&lt;seconds&gt;
+    ['tags']=&gt;array()                    // array of all metainformation tags present in file ('id3v1', 'id3v2', 'ape', 'riff', 'asf', etc)
+    ['audio']=&gt;array() {
+        ['bitrate']=&gt;double()            // average bitrate for audio portion of file (all audio streams), in bits per second
+        ['bitrate_mode']=&gt;string()       // 'cbr' (Constant Bit Rate) or 'vbr' (Variable Bit Rate)
+        ['bits_per_sample']=&gt;integer()   //
+        ['channelmode']=&gt;string()        // 'mono' or 'stereo'
+        ['channels']=&gt;integer()          // number of audio channels
+        ['codec']=&gt;string()              // name of audio compression codec
+        ['compression_ratio']=&gt;double()  // ratio of compressed byte size of audio to uncompressed size
+        ['dataformat']=&gt;string()         // one of the standard filetype abbreviations ('mp3', 'wma', etc)
+        ['encoder']=&gt;string()            // name and version of encoder used to create file, if known
+        ['lossless']=&gt;boolean()          // true = lossless compression; false = lossy compression
+        ['sample_rate']=&gt;integer()
+    }
+    ['video']=&gt;array() {
+        ['bitrate']=&gt;integer()           // average bitrate for video portion of file (all video streams), in bits per second
+        ['bitrate_mode']=&gt;string()       // 'cbr' (Constant Bit Rate) or 'vbr' (Variable Bit Rate)
+        ['bits_per_sample']=&gt;integer()   //
+        ['codec']=&gt;string()              // name of video compression codec
+        ['compression_ratio']=&gt;double()  // ratio of compressed byte size of video to uncompressed size
+        ['dataformat']=&gt;string()         // one of the standard filetype abbreviations ('avi', 'mpeg', etc)
+        ['encoder']=&gt;string()            // name and version of encoder used to create file, if known
+        ['frame_rate']=&gt;double()         // frames per second
+        ['lossless']=&gt;boolean()          // true = lossless compression; false = lossy compression
+        ['resolution_x']=&gt;integer()      // horizontal dimension of video/image in pixels
+        ['resolution_y']=&gt;integer()      // vertical dimension of video/image in pixels
+        ['pixel_aspect_ratio']=&gt;double() // pixel display aspect ratio
+    }
+    ['tags']=&gt;array() {                  // array of array of strings containing best data from any available metainformation tag (APE, ID3v2, ID3v1, Lyrics3, Vorbis, ASF, RIFF, Real, etc.)
+        [&lt;key name&gt;]=&gt;array()            // &lt;key name&gt; can be anything, usually 'artist', 'title', etc. Contains array of one or more values (eg: multiple artists are possible)
+    }
+    ['tags_html']=&gt;array() {             // identical to ['tags'], but with all entries converted to HTML entities as appropriate from various source encodings
+        [&lt;key name&gt;]=&gt;array()            //
+    }
+    ['replay_gain']=&gt;array() {           // replay gain information combined from any source that contains this information (LAME, ID3v2, Vorbis, APE, etc)
+        ['audiophile']=&gt;array() {
+            ['adjustment']=&gt;double()
+            ['originator']=&gt;string()
+            ['peak']=&gt;double()
+        }
+        ['radio']=&gt;array() {
+            ['adjustment']=&gt;double()
+            ['originator']=&gt;string()
+            ['peak']=&gt;double()
+        }
+    }
+
+
+                                         // SECTION 2: Values that are present for specific file types only
+
+    ['aac']=&gt;array() {                            // AAC - Advanced Audio Coding / MPEG-4
+        ['bitrate_distribution']=&gt;array()         //
+        ['header']=&gt;array() {                     //
+            ['channel_configuration']=&gt;integer()  //
+            ['crc_present']=&gt;boolean()            //
+            ['home']=&gt;boolean()                   //
+            ['layer']=&gt;integer()                  //
+            ['mpeg_version']=&gt;integer()           //
+            ['original']=&gt;boolean()               //
+            ['private']=&gt;boolean()                //
+            ['profile_id']=&gt;integer()             //
+            ['profile_text']=&gt;string()            //
+            ['sample_frequency']=&gt;integer()       //
+            ['sample_frequency_index']=&gt;integer() //
+            ['synch']=&gt;integer()                  //
+        }                                         //
+        ['header_type']=&gt;string()                 //
+    }                                             //
+                                                  //
+    ['ape']=&gt;array()                      //
+    {                                     //
+        ['comments']=&gt;array() {           // array of array of strings containing best data from any available metainformation tag (APE, ID3v2, ID3v1, Lyrics3, Vorbis, ASF, RIFF, Real, etc.)
+            [&lt;key name&gt;]=&gt;array()         // &lt;key name&gt; can be anything, usually 'artist', 'title', etc. Contains array of one or more values (eg: multiple artists are possible)
+        }                                 //
+        ['footer']=&gt;array()               //
+        {                                 //
+            ['flags']=&gt;array()            //
+            ['raw']=&gt;array()              //
+            ['tag_version']=&gt;integer()    //
+        }                                 //
+        ['header']=&gt;array()               //
+        {                                 //
+            ['flags']=&gt;array()            //
+            ['raw']=&gt;array()              //
+            ['tag_version']=&gt;integer()    //
+        }                                 //
+        ['items']=&gt;array() {              // array of array of strings containing metainformation
+            [&lt;key name&gt;]=&gt;array() {       // &lt;key name&gt; can be anything, usually 'artist', 'title', etc. Contains array of one or more values (eg: multiple artists are possible)
+                ['data']=&gt;array() {       // array of one or more Unicode values
+                ['data_ascii']=&gt;array() { // array of values converted approximately from Unicode to ASCII
+                ['flags']=&gt;array()        //
+            }                             //
+        }                                 //
+        ['tag_offset_end']=&gt;integer()     //
+        ['tag_offset_start']=&gt;integer()   //
+    }                                     //
+
+
+    ['asf']=&gt;array() {                               // ASF - Advanced Streaming Format (ASF, Windows Media Audio (WMA), Windows Media Video (WMV))
+        ['audio_media']=&gt;array() {                   //
+            [&lt;x&gt;]=&gt;array() {                         //
+                ['bitrate']=&gt;integer()               //
+                ['bits_per_sample']=&gt;integer()       //
+                ['channels']=&gt;integer()              //
+                ['codec']=&gt;string()                  //
+                ['codec_data']=&gt;string()             //
+                ['codec_data_size']=&gt;integer()       //
+                ['raw']=&gt;array() {                   //
+                    ['nAvgBytesPerSec']=&gt;integer()   //
+                    ['wBitsPerSample']=&gt;integer()    //
+                    ['nBlockAlign']=&gt;integer()       //
+                    ['nChannels']=&gt;integer()         //
+                    ['nSamplesPerSec']=&gt;integer()    //
+                    ['wFormatTag']=&gt;integer()        //
+                }                                    //
+                ['sample_rate']=&gt;integer()           //
+            }                                        //
+        }                                            //
+        ['codec_list']=&gt;array() {                    //
+            ['codec_entries']=&gt;array() {             //
+                [&lt;x&gt;]=&gt;array() {                     //
+                    ['description']=&gt;string()        //
+                    ['description_ascii']=&gt;string()  //
+                    ['information']=&gt;string()        //
+                    ['name']=&gt;string()               //
+                    ['name_ascii']=&gt;string()         //
+                    ['type']=&gt;string()               //
+                    ['type_raw']=&gt;integer()          //
+                }                                    //
+            }                                        //
+            ['codec_entries_count']=&gt;integer()       //
+            ['objectid']=&gt;string()                   //
+            ['objectid_guid']=&gt;string()              //
+            ['objectsize']=&gt;integer()                //
+            ['reserved']=&gt;string()                   //
+            ['reserved_guid']=&gt;string()              //
+        }                                            //
+        ['comments']=&gt;array() {                      // array of comment values, derived from ['content_description']
+            ['album']=&gt;string()                      //
+            ['artist']=&gt;string()                     //
+            ['comment']=&gt;string()                    //
+            ['copyright']=&gt;string()                  //
+            ['genre']=&gt;string()                      //
+            ['title']=&gt;string()                      //
+            ['track']=&gt;string()                      //
+            ['year']=&gt;string()                       //
+        }                                            //
+        ['content_description']=&gt;array() {           // raw values - should use values from ['comments'] instead
+            ['author']=&gt;string()                     //
+            ['author_ascii']=&gt;string()               //
+            ['author_length']=&gt;integer()             //
+            ['copyright']=&gt;string()                  //
+            ['copyright_ascii']=&gt;string()            //
+            ['copyright_length']=&gt;integer()          //
+            ['description']=&gt;string()                //
+            ['description_ascii']=&gt;string()          //
+            ['description_length']=&gt;integer()        //
+            ['objectid']=&gt;string()                   //
+            ['objectid_guid']=&gt;string()              //
+            ['objectsize']=&gt;integer()                //
+            ['rating']=&gt;string()                     //
+            ['rating_ascii']=&gt;string()               //
+            ['rating_length']=&gt;integer()             //
+            ['title']=&gt;string()                      //
+            ['title_ascii']=&gt;string()                //
+            ['title_length']=&gt;integer()              //
+        }                                            //
+        ['data_object']=&gt;array() {                   //
+            ['fileid']=&gt;string()                     //
+            ['fileid_guid']=&gt;string()                //
+            ['objectid']=&gt;string()                   //
+            ['objectid_guid']=&gt;string()              //
+            ['objectsize']=&gt;integer()                //
+            ['reserved']=&gt;integer()                  //
+            ['total_data_packets']=&gt;integer()        //
+        }                                            //
+        ['extended_content_description']=&gt;array() {  //
+            ['content_descriptors']=&gt;array() {       //
+                [&lt;x&gt;]=&gt;array() {                     //
+                    ['name']=&gt;string()               //
+                    ['name_ascii']=&gt;string()         //
+                    ['name_length']=&gt;integer()       //
+                    ['value']=&gt;string()              //
+                    ['value_ascii']=&gt;string()        //
+                    ['value_length']=&gt;integer()      //
+                    ['value_type']=&gt;integer()        //
+                }                                    //
+            }                                        //
+            ['content_descriptors_count']=&gt;integer() //
+            ['objectid']=&gt;string()                   //
+            ['objectid_guid']=&gt;string()              //
+            ['objectsize']=&gt;integer()                //
+        }                                            //
+        ['file_properties_object']=&gt;array() {        //
+            ['creation_date']=&gt;double()              //
+            ['creation_date_unix']=&gt;double()         //
+            ['data_packets']=&gt;integer()              //
+            ['fileid']=&gt;string()                     //
+            ['fileid_guid']=&gt;string()                //
+            ['filesize']=&gt;integer()                  //
+            ['flags']=&gt;array() {                     //
+                ['broadcast']=&gt;boolean()             //
+                ['seekable']=&gt;boolean()              //
+            }                                        //
+            ['flags_raw']=&gt;integer()                 //
+            ['max_bitrate']=&gt;integer()               //
+            ['max_packet_size']=&gt;integer()           //
+            ['min_packet_size']=&gt;integer()           //
+            ['objectid']=&gt;string()                   //
+            ['objectid_guid']=&gt;string()              //
+            ['objectsize']=&gt;integer()                //
+            ['play_duration']=&gt;double()              //
+            ['preroll']=&gt;integer()                   //
+            ['send_duration']=&gt;double()              //
+        }                                            //
+        ['header_extension_object']=&gt;array() {       //
+            ['extension_data']=&gt;integer()            //
+            ['extension_data_size']=&gt;integer()       //
+            ['objectid']=&gt;string()                   //
+            ['objectid_guid']=&gt;string()              //
+            ['objectsize']=&gt;integer()                //
+            ['reserved_1']=&gt;string()                 //
+            ['reserved_1_guid']=&gt;string()            //
+            ['reserved_2']=&gt;integer()                //
+        }                                            //
+        ['header_object']=&gt;array() {                 //
+            ['headerobjects']=&gt;integer()             //
+            ['objectid']=&gt;string()                   //
+            ['objectid_guid']=&gt;string()              //
+            ['objectsize']=&gt;integer()                //
+            ['reserved1']=&gt;integer()                 //
+            ['reserved2']=&gt;integer()                 //
+        }                                            //
+        ['marker_object']=&gt;array() {                 //
+            ['markers_count']=&gt;integer()             //
+            ['objectid']=&gt;string()                   //
+            ['objectid_guid']=&gt;string()              //
+            ['objectsize']=&gt;integer()                //
+            ['reserved']=&gt;string()                   //
+            ['reserved_2']=&gt;integer()                //
+            ['reserved_guid']=&gt;string()              //
+        }                                            //
+        ['stream_bitrate_properties']=&gt;array() {     //
+            ['bitrate_records']=&gt;array() {           //
+                [&lt;x&gt;]=&gt;array() {                     //
+                    ['bitrate']=&gt;integer()           //
+                    ['flags_raw']=&gt;integer()         //
+                    ['flags']=&gt;array() {             //
+                        ['stream_number']=&gt;integer() //
+                    }                                //
+                }                                    //
+            }                                        //
+            ['bitrate_records_count']=&gt;integer()     //
+            ['objectid']=&gt;string()                   //
+            ['objectid_guid']=&gt;string()              //
+            ['objectsize']=&gt;integer()                //
+        }                                            //
+        ['stream_properties_object']=&gt;array() {      //
+            [&lt;x&gt;]=&gt;array() {                         //
+                ['error_correct_data']=&gt;string()     //
+                ['error_correct_guid']=&gt;string()     //
+                ['error_correct_type']=&gt;string()     //
+                ['error_data_length']=&gt;integer()     //
+                ['flags_raw']=&gt;integer()             //
+                ['flags']=&gt;array() {                 //
+                    ['encrypted']=&gt;boolean()         //
+                }                                    //
+                ['objectid']=&gt;string()               //
+                ['objectid_guid']=&gt;string()          //
+                ['objectsize']=&gt;integer()            //
+                ['stream_type']=&gt;string()            //
+                ['stream_type_guid']=&gt;string()       //
+                ['time_offset']=&gt;integer()           //
+                ['type_data_length']=&gt;integer()      //
+                ['type_specific_data']=&gt;string()     //
+            }                                        //
+        }                                            //
+        ['video_media']=&gt;array() {                   //
+            [&lt;x&gt;]=&gt;array() {                         //
+                ['flags']=&gt;integer()                 //
+                ['format_data']=&gt;array() {           //
+                    ['bits_per_pixel']=&gt;integer()    //
+                    ['codec']=&gt;string()              //
+                    ['codec_data']=&gt;boolean()        //
+                    ['codec_fourcc']=&gt;string()       //
+                    ['colors_important']=&gt;integer()  //
+                    ['colors_used']=&gt;integer()       //
+                    ['format_data_size']=&gt;integer()  //
+                    ['horizontal_pels']=&gt;integer()   //
+                    ['image_height']=&gt;integer()      //
+                    ['image_size']=&gt;integer()        //
+                    ['image_width']=&gt;integer()       //
+                    ['reserved']=&gt;integer()          //
+                    ['vertical_pels']=&gt;integer()     //
+                }                                    //
+                ['format_data_size']=&gt;integer()      //
+                ['image_height']=&gt;integer()          //
+                ['image_width']=&gt;integer()           //
+            }                                        //
+        }                                            //
+    }                                                //
+
+
+    ['au']=&gt;array() {                       // AU - Next/Sun AUdio format
+        ['bits_per_sample']=&gt;integer()      //
+        ['channels']=&gt;integer()             //
+        ['comment']=&gt;string()               //
+        ['data_format']=&gt;string()           //
+        ['data_format_id']=&gt;integer()       //
+        ['data_size']=&gt;integer()            //
+        ['header_length']=&gt;integer()        //
+        ['sample_rate']=&gt;integer()          //
+        ['used_bits_per_sample']=&gt;integer() //
+    }                                       //
+
+
+    ['bmp']=&gt;array() {                          // BMP - OS/2 or Windows BitMaP
+        ['header']=&gt;array() {                   //
+            ['compression']=&gt;string()           //
+            ['raw']=&gt;array() {                  //
+                ['bits_per_pixel']=&gt;integer()   //
+                ['bmp_data_size']=&gt;integer()    //
+                ['colors_important']=&gt;integer() //
+                ['colors_used']=&gt;integer()      //
+                ['compression']=&gt;integer()      //
+                ['data_offset']=&gt;integer()      //
+                ['filesize']=&gt;integer()         //
+                ['header_size']=&gt;integer()      //
+                ['height']=&gt;integer()           //
+                ['identifier']=&gt;string()        //
+                ['planes']=&gt;integer()           //
+                ['resolution_h']=&gt;integer()     //
+                ['resolution_v']=&gt;integer()     //
+                ['width']=&gt;integer()            //
+            }                                   //
+        }                                       //
+        ['type_os']=&gt;string()                   //
+        ['type_version']=&gt;integer()             //
+    }                                           //
+
+
+    ['bonk']=&gt;array() {                       // BONK - lossy/lossless audio compression (www.bonkenc.org)
+        ['BONK']=&gt;array() {                   //
+            ['channels']=&gt;integer()           //
+            ['downsampling_ratio']=&gt;integer() //
+            ['joint_stereo']=&gt;boolean()       //
+            ['lossless']=&gt;boolean()           //
+            ['number_samples']=&gt;integer()     //
+            ['number_taps']=&gt;integer()        //
+            ['offset']=&gt;integer()             //
+            ['sample_rate']=&gt;integer()        //
+            ['samples_per_packet']=&gt;integer() //
+            ['size']=&gt;integer()               //
+            ['version']=&gt;integer()            //
+        }                                     //
+        ['INFO']=&gt;array() {                   //
+            ['size']=&gt;integer()               //
+            ['offset']=&gt;integer()             //
+            ['version']=&gt;integer()            //
+            [&lt;x&gt;]=&gt;array() {                  //
+                ['nextbit']=&gt;integer()        //
+                ['offset']=&gt;integer()         //
+            }                                 //
+        }                                     //
+        ['dataend']=&gt;integer()                //
+        ['dataoffset']=&gt;integer()             //
+    }                                         //
+
+
+    ['flac']=&gt;array() {                         // FLAC - Free Lossless Audio Compressor
+        ['SEEKTABLE']=&gt;array() {                //
+            [&lt;x&gt;]=&gt;array() {                    //
+                ['offset']=&gt;integer()           //
+                ['samples']=&gt;integer()          //
+            }                                   //
+            ['placeholders']=&gt;integer()         //
+            ['raw']=&gt;array() {                  //
+                ['block_data']=&gt;string()        //
+                ['block_length']=&gt;integer()     //
+                ['block_type']=&gt;integer()       //
+                ['block_type_text']=&gt;string()   //
+                ['last_meta_block']=&gt;boolean()  //
+                ['offset']=&gt;integer()           //
+            }                                   //
+        }                                       //
+        ['STREAMINFO']=&gt;array() {               //
+            ['audio_signature']=&gt;string()       //
+            ['bits_per_sample']=&gt;integer()      //
+            ['channels']=&gt;integer()             //
+            ['max_block_size']=&gt;integer()       //
+            ['max_frame_size']=&gt;integer()       //
+            ['min_block_size']=&gt;integer()       //
+            ['min_frame_size']=&gt;integer()       //
+            ['raw']=&gt;array() {                  //
+                ['block_data']=&gt;string()        //
+                ['block_length']=&gt;integer()     //
+                ['block_type']=&gt;integer()       //
+                ['block_type_text']=&gt;string()   //
+                ['last_meta_block']=&gt;boolean()  //
+                ['offset']=&gt;integer()           //
+            }                                   //
+            ['sample_rate']=&gt;integer()          //
+            ['samples_stream']=&gt;integer()       //
+        }                                       //
+        ['VORBIS_COMMENT']=&gt;array() {           //
+            ['raw']=&gt;array() {                  //
+                ['block_data']=&gt;string()        //
+                ['block_length']=&gt;integer()     //
+                ['block_type']=&gt;integer()       //
+                ['block_type_text']=&gt;string()   //
+                ['last_meta_block']=&gt;boolean()  //
+                ['offset']=&gt;integer()           //
+            }                                   //
+        }                                       //
+        ['compressed_audio_bytes']=&gt;integer()   //
+        ['compression_ratio']=&gt;double()         //
+        ['uncompressed_audio_bytes']=&gt;integer() //
+    }                                           //
+
+
+    ['gif']=&gt;array() {                             // GIF - Graphics Interchange Format
+        ['global_color_table']=&gt;array() {          //
+            [&lt;x&gt;]=&gt;integer()                       //
+        }                                          //
+        ['header']=&gt;array() {                      //
+            ['bits_per_pixel']=&gt;integer()          //
+            ['flags']=&gt;array() {                   //
+                ['global_color_sorted']=&gt;boolean() //
+                ['global_color_table']=&gt;boolean()  //
+            }                                      //
+            ['global_color_size']=&gt;integer()       //
+            ['raw']=&gt;array() {                     //
+                ['aspect_ratio']=&gt;integer()        //
+                ['bg_color_index']=&gt;integer()      //
+                ['flags']=&gt;integer()               //
+                ['height']=&gt;integer()              //
+                ['identifier']=&gt;string()           //
+                ['version']=&gt;string()              //
+                ['width']=&gt;integer()               //
+            }                                      //
+        }                                          //
+        ['version']=&gt;string()                      //
+    }                                              //
+
+
+    ['id3v1']=&gt;array() {                // ID3v1
+        ['album']=&gt;string()             //
+        ['artist']=&gt;string()            //
+        ['comment']=&gt;string()           //
+        ['genre']=&gt;string()             //
+        ['genreid']=&gt;integer()          //
+        ['title']=&gt;string()             //
+        ['track']=&gt;integer()            //
+        ['year']=&gt;string()              //
+        ['padding_valid']=&gt;boolean()    //
+        ['comments']=&gt;array()           //
+        ['tag_offset_start']=&gt;integer() //
+        ['tag_offset_end']=&gt;integer()   //
+    }                                   //
+
+
+    ['id3v2']=&gt;array() {                                 // ID3v2 - www.id3.org
+        [&lt;frame name&gt;]=&gt;array() {                        // &lt;frame name&gt; can be any of the 4-character (3-character in ID3v2.2) frame names allowed in the ID3v2 spec. Exact contents of returned array data varies with frame type.
+            [&lt;x&gt;]=&gt;array() {                             // some frames types allow multiple values ('COMM' for example), others do not and do not have this array level
+                ['asciidata']=&gt;boolean()                 //
+                ['asciidescription']=&gt;string()           //
+                ['data']=&gt;boolean()                      //
+                ['datalength']=&gt;integer()                //
+                ['dataoffset']=&gt;integer()                //
+                ['description']=&gt;string()                //
+                ['encoding']=&gt;string()                   //
+                ['encodingid']=&gt;integer()                //
+                ['flags']=&gt;array() {                     //
+                    ['Encryption']=&gt;boolean()            //
+                    ['FileAlterPreservation']=&gt;boolean() //
+                    ['GroupingIdentity']=&gt;boolean()      //
+                    ['ReadOnly']=&gt;boolean()              //
+                    ['TagAlterPreservation']=&gt;boolean()  //
+                    ['compression']=&gt;boolean()           //
+                }                                        //
+                ['framenamelong']=&gt;string()              //
+                ['language']=&gt;string()                   //
+                ['languagename']=&gt;string()               //
+            }                                            //
+        }                                                //
+        ['comments']=&gt;array() {                          // array of array of strings containing best data from any available metainformation tag (APE, ID3v2, ID3v1, Lyrics3, Vorbis, ASF, RIFF, Real, etc.)
+            [&lt;key name&gt;]=&gt;array()                        // &lt;key name&gt; can be anything, usually 'artist', 'title', etc. Contains array of one or more values (eg: multiple artists are possible)
+        }                                                //
+        ['flags']=&gt;array() {                             //
+            ['experim']=&gt;string()                        //
+            ['exthead']=&gt;string()                        //
+            ['unsynch']=&gt;string()                        //
+        }                                                //
+        ['header']=&gt;boolean()                            //
+        ['headerlength']=&gt;integer()                      //
+        ['majorversion']=&gt;integer()                      //
+        ['minorversion']=&gt;integer()                      //
+        ['padding']=&gt;array() {                           //
+            ['length']=&gt;integer()                        //
+            ['start']=&gt;integer()                         //
+            ['valid']=&gt;boolean()                         //
+        }                                                //
+        ['tag_offset_end']=&gt;integer()                    //
+        ['tag_offset_start']=&gt;integer()                  //
+    }                                                    //
+
+
+    ['iso']=&gt;array() {                                           // ISO-9660 - CD-ROM Image
+        ['directories']=&gt;array() {                               //
+            [&lt;x&gt;]=&gt;array() {                                     //
+                [&lt;x&gt;]=&gt;array() {                                 //
+                    ['file_flags']=&gt;array() {                    //
+                        ['associated']=&gt;boolean()                //
+                        ['directory']=&gt;boolean()                 //
+                        ['extended']=&gt;boolean()                  //
+                        ['hidden']=&gt;boolean()                    //
+                        ['multiple']=&gt;boolean()                  //
+                        ['permissions']=&gt;boolean()               //
+                    }                                            //
+                    ['file_identifier_ascii']=&gt;string()          //
+                    ['filename']=&gt;string()                       //
+                    ['filesize']=&gt;integer()                      //
+                    ['offset_bytes']=&gt;integer()                  //
+                    ['raw']=&gt;array() {                           //
+                        ['extended_attribute_length']=&gt;integer() //
+                        ['file_flags']=&gt;integer()                //
+                        ['file_identifier']=&gt;string()            //
+                        ['file_identifier_length']=&gt;integer()    //
+                        ['file_unit_size']=&gt;integer()            //
+                        ['filesize']=&gt;integer()                  //
+                        ['interleave_gap_size']=&gt;integer()       //
+                        ['length']=&gt;integer()                    //
+                        ['offset_logical']=&gt;integer()            //
+                        ['recording_date_time']=&gt;string()        //
+                        ['volume_sequence_number']=&gt;integer()    //
+                    }                                            //
+                    ['recording_timestamp']=&gt;integer()           //
+                }                                                //
+            }                                                    //
+        }                                                        //
+        ['files']=&gt;array() {                                     // multidimensional tree-structure array listing of all files and directories in image
+            [&lt;directory name&gt;]=&gt;array()                          // entries of type array are directories (key is directory name), may contain files and/or other subdirectories
+            [&lt;file name&gt;]=&gt;integer()                             // entries of type integer are files (key is file name, value is file size in bytes)
+        }                                                        //
+        ['path_table']=&gt;array() {                                //
+            ['directories']=&gt;array() {                           //
+                [&lt;x&gt;]=&gt;array() {                                 //
+                    ['extended_length']=&gt;integer()               //
+                    ['full_path']=&gt;string()                      //
+                    ['length']=&gt;integer()                        //
+                    ['location_bytes']=&gt;integer()                //
+                    ['location_logical']=&gt;integer()              //
+                    ['name']=&gt;string()                           //
+                    ['name_ascii']=&gt;string()                     //
+                    ['parent_directory']=&gt;integer()              //
+                }                                                //
+            }                                                    //
+            ['offset']=&gt;integer()                                //
+            ['raw']=&gt;string()                                    //
+        }                                                        //
+        ['primary_volume_descriptor']=&gt;array() {                 //
+            ['abstract_file_identifier']=&gt;string()               //
+            ['application_identifier']=&gt;string()                 //
+            ['bibliographic_file_identifier']=&gt;string()          //
+            ['copyright_file_identifier']=&gt;string()              //
+            ['data_preparer_identifier']=&gt;string()               //
+            ['offset']=&gt;integer()                                //
+            ['publisher_identifier']=&gt;string()                   //
+            ['raw']=&gt;array() {                                   //
+                ['abstract_file_identifier']=&gt;string()           //
+                ['application_data']=&gt;string()                   //
+                ['application_identifier']=&gt;string()             //
+                ['bibliographic_file_identifier']=&gt;string()      //
+                ['copyright_file_identifier']=&gt;string()          //
+                ['data_preparer_identifier']=&gt;string()           //
+                ['file_structure_version']=&gt;integer()            //
+                ['logical_block_size']=&gt;integer()                //
+                ['path_table_l_location']=&gt;integer()             //
+                ['path_table_l_opt_location']=&gt;integer()         //
+                ['path_table_m_location']=&gt;integer()             //
+                ['path_table_m_opt_location']=&gt;integer()         //
+                ['path_table_size']=&gt;integer()                   //
+                ['publisher_identifier']=&gt;string()               //
+                ['root_directory_record']=&gt;string()              //
+                ['standard_identifier']=&gt;string()                //
+                ['system_identifier']=&gt;string()                  //
+                ['unused_1']=&gt;string()                           //
+                ['unused_2']=&gt;string()                           //
+                ['unused_3']=&gt;string()                           //
+                ['unused_4']=&gt;integer()                          //
+                ['volume_creation_date_time']=&gt;string()          //
+                ['volume_descriptor_type']=&gt;integer()            //
+                ['volume_descriptor_version']=&gt;integer()         //
+                ['volume_effective_date_time']=&gt;string()         //
+                ['volume_expiration_date_time']=&gt;string()        //
+                ['volume_identifier']=&gt;string()                  //
+                ['volume_modification_date_time']=&gt;string()      //
+                ['volume_sequence_number']=&gt;integer()            //
+                ['volume_set_identifier']=&gt;string()              //
+                ['volume_set_size']=&gt;integer()                   //
+                ['volume_space_size']=&gt;integer()                 //
+            }                                                    //
+            ['system_identifier']=&gt;string()                      //
+            ['volume_creation_date_time']=&gt;integer()             //
+            ['volume_effective_date_time']=&gt;boolean()            //
+            ['volume_expiration_date_time']=&gt;boolean()           //
+            ['volume_identifier']=&gt;string()                      //
+            ['volume_modification_date_time']=&gt;integer()         //
+            ['volume_set_identifier']=&gt;string()                  //
+        }                                                        //
+        ['supplementary_volume_descriptor']=&gt;array() {           //
+            ['abstract_file_identifier']=&gt;string()               //
+            ['application_identifier']=&gt;string()                 //
+            ['bibliographic_file_identifier']=&gt;string()          //
+            ['copyright_file_identifier']=&gt;string()              //
+            ['data_preparer_identifier']=&gt;string()               //
+            ['offset']=&gt;integer()                                //
+            ['publisher_identifier']=&gt;string()                   //
+            ['raw']=&gt;array() {                                   //
+                ['abstract_file_identifier']=&gt;string()           //
+                ['application_data']=&gt;string()                   //
+                ['application_identifier']=&gt;string()             //
+                ['bibliographic_file_identifier']=&gt;string()      //
+                ['copyright_file_identifier']=&gt;string()          //
+                ['data_preparer_identifier']=&gt;string()           //
+                ['file_structure_version']=&gt;integer()            //
+                ['logical_block_size']=&gt;integer()                //
+                ['path_table_l_location']=&gt;integer()             //
+                ['path_table_l_opt_location']=&gt;integer()         //
+                ['path_table_m_location']=&gt;integer()             //
+                ['path_table_m_opt_location']=&gt;integer()         //
+                ['path_table_size']=&gt;integer()                   //
+                ['publisher_identifier']=&gt;string()               //
+                ['root_directory_record']=&gt;string()              //
+                ['standard_identifier']=&gt;string()                //
+                ['system_identifier']=&gt;string()                  //
+                ['unused_1']=&gt;string()                           //
+                ['unused_2']=&gt;string()                           //
+                ['unused_3']=&gt;string()                           //
+                ['unused_4']=&gt;integer()                          //
+                ['volume_creation_date_time']=&gt;string()          //
+                ['volume_descriptor_type']=&gt;integer()            //
+                ['volume_descriptor_version']=&gt;integer()         //
+                ['volume_effective_date_time']=&gt;string()         //
+                ['volume_expiration_date_time']=&gt;string()        //
+                ['volume_identifier']=&gt;string()                  //
+                ['volume_modification_date_time']=&gt;string()      //
+                ['volume_sequence_number']=&gt;integer()            //
+                ['volume_set_identifier']=&gt;string()              //
+                ['volume_set_size']=&gt;integer()                   //
+                ['volume_space_size']=&gt;integer()                 //
+            }                                                    //
+            ['system_identifier']=&gt;string()                      //
+            ['volume_creation_date_time']=&gt;integer()             //
+            ['volume_effective_date_time']=&gt;boolean()            //
+            ['volume_expiration_date_time']=&gt;boolean()           //
+            ['volume_identifier']=&gt;string()                      //
+            ['volume_modification_date_time']=&gt;integer()         //
+            ['volume_set_identifier']=&gt;string()                  //
+        }                                                        //
+    }                                                            //
+
+
+    ['jpg']=&gt;array() {    // JPEG - still image
+        ['exif']=&gt;array() // data returned from PHP's exif_read_data() function
+    }                     //
+
+
+    ['la']=&gt;array() {                        // LA - Lossless Audio (www.lossless-audio.com)
+        ['raw']=&gt;array() {
+            ['format']=&gt;integer()            //
+            ['flags']=&gt;integer()             //
+        }                                    //
+        ['flags']=&gt;array() {                 //
+            ['seekable']=&gt;boolean()          //
+            ['high_compression']=&gt;boolean()  //
+        }                                    //
+        ['bits_per_sample']=&gt;integer()       //
+        ['bytes_per_sample']=&gt;integer()      //
+        ['bytes_per_second']=&gt;integer()      //
+        ['channels']=&gt;integer()              //
+        ['compression_ratio']=&gt;double()      //
+        ['format_size']=&gt;integer()           //
+        ['header_size']=&gt;integer()           //
+        ['original_crc']=&gt;double()           //
+        ['sample_rate']=&gt;integer()           //
+        ['samples']=&gt;integer()               //
+        ['uncompressed_size']=&gt;integer()     //
+        ['version']=&gt;double()                //
+        ['version_major']=&gt;integer()         //
+        ['version_minor']=&gt;integer()         //
+        ['footerstart']=&gt;double()            //
+    }
+
+
+    ['lpac']=&gt;array() {                               // LPAC - Lossless Predictive Audio Compressor
+        ['block_length']=&gt;integer()                   //
+        ['file_version']=&gt;integer()                   //
+        ['flags']=&gt;array() {                          //
+            ['16_bit']=&gt;boolean()                     //
+            ['24_bit']=&gt;boolean()                     //
+            ['adaptive_prediction_order']=&gt;boolean()  //
+            ['adaptive_quantization']=&gt;boolean()      //
+            ['fast_compress']=&gt;boolean()              //
+            ['is_wave']=&gt;boolean()                    //
+            ['joint_stereo']=&gt;boolean()               //
+            ['max_prediction_order']=&gt;integer()       //
+            ['quantization']=&gt;integer()               //
+            ['random_access']=&gt;boolean()              //
+            ['stereo']=&gt;boolean()                     //
+        }                                             //
+        ['raw']=&gt;array() {                            //
+            ['audio_type']=&gt;integer()                 //
+            ['parameters']=&gt;double()                  //
+        }                                             //
+        ['total_samples']=&gt;integer()                  //
+    }                                                 //
+
+
+    ['lyrics3']=&gt;array() {                // Lyrics3 - metainformation tags
+        ['comments']=&gt;array() {           //
+            ['album']=&gt;string()           //
+            ['artist']=&gt;string()          //
+            ['author']=&gt;string()          //
+            ['comment']=&gt;string()         //
+            ['title']=&gt;string()           //
+        }                                 //
+        ['flags']=&gt;array() {              //
+            ['lyrics']=&gt;boolean()         //
+            ['timestamps']=&gt;boolean()     //
+        }                                 //
+        ['images']=&gt;array() {             //
+            [&lt;x&gt;]=&gt;array() {              //
+                ['description']=&gt;string() //
+                ['filename']=&gt;string()    //
+                ['timestamp']=&gt;integer()  //
+            }                             //
+        }                                 //
+        ['raw']=&gt;array() {                //
+            ['offset_start']=&gt;integer()   //
+            ['offset_end']=&gt;integer()     //
+            ['AUT']=&gt;string()             //
+            ['EAL']=&gt;string()             //
+            ['EAR']=&gt;string()             //
+            ['ETT']=&gt;string()             //
+            ['IMG']=&gt;string()             //
+            ['IND']=&gt;string()             //
+            ['INF']=&gt;string()             //
+            ['LYR']=&gt;string()             //
+            ['lyrics3tagsize']=&gt;integer() //
+            ['lyrics3version']=&gt;integer() //
+            ['unparsed']=&gt;string()        //
+        }                                 //
+        ['synchedlyrics']=&gt;array() {      //
+            [&lt;x&gt;]=&gt;string()               //
+        }                                 //
+        ['unsynchedlyrics']=&gt;string()     //
+    }                                     //
+
+
+    ['midi']=&gt;array() {                         // MIDI (Musical Instrument Digital Interface) - sequenced music
+        ['comments']=&gt;array() {                 //
+            ['comment']=&gt;string()               //
+            ['copyright']=&gt;string()             //
+        }                                       //
+        ['keysignature']=&gt;array() {             //
+            [&lt;x&gt;]=&gt;string()                     //
+        }                                       //
+        ['raw']=&gt;array() {                      //
+            ['events']=&gt;array() {               //
+                [&lt;x&gt;]=&gt;array() {                //
+                    [&lt;x&gt;]=&gt;array() {            //
+                        ['us_qnote']=&gt;integer() //
+                    }                           //
+                }                               //
+            }                                   //
+            ['fileformat']=&gt;integer()           //
+            ['headersize']=&gt;integer()           //
+            ['ticksperqnote']=&gt;integer()        //
+            ['track']=&gt;array() {                //
+                [&lt;x&gt;]=&gt;array() {                //
+                    ['instrument']=&gt;string()    //
+                    ['instrumentid']=&gt;integer() //
+                    ['name']=&gt;string()          //
+                }                               //
+            }                                   //
+            ['tracks']=&gt;integer()               //
+        }                                       //
+        ['timesignature']=&gt;array() {            //
+            [&lt;x&gt;]=&gt;string()                     //
+        }                                       //
+        ['totalticks']=&gt;integer()               //
+    }                                           //
+
+
+    ['monkeys_audio']=&gt;array() {                // Monkey's Audio - lossless audio compression
+        ['bitrate']=&gt;double()                   //
+        ['bits_per_sample']=&gt;integer()          //
+        ['channels']=&gt;integer()                 //
+        ['compressed_size']=&gt;integer()          //
+        ['compression']=&gt;string()               //
+        ['compression_ratio']=&gt;double()         //
+        ['flags']=&gt;array() {                    //
+            ['24-bit']=&gt;boolean()               //
+            ['8-bit']=&gt;boolean()                //
+            ['crc-32']=&gt;boolean()               //
+            ['no_wav_header']=&gt;boolean()        //
+            ['peak_level']=&gt;boolean()           //
+            ['seek_elements']=&gt;boolean()        //
+        }                                       //
+        ['frames']=&gt;integer()                   //
+        ['peak_level']=&gt;integer()               //
+        ['peak_ratio']=&gt;double()                //
+        ['playtime']=&gt;double()                  //
+        ['raw']=&gt;array() {                      //
+            ['header_tag']=&gt;string()            //
+            ['nChannels']=&gt;integer()            //
+            ['nCompressionLevel']=&gt;integer()    //
+            ['nFinalFrameSamples']=&gt;integer()   //
+            ['nFormatFlags']=&gt;integer()         //
+            ['nPeakLevel']=&gt;integer()           //
+            ['nSampleRate']=&gt;integer()          //
+            ['nSeekElements']=&gt;integer()        //
+            ['nTotalFrames']=&gt;integer()         //
+            ['nVersion']=&gt;integer()             //
+            ['nWAVHeaderBytes']=&gt;integer()      //
+            ['nWAVTerminatingBytes']=&gt;integer() //
+        }                                       //
+        ['sample_rate']=&gt;integer()              //
+        ['samples']=&gt;integer()                  //
+        ['samples_per_frame']=&gt;integer()        //
+        ['uncompressed_size']=&gt;integer()        //
+        ['version']=&gt;double()                   //
+    }                                           //
+
+
+    ['mpc']=&gt;array() {                          // MPC (Musepack) - lossy audio compression
+        ['header']=&gt;array() {                   //
+            ['album_gain_db']=&gt;integer()        //
+            ['album_peak']=&gt;integer()           //
+            ['album_peak_db']=&gt;boolean()        //
+            ['title_gain_db']=&gt;integer()        //
+            ['title_peak']=&gt;integer()           //
+            ['title_peak_db']=&gt;boolean()        //
+            ['begin_loud']=&gt;boolean()           //
+            ['end_loud']=&gt;boolean()             //
+            ['encoder_version']=&gt;string()       //
+            ['frame_count']=&gt;integer()          //
+            ['intensity_stereo']=&gt;boolean()     //
+            ['last_frame_length']=&gt;integer()    //
+            ['max_level']=&gt;integer()            //
+            ['max_subband']=&gt;integer()          //
+            ['mid_side_stereo']=&gt;boolean()      //
+            ['profile']=&gt;string()               //
+            ['sample_rate']=&gt;integer()          //
+            ['samples']=&gt;integer()              //
+            ['size']=&gt;integer()                 //
+            ['stream_major_version']=&gt;integer() //
+            ['stream_minor_version']=&gt;integer() //
+            ['true_gapless']=&gt;boolean()         //
+            ['raw']=&gt;array() {                  //
+                ['album_gain']=&gt;integer()       //
+                ['album_peak']=&gt;integer()       //
+                ['encoder_version']=&gt;integer()  //
+                ['preamble']=&gt;string()          //
+                ['profile']=&gt;integer()          //
+                ['sample_rate']=&gt;integer()      //
+                ['title_gain']=&gt;integer()       //
+                ['title_peak']=&gt;integer()       //
+            }                                   //
+        }                                       //
+    }                                           //
+
+
+    ['mpeg']=&gt;array() {                                // MPEG (Motion Picture Experts Group) - MPEG video and/or MPEG audio (MP3/MP2/MP1)
+        ['audio']=&gt;array() {                           //
+            ['LAME']=&gt;array() {                        //
+                ['RGAD']=&gt;array() {                    //
+                    ['peak_amplitude']=&gt;double()       //
+                }                                      //
+                ['ath_type']=&gt;integer()                //
+                ['audio_bytes']=&gt;integer()             //
+                ['bitrate_min']=&gt;integer()             //
+                ['encoder_delay']=&gt;integer()           //
+                ['encoding_flags']=&gt;array() {          //
+                    ['nogap_next']=&gt;boolean()          //
+                    ['nogap_prev']=&gt;boolean()          //
+                    ['nspsytune']=&gt;boolean()           //
+                    ['nssafejoint']=&gt;boolean()         //
+                }                                      //
+                ['end_padding']=&gt;integer()             //
+                ['lame_tag_crc']=&gt;integer()            //
+                ['lowpass_frequency']=&gt;integer()       //
+                ['mp3_gain_db']=&gt;double()              //
+                ['mp3_gain_factor']=&gt;double()          //
+                ['mp3_gain_raw']=&gt;integer()            //
+                ['music_crc']=&gt;integer()               //
+                ['noise_shaping']=&gt;integer()           //
+                ['noise_shaping_raw']=&gt;integer()       //
+                ['not_optimal_quality']=&gt;boolean()     //
+                ['not_optimal_quality_raw']=&gt;integer() //
+                ['preset_used_id']=&gt;integer()          //
+                ['short_version']=&gt;string()            // ex: &quot;LAME 3.93&quot;
+                ['long_version']=&gt;string()             // (pre-v3.90 only) ex: &quot;LAME 3.88 (alpha)&quot;
+                ['source_sample_freq']=&gt;string()       //
+                ['source_sample_freq_raw']=&gt;integer()  //
+                ['stereo_mode']=&gt;string()              //
+                ['stereo_mode_raw']=&gt;integer()         //
+                ['surround_info']=&gt;string()            //
+                ['surround_info_id']=&gt;integer()        //
+                ['tag_revision']=&gt;integer()            //
+                ['vbr_method']=&gt;string()               //
+                ['vbr_method_raw']=&gt;integer()          //
+            }                                          //
+            ['VBR_bitrate']=&gt;double()                  //
+            ['VBR_bytes']=&gt;integer()                   //
+            ['VBR_frames']=&gt;integer()                  //
+            ['VBR_method']=&gt;string()                   //
+            ['VBR_scale']=&gt;integer()                   //
+            ['bitrate']=&gt;integer()                     //
+            ['bitrate_distribution']=&gt;array() {        //
+                ['free']=&gt;integer()                    //
+                ['8']=&gt;integer()                       //
+                ['16']=&gt;integer()                      //
+                ['24']=&gt;integer()                      //
+                ['32']=&gt;integer()                      //
+                ['40']=&gt;integer()                      //
+                ['48']=&gt;integer()                      //
+                ['56']=&gt;integer()                      //
+                ['64']=&gt;integer()                      //
+                ['80']=&gt;integer()                      //
+                ['96']=&gt;integer()                      //
+                ['112']=&gt;integer()                     //
+                ['128']=&gt;integer()                     //
+                ['144']=&gt;integer()                     //
+                ['160']=&gt;integer()                     //
+            }                                          //
+            ['bitrate_mode']=&gt;string()                 //
+            ['channelmode']=&gt;string()                  //
+            ['channels']=&gt;integer()                    //
+            ['copyright']=&gt;boolean()                   //
+            ['crc']=&gt;integer()                         //
+            ['emphasis']=&gt;string()                     //
+            ['frame_count']=&gt;integer()                 //
+            ['framelength']=&gt;integer()                 //
+            ['layer']=&gt;integer()                       //
+            ['modeextension']=&gt;string()                //
+            ['original']=&gt;boolean()                    //
+            ['padding']=&gt;boolean()                     //
+            ['private']=&gt;boolean()                     //
+            ['protection']=&gt;boolean()                  //
+            ['raw']=&gt;array() {                         //
+                ['bitrate']=&gt;integer()                 //
+                ['channelmode']=&gt;integer()             //
+                ['copyright']=&gt;integer()               //
+                ['emphasis']=&gt;integer()                //
+                ['layer']=&gt;integer()                   //
+                ['modeextension']=&gt;integer()           //
+                ['original']=&gt;integer()                //
+                ['padding']=&gt;integer()                 //
+                ['private']=&gt;integer()                 //
+                ['protection']=&gt;integer()              //
+                ['sample_rate']=&gt;integer()             //
+                ['synch']=&gt;integer()                   //
+                ['version']=&gt;integer()                 //
+            }                                          //
+            ['sample_rate']=&gt;integer()                 //
+            ['stereo_distribution']=&gt;array() {         //
+                ['dual channel']=&gt;integer()            //
+                ['joint stereo']=&gt;integer()            //
+                ['mono']=&gt;integer()                    //
+                ['stereo']=&gt;integer()                  //
+            }                                          //
+            ['toc']=&gt;array() {                         //
+                [&lt;x&gt;]=&gt;integer()                       //
+            }                                          //
+            ['version']=&gt;string()                      //
+            ['version_distribution']=&gt;array() {        //
+                [&lt;x&gt;]=&gt;integer()                       //
+                [&lt;x&gt;]=&gt;integer()                       //
+                ['2.5']=&gt;integer()                     //
+            }                                          //
+            ['xing_flags']=&gt;array() {                  //
+                ['bytes']=&gt;boolean()                   //
+                ['frames']=&gt;boolean()                  //
+                ['toc']=&gt;boolean()                     //
+                ['vbr_scale']=&gt;boolean()               //
+            }                                          //
+            ['xing_flags_raw']=&gt;string()               //
+        }                                              //
+        ['video']=&gt;array() {                           //
+            ['bitrate']=&gt;integer()                     //
+            ['bitrate_mode']=&gt;string()                 //
+            ['frame_rate']=&gt;double()                   //
+            ['framesize_horizontal']=&gt;integer()        //
+            ['framesize_vertical']=&gt;integer()          //
+            ['pixel_aspect_ratio']=&gt;double()           //
+            ['pixel_aspect_ratio_text']=&gt;string()      //
+            ['raw']=&gt;array() {                         //
+                ['bitrate']=&gt;integer()                 //
+                ['constrained_param_flag']=&gt;integer()  //
+                ['frame_rate']=&gt;integer()              //
+                ['framesize_horizontal']=&gt;integer()    //
+                ['framesize_vertical']=&gt;integer()      //
+                ['intra_quant_flag']=&gt;integer()        //
+                ['marker_bit']=&gt;integer()              //
+                ['pixel_aspect_ratio']=&gt;integer()      //
+                ['vbv_buffer_size']=&gt;integer()         //
+            }                                          //
+        }                                              //
+    }                                                  //
+
+
+    ['nsv']=&gt;array() {                     // NSV - Nullsoft Streaming Video
+        ['NSVf']=&gt;array() {                //
+            ['TOC_entries_1']=&gt;integer()   //
+            ['TOC_entries_2']=&gt;integer()   //
+            ['file_size']=&gt;integer()       //
+            ['header_length']=&gt;integer()   //
+            ['identifier']=&gt;string()       //
+            ['meta_size']=&gt;integer()       //
+            ['metadata']=&gt;string()         //
+            ['playtime_ms']=&gt;integer()     //
+        }                                  //
+        ['NSVs']=&gt;array() {                //
+            ['audio_codec']=&gt;string()      //
+            ['frame_rate']=&gt;double()       //
+            ['framerate_index']=&gt;integer() //
+            ['identifier']=&gt;string()       //
+            ['offset']=&gt;integer()          //
+            ['resolution_x']=&gt;integer()    //
+            ['resolution_y']=&gt;integer()    //
+            ['unknown1b']=&gt;integer()       //
+            ['unknown1c']=&gt;integer()       //
+            ['unknown1d']=&gt;integer()       //
+            ['unknown2a']=&gt;integer()       //
+            ['unknown2b']=&gt;integer()       //
+            ['unknown2c']=&gt;integer()       //
+            ['unknown2d']=&gt;integer()       //
+            ['unknown3a']=&gt;integer()       //
+            ['unknown3b']=&gt;integer()       //
+            ['unknown3c']=&gt;integer()       //
+            ['unknown3d']=&gt;integer()       //
+            ['video_codec']=&gt;string()      //
+        }                                  //
+        ['comments']=&gt;array() {            //
+            ['aspect']=&gt;string()           //
+            ['title']=&gt;string()            //
+        }                                  //
+    }                                      //
+
+
+    ['ofr']=&gt;array() {                                   // OFR (OptimFROG) - lossless audio compression
+        ['COMP']=&gt;array() {                              //
+            [&lt;x&gt;]=&gt;array() {                             //
+                ['channel_configuration']=&gt;string()      //
+                ['crc_32']=&gt;boolean()                    //
+                ['encoder']=&gt;string()                    //
+                ['offset']=&gt;integer()                    //
+                ['raw']=&gt;array() {                       //
+                    ['algorithm_id']=&gt;integer()          //
+                    ['channel_configuration']=&gt;integer() //
+                    ['encoder_id']=&gt;integer()            //
+                    ['sample_type']=&gt;integer()           //
+                }                                        //
+                ['sample_count']=&gt;integer()              //
+                ['sample_type']=&gt;string()                //
+                ['size']=&gt;integer()                      //
+            }                                            //
+        }                                                //
+        ['HEAD']=&gt;array() {                              //
+            ['offset']=&gt;integer()                        //
+            ['size']=&gt;integer()                          //
+        }                                                //
+        ['OFR ']=&gt;array() {                              //
+            ['channel_config']=&gt;integer()                //
+            ['channels']=&gt;integer()                      //
+            ['compression']=&gt;string()                    //
+            ['encoder']=&gt;string()                        //
+            ['offset']=&gt;integer()                        //
+            ['raw']=&gt;array() {                           //
+                ['compression']=&gt;integer()               //
+                ['encoder_id']=&gt;integer()                //
+                ['sample_type']=&gt;integer()               //
+            }                                            //
+            ['sample_rate']=&gt;integer()                   //
+            ['sample_type']=&gt;string()                    //
+            ['size']=&gt;integer()                          //
+            ['total_samples']=&gt;integer()                 //
+        }                                                //
+        ['TAIL']=&gt;array() {                              //
+            ['offset']=&gt;integer()                        //
+            ['size']=&gt;integer()                          //
+        }                                                //
+    }                                                    //
+
+
+    ['ogg']=&gt;array() {                           // OGG - container format for Ogg Vorbis, OggFLAC, Speex, etc
+        ['bitrate_average']=&gt;double()            //
+        ['bitrate_max']=&gt;integer()               //
+        ['bitrate_min']=&gt;integer()               //
+        ['bitrate_nominal']=&gt;integer()           //
+        ['bitstreamversion']=&gt;integer()          //
+        ['blocksize_large']=&gt;integer()           //
+        ['blocksize_small']=&gt;integer()           //
+        ['comments']=&gt;array() {                  // array of array of strings containing best data from any available metainformation tag (APE, ID3v2, ID3v1, Lyrics3, Vorbis, ASF, RIFF, Real, etc.)
+            [&lt;key name&gt;]=&gt;array()                // &lt;key name&gt; can be anything, usually 'artist', 'title', etc. Contains array of one or more values (eg: multiple artists are possible)
+        }                                        //
+        ['comments_raw']=&gt;array() {              //
+            [&lt;x&gt;]=&gt;array() {                     //
+                ['dataoffset']=&gt;integer()        //
+                ['key']=&gt;string()                //
+                ['size']=&gt;integer()              //
+                ['value']=&gt;string()              //
+            }                                    //
+        }                                        //
+        ['numberofchannels']=&gt;integer()          //
+        ['pageheader']=&gt;array() {                //
+            [&lt;x&gt;]=&gt;array() {                     //
+                ['flags']=&gt;array() {             //
+                    ['bos']=&gt;boolean()           //
+                    ['eos']=&gt;boolean()           //
+                    ['fresh']=&gt;boolean()         //
+                }                                //
+                ['flags_raw']=&gt;integer()         //
+                ['header_end_offset']=&gt;integer() //
+                ['packet_type']=&gt;integer()       //
+                ['page_checksum']=&gt;double()      //
+                ['page_end_offset']=&gt;integer()   //
+                ['page_length']=&gt;integer()       //
+                ['page_segments']=&gt;integer()     //
+                ['page_seqno']=&gt;integer()        //
+                ['page_start_offset']=&gt;integer() //
+                ['pcm_abs_position']=&gt;integer()  //
+                ['segment_table']=&gt;array() {     //
+                    [&lt;x&gt;]=&gt;integer()             //
+                }                                //
+                ['stream_serialno']=&gt;integer()   //
+                ['stream_structver']=&gt;integer()  //
+                ['stream_type']=&gt;string()        //
+            }                                    //
+            ['eos']=&gt;array() {                   //
+                ['flags']=&gt;array() {             //
+                    ['bos']=&gt;boolean()           //
+                    ['eos']=&gt;boolean()           //
+                    ['fresh']=&gt;boolean()         //
+                }                                //
+                ['flags_raw']=&gt;integer()         //
+                ['header_end_offset']=&gt;integer() //
+                ['page_checksum']=&gt;double()      //
+                ['page_end_offset']=&gt;integer()   //
+                ['page_length']=&gt;integer()       //
+                ['page_segments']=&gt;integer()     //
+                ['page_seqno']=&gt;integer()        //
+                ['page_start_offset']=&gt;integer() //
+                ['pcm_abs_position']=&gt;integer()  //
+                ['segment_table']=&gt;array() {     //
+                    [&lt;x&gt;]=&gt;integer()             //
+                }                                //
+                ['stream_serialno']=&gt;integer()   //
+                ['stream_structver']=&gt;integer()  //
+            }                                    //
+        }                                        //
+        ['samplerate']=&gt;integer()                //
+        ['samples']=&gt;integer()                   //
+        ['stop_bit']=&gt;integer()                  //
+        ['vendor']=&gt;string()                     //
+    }                                            //
+
+
+    ['png']=&gt;array() {                                // PNG (Portable Network Graphics) - still image
+        ['IDAT']=&gt;array() {                           //
+            [&lt;x&gt;]=&gt;array() {                          //
+                ['header']=&gt;array() {                 //
+                    ['crc']=&gt;integer()                //
+                    ['data_length']=&gt;integer()        //
+                    ['flags']=&gt;array() {              //
+                        ['ancilliary']=&gt;boolean()     //
+                        ['private']=&gt;boolean()        //
+                        ['reserved']=&gt;boolean()       //
+                        ['safe_to_copy']=&gt;boolean()   //
+                    }                                 //
+                    ['type_raw']=&gt;double()            //
+                    ['type_text']=&gt;string()           //
+                }                                     //
+            }                                         //
+        }                                             //
+        ['IEND']=&gt;array() {                           //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;double()                     //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+        }                                             //
+        ['IHDR']=&gt;array() {                           //
+            ['color_type']=&gt;array() {                 //
+                ['alpha']=&gt;boolean()                  //
+                ['palette']=&gt;boolean()                //
+                ['true_color']=&gt;boolean()             //
+            }                                         //
+            ['compression_method_text']=&gt;string()     //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;double()                     //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+            ['height']=&gt;integer()                     //
+            ['raw']=&gt;array() {                        //
+                ['bit_depth']=&gt;integer()              //
+                ['color_type']=&gt;integer()             //
+                ['compression_method']=&gt;integer()     //
+                ['filter_method']=&gt;integer()          //
+                ['interlace_method']=&gt;integer()       //
+            }                                         //
+            ['width']=&gt;integer()                      //
+        }                                             //
+        ['PLTE']=&gt;array() {                           //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;double()                     //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+            [&lt;x&gt;]=&gt;integer()                          //
+        }                                             //
+        ['comments']=&gt;array() {                       // array of array of strings containing best data from any available metainformation tag (APE, ID3v2, ID3v1, Lyrics3, Vorbis, ASF, RIFF, Real, etc.)
+            [&lt;key name&gt;]=&gt;array()                     // &lt;key name&gt; can be anything, usually 'artist', 'title', etc. Contains array of one or more values (eg: multiple artists are possible)
+        }                                             //
+        ['gAMA']=&gt;array() {                           //
+            ['gamma']=&gt;double()                       //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;integer()                    //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+        }                                             //
+        ['oFFs']=&gt;array() {                           //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;double()                     //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+            ['position_x']=&gt;integer()                 //
+            ['position_y']=&gt;integer()                 //
+            ['unit']=&gt;string()                        //
+            ['unit_specifier']=&gt;integer()             //
+        }                                             //
+        ['pHYs']=&gt;array() {                           //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;integer()                    //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+            ['pixels_per_unit_x']=&gt;integer()          //
+            ['pixels_per_unit_y']=&gt;integer()          //
+            ['unit']=&gt;string()                        //
+            ['unit_specifier']=&gt;integer()             //
+        }                                             //
+        ['pcLb']=&gt;array() {                           //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;double()                     //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+        }                                             //
+        ['tEXt']=&gt;array() {                           //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;integer()                    //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+            ['keyword']=&gt;string()                     //
+            ['text']=&gt;string()                        //
+        }                                             //
+        ['tIME']=&gt;array() {                           //
+            ['day']=&gt;integer()                        //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;integer()                    //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+            ['hour']=&gt;integer()                       //
+            ['minute']=&gt;integer()                     //
+            ['month']=&gt;integer()                      //
+            ['second']=&gt;integer()                     //
+            ['unix']=&gt;integer()                       //
+            ['year']=&gt;integer()                       //
+        }                                             //
+        ['tRNS']=&gt;array() {                           //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;double()                     //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+            ['transparent_color_blue']=&gt;integer()     //
+            ['transparent_color_green']=&gt;integer()    //
+            ['transparent_color_red']=&gt;integer()      //
+        }                                             //
+        ['zTXt']=&gt;array() {                           //
+            ['compressed_text']=&gt;string()             //
+            ['compression_method']=&gt;integer()         //
+            ['compression_method_text']=&gt;string()     //
+            ['header']=&gt;array() {                     //
+                ['crc']=&gt;double()                     //
+                ['data']=&gt;string()                    //
+                ['data_length']=&gt;integer()            //
+                ['flags']=&gt;array() {                  //
+                    ['ancilliary']=&gt;boolean()         //
+                    ['private']=&gt;boolean()            //
+                    ['reserved']=&gt;boolean()           //
+                    ['safe_to_copy']=&gt;boolean()       //
+                }                                     //
+                ['type_raw']=&gt;double()                //
+                ['type_text']=&gt;string()               //
+            }                                         //
+            ['keyword']=&gt;string()                     //
+            ['text']=&gt;string()                        //
+        }                                             //
+    }                                                 //
+
+
+    ['quicktime']=&gt;array() {               // Quicktime - video/audio
+        ['']=&gt;array() {                    //
+            ['name']=&gt;boolean()            //
+            ['offset']=&gt;integer()          //
+            ['size']=&gt;integer()            //
+        }                                  //
+        ['audio']=&gt;array() {               //
+            ['bit_depth']=&gt;integer()       //
+            ['channels']=&gt;integer()        //
+            ['codec']=&gt;string()            //
+            ['sample_rate']=&gt;double()      //
+        }                                  //
+        ['free']=&gt;array() {                //
+            ['name']=&gt;string()             //
+            ['offset']=&gt;integer()          //
+            ['size']=&gt;integer()            //
+        }                                  //
+        ['mdat']=&gt;array() {                //
+            ['name']=&gt;string()             //
+            ['offset']=&gt;integer()          //
+            ['size']=&gt;integer()            //
+        }                                  //
+        ['moov']=&gt;array() {                //
+            ['hierarchy']=&gt;string()        //
+            ['name']=&gt;string()             //
+            ['offset']=&gt;integer()          //
+            ['size']=&gt;integer()            //
+            ['subatoms']=&gt;array()          // This is an undocumentably-complex recursive array, typically containing a huge amount of seemingly disorganized data. Avoid this like the plague.
+        }                                  //
+        ['time_scale']=&gt;integer()          //
+        ['display_scale']=&gt;integer()       // 1 = normal; 0.5 = half; 2 = double
+        ['video']=&gt;array() {               //
+            ['codec']=&gt;string()            //
+            ['color_depth']=&gt;integer()     //
+            ['color_depth_name']=&gt;string() //
+            ['resolution_x']=&gt;double()     //
+            ['resolution_y']=&gt;double()     //
+        }                                  //
+        ['wide']=&gt;array() {                //
+            ['name']=&gt;string()             //
+            ['offset']=&gt;integer()          //
+            ['size']=&gt;integer()            //
+        }                                  //
+    }                                      //
+
+
+    ['real']=&gt;array() {                           // Real (RealAudio / RealVideo) - audio/video
+        ['chunks']=&gt;array() {                     //
+            [&lt;x&gt;]=&gt;array() {                      //
+                ['file_version']=&gt;integer()       //
+                ['headers_count']=&gt;integer()      //
+                ['length']=&gt;integer()             //
+                ['name']=&gt;string()                //
+                ['object_version']=&gt;integer()     //
+                ['offset']=&gt;integer()             //
+            }                                     //
+            [&lt;x&gt;]=&gt;array() {                      //
+                ['avg_bit_rate']=&gt;integer()       //
+                ['avg_packet_size']=&gt;integer()    //
+                ['data_offset']=&gt;integer()        //
+                ['duration']=&gt;integer()           //
+                ['flags']=&gt;array() {              //
+                    ['live_broadcast']=&gt;boolean() //
+                    ['perfect_play']=&gt;boolean()   //
+                    ['save_enabled']=&gt;boolean()   //
+                }                                 //
+                ['flags_raw']=&gt;integer()          //
+                ['index_offset']=&gt;integer()       //
+                ['length']=&gt;integer()             //
+                ['max_bit_rate']=&gt;integer()       //
+                ['max_packet_size']=&gt;integer()    //
+                ['name']=&gt;string()                //
+                ['num_packets']=&gt;integer()        //
+                ['num_streams']=&gt;integer()        //
+                ['object_version']=&gt;integer()     //
+                ['offset']=&gt;integer()             //
+                ['preroll']=&gt;integer()            //
+            }                                     //
+        }                                         //
+        ['comments']=&gt;array() {                   //
+            ['artist']=&gt;string()                  //
+            ['comment']=&gt;string()                 //
+            ['title']=&gt;string()                   //
+        }                                         //
+    }                                             //
+
+
+    ['riff']=&gt;array() {                                     // RIFF (Resource Interchange File Format) - audio/video container format (AVI, WAV, CDDA, etc)
+        ['AIFC']=&gt;array() {                                 //
+            ['COMM']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['FVER']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['INST']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['MARK']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['SSND']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+        }                                                   //
+        ['AIFF']=&gt;array() {                                 //
+            ['(c) ']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['COMM']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['SSND']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+        }                                                   //
+        ['AVI ']=&gt;array() {                                 //
+            ['JUNK']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['hdrl']=&gt;array() {                             //
+                ['avih']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['odml']=&gt;array() {                         //
+                    ['dmlh']=&gt;array() {                     //
+                        [&lt;x&gt;]=&gt;array() {                    //
+                            ['data']=&gt;string()              //
+                            ['offset']=&gt;integer()           //
+                            ['size']=&gt;integer()             //
+                        }                                   //
+                    }                                       //
+                }                                           //
+                ['strl']=&gt;array() {                         //
+                    ['JUNK']=&gt;array() {                     //
+                        [&lt;x&gt;]=&gt;array() {                    //
+                            ['offset']=&gt;integer()           //
+                            ['size']=&gt;integer()             //
+                        }                                   //
+                    }                                       //
+                    ['strf']=&gt;array() {                     //
+                        [&lt;x&gt;]=&gt;array() {                    //
+                            ['data']=&gt;string()              //
+                            ['offset']=&gt;integer()           //
+                            ['size']=&gt;integer()             //
+                        }                                   //
+                    }                                       //
+                    ['strh']=&gt;array() {                     //
+                        [&lt;x&gt;]=&gt;array() {                    //
+                            ['data']=&gt;string()              //
+                            ['offset']=&gt;integer()           //
+                            ['size']=&gt;integer()             //
+                        }                                   //
+                    }                                       //
+                    ['strn']=&gt;array() {                     //
+                        [&lt;x&gt;]=&gt;array() {                    //
+                            ['data']=&gt;string()              //
+                            ['offset']=&gt;integer()           //
+                            ['size']=&gt;integer()             //
+                        }                                   //
+                    }                                       //
+                }                                           //
+            }                                               //
+            ['idx1']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['movi']=&gt;array() {                             //
+                ['offset']=&gt;integer()                       //
+                ['size']=&gt;integer()                         //
+            }                                               //
+        }                                                   //
+        ['CDDA']=&gt;array() {                                 //
+            ['fmt ']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['disc_id']=&gt;integer()                  //
+                    ['offset']=&gt;integer()                   //
+                    ['playtime_frames']=&gt;integer()          //
+                    ['playtime_seconds']=&gt;double()          //
+                    ['size']=&gt;integer()                     //
+                    ['start_offset_frame']=&gt;integer()       //
+                    ['start_offset_seconds']=&gt;double()      //
+                    ['track_num']=&gt;integer()                //
+                    ['unknown1']=&gt;integer()                 //
+                    ['unknown6']=&gt;integer()                 //
+                    ['unknown7']=&gt;integer()                 //
+                }                                           //
+            }                                               //
+        }                                                   //
+        ['WAVE']=&gt;array() {                                 //
+            ['DISP']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['INFO']=&gt;array() {                             //
+                ['IART']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['ICMT']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['ICOP']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['IENG']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['IGNR']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['IKEY']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['IMED']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['INAM']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['ISBJ']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['ISFT']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['ISRC']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['ISRF']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+                ['ITCH']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['data']=&gt;string()                  //
+                        ['offset']=&gt;integer()               //
+                        ['size']=&gt;integer()                 //
+                    }                                       //
+                }                                           //
+            }                                               //
+            ['MEXT']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['anciliary_data_length']=&gt;integer()    //
+                    ['data']=&gt;string()                      //
+                    ['flags']=&gt;array() {                    //
+                        ['anciliary_data_free']=&gt;boolean()  //
+                        ['anciliary_data_left']=&gt;boolean()  //
+                        ['anciliary_data_right']=&gt;boolean() //
+                        ['homogenous']=&gt;boolean()           //
+                    }                                       //
+                    ['offset']=&gt;integer()                   //
+                    ['raw']=&gt;array() {                      //
+                        ['anciliary_data_def']=&gt;integer()   //
+                        ['sound_information']=&gt;integer()    //
+                    }                                       //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['bext']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['author']=&gt;string()                    //
+                    ['bwf_version']=&gt;integer()              //
+                    ['coding_history']=&gt;array() {           //
+                        [&lt;x&gt;]=&gt;string()                     //
+                    }                                       //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['origin_date']=&gt;string()               //
+                    ['origin_date_unix']=&gt;integer()         //
+                    ['origin_time']=&gt;string()               //
+                    ['reference']=&gt;string()                 //
+                    ['reserved']=&gt;integer()                 //
+                    ['size']=&gt;integer()                     //
+                    ['time_reference']=&gt;integer()           //
+                    ['title']=&gt;string()                     //
+                }                                           //
+            }                                               //
+            ['cart']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['artist']=&gt;string()                    //
+                    ['category']=&gt;string()                  //
+                    ['classification']=&gt;string()            //
+                    ['client_id']=&gt;string()                 //
+                    ['cut_id']=&gt;string()                    //
+                    ['data']=&gt;string()                      //
+                    ['end_date']=&gt;string()                  //
+                    ['end_time']=&gt;string()                  //
+                    ['offset']=&gt;integer()                   //
+                    ['out_cue']=&gt;string()                   //
+                    ['post_time']=&gt;array() {                //
+                        [&lt;x&gt;]=&gt;array() {                    //
+                            ['timer_value']=&gt;integer()      //
+                            ['usage_fourcc']=&gt;string()      //
+                        }                                   //
+                    }                                       //
+                    ['producer_app_id']=&gt;string()           //
+                    ['producer_app_version']=&gt;string()      //
+                    ['size']=&gt;integer()                     //
+                    ['start_date']=&gt;string()                //
+                    ['start_time']=&gt;string()                //
+                    ['tag_text']=&gt;array() {                 //
+                        [&lt;x&gt;]=&gt;string()                     //
+                    }                                       //
+                    ['title']=&gt;string()                     //
+                    ['url']=&gt;string()                       //
+                    ['user_defined_text']=&gt;string()         //
+                    ['version']=&gt;string()                   //
+                    ['zero_db_reference']=&gt;integer()        //
+                }                                           //
+            }                                               //
+            ['data']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['fact']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['fmt ']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+            ['rgad']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['data']=&gt;string()                      //
+                    ['offset']=&gt;integer()                   //
+                    ['size']=&gt;integer()                     //
+                }                                           //
+            }                                               //
+        }                                                   //
+        ['audio']=&gt;array() {                                //
+            [&lt;x&gt;]=&gt;array() {                                //
+                ['bitrate']=&gt;integer()                      //
+                ['bits_per_sample']=&gt;integer()              //
+                ['channels']=&gt;integer()                     //
+                ['codec']=&gt;string()                         //
+                ['sample_rate']=&gt;integer()                  //
+            }                                               //
+            ['bits_per_sample']=&gt;integer()                  //
+            ['channels']=&gt;integer()                         //
+            ['codec_fourcc']=&gt;string()                      //
+            ['codec_name']=&gt;string()                        //
+            ['sample_rate']=&gt;integer()                      //
+            ['total_samples']=&gt;integer()                    //
+        }                                                   //
+        ['comments']=&gt;array() {                             // array of array of strings containing best data from any available metainformation tag (APE, ID3v2, ID3v1, Lyrics3, Vorbis, ASF, RIFF, Real, etc.)
+            [&lt;key name&gt;]=&gt;array()                           // &lt;key name&gt; can be anything, usually 'artist', 'title', etc. Contains array of one or more values (eg: multiple artists are possible)
+        }                                                   //
+        ['header_size']=&gt;integer()                          //
+        ['raw']=&gt;array() {                                  //
+            ['avih']=&gt;array() {                             //
+                ['dwFlags']=&gt;integer()                      //
+                ['dwHeight']=&gt;integer()                     //
+                ['dwInitialFrames']=&gt;integer()              //
+                ['dwLength']=&gt;integer()                     //
+                ['dwMaxBytesPerSec']=&gt;integer()             //
+                ['dwMicroSecPerFrame']=&gt;integer()           //
+                ['dwPaddingGranularity']=&gt;integer()         //
+                ['dwRate']=&gt;integer()                       //
+                ['dwScale']=&gt;integer()                      //
+                ['dwStart']=&gt;integer()                      //
+                ['dwStreams']=&gt;integer()                    //
+                ['dwSuggestedBufferSize']=&gt;integer()        //
+                ['dwTotalFrames']=&gt;integer()                //
+                ['dwWidth']=&gt;integer()                      //
+                ['flags']=&gt;array() {                        //
+                    ['capturedfile']=&gt;boolean()             //
+                    ['copyrighted']=&gt;boolean()              //
+                    ['hasindex']=&gt;boolean()                 //
+                    ['interleaved']=&gt;boolean()              //
+                    ['mustuseindex']=&gt;boolean()             //
+                    ['trustcktype']=&gt;boolean()              //
+                }                                           //
+            }                                               //
+            ['fact']=&gt;array() {                             //
+                ['NumberOfSamples']=&gt;integer()              //
+            }                                               //
+            ['fmt ']=&gt;array() {                             //
+                ['nAvgBytesPerSec']=&gt;integer()              //
+                ['wBitsPerSample']=&gt;integer()               //
+                ['nBlockAlign']=&gt;integer()                  //
+                ['nChannels']=&gt;integer()                    //
+                ['nSamplesPerSec']=&gt;integer()               //
+                ['wFormatTag']=&gt;integer()                   //
+            }                                               //
+            ['rgad']=&gt;array() {                             //
+                ['audiophile']=&gt;array() {                   //
+                    ['adjustment']=&gt;integer()               //
+                    ['name']=&gt;integer()                     //
+                    ['originator']=&gt;integer()               //
+                    ['signbit']=&gt;integer()                  //
+                }                                           //
+                ['fPeakAmplitude']=&gt;double()                //
+                ['nAudiophileRgAdjust']=&gt;integer()          //
+                ['nRadioRgAdjust']=&gt;integer()               //
+                ['radio']=&gt;array() {                        //
+                    ['adjustment']=&gt;integer()               //
+                    ['name']=&gt;integer()                     //
+                    ['originator']=&gt;integer()               //
+                    ['signbit']=&gt;integer()                  //
+                }                                           //
+            }                                               //
+            ['strf']=&gt;array() {                             //
+                ['auds']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['nAvgBytesPerSec']=&gt;integer()      //
+                        ['wBitsPerSample']=&gt;integer()       //
+                        ['nBlockAlign']=&gt;integer()          //
+                        ['nChannels']=&gt;integer()            //
+                        ['nSamplesPerSec']=&gt;integer()       //
+                        ['wFormatTag']=&gt;integer()           //
+                    }                                       //
+                }                                           //
+                ['vids']=&gt;array() {                         //
+                    [&lt;x&gt;]=&gt;array() {                        //
+                        ['biBitCount']=&gt;integer()           //
+                        ['biClrImportant']=&gt;integer()       //
+                        ['biClrUsed']=&gt;integer()            //
+                        ['biHeight']=&gt;integer()             //
+                        ['biPlanes']=&gt;integer()             //
+                        ['biSize']=&gt;integer()               //
+                        ['biSizeImage']=&gt;integer()          //
+                        ['biWidth']=&gt;integer()              //
+                        ['biXPelsPerMeter']=&gt;integer()      //
+                        ['biYPelsPerMeter']=&gt;integer()      //
+                        ['fourcc']=&gt;string()                //
+                    }                                       //
+                }                                           //
+            }                                               //
+            ['strh']=&gt;array() {                             //
+                [&lt;x&gt;]=&gt;array() {                            //
+                    ['dwFlags']=&gt;integer()                  //
+                    ['dwInitialFrames']=&gt;integer()          //
+                    ['dwLength']=&gt;integer()                 //
+                    ['dwQuality']=&gt;integer()                //
+                    ['dwRate']=&gt;integer()                   //
+                    ['dwSampleSize']=&gt;integer()             //
+                    ['dwScale']=&gt;integer()                  //
+                    ['dwStart']=&gt;integer()                  //
+                    ['dwSuggestedBufferSize']=&gt;integer()    //
+                    ['fccHandler']=&gt;string()                //
+                    ['fccType']=&gt;string()                   //
+                    ['rcFrame']=&gt;integer()                  //
+                    ['wLanguage']=&gt;integer()                //
+                    ['wPriority']=&gt;integer()                //
+                }                                           //
+            }                                               //
+        }                                                   //
+        ['rgad']=&gt;array() {                                 //
+            ['audiophile']=&gt;array() {                       //
+                ['adjustment']=&gt;double()                    //
+                ['name']=&gt;string()                          //
+                ['originator']=&gt;string()                    //
+            }                                               //
+            ['peakamplitude']=&gt;double()                     //
+            ['radio']=&gt;array() {                            //
+                ['adjustment']=&gt;double()                    //
+                ['name']=&gt;string()                          //
+                ['originator']=&gt;string()                    //
+            }                                               //
+        }                                                   //
+        ['video']=&gt;array() {                                //
+            [&lt;x&gt;]=&gt;array() {                                //
+                ['codec']=&gt;string()                         //
+                ['frame_height']=&gt;integer()                 //
+                ['frame_rate']=&gt;double()                    //
+                ['frame_width']=&gt;integer()                  //
+            }                                               //
+        }                                                   //
+        ['litewave']=&gt;array() {                             // <A HREF="http://www.clearjump.com">http://www.clearjump.com</A>
+            ['raw']=&gt;array() {                              //
+                ['compression_method']=&gt;integer()           // 1=lossy; 2=lossless
+                ['compression_flags']=&gt;integer()            //
+                ['m_dwScale']=&gt;integer()                    // scalefactor for lossy compression - related to m_wQuality as: $m_wQuality = round((2000 - $m_dwScale) / 20)
+                ['m_dwBlockSize']=&gt;integer()                // number of samples in encoded blocks
+                ['m_wQuality']=&gt;integer()                   // quality factor (0=most compressed lossy; 99=best quality lossy; 100=lossless)
+                ['m_wMarkDistance']=&gt;integer()              // distance between marks in bytes
+                ['m_wReserved']=&gt;integer()                  //
+                ['m_dwOrgSize']=&gt;integer()                  // original file size in bytes
+                ['m_bFactExists']=&gt;integer()                // indicates if 'fact' chunk exists in the original file
+                ['m_dwRiffChunkSize']=&gt;integer()            // riff chunk size in the original file
+            }                                               //
+            ['quality_factor']=&gt;integer()                   // alias of ['raw']['m_wQuality']
+        }                                                   //
+    }                                                       //
+
+
+    ['shn']=&gt;array() {             // Shorten - lossless audio compression
+        ['seektable']=&gt;array() {   //
+            ['length']=&gt;integer()  //
+            ['offset']=&gt;integer()  //
+            ['present']=&gt;boolean() //
+        }                          //
+        ['version']=&gt;integer()     //
+    }                              //
+
+
+    ['swf']=&gt;array() {                  // SWF - ShockWave Flash (www.openswf.org)
+        ['header']=&gt;array() {           //
+            ['frame_count']=&gt;integer()  //
+            ['frame_height']=&gt;integer() //
+            ['frame_width']=&gt;integer()  //
+            ['length']=&gt;integer()       //
+            ['signature']=&gt;string()     //
+            ['version']=&gt;integer()      //
+        }                               //
+        ['bgcolor']=&gt;string()           //
+        ['tags']=&gt;array()               //
+    }                                   //
+
+
+    ['voc']=&gt;array() {                            // VOC - SoundBlaster VOC audio format
+        ['blocks']=&gt;array() {                     //
+            [&lt;x&gt;]=&gt;array() {                      //
+                ['bits_per_sample']=&gt;integer()    //
+                ['block_offset']=&gt;integer()       //
+                ['block_size']=&gt;integer()         //
+                ['block_type_id']=&gt;integer()      //
+                ['channels']=&gt;integer()           //
+                ['compression_name']=&gt;string()    //
+                ['compression_type']=&gt;integer()   //
+                ['pack_method']=&gt;integer()        //
+                ['sample_rate']=&gt;integer()        //
+                ['sample_rate_id']=&gt;integer()     //
+                ['stereo']=&gt;boolean()             //
+                ['time_constant']=&gt;integer()      //
+                ['wFormat']=&gt;integer()            //
+            }                                     //
+        }                                         //
+        ['compressed_bits_per_sample']=&gt;integer() //
+        ['header']=&gt;array() {                     //
+            ['datablock_offset']=&gt;integer()       //
+            ['major_version']=&gt;integer()          //
+            ['minor_version']=&gt;integer()          //
+        }                                         //
+    }                                             //
+
+
+    ['vqf']=&gt;array() {                    // VQF - transform-domain weighted interleave Vector Quantization Format (lossy audio)
+        ['COMM']=&gt;array() {               //
+            ['bitrate']=&gt;integer()        //
+            ['channel_mode']=&gt;integer()   //
+            ['sample_rate']=&gt;integer()    //
+            ['security_level']=&gt;integer() //
+        }                                 //
+        ['DSIZ']=&gt;integer()               //
+        ['comments']=&gt;array() {           // array of array of strings containing best data from any available metainformation tag (APE, ID3v2, ID3v1, Lyrics3, Vorbis, ASF, RIFF, Real, etc.)
+            [&lt;key name&gt;]=&gt;array()         // &lt;key name&gt; can be anything, usually 'artist', 'title', etc. Contains array of one or more values (eg: multiple artists are possible)
+        }                                 //
+        ['raw']=&gt;array() {                //
+            ['header_tag']=&gt;string()      //
+            ['size']=&gt;integer()           //
+            ['version']=&gt;string()         //
+        }                                 //
+    }                                     //
+
+
+    ['wavpack']=&gt;array() {           // WavPack - lossless audio compression
+        ['bits']=&gt;integer()          //
+        ['crc1']=&gt;double()           //
+        ['crc2']=&gt;integer()          //
+        ['extension']=&gt;string()      //
+        ['extra_bc']=&gt;string()       //
+        ['extras']=&gt;string()         //
+        ['flags_raw']=&gt;integer()     //
+        ['offset']=&gt;integer()        //
+        ['shift']=&gt;integer()         //
+        ['size']=&gt;integer()          //
+        ['total_samples']=&gt;integer() //
+        ['version']=&gt;integer()       //
+    }                                //
+
+
+    ['zip']=&gt;array() {                                           // ZIP - lossless data compression
+        ['central_directory']=&gt;array() {                         //
+            [&lt;x&gt;]=&gt;array() {                                     //
+                ['compressed_size']=&gt;integer()                   //
+                ['compression_method']=&gt;string()                 //
+                ['create_version']=&gt;string()                     //
+                ['entry_offset']=&gt;integer()                      //
+                ['extract_version']=&gt;string()                    //
+                ['filename']=&gt;string()                           //
+                ['flags']=&gt;array() {                             //
+                    ['compression_speed']=&gt;string()              //
+                    ['data_descriptor_used']=&gt;boolean()          //
+                    ['encrypted']=&gt;boolean()                     //
+                }                                                //
+                ['host_os']=&gt;string()                            //
+                ['last_modified_timestamp']=&gt;integer()           //
+                ['offset']=&gt;integer()                            //
+                ['raw']=&gt;array() {                               //
+                    ['compressed_size']=&gt;integer()               //
+                    ['compression_method']=&gt;integer()            //
+                    ['crc_32']=&gt;double()                         //
+                    ['create_version']=&gt;integer()                //
+                    ['disk_number_start']=&gt;integer()             //
+                    ['external_file_attrib']=&gt;double()           //
+                    ['extra_field_length']=&gt;integer()            //
+                    ['extract_version']=&gt;integer()               //
+                    ['file_comment_length']=&gt;integer()           //
+                    ['filename_length']=&gt;integer()               //
+                    ['general_flags']=&gt;integer()                 //
+                    ['internal_file_attrib']=&gt;integer()          //
+                    ['last_mod_file_date']=&gt;integer()            //
+                    ['last_mod_file_time']=&gt;integer()            //
+                    ['local_header_offset']=&gt;integer()           //
+                    ['signature']=&gt;integer()                     //
+                    ['uncompressed_size']=&gt;integer()             //
+                }                                                //
+                ['uncompressed_size']=&gt;integer()                 //
+            }                                                    //
+        }                                                        //
+        ['comments']=&gt;array() {                                  //
+            ['comment']=&gt;string()                                //
+        }                                                        //
+        ['compressed_size']=&gt;integer()                           //
+        ['compression_method']=&gt;string()                         //
+        ['compression_speed']=&gt;string()                          //
+        ['end_central_directory']=&gt;array() {                     //
+            ['comment']=&gt;string()                                //
+            ['comment_length']=&gt;integer()                        //
+            ['directory_entries_this_disk']=&gt;integer()           //
+            ['directory_entries_total']=&gt;integer()               //
+            ['directory_offset']=&gt;integer()                      //
+            ['directory_size']=&gt;integer()                        //
+            ['disk_number_current']=&gt;integer()                   //
+            ['disk_number_start_directory']=&gt;integer()           //
+            ['offset']=&gt;integer()                                //
+            ['signature']=&gt;integer()                             //
+        }                                                        //
+        ['entries']=&gt;array() {                                   //
+            [&lt;x&gt;]=&gt;array() {                                     //
+                ['compressed_size']=&gt;integer()                   //
+                ['compression_method']=&gt;string()                 //
+                ['extract_version']=&gt;string()                    //
+                ['filename']=&gt;string()                           //
+                ['flags']=&gt;array() {                             //
+                    ['compression_speed']=&gt;string()              //
+                    ['data_descriptor_used']=&gt;boolean()          //
+                    ['encrypted']=&gt;boolean()                     //
+                }                                                //
+                ['host_os']=&gt;string()                            //
+                ['last_modified_timestamp']=&gt;integer()           //
+                ['offset']=&gt;integer()                            //
+                ['raw']=&gt;array() {                               //
+                    ['compressed_size']=&gt;integer()               //
+                    ['compression_method']=&gt;integer()            //
+                    ['crc_32']=&gt;integer()                        //
+                    ['extra_field_length']=&gt;integer()            //
+                    ['extract_version']=&gt;integer()               //
+                    ['filename_length']=&gt;integer()               //
+                    ['general_flags']=&gt;integer()                 //
+                    ['last_mod_file_date']=&gt;integer()            //
+                    ['last_mod_file_time']=&gt;integer()            //
+                    ['signature']=&gt;integer()                     //
+                    ['uncompressed_size']=&gt;integer()             //
+                }                                                //
+                ['uncompressed_size']=&gt;integer()                 //
+            }                                                    //
+        }                                                        //
+        ['entries_count']=&gt;integer()                             //
+        ['files']=&gt;array() {                                     // multidimensional tree-structure array listing of all files and directories in image
+            [&lt;directory name&gt;]=&gt;array()                          // entries of type array are directories (key is directory name), may contain files and/or other subdirectories
+            [&lt;file name&gt;]=&gt;integer()                             // entries of type integer are files (key is file name, value is file size in bytes)
+        }                                                        //
+        ['uncompressed_size']=&gt;integer()                         //
+    }                                                            //
+}                                                                //

Modified: node/branches/video_test/code/share/db.sql
===================================================================
--- node/branches/video_test/code/share/db.sql	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/share/db.sql	2006-05-04 14:34:58 UTC (rev 558)
@@ -104,6 +104,7 @@
 &quot;neighbours&quot; varchar(255), -- 
 &quot;last_sync_in&quot; timestamptz,							-- time of last sync 
 &quot;last_sync_out&quot; timestamptz							-- time of last sync 
+&quot;video_capable&quot; bool DEFAULT 'f'::bool --ADDED BY Martin Schmidt
 );
 
 CREATE TABLE &quot;sotf_neighbours&quot; (

Modified: node/branches/video_test/code/share/update.sql
===================================================================
--- node/branches/video_test/code/share/update.sql	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/share/update.sql	2006-05-04 14:34:58 UTC (rev 558)
@@ -204,3 +204,23 @@
 -- 2005-07-04
 -- removed default of now + 56 days for expiry_date in sotf_programmes
 ALTER TABLE sotf_programmes ALTER COLUMN expiry_date DROP DEFAULT;
+
+
+-- 2006-02-18
+-- ADDED BY Martin Schmidt
+-- NEW METADATA COLUMNS FOR VIDEO
+
+BEGIN;
+ALTER TABLE sotf_media_files ADD COLUMN &quot;codec&quot; varchar(40) NULL;
+ALTER TABLE sotf_media_files ADD COLUMN &quot;frame_rate&quot; int NULL;
+ALTER TABLE sotf_media_files ADD COLUMN &quot;lossless&quot; boolean NULL;
+ALTER TABLE sotf_media_files ADD COLUMN &quot;resolution_x&quot; int NULL;
+ALTER TABLE sotf_media_files ADD COLUMN &quot;resolution_y&quot; int NULL;
+ALTER TABLE sotf_media_files ADD COLUMN &quot;pixel_aspect_ratio&quot; float NULL;
+COMMIT;
+
+
+-- ADDED BY Martin Schmidt
+-- NEW FIELD &quot;video_capable&quot; in sotf_nodes
+ALTER TABLE sotf_nodes ADD COLUMN &quot;video_capable&quot; bool;
+ALTER TABLE sotf_nodes ALTER video_capable SET DEFAULT 'f'::bool;

Modified: node/branches/video_test/code/templates/advsearch.htm
===================================================================
--- node/branches/video_test/code/templates/advsearch.htm	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/templates/advsearch.htm	2006-05-04 14:34:58 UTC (rev 558)
@@ -3,24 +3,41 @@
 &lt;div align=&quot;center&quot;&gt;
 &lt;TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=&quot;80%&quot; BGCOLOR=&quot;{#searchBgColor2#}&quot;&gt;
 	&lt;TR BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;
-		&lt;TD COLSPAN=6&gt;{#your_query_is#}{if count($SQLquery) &gt; 0}:{else} {#empty#}{/if}
+		&lt;TD COLSPAN=6&gt;{* commented out by Martin Schmidt{#your_query_is#}{if count($SQLquery) &gt; 0}:{else} {#empty#}{/if}*}&nbsp;&nbsp;
 		&lt;INPUT type=&quot;hidden&quot; name=&quot;SQLquerySerial&quot; value=&quot;{$SQLquerySerial}&quot;&gt;
 		&lt;INPUT type=&quot;image&quot; SRC=&quot;{$IMAGE_URL}/transp.gif&quot; name=&quot;image&quot;&gt;
 		&lt;/TD&gt;
 	&lt;/TR&gt;
-
+	&lt;TR&gt;
+	&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;TD colspan='4' ALIGN=center&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+	
+	&lt;TR&gt;
+	&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;TD colspan='4' ALIGN=center&gt;&lt;B&gt;{#combine#}&lt;/B&gt;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;/TR&gt;
+	
+	&lt;TR&gt;
+	&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;TD colspan='4' ALIGN=center&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;/TR&gt;
+	
+	&lt;tr height=&quot;3&quot;&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&lt;/TD&gt;&lt;td height=&quot;3&quot; colspan=&quot;4&quot; bgcolor=&quot;#FFFFFF&quot;&gt;&lt;/td&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&lt;/TD&gt;&lt;/tr&gt;
 	{section name=i loop=$SQLquery}
-	{if $smarty.section.i.index != 0}
-		{if $SQLquery[i][0] == &quot;AND&quot;}&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD COLSPAN=4 BGCOLOR=&quot;#FFFFFF&quot; align=center&gt;{#AND#}&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;{/if}
-	{/if}
+	{* commented out by Martin Schmidt{if $smarty.section.i.index != 0}
+		 {if $SQLquery[i][0] == &quot;AND&quot;}&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD COLSPAN=4 BGCOLOR=&quot;#FFFFFF&quot; align=center&gt;{#AND#}&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;{/if}
+	{/if}*}
 	&lt;TR&gt;
 		&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+		
+		&lt;TD&gt;&nbsp;&nbsp;&lt;INPUT type=&quot;checkbox&quot; name=&quot;SQLchosen[]&quot; value=&quot;{$SQLquery[i][1]}&quot; {if $SQLquery[i][0] == &quot;AND&quot;} checked {/if}/&gt;&lt;/TD&gt; {*ADDED BY Martin Schmidt*}
+		 
 		&lt;TD&gt;&lt;B&gt;{$SQLqueryfields[i]}&lt;/B&gt;&lt;/TD&gt;
 		{if $SQLquery[i][4] == &quot;string&quot;}
 			&lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQstring selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
 			&lt;TD&gt;&lt;INPUT type=&quot;text&quot; name=&quot;SQLstring[]&quot; value=&quot;{$SQLquery[i][3]}&quot; size=&quot;30&quot;&gt;&lt;/TD&gt;
 		{elseif $SQLquery[i][4] == &quot;date&quot;}
-			&lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot; with=13&gt;{html_options options=$EQdate selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+			&lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot; width=13&gt;{html_options options=$EQdate selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
 			&lt;TD&gt;{html_select_date prefix=&quot;SQLstring[]&quot; time=$SQLquery[i][3] start_year=&quot;2000&quot; end_year=&quot;+0&quot; display_days=true month_format=&quot;%m&quot; field_order=&quot;YMD&quot; }&lt;/TD&gt;
 		{elseif $SQLquery[i][4] == &quot;lang&quot;}
 			&lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQlang selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
@@ -43,18 +60,62 @@
 		{elseif $SQLquery[i][4] == &quot;topic&quot;}
 			&lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQtopic selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
 			&lt;TD&gt;&lt;INPUT type=&quot;text&quot; name=&quot;SQLstring[]&quot; value=&quot;{$SQLquery[i][3]}&quot; size=&quot;30&quot;&gt;&lt;/TD&gt;
+			
+		{* added by Martin Schmidt *}
+		{elseif $SQLquery[i][4] == &quot;contenttype&quot;}
+			&lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQcontenttype selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+			&lt;TD&gt;&lt;SELECT name=&quot;SQLstring[]&quot;&gt;{html_options options=$ContentTypes selected=$SQLquery[i][3]}&lt;/SELECT&gt;&lt;/TD&gt;
+		{**************************************}
+		
 		{/if}
-		&lt;TD ALIGN=&quot;right&quot; valign=&quot;middle&quot;&gt;&lt;INPUT type=&quot;image&quot; SRC=&quot;{$IMAGE_URL}/plusz.gif&quot;  ALT=&quot;{#add#}&quot; name=&quot;ADD{$smarty.section.i.index}&quot; value=&quot;{#delete#}&quot;&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;INPUT type=&quot;image&quot; ALT=&quot;{#delete#}&quot; SRC=&quot;{$IMAGE_URL}/minusz.gif&quot; name=&quot;DEL{$smarty.section.i.index}&quot; value=&quot;{#delete#}&quot;&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;/TD&gt;
+		
+		{* commented out by Martin Schmidt &lt;TD ALIGN=&quot;right&quot; valign=&quot;middle&quot;&gt;&lt;INPUT type=&quot;image&quot; SRC=&quot;{$IMAGE_URL}/plusz.gif&quot;  ALT=&quot;{#add#}&quot; name=&quot;ADD{$smarty.section.i.index}&quot; value=&quot;{#delete#}&quot;&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;INPUT type=&quot;image&quot; ALT=&quot;{#delete#}&quot; SRC=&quot;{$IMAGE_URL}/minusz.gif&quot; name=&quot;DEL{$smarty.section.i.index}&quot; value=&quot;{#delete#}&quot;&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;/TD&gt;*}
+		
 		&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
 	&lt;/TR&gt;
+	&lt;tr height=&quot;3&quot;&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&lt;/TD&gt;&lt;td height=&quot;3&quot; colspan=&quot;4&quot; bgcolor=&quot;#FFFFFF&quot;&gt;&lt;/td&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&lt;/TD&gt;&lt;/tr&gt;
 	{/section}
+	
+	&lt;TR&gt;
+	&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;TD colspan='4' ALIGN=center&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+		&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD colspan='4' ALIGN=center&gt;&lt;B&gt;{#sort1#}&lt;/B&gt;&lt;BR&gt;&nbsp;&lt;BR&gt;&lt;SELECT name=&quot;sort1&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt;{html_options options=$OrderFields selected=$sort1}&lt;/SELECT&gt;&lt;INPUT type=&quot;checkbox&quot; name=&quot;dir1&quot;{if $dir1} checked{/if}{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if} /&gt; {#desc#}&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+		&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD colspan='4' ALIGN=center&gt;{#sort2#}&lt;BR&gt;&lt;SELECT name=&quot;sort2&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt;{html_options options=$OrderFields selected=$sort2}&lt;/SELECT&gt;&lt;INPUT type=&quot;checkbox&quot; name=&quot;dir2&quot;{if $dir2} checked{/if}{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if} /&gt; {#desc#}&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+		&lt;TR&gt;
+	&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;TD colspan='4' ALIGN=center&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+		&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD colspan='4' ALIGN=center&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;run&quot; value=&quot;{#run#}&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt;&lt;BR&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;new&quot; value=&quot;{#new_search#}&quot;&gt;&lt;/TD&gt;&lt;!--&lt;TD ALIGN=center&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;upload_query&quot; value=&quot;{#upload_query#}&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if} onclick=&quot;javascript:Q=prompt('{#portal_http#}: ','{$old_upload}');if (Q) {literal}{this.form.upload_http.value = Q; this.form.submit();} else return false;{/literal}&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;upload_http&quot;&gt;&lt;/TD&gt;--&gt;
+		&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+		&lt;/TR&gt;
+		&lt;TR&gt;
+	&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;TD colspan='4' ALIGN=center&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+	
+	{if $notLoggedIn == false}
+	&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;TD colspan='4' ALIGN=center BGCOLOR=&quot;{#searchBgColor3#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+	
+	&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;TD ALIGN=&quot;center&quot; COLSPAN=4 BGCOLOR=&quot;{#searchBgColor3#}&quot;&gt;&lt;B&gt;{#manage_queries#}&lt;/B&gt;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+	
+		&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD COLSPAN=4 ALIGN=center BGCOLOR=&quot;{#searchBgColor3#}&quot;&gt;&lt;SELECT name=&quot;loadfrom&quot; {if $saved == &quot;&quot;}disabled=&quot;true&quot;{/if}&gt;{html_options options=$saved}&lt;/SELECT&gt; &lt;INPUT type=&quot;submit&quot; name=&quot;load&quot; value=&quot;{#load#}&quot; {if $saved == &quot;&quot;}disabled=&quot;true&quot;{/if}&gt;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+		&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD COLSPAN=4 ALIGN=center BGCOLOR=&quot;{#searchBgColor3#}&quot;&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;default&quot; value=&quot;{#default#}&quot; {if $saved == &quot;&quot;}disabled=&quot;true&quot;{/if}&gt;&nbsp;&nbsp;&lt;INPUT type=&quot;submit&quot; name=&quot;deleteq&quot; value=&quot;{#deleteq#}&quot; {if $saved == &quot;&quot;}disabled=&quot;true&quot;{/if}&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+		&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD COLSPAN=4 ALIGN=center BGCOLOR=&quot;{#searchBgColor3#}&quot;&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;save&quot; value=&quot;{#save#}&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt; &lt;INPUT type=&quot;text&quot; name=&quot;saveas&quot; value=&quot;&quot; MAXLENGTH=15{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+		
+		&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+	&lt;TD ALIGN=&quot;center&quot; COLSPAN=4 BGCOLOR=&quot;{#searchBgColor3#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+
+
+	{/if}
+	
+	
 	&lt;TR BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&lt;TD COLSPAN=6&gt;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
 &lt;/TABLE&gt;
 &lt;/div&gt;
 &lt;BR /&gt;
-&lt;TABLE BORDER=0 WIDTH=&quot;100%&quot;&gt;
+{*&lt;TABLE BORDER=0 WIDTH=&quot;100%&quot;&gt;
 &lt;TR&gt;
-	&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;
+	 commented out by Martin Schmidt&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;
 	&lt;TABLE BORDER=0 CELLPADDING=3&gt;
 		&lt;TR&gt;&lt;TD COLSPAN=2&gt;&lt;B&gt;{#box1#}&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
 		&lt;TR&gt;&lt;TD&gt;&lt;INPUT type=&quot;radio&quot; name=&quot;SQLlink&quot; value=&quot;AND&quot; checked&gt; {#AND#}&lt;/TD&gt;
@@ -63,7 +124,6 @@
 		&lt;TR&gt;&lt;TD ALIGN=&quot;center&quot;&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;add&quot; value=&quot;{#add#}&quot;&gt;&lt;/TD&gt;&lt;TD ALIGN=&quot;center&quot;&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;new&quot; value=&quot;{#new_search#}&quot;&gt;&lt;/TD&gt;&lt;/TR&gt;
 	&lt;/TABLE&gt;
 	&lt;/TD&gt;
-
 	&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;{#searchBgColor2#}&quot;&gt;
 	&lt;TABLE CELLPADDING=3&gt;
 		&lt;TR&gt;&lt;TD colspan='2'&gt;&lt;B&gt;{#box2#}&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
@@ -72,7 +132,6 @@
 		&lt;TR&gt;&lt;TD ALIGN=center&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;run&quot; value=&quot;{#run#}&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt;&lt;/TD&gt;&lt;!--&lt;TD ALIGN=center&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;upload_query&quot; value=&quot;{#upload_query#}&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if} onclick=&quot;javascript:Q=prompt('{#portal_http#}: ','{$old_upload}');if (Q) {literal}{this.form.upload_http.value = Q; this.form.submit();} else return false;{/literal}&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;upload_http&quot;&gt;&lt;/TD&gt;--&gt;&lt;/TR&gt;
 	&lt;/TABLE&gt;
 	&lt;/TD&gt;
-
 	{if $notLoggedIn == false}
 	&lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;{#searchBgColor3#}&quot;&gt;
 	&lt;TABLE BORDER=0 CELLPADDING=3&gt;
@@ -83,8 +142,9 @@
 	&lt;/TABLE&gt;
 	&lt;/TD&gt;
 	{/if}
+	
 &lt;/TR&gt;
-&lt;/TABLE&gt;
+&lt;/TABLE&gt;*}
 &lt;/FORM&gt;
 {if $upload_query}
 	&lt;script language=&quot;javascript&quot;&gt;

Added: node/branches/video_test/code/templates/advsearch.orig.htm
===================================================================
--- node/branches/video_test/code/templates/advsearch.orig.htm	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/templates/advsearch.orig.htm	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,104 @@
+&lt;h3&gt;{#Advanced_search#}&lt;/h3&gt;
+&lt;FORM method=&quot;post&quot; action=&quot;advsearch.php&quot;&gt;
+&lt;div align=&quot;center&quot;&gt;
+&lt;TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=&quot;80%&quot; BGCOLOR=&quot;{#searchBgColor2#}&quot;&gt;
+        &lt;TR BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;
+                &lt;TD COLSPAN=6&gt;{#your_query_is#}{if count($SQLquery) &gt; 0}:{else} {#empty#}{/if}
+                &lt;INPUT type=&quot;hidden&quot; name=&quot;SQLquerySerial&quot; value=&quot;{$SQLquerySerial}&quot;&gt;
+                &lt;INPUT type=&quot;image&quot; SRC=&quot;{$IMAGE_URL}/transp.gif&quot; name=&quot;image&quot;&gt;
+                &lt;/TD&gt;
+        &lt;/TR&gt;
+
+        {section name=i loop=$SQLquery}
+        {if $smarty.section.i.index != 0}
+                {if $SQLquery[i][0] == &quot;AND&quot;}&lt;TR&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;TD COLSPAN=4 BGCOLOR=&quot;#FFFFFF&quot; align=center&gt;{#AND#}&lt;/TD&gt;&lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;&lt;/TR&gt;{/if}
+        {/if}
+        &lt;TR&gt;
+                &lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+                &lt;TD&gt;&lt;B&gt;{$SQLqueryfields[i]}&lt;/B&gt;&lt;/TD&gt;
+                {if $SQLquery[i][4] == &quot;string&quot;}
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQstring selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+                        &lt;TD&gt;&lt;INPUT type=&quot;text&quot; name=&quot;SQLstring[]&quot; value=&quot;{$SQLquery[i][3]}&quot; size=&quot;30&quot;&gt;&lt;/TD&gt;
+                {elseif $SQLquery[i][4] == &quot;date&quot;}
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot; with=13&gt;{html_options options=$EQdate selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+                        &lt;TD&gt;{html_select_date prefix=&quot;SQLstring[]&quot; time=$SQLquery[i][3] start_year=&quot;2000&quot; end_year=&quot;+0&quot; display_days=true month_format=&quot;%m&quot; field_order=&quot;YMD&quot; }&lt;/TD&gt;
+                {elseif $SQLquery[i][4] == &quot;lang&quot;}
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQlang selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLstring[]&quot;&gt;{html_options options=$Languages selected=$SQLquery[i][3]}&lt;/SELECT&gt;&lt;/TD&gt;
+                {elseif $SQLquery[i][4] == &quot;station&quot;}
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQlang selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLstring[]&quot;&gt;{html_options options=$Stations selected=$SQLquery[i][3]}&lt;/SELECT&gt;&lt;/TD&gt;
+                {elseif $SQLquery[i][4] == &quot;genre&quot;}
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQlang selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLstring[]&quot;&gt;{html_options options=$Genres selected=$SQLquery[i][3]}&lt;/SELECT&gt;&lt;/TD&gt;
+                {elseif $SQLquery[i][4] == &quot;length&quot;}
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQlength selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+                        &lt;TD&gt;&lt;INPUT type=&quot;text&quot; name=&quot;SQLstring[]&quot; value=&quot;{$SQLquery[i][3]}&quot; size=&quot;5&quot; MAXLENGTH=5&gt; {#seconds#}&lt;/TD&gt;
+                {elseif $SQLquery[i][4] == &quot;rating&quot;}
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQnumber selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLstring[]&quot;&gt;{html_options options=$Ratings selected=$SQLquery[i][3]}&lt;/SELECT&gt;&lt;/TD&gt;
+                {elseif $SQLquery[i][4] == &quot;number&quot;}
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQnumber selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+                        &lt;TD&gt;&lt;INPUT type=&quot;text&quot; name=&quot;SQLstring[]&quot; value=&quot;{$SQLquery[i][3]}&quot; size=&quot;5&quot; MAXLENGTH=5&gt;&lt;/TD&gt;
+                {elseif $SQLquery[i][4] == &quot;topic&quot;}
+                        &lt;TD&gt;&lt;SELECT name=&quot;SQLeq[]&quot;&gt;{html_options options=$EQtopic selected=$SQLquery[i][2]}&lt;/SELECT&gt;&lt;/TD&gt;
+                        &lt;TD&gt;&lt;INPUT type=&quot;text&quot; name=&quot;SQLstring[]&quot; value=&quot;{$SQLquery[i][3]}&quot; size=&quot;30&quot;&gt;&lt;/TD&gt;
+                {/if}
+                &lt;TD ALIGN=&quot;right&quot; valign=&quot;middle&quot;&gt;&lt;INPUT type=&quot;image&quot; SRC=&quot;{$IMAGE_URL}/plusz.gif&quot;  ALT=&quot;{#add#}&quot; name=&quot;ADD{$smarty.section.i.index}&quot; value=&quot;{#delete#}&quot;&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;INPUT type=&quot;image&quot; ALT=&quot;{#delete#}&quot; SRC=&quot;{$IMAGE_URL}/minusz.gif&quot; name=&quot;DEL{$smarty.section.i.index}&quot; value=&quot;{#delete#}&quot;&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;IMG SRC=&quot;{$IMAGE_URL}/transp.gif&quot; /&gt;&lt;/TD&gt;
+                &lt;TD BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&nbsp;&nbsp;&lt;/TD&gt;
+        &lt;/TR&gt;
+        {/section}
+        &lt;TR BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;&lt;TD COLSPAN=6&gt;&nbsp;&lt;/TD&gt;&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;/div&gt;
+&lt;BR /&gt;
+&lt;TABLE BORDER=0 WIDTH=&quot;100%&quot;&gt;
+&lt;TR&gt;
+        &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;{#searchBgColor1#}&quot;&gt;
+        &lt;TABLE BORDER=0 CELLPADDING=3&gt;
+                &lt;TR&gt;&lt;TD COLSPAN=2&gt;&lt;B&gt;{#box1#}&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
+                &lt;TR&gt;&lt;TD&gt;&lt;INPUT type=&quot;radio&quot; name=&quot;SQLlink&quot; value=&quot;AND&quot; checked&gt; {#AND#}&lt;/TD&gt;
+                &lt;TD  ROWSPAN=2&gt;&lt;SELECT name=&quot;SQLfield&quot; size=4&gt;{html_options options=$SQLfields selected=$SQLfieldDefault}&lt;/SELECT&gt;&lt;/TD&gt;&lt;/TR&gt;
+                &lt;TR&gt;&lt;TD&gt;&lt;INPUT type=&quot;radio&quot; name=&quot;SQLlink&quot; value=&quot;OR&quot;&gt; {#OR#}&lt;/TD&gt;&lt;/TR&gt;
+                &lt;TR&gt;&lt;TD ALIGN=&quot;center&quot;&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;add&quot; value=&quot;{#add#}&quot;&gt;&lt;/TD&gt;&lt;TD ALIGN=&quot;center&quot;&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;new&quot; value=&quot;{#new_search#}&quot;&gt;&lt;/TD&gt;&lt;/TR&gt;
+        &lt;/TABLE&gt;
+        &lt;/TD&gt;
+
+        &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;{#searchBgColor2#}&quot;&gt;
+        &lt;TABLE CELLPADDING=3&gt;
+                &lt;TR&gt;&lt;TD colspan='2'&gt;&lt;B&gt;{#box2#}&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
+                &lt;TR&gt;&lt;TD colspan='2' ALIGN=center&gt;{#sort1#} &lt;SELECT name=&quot;sort1&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt;{html_options options=$OrderFields selected=$sort1}&lt;/SELECT&gt;&lt;INPUT type=&quot;checkbox&quot; name=&quot;dir1&quot;{if $dir1} checked{/if}{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if} /&gt; {#desc#}&lt;/TD&gt;&lt;/TR&gt;
+                &lt;TR&gt;&lt;TD colspan='2' ALIGN=center&gt;{#sort2#} &lt;SELECT name=&quot;sort2&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt;{html_options options=$OrderFields selected=$sort2}&lt;/SELECT&gt;&lt;INPUT type=&quot;checkbox&quot; name=&quot;dir2&quot;{if $dir2} checked{/if}{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if} /&gt; {#desc#}&lt;/TD&gt;&lt;/TR&gt;
+                &lt;TR&gt;&lt;TD ALIGN=center&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;run&quot; value=&quot;{#run#}&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt;&lt;/TD&gt;&lt;!--&lt;TD ALIGN=center&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;upload_query&quot; value=&quot;{#upload_query#}&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if} onclick=&quot;javascript:Q=prompt('{#portal_http#}: ','{$old_upload}');if (Q) {literal}{this.form.upload_http.value = Q; this.form.submit();} else return false;{/literal}&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;upload_http&quot;&gt;&lt;/TD&gt;--&gt;&lt;/TR&gt;
+        &lt;/TABLE&gt;
+        &lt;/TD&gt;
+
+        {if $notLoggedIn == false}
+        &lt;TD ALIGN=&quot;center&quot; BGCOLOR=&quot;{#searchBgColor3#}&quot;&gt;
+        &lt;TABLE BORDER=0 CELLPADDING=3&gt;
+                &lt;TR&gt;&lt;TD COLSPAN=2&gt;&lt;B&gt;{#box3#}&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;
+                &lt;TR&gt;&lt;TD COLSPAN=2 ALIGN=center&gt;&lt;SELECT name=&quot;loadfrom&quot; {if $saved == &quot;&quot;}disabled=&quot;true&quot;{/if}&gt;{html_options options=$saved}&lt;/SELECT&gt; &lt;INPUT type=&quot;submit&quot; name=&quot;load&quot; value=&quot;{#load#}&quot; {if $saved == &quot;&quot;}disabled=&quot;true&quot;{/if}&gt;&lt;/TD&gt;&lt;/TR&gt;
+                &lt;TR&gt;&lt;TD ALIGN=center&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;default&quot; value=&quot;{#default#}&quot; {if $saved == &quot;&quot;}disabled=&quot;true&quot;{/if}&gt;&lt;/TD&gt;&lt;TD ALIGN=center&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;deleteq&quot; value=&quot;{#deleteq#}&quot; {if $saved == &quot;&quot;}disabled=&quot;true&quot;{/if}&gt;&lt;/TD&gt;&lt;/TR&gt;
+                &lt;TR&gt;&lt;TD COLSPAN=2 ALIGN=center&gt;&lt;INPUT type=&quot;submit&quot; name=&quot;save&quot; value=&quot;{#save#}&quot;{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt; &lt;INPUT type=&quot;text&quot; name=&quot;saveas&quot; value=&quot;&quot; MAXLENGTH=15{if $SQLquery == &quot;&quot;} disabled=&quot;true&quot;{/if}&gt;&lt;/TD&gt;&lt;/TR&gt;
+        &lt;/TABLE&gt;
+        &lt;/TD&gt;
+        {/if}
+&lt;/TR&gt;
+&lt;/TABLE&gt;
+&lt;/FORM&gt;
+{if $upload_query}
+        &lt;script language=&quot;javascript&quot;&gt;
+        &lt;!--
+        function my_onload()
+        {literal}{{/literal}
+                {if $upload_query != &quot;<A HREF="http://">http://</A>&quot;}
+                //alert(&quot;OK&quot;);
+		window.open('{$upload_query}?type=query&amp;data={$SQLquerySerial}','','scrollbars=yes,width=640,height=340,left=320,top=200');
+                {else}
+                alert(&quot;{#URL_missing#}&quot;);
+                {/if}
+        {literal}}{/literal}
+        document.body.onload = my_onload;
+        // --&gt;
+	&lt;/script&gt; 
+{/if}
\ No newline at end of file

Modified: node/branches/video_test/code/templates/advsearchresults.htm
===================================================================
--- node/branches/video_test/code/templates/advsearchresults.htm	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/templates/advsearchresults.htm	2006-05-04 14:34:58 UTC (rev 558)
@@ -9,6 +9,32 @@
               &lt;td&gt;
                 &lt;p&gt;
                 &lt;b&gt;{#your_query_is#}:&lt;/b&gt;
+				
+				{* ADDED BY Martin Schmidt *}
+				{section name=i loop=$SQLquery}
+				{if $HumanReadable[i][0] != &quot;IGNORE&quot;}
+				  {if $smarty.section.i.index != 0 &amp;&amp; $smarty.section.i.index!=$FirstNonIgnore}
+                     {$HumanReadable[i][0]}
+                  {/if}
+                  {if $SQLquery[i.index_next][0] == &quot;OR&quot;}
+                     {if $SQLquery[i][0] == &quot;AND&quot;}
+                       (
+                     {elseif $smarty.section.i.index == 0}
+                       (
+                     {/if}
+                  {/if}
+                  {$HumanReadable[i][1]} {$HumanReadable[i][2]} &lt;i&gt;{$HumanReadable[i][3]}&lt;/i&gt;
+                  {if $SQLquery[i][0] == &quot;OR&quot;}
+                    {if $SQLquery[i.index_next][0] != &quot;OR&quot;}
+                      )
+                    {/if}
+                  {/if}
+				{/if}
+                {/section}			
+				{***************************}
+				
+				
+				{*COMMENTED OUT BY Martin Schmidt
                   {section name=i loop=$SQLquery}
                   {if $smarty.section.i.index != 0}
                      {$HumanReadable[i][0]}
@@ -27,6 +53,7 @@
                     {/if}
                   {/if}
                   {/section}
+				  *}
                   &lt;br /&gt;
                 &lt;a href=&quot;advsearchresults.php?back=true&amp;SQLquerySerial={$SQLquerySerial}&quot;&gt;{#back#}&lt;/a&gt;
                 &lt;/p&gt;
@@ -35,8 +62,10 @@
               &lt;TD ALIGN=&quot;right&quot; width=&quot;10%&quot;&gt;
               &lt;!-- &lt;INPUT class=&quot;action&quot; type=&quot;submit&quot; name=&quot;back&quot; value=&quot;{#back#}&quot;&gt; 
                   &lt;br /&gt; --&gt;
-		  &lt;a href=&quot;{$ROOT_URL}/podcast.php?uiLang={$LANG}&amp;query={$SQLquerySerial}&quot;&gt;podcast&lt;/a&gt;&lt;br /&gt;
-              &lt;INPUT class=&quot;action&quot; type=&quot;button&quot; name=&quot;upload_query&quot; value=&quot;{#upload_query#}&quot; onclick=&quot;javascript:window.open('portal_upload.php?type=query&amp;data={$SQLquerySerial}','','scrollbars=yes,width=640,height=340,left=320,top=200');&quot;&gt;
+				  &lt;INPUT class=&quot;action&quot; type=&quot;button&quot; name=&quot;upload_query&quot; value=&quot;{#upload_query#}&quot; onclick=&quot;javascript:window.open('portal_upload.php?type=query&amp;data={$SQLquerySerial}','','scrollbars=yes,width=640,height=340,left=320,top=200');&quot;&gt;
+		  &lt;br&gt;&nbsp;&lt;br&gt;
+				&lt;a href=&quot;{$ROOT_URL}/podcast.php?uiLang={$LANG}&amp;query={$SQLquerySerial}&quot;&gt;&lt;img border='0' style=&quot;vertical-align:bottom&quot; src='{$IMAGE_URL}/rss.gif'/&gt;&lt;/a&gt; &lt;a href=&quot;{$ROOT_URL}/podcast.php?uiLang={$LANG}&amp;query={$SQLquerySerial}&quot;&gt;Pod-/Vodcast&lt;/a&gt; &lt;br /&gt;{* mod by Martin Schmidt *}
+              
               &lt;/TD&gt;
             &lt;/TR&gt;
           &lt;/TABLE&gt;

Modified: node/branches/video_test/code/templates/editFiles.htm
===================================================================
--- node/branches/video_test/code/templates/editFiles.htm	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/templates/editFiles.htm	2006-05-04 14:34:58 UTC (rev 558)
@@ -17,6 +17,7 @@
 &lt;/SCRIPT&gt;
 {/literal}
 
+
 &lt;form&gt;
 {if $NEW}
   &lt;table width=&quot;100%&quot;&gt;
@@ -41,7 +42,10 @@
 &lt;form&gt;
 &lt;table class=&quot;tab&quot;&gt;
   &lt;tr&gt; 
-    &lt;td nowrap class=&quot;tab&quot;&gt;{#Prg_files#}&lt;/td&gt;
+    &lt;td nowrap class=&quot;tab&quot;&gt;
+	{#Prg_files#} 
+
+	&lt;/td&gt;
   &lt;/tr&gt;
 &lt;/table&gt;
 &lt;table class=&quot;tabarea&quot; width=&quot;100%&quot;&gt;
@@ -55,7 +59,9 @@
           &lt;th&gt;{#filesize#}&lt;/th&gt;
           &lt;th&gt;{#last_modified#}&lt;/th&gt;
           &lt;th&gt;{#play_length#}&lt;/th&gt;
+		  {if !$VIDEO}
           &lt;th&gt;{#stream_access#}&lt;/th&gt;
+		  {/if}
           &lt;th&gt;{#download_access#}&lt;/th&gt;
           &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
@@ -65,6 +71,10 @@
             &lt;td&gt;
               {if !empty($item.filename) }
               &lt;a target=&quot;link&quot; href=&quot;getFile.php/{$item.filename}?audio=1&amp;id={$PRG_ID}&amp;filename={$item.filename}&quot;&gt;{$item.filename}&lt;/a&gt;
+			  {elseif !empty($item.errors) }
+			  	&lt;font color=&quot;red&quot;&gt;converting error&lt;/font&gt;
+			  {elseif $item.converting}
+			  &lt;font color=&quot;green&quot;&gt;converting {$item.percentage}&lt;/font&gt;
               { else }
               &lt;font color=&quot;red&quot;&gt;{#missing#}&lt;/font&gt;
               {/if}
@@ -83,22 +93,28 @@
               {$item.play_length} {#sec#}
               {/if}
             &lt;/td&gt;
+			{if !$VIDEO}
             &lt;td&gt;
                 {if !empty($item.filename) }
                 &lt;input type=&quot;checkbox&quot; onclick=&quot;javascript:setvalue('audiofilesa', '{$item.id}', this.checked);return true;&quot;{ if $item.stream_access eq 't' } CHECKED=&quot;1&quot; {/if} /&gt;
                 {/if}
             &lt;/td&gt;
+			{/if}
             &lt;td&gt;
                 {if !empty($item.filename) }
               &lt;input type=&quot;checkbox&quot; onclick=&quot;javascript:setvalue('audiofilesd', '{$item.id}', this.checked);return true;&quot;{ if $item.download_access eq 't' } CHECKED=&quot;1&quot; {/if} /&gt;
                 {/if}
             &lt;/td&gt;
             &lt;td nowrap&gt;
-              {if empty($item.filename) }
+			{if !$item.converting and empty($item.errors)}
+              {if empty($item.filename) and $PRG_DATA.type!='video'}
               &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#convert#}&quot; onClick=&quot;window.open('convert.php?id={$PRG_ID}&amp;index={$item.index}','convert_progress','menubar=no, status=no, toolbar=no, width=350, height=180')&quot; /&gt;
-              {else}
+              {elseif empty($item.filename) and $PRG_DATA.type=='video'}
+			  &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#convert#}&quot; onClick=&quot;javascript:document.location.href='editFiles.php?id={$PRG_ID}&amp;convertindex={$item.index}&amp;videoconversion=1'&quot; /&gt;
+			   {else}
                 &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#delete#}&quot; onClick=&quot;redir(this.form, 'editFiles.php?delfile={$item.id}&amp;id={$PRG_ID}')&quot; /&gt;
               {/if}
+			 {/if}
             &lt;/td&gt;
           &lt;/tr&gt;
           {/foreach}    
@@ -107,9 +123,18 @@
                  &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#add_content#}&quot; onClick=&quot;popup('addFiles.php?main=1&amp;prgid={$PRG_ID}','AddFiles',500,500,true)&quot; /&gt;
               &lt;/td&gt;
               &lt;td colspan=&quot;8&quot; align=&quot;right&quot;&gt;
-                {if $MAIN_AUDIO_COUNT gt 0 and $MISSING}
-                   &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b2&quot; value=&quot;{#convert_all#}&quot; onClick=&quot;window.open('convert.php?id={$PRG_ID}&amp;all=1','convert_progress','menubar=no, status=no, toolbar=no, width=350, height=400')&quot; /&gt;
-                {/if}
+			  {if !$CONVERTING}
+                {if $MAIN_AUDIO_COUNT gt 0 and $MISSING and $PRG_DATA.type!='video'}
+                   &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b2&quot; value=&quot;{#convert_all#}&quot; onClick=&quot;window.open('convert.php?id={$PRG_ID}&amp;all=1','convert_progress','menubar=no, status=no, toolbar=no, width=350, height=600')&quot; /&gt;
+                
+				{else if $MAIN_AUDIO_COUNT gt 0 and $MISSING and $PRG_DATA.type=='video'}
+					&lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b2&quot; value=&quot;{#convert_all#}&quot; onClick=&quot;javascript:document.location.href='editFiles.php?id={$PRG_ID}&amp;convertall=1&amp;videoconversion=1'&quot; /&gt;&lt;br&gt;
+				{/if}
+				
+			  {/if}
+			  {if $PRG_DATA.type=='video' AND !$STILL_FOUND}
+                   &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b2&quot; value=&quot;Create Stills&quot; onClick=&quot;javascript:document.location.href='editFiles.php?id={$PRG_ID}&amp;createstills=1'&quot; /&gt;
+			{/if}
               &lt;/td&gt;
           &lt;/tr&gt;  
     &lt;/table&gt;
@@ -285,4 +310,8 @@
   &lt;div align=&quot;right&quot;&gt;
     &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#goto_step2#}&quot; onClick=&quot;redir(this.form, 'editMeta.php?new=1&amp;id={$PRG_ID}')&quot; /&gt;
   &lt;/div&gt;
+{/if}
+
+{if $CONVERTING OR $CREATESTILLS}
+		&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;setTimeout(&quot;document.location.href='editFiles.php?id={$PRG_ID}'&quot;, 5000);&lt;/script&gt;
 {/if}
\ No newline at end of file

Modified: node/branches/video_test/code/templates/get.htm
===================================================================
--- node/branches/video_test/code/templates/get.htm	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/templates/get.htm	2006-05-04 14:34:58 UTC (rev 558)
@@ -7,6 +7,7 @@
 } 
 --&gt;
 &lt;/SCRIPT&gt;
+
 {/literal}
 {if not $ID}
   &lt;form action=&quot;{$ROOT_URL}/get.php&quot;&gt;
@@ -56,7 +57,7 @@
         {/if}
       &lt;/td&gt;
         &lt;td class=&quot;title2&quot; width=&quot;10%&quot; align=&quot;right&quot; valign=&quot;bottom&quot;&gt;
-          &lt;a href=&quot;{$ROOT_URL}/rss.php?id={$ID}&amp;uiLang={$LANG}&quot;&gt;RSS&lt;/a&gt;&lt;br /&gt;
+          &lt;a href=&quot;{$ROOT_URL}/rss.php?id={$ID}&amp;uiLang={$LANG}&quot;&gt;&lt;img border='0' style=&quot;vertical-align:bottom&quot; src='{$IMAGE_URL}/rss.gif'/&gt;&lt;/a&gt;&lt;br /&gt;
           {if hasPerm($ID,'change') }
           &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#edit_meta#}&quot; onClick=&quot;redir(this.form,'{$ROOT_URL}/editMeta.php?id={$ID}')&quot; /&gt;
           &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#edit_files#}&quot; onClick=&quot;redir(this.form,'{$ROOT_URL}/editFiles.php?id={$ID}')&quot; /&gt;
@@ -73,7 +74,59 @@
 
     &lt;/tr&gt;
   &lt;/table&gt;
+  
+  {*ADDED BY Martin Schmidt*}
+  
+  {if $VIDEO_PRG}
+  &lt;table class=&quot;tab&quot;&gt;
+    &lt;tr&gt; 
+      &lt;td nowrap class=&quot;tab&quot;&gt;Preview&lt;/td&gt;
+    &lt;/tr&gt;
+  &lt;/table&gt;
 
+  &lt;table class=&quot;tabarea&quot; width=&quot;100%&quot; &gt;
+    &lt;tr&gt; 
+	
+	{if $FLV_FOUND} 
+      &lt;td class=&quot;tabarea&quot;&gt; 
+	  {*
+  &lt;OBJECT class=&quot;videoplayer&quot; classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'
+        codebase='<A HREF="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0">http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0</A>'
+        width='216' height='186' style=&quot;padding:0; margin:0&quot;&gt;
+        &lt;param name='movie' value=&quot;{$ROOT_URL}/videoplayer.swf&quot;&gt;
+		&lt;param name='bgcolor' value=&quot;#EFF4FE&quot;&gt;
+        &lt;param name='quality' value=&quot;high&quot;&gt;
+       &lt;param name='loop' value=&quot;false&quot;&gt;
+        &lt;EMBED class=&quot;videoplayer&quot; style=&quot;padding:0; margin:0&quot; src=&quot;{$ROOT_URL}/videoplayer.swf&quot; quality='high' width='216' height='186' bgcolor=&quot;#EFF4FE&quot; loop=&quot;false&quot; type='application/x-shockwave-flash'
+        pluginspage='<A HREF="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash">http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash</A>'&gt;
+        &lt;/EMBED&gt;
+		  &lt;/OBJECT&gt; *}
+		
+	&lt;object type=&quot;application/x-shockwave-flash&quot; width=&quot;176&quot; height=&quot;144&quot; 
+    wmode=&quot;transparent&quot; data=&quot;flvplayer.swf?file={$FLV_PATH}&quot;&gt;
+  &lt;param name=&quot;movie&quot; value=&quot;flvplayer.swf?file={$FLV_PATH}&quot; /&gt;
+  &lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;
+  &lt;/object&gt;
+  
+  	
+
+  &lt;/td&gt;
+  
+{elseif !$FLV_FOUND and $VIDEO_PRG}
+&lt;td class=&quot;tabarea&quot;&gt; 
+  		Flash-Preview for this programme is not available.
+		&lt;/td&gt;
+  {/if}
+  
+  {if $STILLS}&lt;td  class=&quot;tabarea&quot;&gt;{foreach item=item from=$STILLS}
+  &lt;img style=&quot;padding:10px&quot; src='getFile.php/{$item.filename}?id={$PRG_DATA.id}&amp;filename={$item.filename}'&gt;
+  {/foreach}    &lt;/td&gt;
+  {/if}
+&lt;/tr&gt;&lt;/table&gt;
+&lt;p&gt;&lt;/p&gt;
+ {/if}
+ 
+	
   &lt;table class=&quot;tab&quot;&gt;
     &lt;tr&gt; 
       &lt;td nowrap class=&quot;tab&quot;&gt;{#Metadata#}&lt;/td&gt;
@@ -234,7 +287,12 @@
 &lt;tr&gt; 
   &lt;td class=&quot;tabarea&quot;&gt; 
    {if $AUDIO_FILES }
-        &lt;div class=&quot;subheader&quot;&gt;{#audio_file_list#}&lt;/div&gt;
+        &lt;div class=&quot;subheader&quot;&gt;
+		{if $VIDEO_PRG}
+			Video Files:
+		{else}
+			{#audio_file_list#}
+		{/if}&lt;/div&gt;
         &lt;a name=&quot;mfiles&quot;&gt;&lt;/a&gt;
     &lt;table&gt;
        {cycle name=&quot;audio&quot; values=&quot;list1,list2&quot; print=false advance=false}
@@ -244,23 +302,43 @@
             &lt;td width=&quot;5%&quot;&gt;&lt;/td&gt;
             &lt;td&gt;
               {if $item.main_content eq 't' }
+			  	{if $VIDEO_PRG}
+				 Programme video
+				 {else}
                  {#programme_audio#}
+				{/if}
               {elseif $item.caption} 
                  {$item.caption}
               {else}
                  {$item.filename}
               {/if}
             &lt;/td&gt;
-            &lt;td align=&quot;right&quot;&gt;
-              {$item.bitrate} kbps 
-            &lt;/td&gt;
+			{if $VIDEO_PRG}
+				&lt;td&gt;
+					&lt;strong&gt;{$item.format}&lt;/strong&gt;
+				&lt;/td&gt;
+				&lt;td align=&quot;right&quot;&gt;
+				  {$item.bitrate} kbps 
+				&lt;/td&gt;
+				
+				&lt;td align=&quot;right&quot;&gt;
+				  {$item.playtime_string}
+				&lt;/td&gt;
+				&lt;td align=&quot;right&quot;&gt;
+				  {$item.filesize} {#bytes#}
+				&lt;/td&gt;
+			{else}
+				&lt;td align=&quot;right&quot;&gt;
+				  {$item.bitrate} kbps 
+				&lt;/td&gt;
+				&lt;td&gt;
+				  {$item.format}
+				&lt;/td&gt;
+				&lt;td align=&quot;right&quot;&gt;
+				  {$item.playtime_string}
+				&lt;/td&gt;
+			{/if}
             &lt;td&gt;
-                {$item.format}
-            &lt;/td&gt;
-            &lt;td align=&quot;right&quot;&gt;
-              {$item.playtime_string}
-            &lt;/td&gt;
-            &lt;td&gt;
               { if $item.download_access eq 't'}
                 &lt;!-- &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#Download#}&quot; onClick=&quot;popup('{$ROOT_URL}/getFile.php/{$item.filename}?{if $item.main_content eq 't' }audio=1&amp;{/if}id={$ID}&amp;filename={$item.filename}','ViewPopup',500,500,true)&quot; /&gt; --&gt;
                 &lt;a href=&quot;{$ROOT_URL}/getFile.php/{$item.filename}?{if $item.main_content eq 't' }audio=1&amp;{/if}id={$ID}&amp;filename={$item.filename}&quot;&gt;&lt;img src=&quot;{$IMAGE_URL}/download.gif&quot; border=&quot;0&quot; alt=&quot;{#Download#}&quot;&gt;&lt;/a&gt;

Modified: node/branches/video_test/code/templates/index.htm
===================================================================
--- node/branches/video_test/code/templates/index.htm	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/templates/index.htm	2006-05-04 14:34:58 UTC (rev 558)
@@ -371,6 +371,8 @@
                   {html_options values=$searchLangs selected=&quot;any_language&quot; output=$langNames}
 
                 &lt;/select&gt;
+				&lt;br&gt;&lt;input type=&quot;checkbox&quot; checked name=&quot;audio&quot; value=&quot;1&quot;&gt; Audio
+				&lt;input type=&quot;checkbox&quot; checked name=&quot;video&quot; value=&quot;1&quot;&gt; Video
 
                 &lt;input type=&quot;submit&quot; name=&quot;search&quot; value=&quot;{#Search#}&quot;&gt;
 

Modified: node/branches/video_test/code/templates/search.htm
===================================================================
--- node/branches/video_test/code/templates/search.htm	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/templates/search.htm	2006-05-04 14:34:58 UTC (rev 558)
@@ -12,13 +12,17 @@
                     &lt;select name=&quot;language&quot; style=&quot;width: 100%&quot;&gt;
                         {html_options values=$searchLangs selected=$LANGUAGE output=$langNames}
                     &lt;/select&gt;
-                  &lt;/td&gt;
-                  &lt;td width=&quot;1&quot;&gt; 
-                    &lt;input type=&quot;submit&quot; name=&quot;search&quot; value=&quot;{#Search#}&quot;&gt;
-                  &lt;/td&gt;
+					
+                  &lt;/td&gt;				
+				  &lt;td width=&quot;1&quot;&gt; {*ADDED BY Martin Schmidt *}
+
+                  &lt;input type=&quot;checkbox&quot; {if $AUDIO}checked{/if} name=&quot;audio&quot; value=&quot;1&quot;&gt; Audio
+				&lt;input type=&quot;checkbox&quot; {if $VIDEO}checked{/if} name=&quot;video&quot; value=&quot;1&quot;&gt; Video
+                    &lt;input type=&quot;submit&quot; name=&quot;search&quot; value=&quot;{#Search#}&quot;&gt;  &lt;/td&gt;
                 &lt;/tr&gt;
+
                 &lt;tr&gt;
-                    &lt;td&gt;&lt;font size=2&gt;&lt;A href=&quot;advsearch.php&quot;&gt;{#advSearch#}&lt;/a&gt;&lt;/font&gt;
+                    &lt;td colspan=3 &gt;&lt;font size=2&gt;&lt;A href=&quot;advsearch.php&quot;&gt;{#advSearch#}&lt;/a&gt;&lt;/font&gt;&lt;/td&gt;
                     &lt;/tr&gt;
               &lt;/table&gt;
             &lt;/form&gt;

Modified: node/branches/video_test/code/templates/showSeries.htm
===================================================================
--- node/branches/video_test/code/templates/showSeries.htm	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/templates/showSeries.htm	2006-05-04 14:34:58 UTC (rev 558)
@@ -11,8 +11,8 @@
         &lt;/td&gt;
         &lt;td class=&quot;title2&quot; width=&quot;10%&quot; align=&quot;right&quot; valign=&quot;bottom&quot;&gt;
           {if $JINGLE}&lt;a href=&quot;{$ROOT_URL}/listen.php?id={$SERIES_DATA.id}&amp;jingle=1&quot;&gt;{#jingle#}&lt;/a&gt;, {/if}
-          &lt;a href=&quot;{$HOME_URL}/podcast.php?series={$SERIES_DATA.id}&quot;&gt;podcast&lt;/a&gt;&lt;br /&gt;
-          &lt;a href=&quot;{$ROOT_URL}/rss.php?series={$SERIES_DATA.id}&amp;uiLang={$LANG}&quot;&gt;RSS&lt;/a&gt;&lt;br /&gt;
+          &lt;a href=&quot;{$HOME_URL}/podcast.php?series={$SERIES_DATA.id}&quot;&gt;Pod-/Vodcast&lt;/a&gt; | 
+          &lt;a href=&quot;{$ROOT_URL}/rss.php?series={$SERIES_DATA.id}&amp;uiLang={$LANG}&quot;&gt;&lt;img border='0' style=&quot;vertical-align:bottom&quot; src='{$IMAGE_URL}/rss.gif'/&gt;&lt;/a&gt;&lt;br /&gt;
           {if hasPerm($SERIES_DATA,'change') }
           &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#edit_series#}&quot; onClick=&quot;popup('{$ROOT_URL}/editSeries.php?seriesid={$SERIES_DATA.id}','EditSeries',550,550,true)&quot;&gt;
             {/if}

Modified: node/branches/video_test/code/templates/showStation.htm
===================================================================
--- node/branches/video_test/code/templates/showStation.htm	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/code/templates/showStation.htm	2006-05-04 14:34:58 UTC (rev 558)
@@ -11,8 +11,8 @@
         &lt;/td&gt;
         &lt;td class=&quot;title2&quot; width=&quot;10%&quot; align=&quot;right&quot; valign=&quot;bottom&quot;&gt;
           {if $JINGLE}&lt;a href=&quot;{$ROOT_URL}/listen.php?id={$STATION_ID}&amp;jingle=1&quot;&gt;{#jingle#}&lt;/a&gt;, {/if}
-	  &lt;a href=&quot;{$HOME_URL}/podcast.php?station={$STATION_ID}&quot;&gt;podcast&lt;/a&gt;&lt;br /&gt;
-          &lt;a href=&quot;{$ROOT_URL}/rss.php?station={$STATION_ID}&amp;uiLang={$LANG}&quot;&gt;RSS&lt;/a&gt;&lt;br /&gt;
+	  &lt;a href=&quot;{$HOME_URL}/podcast.php?station={$STATION_ID}&quot;&gt;Pod-/Vodcast&lt;/a&gt; | 
+          &lt;a href=&quot;{$ROOT_URL}/rss.php?station={$STATION_ID}&amp;uiLang={$LANG}&quot;&gt;&lt;img border='0' style=&quot;vertical-align:bottom&quot; src='{$IMAGE_URL}/rss.gif'/&gt;&lt;/a&gt;&lt;br /&gt;
           {if hasPerm($STATION_DATA,'change','authorize') }
           &lt;input class=&quot;action&quot; type=&quot;button&quot; name=&quot;b1&quot; value=&quot;{#edit_station#}&quot; onClick=&quot;redir(this.form, '{$ROOT_URL}/editStation.php?stationid={$STATION_ID}')&quot;&gt;
             {/if}

Modified: node/branches/video_test/www/admin.php
===================================================================
--- node/branches/video_test/www/admin.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/admin.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -3,7 +3,7 @@
 /*  
  * $Id$
  * Created for the StreamOnTheFly project (IST-2001-32226)
- * Authors: Andr&#225;s Micsik, M&#225;t&#233; Pataki, Tam&#225;s D&#233;ri 
+ * Authors: Andrs Micsik, Mt Pataki, Tams Dri 
  *          at MTA SZTAKI DSD, <A HREF="http://dsd.sztaki.hu">http://dsd.sztaki.hu</A>
  * Update Topic Tree by Martin Schmidt, FH St. Poelten
  */
@@ -168,6 +168,7 @@
 // neighbours
 //$neighbours = sotf_Neighbour::listAll();
 $nodes = sotf_Node::listAll();
+print_r($neighbours);
 while(list(,$node)= each($nodes)) {
   $nodeId = $node-&gt;get('node_id');
   if($nodeId == $config['nodeId'])

Modified: node/branches/video_test/www/advsearch.php
===================================================================
--- node/branches/video_test/www/advsearch.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/advsearch.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -37,6 +37,8 @@
 $run_image = $paramcache-&gt;getRegistered('image_x');		//TRANSPARENT_run query button (default by enter)
 $portal_http = $paramcache-&gt;getRegistered('upload_http');	//if upload pressed, the portal field
 
+$SQLchosen = $paramcache-&gt;getRegistered('SQLchosen'); //ADDED BY Martin Schmidt
+
 //3. Manage your queries
 $loadfrom = $paramcache-&gt;getRegistered('loadfrom');		//dropdown box with the saved queries
 $load = $paramcache-&gt;getRegistered('load');			//load button
@@ -49,7 +51,45 @@
 $SQLeq = $paramcache-&gt;getRegistered('SQLeq');			//= &lt; &gt; ... values array
 $SQLstring = $paramcache-&gt;getRegistered('SQLstring');		//last parameter value array
 
+/*
+// select all fields - ADDED BY Martin Schmidt
+$timestamp = time();
+$SQLall = 'entry_date DESC|Bstation|AAND|Babstract|Bcontains|B|Bstring|AAND|Bbroadcast_date|Bbigger|B1145397600|Bdate|AAND|Bcontenttype|Bis|Bsound|Bcontenttype|AAND|Bentry_date|Bbigger|B'.$timestamp.'|Bdate|AAND|Bexpiry_date|Bbigger|B'.$timestamp.'|Bdate|AAND|Bgenre_id|Bis|B1|Bgenre|AAND|Bkeywords|Bcontains|B|Bstring|AAND|Blanguage|Bis|Beng|Blang|AAND|Blength|Bbigger|B0|Blength|AAND|Bmodify_date|Bbigger|B'.$timestamp.'|Bdate|AAND|Bperson|Bcontains|B|Bstring|AAND|Bproduction_date|Bbigger|B'.$timestamp.'|Bdate|AAND|Brating|Bbigger|B1|Brating|AAND|Bseriesdescription|Bcontains|B|Bstring|AAND|Bseriestitle|Bcontains|B|Bstring|AAND|Bspatial_coverage|Bcontains|B|Bstring|AAND|Bstation|Bis|Bsunny fm|Bstation|AAND|Btemporal_coverage|Bbigger|B'.$timestamp.'|Bdate|AAND|Btitle|Bcontains|B|Bstring';
+
+
+$SQLquerySerial = $SQLall;*/
+
+
+// MODIFIED BY Martin Schmidt
+
 $SQLquerySerial = $paramcache-&gt;getRegistered('SQLquerySerial');		//the serialized query come from ADVSEARCH.PHP (hidden field)
+
+if ($SQLquerySerial == &quot;&quot;) {
+	$fromSearchResults = true; //ADDED BY Martin Schmidt
+	$SQLquerySerial = $_SESSION[&quot;SQLquerySerial&quot;];	//  from ADVSEARCHRESULTS.PHP or somewhere else (session)
+}
+
+if ($SQLquerySerial == &quot;&quot;)			//make a new query if first time here
+{
+	$SQLquery = $_SESSION[&quot;SQLquery&quot;];		//get array from session
+	$advsearch = new sotf_AdvSearch();	//create search object object with this array
+	$SQLquery = $advsearch-&gt;addAll(); //add all fields - ADDED BY Martin Schmidt
+	$advsearch-&gt;SetSortOrder();
+}
+else 						//else careate query from loaded
+{
+	$advsearch = new sotf_AdvSearch();		//create new search object object
+	$SQLquery = $advsearch-&gt;Deserialize($SQLquerySerial);	//deserialize the content of the hidden field
+	
+}
+///////////////////////////////////////////////
+
+
+/*
+
+$SQLquerySerial = $paramcache-&gt;getRegistered('SQLquerySerial');		//the serialized query come from ADVSEARCH.PHP (hidden field)
+
+
 if ($SQLquerySerial == &quot;&quot;) $SQLquerySerial = $_SESSION[&quot;SQLquerySerial&quot;];	//  from ADVSEARCHRESULTS.PHP or somewhere else (session)
 
 if ($SQLquerySerial == &quot;&quot;)			//make a new query if first time here
@@ -62,6 +102,7 @@
 	$advsearch = new sotf_AdvSearch();		//create new search object object
 	$SQLquery = $advsearch-&gt;Deserialize($SQLquerySerial);	//deserialize the content of the hidden field
 }
+*/
 
 if ($SQLquery == NULL) $advsearch-&gt;SetSortOrder();	//set DEFAULT sort order for new queries
 
@@ -89,8 +130,30 @@
 	else	$SQLquery[$i][3] = $SQLstring[$k];
 	$k++;
 }
+
+	
+// ADDED BY Martin Schmidt
+
+if (!$fromSearchResults){
+	for($j=0;$j&lt;count($SQLquery);$j++){
+		$was_chosen=false;
+		for($l=0;$l&lt;count($SQLchosen);$l++){
+			if($SQLchosen) {
+				if($SQLquery[$j][1] == $SQLchosen[$l]){
+					 $SQLquery[$j][0]=&quot;AND&quot;;
+					 $was_chosen=true;
+				}
+			}
+		}
+		if(!$was_chosen) $SQLquery[$j][0]=&quot;IGNORE&quot;;
+	}
+}
+
+/////////////////////////////////
+
 $advsearch-&gt;sotf_AdvSearch($SQLquery);			//set the inner variables of the class as well
 
+
 if($add)									////add term button pressed
 {
 	//nagyon kell figyelni a speci karektereket, nehogy SQL parancsot tegyen bele
@@ -99,15 +162,25 @@
 }
 elseif (($run or ($run_image==&quot;0&quot;)) and $SQLquery!=NULL)			////run query button pressed, run if any terms
 {
-	//$_SESSION[&quot;SQLquery&quot;] = $SQLquery;
-	//$_SESSION[&quot;SQLquerySerial&quot;] = $advsearch-&gt;Serialize();
-	$SQLquerySerial = $advsearch-&gt;Serialize();
-	$_SESSION[&quot;SQLquerySerial&quot;] = $SQLquerySerial;	//save the new query to the session
-	$page-&gt;redirect(&quot;advsearchresults.php?SQLquerySerial=$SQLquerySerial&quot;);
+	//ADDED BY Martin Schmidt - Make sure min 1 field is selected
+	$minOneField=false;
+	for($j=0;$j&lt;count($SQLquery);$j++){
+			if($SQLquery[$j][0] != &quot;IGNORE&quot;) $minOneField=true;
+	}
+	///////////////////////////////////////////////
+	
+	if($minOneField){
+		//$_SESSION[&quot;SQLquery&quot;] = $SQLquery;
+		//$_SESSION[&quot;SQLquerySerial&quot;] = $advsearch-&gt;Serialize();
+		$SQLquerySerial = $advsearch-&gt;Serialize();
+		$_SESSION[&quot;SQLquerySerial&quot;] = $SQLquerySerial;	//save the new query to the session
+		$page-&gt;redirect(&quot;advsearchresults.php?SQLquerySerial=$SQLquerySerial&quot;);
+	}
 }
 elseif ($new)									////new query button pressed
 {
 	$SQLquery = $advsearch-&gt;DeleteQuery();
+	$SQLquery = $advsearch-&gt;addAll();
 	$advsearch-&gt;SetSortOrder();		//set back default sort order for new queries
 }
 elseif ($load)									////load button pressed
@@ -180,11 +253,14 @@
 $smarty-&gt;assign(&quot;EQlang&quot;, $advsearch-&gt;GetEQlang());			//EQ dropdown for lang
 $smarty-&gt;assign(&quot;EQlength&quot;, $advsearch-&gt;GetEQlength());			//EQ dropdown for length
 $smarty-&gt;assign(&quot;EQnumber&quot;, $advsearch-&gt;GetEQnumber());			//EQ dropdown for numbers
+$smarty-&gt;assign(&quot;EQcontenttype&quot;, $advsearch-&gt;GetEQcontenttype());	//EQ dropdown for contenttype - ADDED BY Martin Schmidt
 
 $smarty-&gt;assign(&quot;Languages&quot;, $advsearch-&gt;GetLanguages());		//all possible languages
 $smarty-&gt;assign(&quot;Stations&quot;, $advsearch-&gt;GetStations());			//all possible stationnames
 $smarty-&gt;assign(&quot;Genres&quot;, $advsearch-&gt;GetGenres());			//all possible genrenames
 $smarty-&gt;assign(&quot;Ratings&quot;, $advsearch-&gt;getRatings());			//all possible ratings + a half value between all
+$smarty-&gt;assign(&quot;ContentTypes&quot;, $advsearch-&gt;GetContentTypes());		//all possible contenttypes - ADDED BY Martin Schmidt
+
 $smarty-&gt;assign(&quot;SQLstring&quot;, $SQLstring);				//selected values
 
 //box 1

Modified: node/branches/video_test/www/advsearchresults.php
===================================================================
--- node/branches/video_test/www/advsearchresults.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/advsearchresults.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -97,6 +97,7 @@
 			if ($values[$topicname] == &quot;&quot;) $values[$topicname] = $topic[&quot;name&quot;];
 			else $values[$topicname] .= &quot;; &quot;.$topic[&quot;name&quot;];
 	}
+	
 
 	$item['title'] = $result[$i][title];
 	$item['id'] = $result[$i][id];
@@ -111,6 +112,15 @@
 //if (DB::isError($result)) die($result-&gt;getMessage());
 //print(&quot;&lt;BR /&gt;&quot;.count($result));
 
+// GET FIRST &quot;NON-IGNORE&quot;-FIELD - ADDED BY Martin Schmidt
+$i=0;
+while($SQLquery[$i][0]==&quot;IGNORE&quot;){
+	$i++;
+} 
+$FirstNonIgnore=$i;
+///////////////////////
+
+$smarty-&gt;assign(&quot;FirstNonIgnore&quot;, $FirstNonIgnore); //ADDED BY Martin Schmidt
 $smarty-&gt;assign(&quot;SQLquery&quot;, $SQLquery);					//the query
 $smarty-&gt;assign(&quot;SQLquerySerial&quot;, $SQLquerySerial);			//the serialized query
 //$smarty-&gt;assign(&quot;SQLqueryfields&quot;, $advsearch-&gt;GetSQLqueryfields());	//translated name for all fieldnames of the query

Modified: node/branches/video_test/www/convert.php
===================================================================
--- node/branches/video_test/www/convert.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/convert.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -27,10 +27,14 @@
 		echo &quot; &quot;;
 }
 
-function endPage()
+function endPage($file_errors=0)
 {
 	echo &quot;&lt;script&gt;\n&quot;;
-	echo &quot;alert('Convert ready!');\n&quot;;
+	
+	echo &quot;alert('Convert ready!&quot;;
+	if($file_errors==1) echo &quot;\\n 1 file has not successfully been converted&quot;;
+	elseif($file_errors) echo &quot;\\n $file_errors files has not successfully been converted&quot;;
+	echo &quot;');\n&quot;;
 	echo &quot;document.location.href='closeAndRefresh.php';\n&quot;;
 	echo &quot;&lt;/script&gt;\n&quot;;
 	echo &quot;&lt;/body&gt;\n&quot;;
@@ -68,6 +72,7 @@
 	while(!feof($fp))
 	{
 		$data = fread($fp,1);
+		
 		if ((ord($data) == 13) || (ord($data) == 10))
 		{
 			if (preg_match($regexp,$line,$match))
@@ -96,6 +101,8 @@
 	flush();
 }
 
+
+
 function encodeWithLame($cmd)
 {
 	global $config;
@@ -162,6 +169,19 @@
 	flush();
 }
 
+function transcodeWithFfmpeg($cmd) //ADDED BY BUDDHAFLY
+{
+	global $config;
+
+	echo &quot;&lt;p&gt;Encoding Video file...&lt;br /&gt;\n&quot;;
+	flush();
+
+	progressBar($cmd,$config['ffmpegRegexp']);
+	echo &quot;&lt;/p&gt;\n&quot;;
+	flush();
+}
+
+
 function checkFile($file) {
   if(!is_readable($file)) {
 	 raiseError(&quot;conversion_failed&quot;);
@@ -172,49 +192,78 @@
   unlink($file) or logError(&quot;Could not delete file: $file&quot;);
 }
 
+function fileOK($file) {
+
+	$getID3 = new getID3();
+	$fileinfo = $getID3-&gt;analyze($file);
+	getid3_lib::CopyTagsToComments($fileinfo);
+	
+  if(!is_readable($file) || filesize($file)==0 || !isset($fileinfo['audio'])) {
+	return false;
+  }
+	return true;
+}
+
+
 $id = sotf_Utils::getParameter('id'); 
 $index = sotf_Utils::getParameter('index'); 
 $jingle = sotf_Utils::getParameter('jingle'); 
-$all = sotf_Utils::getParameter('all'); 
+$all = sotf_Utils::getParameter('all');
 
+
 $obj = $repository-&gt;getObject($id);
+
 if(!$obj)
 	  raiseError(&quot;object does not exist!&quot;);
-
 checkPerm($obj-&gt;id, 'change');
 
-$audioFiles = &amp; new sotf_FileList();
+
+// CHANGED BY BUDDHAFLY
+$audioVideoFiles = &amp; new sotf_FileList(); 
 if($jingle) {
-  $audioFiles-&gt;getAudioFromDir($obj-&gt;getMetaDir());
+  $audioVideoFiles-&gt;getAudioVideoFromDir($obj-&gt;getMetaDir());
 } else {
-  $audioFiles-&gt;getAudioFromDir($obj-&gt;getAudioDir());
+  $audioVideoFiles-&gt;getAudioVideoFromDir($obj-&gt;getAudioDir()); 
 }
-$checker = &amp; new sotf_AudioCheck($audioFiles);
-$checker-&gt;console = true;
+$checker = &amp; new sotf_ContentCheck($audioVideoFiles);
+$checker = $checker-&gt;selectType(); 
+if($videoconv) $checker-&gt;console = false;
+else $checker-&gt;console = true;
+////////////////////////////////////////////////////////
 
 startPage();
 
+$file_errors = 0;
+
 if($all) {
   $targets = $checker-&gt;convertAll($obj-&gt;id);
 
   foreach($targets as $target) {
+  	 if(!$checker-&gt;fileOK($target)) {
+	 	$file_errors++;
+		continue;
+	 }
+	 
 	 if($jingle) {
 		$obj-&gt;setJingle($target);
-	 } else {
+	 } else{
 		$obj-&gt;setAudio($target);
 	 }
   }
 
 } else {
   $target = $checker-&gt;convert($obj-&gt;id, $index);
-  
-  if($jingle) {
-	 $obj-&gt;setJingle($target);
-  } else {
-	 $obj-&gt;setAudio($target);
-  }
+  if($checker-&gt;fileOK($target)){
+	  if($jingle) {
+		 $obj-&gt;setJingle($target);
+	  } else{
+		 $obj-&gt;setAudio($target);
+	  }
+   }
+   else $file_errors++;
 }
 
-endPage();
 
+endPage($file_errors);
+
 ?&gt;
\ No newline at end of file

Modified: node/branches/video_test/www/editFiles.php
===================================================================
--- node/branches/video_test/www/editFiles.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/editFiles.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -12,6 +12,10 @@
 $id = sotf_Utils::getParameter('id');
 $new = sotf_Utils::getParameter('new');
 $okURL = sotf_Utils::getParameter('okURL');
+$videoconv=sotf_Utils::getParameter('videoconversion');
+$convertall=sotf_Utils::getParameter('convertall');
+$convertindex=sotf_Utils::getParameter('convertindex');
+$createstills=sotf_Utils::getParameter('createstills');
 
 if($new) {
   $smarty-&gt;assign(&quot;PAGETITLE&quot;, $page-&gt;getlocalized(&quot;New_prog_step1&quot;));
@@ -45,6 +49,11 @@
 
 $prg = &amp; new sotf_Programme($id);
 
+if($prg-&gt;isVideoPrg()) $video=true;
+else $video = false;
+$converting=false;
+
+
 // admins or owners can change files
 checkPerm($id, 'change');
 
@@ -68,8 +77,7 @@
 
 // generate output
 //$smarty-&gt;assign(&quot;OKURL&quot;,$okURL);
-if($new)
-     $smarty-&gt;assign(&quot;NEW&quot;,1);
+if($new)$smarty-&gt;assign(&quot;NEW&quot;,1);
 
 $smarty-&gt;assign('PRG_DATA', $prg-&gt;getAll());
 
@@ -83,15 +91,16 @@
 
 // audio files which does not contain the main programme
 $smarty-&gt;assign('AUDIO_FILES', $prg-&gt;listAudioFiles('false'));
-
+ 
 // audio files for programme
 $audioFiles = $prg-&gt;listAudioFiles('true');
+
 for ($i=0;$i&lt;count($audioFiles);$i++) {
     $mainAudio[$audioFiles[$i]['filename']] = $audioFiles[$i];
 }
 
 $prgAudiolist = &amp; new sotf_FileList();
-$prgAudiolist-&gt;getAudioFromDir($prg-&gt;getAudioDir());
+$prgAudiolist-&gt;getAudioVideoFromDir($prg-&gt;getAudioDir()); //CHANGED BY BUDDHAFLY
 
 // check SQL validity
 if($prgAudiolist-&gt;count() != count($mainAudio)) {
@@ -99,7 +108,7 @@
 }
 
 $files = $prgAudiolist-&gt;getFiles();
-debug('mainAUdio', $mainAudio);
+debug('mainAudio', $mainAudio);
 debug('prgaudiolist', $files);
 for ($i=0;$i&lt;count($files);$i++) {
   if(!$mainAudio[$files[$i]-&gt;name]) {
@@ -112,38 +121,172 @@
   // TODO: check all fields
 }
 
+
+
+
+
+if($video){
+	$still_found=false;
+	
+	if ($directory = opendir($prg-&gt;getOtherFilesDir())) {
+	   while (false !== ($filename = readdir($directory))) {
+			if(preg_match(&quot;/^still_&quot;.$id.&quot;_[12345]\.gif$/&quot;,$filename)){
+				$still_found=true;
+		   }
+	   }
+	   closedir($directory);
+	}
+	
+	if ($tempdir = opendir($config['wwwdir'].&quot;/tmp&quot;)) {
+	   while (false !== ($filename = readdir($tempdir))) {
+			if(preg_match(&quot;/^still_&quot;.$id.&quot;_[12345]\.gif$/&quot;,$filename)){
+				$still_found=true;
+		   }
+	   }
+	   closedir($tempdir);
+	}
+	
+	if(!$still_found &amp;&amp; $createstills) {
+		sotf_VideoFile::createStills($files[0]-&gt;path, $files[0]-&gt;duration, $id);
+	}
+}
+
+
 if($missing) {
   // there was a missing file description, so we have to restart the whole process
   $page-&gt;redirectSelf();
   exit;
 }
 
-// compare with required formats
-$checker = &amp; new sotf_AudioCheck($prgAudiolist);
 
-$PRG_AUDIO = array();
-for ($i=0;$i&lt;count($config['audioFormats']);$i++)
-{
-  $PRG_AUDIO[$i] = array(&quot;format&quot; =&gt; $checker-&gt;getFormatFileName($i),
-                         &quot;index&quot; =&gt; $i);
-  if ($checker-&gt;reqs[$i][0]) {
-    $fname = $prgAudiolist-&gt;list[$checker-&gt;reqs[$i][1]]-&gt;name;
-    $PRG_AUDIO[$i] = array_merge($PRG_AUDIO[$i], $mainAudio[$fname]);
-    //$PRG_AUDIO[$i]['name'] = $fname;
-    unset($mainAudio[$fname]);
-  } else {
-    $PRG_AUDIO[$i]['missing'] = 1;
-	 $missing = 1;
-  }
+$checker = &amp; new sotf_ContentCheck($prgAudiolist); //todo $prgAudioList MEANT CONTENT
+$checker = $checker-&gt;selectType();
+
+//check for recently converted files or transcoding in progress
+if($video &amp;&amp; $prgAudiolist-&gt;count()){
+	$temppath=$config['wwwdir'].&quot;/tmp/&quot;;
+	$obj = $repository-&gt;getObject($id);
+	if(!$obj) raiseError(&quot;object does not exist!&quot;);
+	
+	$list_changed=false;
+	
+	if ($tempdir = opendir($config['wwwdir'].&quot;/tmp&quot;)) {
+	   while (false !== ($filename = readdir($tempdir))) {
+			if(preg_match(&quot;/^&quot;.$id.&quot;_/&quot;,$filename)){
+				if($checker-&gt;fileOK($temppath.$filename)) {
+					if(is_file($temppath.$filename.&quot;.txt&quot;)) unlink($temppath.$filename.&quot;.txt&quot;);
+					$obj-&gt;setAudio($temppath.$filename);
+					$list_changed=true;
+				}
+			
+			}if(preg_match(&quot;/^still_&quot;.$id.&quot;_[12345]\.gif$/&quot;,$filename)){
+				$obj_id=$prg-&gt;setOtherFile($temppath.$filename);
+				//$still=new sotf_NodeObject('sotf_other_files', $obj_id);
+					$fileInfo = &amp;$repository-&gt;getObject($obj_id);
+					$fileInfo-&gt;set('public_access', 'f');
+					$fileInfo-&gt;update();
+				$list_changed=true;
+		   }
+	   }
+	   closedir($tempdir);
+	}
+	
+	if($list_changed) {
+	  $page-&gt;redirectSelf();
+	  exit;
+	}
 }
 
-debug(&quot;mainAudio&quot;, $mainAudio);
-if(is_array($mainAudio)) {
-  while(list($fn,$finfo) = each($mainAudio)) {
-	 $PRG_AUDIO[] = $finfo;
-  }
+
+	
+// compare with required formats	
+	
+	$PRG_AUDIO = array();
+	
+	
+	for ($i=0;$i&lt;count($config[$checker-&gt;prefix.'Formats']);$i++) // is either &quot;audioFormats&quot; or &quot;videoFormats&quot;
+	{
+	  $PRG_AUDIO[$i] = array(&quot;format&quot; =&gt; $checker-&gt;getFormatFileName($i),
+							 &quot;index&quot; =&gt; $i);
+	  if ($checker-&gt;reqs[$i][0]) {
+		$fname = $prgAudiolist-&gt;list[$checker-&gt;reqs[$i][1]]-&gt;name;
+		$PRG_AUDIO[$i] = array_merge($PRG_AUDIO[$i], $mainAudio[$fname]);
+		//$PRG_AUDIO[$i]['name'] = $fname;
+		unset($mainAudio[$fname]);
+	  } else {
+	  	
+		if($video){
+			// if conversion in progress calculate percentage
+			$regexp_file=&quot;/^&quot;.$id . '_.*_' . $checker-&gt;getFormatFilename($i).&quot;$/&quot;;
+			$source = $prgAudiolist-&gt;list[$checker-&gt;reqs[$i][1]]-&gt;getPath();
+			
+			if ($tempdir = opendir($config['wwwdir'].&quot;/tmp&quot;)) {
+			   while (false !== ($filename = readdir($tempdir))) {
+					if(preg_match($regexp_file, $filename)){
+						$PRG_AUDIO[$i]['converting']=true;
+						$totalframes=$checker-&gt;getTotalFrames($source, $i);
+						$perc_error = $checker-&gt;getPercentageOrError($temppath.$filename, $totalframes);
+						$PRG_AUDIO[$i]['errors']=$perc_error['errors'];
+						if($perc_error['percentage'])$PRG_AUDIO[$i]['percentage']=&quot;~ &quot;.$perc_error['percentage'].&quot;%&quot;;
+						if(!empty($perc_error['errors'])) $PRG_AUDIO[$i]['converting'] = false;
+				   }
+			   }
+			   closedir($tempdir);
+			}
+		}
+				
+		$PRG_AUDIO[$i]['missing'] = 1;
+		 $missing = 1;
+	  }
+	}
+	
+	
+	//check whether a file is converting
+	$converting=false;
+	for ($i=0;$i&lt;count($config[$checker-&gt;prefix.'Formats']);$i++){
+		if($PRG_AUDIO[$i]['converting']==true) $converting=true;	
+	}
+	
+
+	debug(&quot;mainAudio&quot;, $mainAudio);
+	if(is_array($mainAudio)) {
+	  while(list($fn,$finfo) = each($mainAudio)) {
+		 $PRG_AUDIO[] = $finfo;
+	  }
+	}
+
+
+
+// start converting required formats
+if($videoconv &amp;&amp; $missing){
+
+	if(!$obj)
+		  raiseError(&quot;object does not exist!&quot;);
+	checkPerm($obj-&gt;id, 'change');
+	
+	$checker-&gt;console = false;
+	
+	if($convertall) {
+	  $checker-&gt;convertAll($obj-&gt;id);
+	} 
+	elseif($convertindex!=&quot;&quot;) {
+	  $checker-&gt;convert($obj-&gt;id, $convertindex);
+	}
+	
+	$page-&gt;redirect(&quot;editFiles.php?id=$id&quot;);
+	exit;
 }
 
+//////////////////////////////////////////////////////////
+
+$smarty-&gt;assign('CREATESTILLS', $createstills);
+
+$smarty-&gt;assign('STILL_FOUND', $still_found);
+
+$smarty-&gt;assign('VIDEO',$video);
+
+$smarty-&gt;assign('CONVERTING',$converting);
+
 $smarty-&gt;assign('MISSING',$missing);
 
 $smarty-&gt;assign('MAIN_AUDIO_COUNT', $prgAudiolist-&gt;count());

Modified: node/branches/video_test/www/editMeta.php
===================================================================
--- node/branches/video_test/www/editMeta.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/editMeta.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -3,16 +3,14 @@
 /*  
  * $Id$
  * Created for the StreamOnTheFly project (IST-2001-32226)
- * Authors: Andr&#225;s Micsik, M&#225;t&#233; Pataki, Tam&#225;s D&#233;ri 
+ * Authors: Andrs Micsik, Mt Pataki, Tams Dri 
  *          at MTA SZTAKI DSD, <A HREF="http://dsd.sztaki.hu">http://dsd.sztaki.hu</A>
+     @internal change &quot;read ID3 Tags from MP3 File and write ID3 Tags from Metadata fields&quot;
+ *           by wolfgang csacsinovits and martin schmidt (fh st. poelten)
  *
- 	@internal change &quot;read ID3 Tags from MP3 File and write ID3 Tags from Metadata fields&quot;
-~  *           by wolfgang csacsinovits and martin schmidt (fh st. poelten)
-~  * 
-~  * 
-~  */
+ *
+ */
 
-
 require(&quot;init.inc.php&quot;);
 
 $prgId = sotf_Utils::getParameter('id');
@@ -22,6 +20,7 @@
      $smarty-&gt;assign(&quot;PAGETITLE&quot;, $page-&gt;getlocalized(&quot;New_prog_step1&quot;));
 else
      $smarty-&gt;assign(&quot;PAGETITLE&quot;, $page-&gt;getlocalized(&quot;editmeta&quot;));
+
 $page-&gt;forceLogin();
 
 $okURL = sotf_Utils::getParameter('okURL');
@@ -37,46 +36,45 @@
 $prg = &amp; new sotf_Programme($prgId);
 
 
-// ---- changed by wolfgang csacsinovits and martin schmidt GET ID3 TAGS and write into Metadata - Fields
-
-
-	$audioFiles = $prg-&gt;listAudioFiles('true');
-	
-	$file =  $prg-&gt;getAudioDir() . '/' . $audioFiles[0] ['filename'];
-
-	if($new){
-
-	$ThisFileInfo = GetAllFileInfo($file, 'mp3', false, false, false) ;
-	
-	
-	if (($ThisFileInfo['comments']['title']) != '' ) {
-		$title = implode(', ', $ThisFileInfo['comments']['title']);
-		}
-		
-	if (($ThisFileInfo['comments']['artist']) != '' ) {	
-		$artist = implode(', ', $ThisFileInfo['comments']['artist']);
-		}
-	if (($ThisFileInfo['comments']['genre']) != '' ) {	
-		$genre = implode(', ', $ThisFileInfo['comments']['genre']);
-		}
-	
-	if (($ThisFileInfo['comments']['album']) != '' ) {	
-		$album = implode(', ', $ThisFileInfo['comments']['album']);
-		}
-	
-		$keywords = $artist;
-		if ($title != '') $keywords .= ', ' . $title;
-		if ($genre != '' &amp;&amp; $genre!='UNKNOWN_GENRE') $keywords .= ', ' . $genre;
-
-		$prg-&gt;set('title' , $title);
-		$prg-&gt;set('keywords' ,$keywords);
-
-	}
-// -------------------------------------------------------------------------------------
-
-
-
-if(!$prg-&gt;isLocal()) {
+	   // ---- changed by wolfgang csacsinovits and martin schmidt GET ID3 TAGS and write into Metadata - Fields
+  	 
+  	 
+  	    $audioFiles = $prg-&gt;listAudioFiles('true');
+  	    
+  	    $file =  $prg-&gt;getAudioDir() . '/' . $audioFiles[0] ['filename'];
+  	 
+	 	if($new){
+	 
+			$ThisFileInfo = GetAllFileInfo($file, 'mp3', false, false, false) ;
+			
+			
+			if (($ThisFileInfo['comments']['title']) != '' ) {
+				$title = implode(', ', $ThisFileInfo['comments']['title']);
+				}
+				
+			if (($ThisFileInfo['comments']['artist']) != '' ) {    
+				$artist = implode(', ', $ThisFileInfo['comments']['artist']);
+				}
+			if (($ThisFileInfo['comments']['genre']) != '' ) {    
+				$genre = implode(', ', $ThisFileInfo['comments']['genre']);
+				}
+			
+			if (($ThisFileInfo['comments']['album']) != '' ) {    
+				$album = implode(', ', $ThisFileInfo['comments']['album']);
+				}
+			
+				$keywords = $artist;
+				if ($title != '') $keywords .= ', ' . $title;
+				if ($genre != '' &amp;&amp; $genre!='UNKNOWN_GENRE') $keywords .= ', ' . $genre;
+		 
+				$prg-&gt;set('title' , $title);
+				$prg-&gt;set('keywords' ,$keywords);
+		  }
+	// -------------------------------------------------------------------------------------
+  	 
+  	 
+  	 
+  	if(!$prg-&gt;isLocal()) {
   raiseError(&quot;You can only edit programmes locally!&quot;);
 }
 
@@ -94,39 +92,35 @@
 $save = sotf_Utils::getParameter('save');
 if($save || $finish || $finishpublish) {
   checkPerm($prg, 'change');
-  $params = array('title'=&gt;array('text',1),
-                  'alternative_title'=&gt;array('text',0),
-                  'episode_title'=&gt;array('text',0),
-                  'episode_sequence'=&gt;array('number',0),
-                  'keywords'=&gt;array('text',1),
-                  'abstract'=&gt;array('text',1),
-                  'genre_id'=&gt;array('number',1),
-                  'spatial_coverage'=&gt;array('text',0),
-                  'temporal_coverage'=&gt;array('date',0),
-                  'production_date'=&gt;array('date',0),
-                  'broadcast_date'=&gt;array('date',0),
-                  'expiry_date'=&gt;array('date',0)
-                  );
-  
- // changed by wolfgang csacsinovits and martin schmidt -&gt; check empty fields, validate input data
-  $field_error = array();
-  $error_count = 0;
+   $params = array('title'=&gt;array('text',1),
+	'alternative_title'=&gt;array('text',0),
+	'episode_title'=&gt;array('text',0),
+	'episode_sequence'=&gt;array('number',0),
+	'keywords'=&gt;array('text',1),
+	'abstract'=&gt;array('text',1),
+	'genre_id'=&gt;array('number',1),
+	'spatial_coverage'=&gt;array('text',0),
+	'temporal_coverage'=&gt;array('date',0),
+	'production_date'=&gt;array('date',0),
+	'broadcast_date'=&gt;array('date',0),
+	'expiry_date'=&gt;array('date',0)
+   );
+   
+    // changed by wolfgang csacsinovits and martin schmidt -&gt; check empty fields, validate input data	  
+	$field_error = array();	  
+	$error_count = 0;
+   
   foreach($params as $param=&gt;$type) {
-  
     $value = sotf_Utils::getParameter($param);
-	
-	if($type[1]== 1 &amp;&amp; ($value == '' || $value == 'untitled')) {
-	$field_error[$param]=true;
-	$error_count++;
-	}
-	else $field_error[$param]=false;
-	
-	if($param=='genre_id' &amp;&amp; $value==0) {
-	$field_error[$param]=true;
-	$error_count++;
-	}
-	
-    if($type[0]=='text') {
+    if($type[1]== 1 &amp;&amp; ($value == '' || $value == 'untitled')) {
+		    $field_error[$param]=true;
+		  	$error_count++;
+	}	    else $field_error[$param]=false;	    	    
+	if($param=='genre_id' &amp;&amp; $value==0) {	    
+		$field_error[$param]=true;	    
+		$error_count++;	    
+	}	    
+		if($type[0]=='text') {
       $value = strip_tags($value);
     } elseif($type[0]=='number') {
       if(empty($value))
@@ -141,141 +135,98 @@
 	        . sotf_Utils::getParameter($param . 'Month') . '-'
 	        . sotf_Utils::getParameter($param . 'Day');
 			if($param == 'broadcast_date') {
-				$value = $value . ' ' . sotf_Utils::getParameter('broadcast_dateHour') . ':' . sotf_Utils::getParameter('broadcast_dateMinute'); // . ' ' . $db-&gt;myTZ();
+			   $value = $value . ' ' . sotf_Utils::getParameter('broadcast_dateHour') . ':' . sotf_Utils::getParameter('broadcast_dateMinute'); // . ' ' . $db-&gt;myTZ();
 			}
 		} else {
 		  $value = NULL;
 		}
     }
-	
-	
     $prg-&gt;set($param, $value);
-	 
-	
   }
-
-
-
-//echo $error_msg;
-
   // language hack
   $prg-&gt;setLanguageWithParams();
-  
-  
-	// changed by wolfgang csacsinovits and martin schmidt - WRITE ID3 - TAGS --------------------------------------------------
-	
-	$audioFiles = $prg-&gt;listAudioFiles('true');
-	for($q = 0; $q &lt; count($audioFiles); $q++) {
-	
-		$file =  $prg-&gt;getAudioDir() . '/' . $audioFiles[$q] ['filename'];
-		
-		// check if file is mp3 - file
-		$filename = $file;
-		$extension = substr($filename, strrpos($filename, '.') +1);
-		
-		$productiondate = (SafeStripSlashes(sotf_Utils::getParameter('production_date')));
-		
-		if($extension==&quot;mp3&quot;) {
-		
-		
-		// TITLE
-		$data['id3v2']['TIT2']['encodingid'] = 0;
-		$data['id3v2']['TIT2']['data']       = SafeStripSlashes(sotf_Utils::getParameter('title'));
-		$data['ape']['title'][] = SafeStripSlashes(sotf_Utils::getParameter('title'));
-		
-		$data['id3v1']['TIT2']['encodingid'] = 0;
-		$data['id3v1']['TIT2']['data']       = SafeStripSlashes(sotf_Utils::getParameter('title'));
-		$data['ape']['title'][] = SafeStripSlashes(sotf_Utils::getParameter('title'));
-		$title =  $data['ape']['title'][0];
-
-		
-		// STATION
-		
-		$prg-&gt;station = $prg-&gt;getObject($prg-&gt;get('station_id'));
-		if(is_object($prg-&gt;station)) {
-			$prg-&gt;stationName = $prg-&gt;station-&gt;get('name');
-			$station_name = $prg-&gt;stationName;
-		}
-		else $station_name = &quot;&quot;;
-		
-		$data['id3v2']['TPE1']['encodingid'] = 0;
-		$data['id3v2']['TPE1']['data']       = SafeStripSlashes($station_name);
-		$data['ape']['artist'][] = SafeStripSlashes($station_name);
-		
-		$data['id3v1']['TPE1']['encodingid'] = 0;
-		$data['id3v1']['TPE1']['data']       = SafeStripSlashes($station_name);
-		$data['ape']['artist'][] = SafeStripSlashes($station_name);
-		$artist = $data['ape']['artist'][0];
-
-		
-		// YEAR
-		$data['id3v2']['TYER']['encodingid'] = 0;
-		$data['id3v2']['TYER']['data']       = SafeStripSlashes(sotf_Utils::getParameter('production_date' . 'Year'));//
-		$data['ape']['year'][] = SafeStripSlashes(sotf_Utils::getParameter('production_date' . 'Year'));//
-		
-		$data['id3v1']['TYER']['encodingid'] = 0;
-		$data['id3v1']['TYER']['data']       = SafeStripSlashes(sotf_Utils::getParameter('production_date' . 'Year'));//
-		$data['ape']['year'][] = SafeStripSlashes(sotf_Utils::getParameter('production_date' . 'Year'));//
-		$year = $data['ape']['year'][0]; 
-
-		
-		// GENRE
-		$data['id3v2']['TCON']['encodingid'] = 0;
-		$data['id3v2']['TCON']['data']       = SafeStripSlashes($vocabularies-&gt;getGenreName($prg-&gt;get('genre_id')));
-		$data['ape']['genre'][] = SafeStripSlashes($vocabularies-&gt;getGenreName($prg-&gt;get('genre_id')));
-		
-		$data['id3v2']['TRCK']['encodingid'] = 0;
-		$data['id3v2']['TRCK']['data']       = SafeStripSlashes(sotf_Utils::getParameter('title'));
-		$data['ape']['track'][] = SafeStripSlashes(sotf_Utils::getParameter('title'));
-		
-		$data['id3v1']['TCON']['encodingid'] = 0;
-		$data['id3v1']['TCON']['data']       = SafeStripSlashes($vocabularies-&gt;getGenreName($prg-&gt;get('genre_id')));
-		$data['ape']['genre'][] = SafeStripSlashes($vocabularies-&gt;getGenreName($prg-&gt;get('genre_id')));
-		$genre = $data['ape']['genre'][0];
-		
-		$data['id3v1']['TRCK']['encodingid'] = 0;
-		$data['id3v1']['TRCK']['data']       = SafeStripSlashes(sotf_Utils::getParameter('title'));
-		$data['ape']['track'][] = SafeStripSlashes(sotf_Utils::getParameter('title'));
-		
-		// COMMENT
-		$data['id3v1']['COMM'][0]['encodingid']  = 0;
-		$data['id3v1']['COMM'][0]['language']    = 'eng';
-		$data['id3v1']['COMM'][0]['description'] = '';
-		$data['id3v1']['COMM'][0]['data']        = SafeStripSlashes(sotf_Utils::getParameter('keywords'));
-		$data['ape']['comments'][] = SafeStripSlashes(sotf_Utils::getParameter('keywords'));
-		$comment = $data['ape']['comments'][0];
-		
-		
-		$data['id3v2']['TALB']['encodingid'] = 0;
-		$data['id3v2']['TALB']['data']       = '*ID3Tags modified by SOTF*';
-		$data['ape']['album'][] = '*ID3Tags modified by SOTF*';
-				
-
-	WriteID3v1($file, $title, $artist, '*ID3Tags modified by SOTF*' , $year, $comment, $genre, $title, false );
-	WriteID3v2($file, $data, 3, 0, true, 0, true);
-
-		if (!empty($_POST['VersionToEditAPE'])) {
-			echo 'APE changes'.(WriteAPEtag($EditorFilename, $data['ape'], false) ? '' : ' NOT').' written successfully&lt;HR&gt;';
-			}
-				
-					}
-			
-		}
-		
-   //-----------------------------------------------------------------------------------------------------
-
-				
   // save
-  
-  // added by wolfgang csacsinovits &amp; martin schmidt 05-09-27
-  if($error_count&gt;0){
-	  $smarty-&gt;assign(&quot;FIELD_ERROR&quot;, $field_error); 
-	  $smarty-&gt;assign(&quot;ERROR_COUNT&quot;, $error_count);
-  }
- 
-  // -----------------------------------
+      // changed by wolfgang csacsinovits and martin schmidt - WRITE ID3 - TAGS --------------------------------------------------	    	
+	  $audioFiles = $prg-&gt;listAudioFiles('true');	    
+	  for($q = 0; $q &lt; count($audioFiles); $q++) {	    	        
+		  $file =  $prg-&gt;getAudioDir() . '/' . $audioFiles[$q] ['filename'];	        	        
+		  // check if file is mp3 - file	        
+		  $filename = $file;	        
+		  $extension = substr($filename, strrpos($filename, '.') +1);	        	        
+		  $productiondate = (SafeStripSlashes(sotf_Utils::getParameter('production_date')));	        	        
+		  if($extension==&quot;mp3&quot;) {	        	        	        
+		  // TITLE	        
+		  $data['id3v2']['TIT2']['encodingid'] = 0;	        
+		  $data['id3v2']['TIT2']['data']       = SafeStripSlashes(sotf_Utils::getParameter('title'));	        
+		  $data['ape']['title'][] = SafeStripSlashes(sotf_Utils::getParameter('title'));	        	        
+		  $data['id3v1']['TIT2']['encodingid'] = 0;	        $data['id3v1']['TIT2']['data']       = SafeStripSlashes(sotf_Utils::getParameter('title'));	        $data['ape']['title'][] = SafeStripSlashes(sotf_Utils::getParameter('title'));	        $title =  $data['ape']['title'][0];	 	        	        
+		  // STATION	 
+		  
+		  //php4 compatibility hack
+		  $prg-&gt;station = $prg-&gt;getObject($prg-&gt;get('station_id'));	        
+		  if(is_object($prg-&gt;station)) {	            
+			  $prg-&gt;stationName = $prg-&gt;station-&gt;get('name');	            
+			  $station_name = $prg-&gt;stationName;	        
+		  }	        
+		  else $station_name = &quot;&quot;;	        
+		         
+				 
+		  $data['id3v2']['TPE1']['encodingid'] = 0;	        
+		  $data['id3v2']['TPE1']['data']       = SafeStripSlashes($station_name);	        
+		  $data['ape']['artist'][] = SafeStripSlashes($station_name);	        	        
+		  $data['id3v1']['TPE1']['encodingid'] = 0;	        
+		  $data['id3v1']['TPE1']['data']       = SafeStripSlashes($station_name);	        
+		  $data['ape']['artist'][] = SafeStripSlashes($station_name);	        
+		  $artist = $data['ape']['artist'][0];	 	        	        
+		  // YEAR	        
+		  $data['id3v2']['TYER']['encodingid'] = 0;	        
+		  $data['id3v2']['TYER']['data']       = SafeStripSlashes(sotf_Utils::getParameter('production_date' . 'Year'));        
+		  $data['ape']['year'][] = SafeStripSlashes(sotf_Utils::getParameter('production_date' . 'Year'));        	        
+		  $data['id3v1']['TYER']['encodingid'] = 0;	        
+		  $data['id3v1']['TYER']['data']       = SafeStripSlashes(sotf_Utils::getParameter('production_date' . 'Year'));
+		  $data['ape']['year'][] = SafeStripSlashes(sotf_Utils::getParameter('production_date' . 'Year'));
+		  $year = $data['ape']['year'][0];	 	        	        
+		  // GENRE	        
+		  $data['id3v2']['TCON']['encodingid'] = 0;	        
+		  $data['id3v2']['TCON']['data']       = SafeStripSlashes($vocabularies-&gt;getGenreName($prg-&gt;get('genre_id')));	        
+		  $data['ape']['genre'][] = SafeStripSlashes($vocabularies-&gt;getGenreName($prg-&gt;get('genre_id')));	        	        
+		  $data['id3v2']['TRCK']['encodingid'] = 0;	        
+		  $data['id3v2']['TRCK']['data']       = SafeStripSlashes(sotf_Utils::getParameter('title'));	        
+		  $data['ape']['track'][] = SafeStripSlashes(sotf_Utils::getParameter('title'));	        	        
+		  $data['id3v1']['TCON']['encodingid'] = 0;	        
+		  $data['id3v1']['TCON']['data']       = SafeStripSlashes($vocabularies-&gt;getGenreName($prg-&gt;get('genre_id')));	        
+		  $data['ape']['genre'][] = SafeStripSlashes($vocabularies-&gt;getGenreName($prg-&gt;get('genre_id')));	        
+		  $genre = $data['ape']['genre'][0];	        	        
+		  $data['id3v1']['TRCK']['encodingid'] = 0;	        
+		  $data['id3v1']['TRCK']['data']       = SafeStripSlashes(sotf_Utils::getParameter('title'));	        
+		  $data['ape']['track'][] = SafeStripSlashes(sotf_Utils::getParameter('title'));	        	        
+		  // COMMENT	        
+		  $data['id3v1']['COMM'][0]['encodingid']  = 0;	        
+		  $data['id3v1']['COMM'][0]['language']    = 'eng';	        
+		  $data['id3v1']['COMM'][0]['description'] = '';	        
+		  $data['id3v1']['COMM'][0]['data']        = SafeStripSlashes(sotf_Utils::getParameter('keywords'));	        
+		  $data['ape']['comments'][] = SafeStripSlashes(sotf_Utils::getParameter('keywords'));	        
+		  $comment = $data['ape']['comments'][0];	        	        	        
+		  $data['id3v2']['TALB']['encodingid'] = 0;	        
+		  $data['id3v2']['TALB']['data']       = '*ID3Tags modified by SOTF*';	        
+		  $data['ape']['album'][] = '*ID3Tags modified by SOTF*';	                	 	    
+		  WriteID3v1($file, $title, $artist, '*ID3Tags modified by SOTF*' , $year, $comment, $genre, $title, false );	    
+		  WriteID3v2($file, $data, 3, 0, true, 0, true);	 	        
+		  if (!empty($_POST['VersionToEditAPE'])) {	            
+			  echo 'APE changes'.(WriteAPEtag($EditorFilename, $data['ape'], false) ? '' : ' NOT').' written successfully&lt;HR&gt;';	            
+		  }	                	                    
+	  }	//for count($audioFiles)        
+ }	//foreach params        	   	
+	  //-----------------------------------------------------------------------------------------------------	 	                	  
 
-  elseif ($finishpublish) {
+// save	  	  
+// added by wolfgang csacsinovits &amp; martin schmidt 05-09-27	  
+ if($error_count&gt;0){	      
+	 $smarty-&gt;assign(&quot;FIELD_ERROR&quot;, $field_error);	      
+	 $smarty-&gt;assign(&quot;ERROR_COUNT&quot;, $error_count);	  
+ }	 	  
+ // -----------------------------------	 	  
+ elseif ($finishpublish) {
     $prg-&gt;publish();
     $page-&gt;redirect(&quot;editor.php&quot;);
   } elseif ($finish) {
@@ -290,7 +241,6 @@
 $smarty-&gt;assign('PRG_ID', $prgId);
 $smarty-&gt;assign('PRG_TITLE', $prg-&gt;get('title'));
 
-
 // delete role
 $delrole = sotf_Utils::getParameter('delrole');
 $roleid = sotf_Utils::getParameter('roleid');
@@ -369,22 +319,17 @@
   exit;
 }
 
-
-
 // generate output
 
 // general data
 if($new)
-
-
      $smarty-&gt;assign(&quot;NEW&quot;,1);
-	 $smarty-&gt;assign('PRG_DATA', $prg-&gt;getAllForHTML());
+$smarty-&gt;assign('PRG_DATA', $prg-&gt;getAllForHTML());
 
-//--- modified by martin schmidt 05-09-11
-if($prg-&gt;get('broadcast_date')) $smarty-&gt;assign('BROADCAST_TIME', strtotime($prg-&gt;get('broadcast_date')));
+//--- modified by martin schmidt 05-09-11	
+if($prg-&gt;get('broadcast_date')) $smarty-&gt;assign('BROADCAST_TIME', strtotime($prg-&gt;get('broadcast_date')));	
 //----------------------------------
 
-
 // station data
 $station = $prg-&gt;getStation();
 $smarty-&gt;assign('STATION_DATA', $station-&gt;getAllForHTML());

Modified: node/branches/video_test/www/editor.php
===================================================================
--- node/branches/video_test/www/editor.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/editor.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -31,11 +31,20 @@
   $fname = sotf_Utils::getParameter('fname');
   $station = sotf_Utils::getParameter('station');
   checkPerm($station, 'create');
+  
+  //ADDED BY BUDDHAFLY
+	$getID3 = new getID3();
+	$fileinfo = $getID3-&gt;analyze($user-&gt;getUserDir().'/'.$fname);
+	getid3_lib::CopyTagsToComments($fileinfo);
+	if (isset ($fileinfo['video'])) $is_video = true;
+  //--------------------------------------------
+  //logError(print_r($fileinfo, true));
   $newPrg = new sotf_Programme();
   $track = preg_replace('/\.[^.]*$/','', $fname);
   debug(&quot;create with track&quot;, $track);
-  $newPrg-&gt;create($station, $track);
+  $newPrg-&gt;create($station, $track, $is_video); //MOD BY BUDDHAFLY
   $newPrg-&gt;setAudio($user-&gt;getUserDir() . '/' . $fname);
+  
   $permissions-&gt;addPermission($newPrg-&gt;id, $user-&gt;id, 'admin');
   //$page-&gt;redirect(&quot;editFiles.php&quot;);
   $page-&gt;redirect(&quot;editFiles.php?new=1&amp;id=&quot; . $newPrg-&gt;getID());
@@ -83,7 +92,7 @@
 }
 
 $userAudioFiles = new sotf_FileList();
-$userAudioFiles-&gt;getAudioFromDir($user-&gt;getUserDir());
+$userAudioFiles-&gt;getAudioVideoFromDir($user-&gt;getUserDir()); //CHANGED BY BUDDHAFLY, $userAudioFiles MEANT CONTENT
 $list = $userAudioFiles-&gt;getFileNames();
 if(!empty($list)) {
 		 $smarty-&gt;assign_by_ref(&quot;USER_AUDIO_FILES&quot;, $list);

Added: node/branches/video_test/www/flvplayer.swf
===================================================================
(Binary files differ)


Property changes on: node/branches/video_test/www/flvplayer.swf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: node/branches/video_test/www/get.php
===================================================================
--- node/branches/video_test/www/get.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/get.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -58,29 +58,97 @@
   // rights sections
   $smarty-&gt;assign('RIGHTS', $prg-&gt;getAssociatedObjects('sotf_rights', 'start_time'));
 
-  // audio files 
-  $audioFiles = $prg-&gt;getAssociatedObjects('sotf_media_files', 'main_content DESC, filename');
-  $to = count($audioFiles);
+
+//check for recently converted files or transcoding in progress
+
+if($prg-&gt;isVideoPrg()){
+  $prgAudiolist = &amp; new sotf_FileList();
+  $prgAudiolist-&gt;getAudioVideoFromDir($prg-&gt;getAudioDir());
+  
+  $checker = &amp; new sotf_ContentCheck($prgAudiolist); //todo $prgAudioList MEANT CONTENT
+  $checker = $checker-&gt;selectType();
+
+	$temppath=$config['wwwdir'].&quot;/tmp/&quot;;
+	
+	if ($tempdir = opendir($config['wwwdir'].&quot;/tmp&quot;)) {
+	   while (false !== ($filename = readdir($tempdir))) {
+	   		if(preg_match(&quot;/&quot;.$id.&quot;_/&quot;,$filename)){
+				if(preg_match(&quot;/^&quot;.$id.&quot;_/&quot;,$filename)){
+					if($checker-&gt;fileOK($temppath.$filename)) {
+						if(is_file($temppath.$filename.&quot;.txt&quot;)) unlink($temppath.$filename.&quot;.txt&quot;);
+						$prg-&gt;setAudio($temppath.$filename);
+					}
+				
+				}if(preg_match(&quot;/^still_&quot;.$id.&quot;_[12345]\.gif$/&quot;,$filename)){
+					$obj_id=$prg-&gt;setOtherFile($temppath.$filename);
+					if(is_file($temppath.$filename.&quot;.txt&quot;)) unlink($temppath.$filename.&quot;.txt&quot;);
+					$fileInfo = &amp;$repository-&gt;getObject($obj_id);
+					$fileInfo-&gt;set('public_access', 'f');
+					$fileInfo-&gt;update();
+			   }
+			}
+	   }
+	   closedir($tempdir);
+	}
+}
+
+  // content files 
+  $mainContentFiles = $prg-&gt;getAssociatedObjects('sotf_media_files', 'main_content DESC, filename');
+  $to = count($mainContentFiles);
+  $flv_found = false; //ADDED BY Martin Schmidt
   for($i=0; $i&lt;$to; $i++) {
 	 if($prg-&gt;isLocal()) {
 		// if local, we check if file disappeared in the meantime
-		$path = $prg-&gt;getFilePath($audioFiles[$i]);
+		$path = $prg-&gt;getFilePath($mainContentFiles[$i]);
 		if(!is_readable($path)) {
 		  debug(&quot;DISAPPEARED FILE&quot;, $path);
-		  unset($audioFiles[$i]);
+		  unset($mainContentFiles[$i]);
 		  continue;
 		}
 	 }
-    $audioFiles[$i] =  array_merge($audioFiles[$i], sotf_AudioFile::decodeFormatFilename($audioFiles[$i]['format']));
-	$d = getdate($audioFiles[$i]['play_length']);
+    $mainContentFiles[$i] =  array_merge($mainContentFiles[$i], sotf_AudioFile::decodeFormatFilename($mainContentFiles[$i]['format']));
+	
+	
+	//ADDED BY Martin Schmidt
+	//print_r($mainContentFiles[$i]);
+	  if ($prg-&gt;isVideoPrg() &amp;&amp; $mainContentFiles[$i]['format']==&quot;flv&quot; &amp;&amp; $mainContentFiles[$i]['download_access']=='t'){
+	  	$flv_path = sotf_Node::getHomeNodeRootUrl($prg) . '/getFile.php/' . 'fid__' . $mainContentFiles[$i]['id']. '__' . $fname.&quot;.flv&quot;;
+		$flv_found= true;
+		//$_SESSION['flv_path'] = $flv_path;
+	  }
+	  
+	  $smarty-&gt;assign('FLV_PATH', $flv_path);
+	  
+	///////////////////// 
+	
+	$d = getdate($mainContentFiles[$i]['play_length']);
 	$d['hours']--;
-	$audioFiles[$i]['playtime_string'] = ($d['hours'] ? $d['hours'].':' : '') . sprintf('%02d',$d['minutes']) . ':' . sprintf('%02d',$d['seconds']);
+	$mainContentFiles[$i]['playtime_string'] = ($d['hours'] ? $d['hours'].':' : '') . sprintf('%02d',$d['minutes']) . ':' . sprintf('%02d',$d['seconds']);
   }
-  $smarty-&gt;assign('AUDIO_FILES', $audioFiles);
+  
+  $smarty-&gt;assign('FLV_FOUND', $flv_found);
+  
+  $smarty-&gt;assign('AUDIO_FILES', $mainContentFiles);
+  
+  if($prg-&gt;isVideoPrg())$smarty-&gt;assign('VIDEO_PRG', 'true');
+  
 
   // other files
   $otherFiles = $prg-&gt;getAssociatedObjects('sotf_other_files', 'filename');
+  
+  //select stills from other files
+  $stills=array();
+  for($k=count($otherFiles)-1;$k&gt;=0;$k--){
+  	if(preg_match('/^still_'.$id.'_[12345].gif$/', $otherFiles[$k]['filename'])){
+		array_push($stills, $otherFiles[$k]);
+		//unset ($otherFiles[$k]);
+	}
+  }
+  $stills=array_reverse($stills);
+  //
+  
   $smarty-&gt;assign('OTHER_FILES', $otherFiles);
+  $smarty-&gt;assign('STILLS', $stills);
   
   // links
   $smarty-&gt;assign('LINKS', $prg-&gt;getAssociatedObjects('sotf_links', 'caption'));

Modified: node/branches/video_test/www/getFile.php
===================================================================
--- node/branches/video_test/www/getFile.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/getFile.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -26,8 +26,11 @@
 }
 
 if($fid) {
+  
   $pos = strpos($fid, &quot;.mp3&quot;);
   if ($pos !== false) { $fid = rtrim($fid, &quot;.mp3&quot;); }
+  
+  
   debug (&quot;fid&quot;, $fid);
   $fobj = &amp;$repository-&gt;getObject($fid);
   if(!$fobj)

Modified: node/branches/video_test/www/init.inc.php
===================================================================
--- node/branches/video_test/www/init.inc.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/init.inc.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -107,7 +107,9 @@
 require($config['classdir'] . '/db_Wrap.class.php');
 require($config['classdir'] . '/sotf_Utils.class.php');
 require($config['classdir'] . '/sotf_FileList.class.php');
+require($config['classdir'] . '/sotf_ContentCheck.class.php'); //ADDED BY BUDDHAFLY
 require($config['classdir'] . '/sotf_AudioCheck.class.php');
+require($config['classdir'] . '/sotf_VideoCheck.class.php'); //ADDED BY BUDDHAFLY
 require($config['classdir'] . '/sotf_User.class.php');
 require($config['classdir'] . '/sotf_UserPrefs.class.php');
 require($config['classdir'] . '/sotf_Page.class.php');

Modified: node/branches/video_test/www/podcast.php
===================================================================
--- node/branches/video_test/www/podcast.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/podcast.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -65,13 +65,28 @@
 
 function selectStream(&amp;$prg) {
   global $config;
-  $files = $prg-&gt;listAudioFiles('TRUE','kbps DESC');
+  $files = $prg-&gt;listAudioFiles('TRUE','kbps DESC'); //meant ContentFiles
   if(is_array($files)) {
        foreach($files as $f) {
-              if($f['stream_access']=='t') {
-                $f['url'] = $config['rootUrl'] . '/listen.php?id=' . $prg-&gt;id . '&amp;fileid=' . $f['id'];
-                return $f;
-              }
+	   		if($f['stream_access']=='t'){
+			
+				  //MODIFIED BY Martin Schmidt
+				  $f =  array_merge($f, sotf_AudioFile::decodeFormatFilename($f['format']));
+				 
+				  if($prg-&gt;isVideoPrg() &amp;&amp; $f['format']==&quot;mp4&quot;){
+				  	$f['url'] = $config['rootUrl'] . '/listen.php?id=' . $prg-&gt;id . '&amp;fileid=' . $f['id'];
+					
+					return $f;
+				  }
+			      
+				  elseif($prg-&gt;isAudioPrg()) {
+				  
+					$f['url'] = $config['rootUrl'] . '/listen.php?id=' . $prg-&gt;id . '&amp;fileid=' . $f['id'];
+					return $f;
+				  }
+				  /////////////////////////////
+				  
+			}
       }
   }
   return NULL;
@@ -79,10 +94,11 @@
 
 
 
-function selectAudio(&amp;$prg) {
+function selectAudioVideo(&amp;$prg) {
   global $config;
   $files = $prg-&gt;listAudioFiles('TRUE','kbps DESC');
   if(is_array($files)) {
+
 	 foreach($files as $f) {
 		if($f['download_access']=='t') {
 		  /* sun 8.2.06 added to format properly the enclosure url --rama */
@@ -102,9 +118,22 @@
 		  //$f['url'] = $config['rootUrl'] . '/getFile.php?audio=1&amp;id=' . $prg-&gt;id . '&amp;filename=' . $f['filename'];
 		  $baseUrl = sotf_Node::getHomeNodeRootUrl($prg);
 		  //$f['url'] = $baseUrl . '/getFile.php/fid__' . $f['id'].&quot;.mp3&quot;; // wreutz: very dirty hack for ipooder to work on os x
-		  $f['url'] = $baseUrl . '/getFile.php/' . 'fid__' . $f['id']. '__' . $fname.&quot;.mp3&quot;; //rjankowski changed order to get parsed by getFile.php
+		  
+		  //MODIFIED BY Martin Schmidt
+		  $f =  array_merge($f, sotf_AudioFile::decodeFormatFilename($f['format']));
+		  if ($prg-&gt;isVideoPrg() &amp;&amp; $f['format']==&quot;mp4&quot;){
+		  //echo &quot;drinnen&quot;;
+		  	$f['url'] = $baseUrl . '/getFile.php/' . 'fid__' . $f['id']. '__' . $fname.&quot;.mp4&quot;;
+			return $f;
+		  }
+		  
+		  else if ($prg-&gt;isAudioPrg()){
+		  	$f['url'] = $baseUrl . '/getFile.php/' . 'fid__' . $f['id']. '__' . $fname.&quot;.mp3&quot;; //rjankowski changed order to get parsed by getFile.php
+			return $f;
+		  }
+		  //////////////////////////
+		  
 		  // rama: included $fname as formatted name $station-$series-$title
-		  return $f;
 		}
 	 }
   }
@@ -142,29 +171,35 @@
   writeTag($rss, &quot;pubDate&quot;, toW3CDate($prog-&gt;get('entry_date')));
   writeTag($rss, &quot;description&quot;, $prog-&gt;get('abstract'));
   writeTag($rss, &quot;BroadcastDate&quot;, toW3CDate($prog-&gt;get('broadcast_date')));
-  $audioAttrs = selectAudio($prog);
-  if($audioAttrs) {
+  
+  if($prog-&gt;isVideoPrg()) $type = 'video/mov'; //ADDED BY Martin Schmidt
+  else $type = 'audio/mpeg';
+  
+  $audioAttrs = selectAudioVideo($prog);
+  if($audioAttrs['url']) { //MODIFIED BY Martin Schmidt, was if($audioAttrs)
 	 //$filepath = $prog-&gt;getFilePath($audioAttrs);
 	 //$tmpFile = linkAudio($filepath, $audioAttrs);
-	 $enclAttrs = array('type' =&gt; 'audio/mpeg',
-							  'length' =&gt; $audioAttrs['filesize'],
-							  //'url' =&gt; $config['tmpUrl'] . '/' . basename($tmpFile),
-							  'url' =&gt; $audioAttrs['url'],
-							  //'url' =&gt; $config['tmpUrl'] . '/' . 'au_011pr105_budh1204_24kbps_1chn_22050Hz.mp3',
-							  );
+	 $enclAttrs = array('type' =&gt; $type,
+						  'length' =&gt; $audioAttrs['filesize'],
+						  //'url' =&gt; $config['tmpUrl'] . '/' . basename($tmpFile),
+						  'url' =&gt; $audioAttrs['url']
+						  //'url' =&gt; $config['tmpUrl'] . '/' . 'au_011pr105_budh1204_24kbps_1chn_22050Hz.mp3',
+						  );
 	 writeTag($rss, &quot;enclosure&quot;, NULL, NULL, $enclAttrs);
   }
+  
   $streamAttrs = selectStream($prog);
-  if($streamAttrs) {
+  if($streamAttrs['url']) { //MODIFIED BY Martin Schmidt, was if($streamAttrs)
        //$filepath = $prog-&gt;getFilePath($audioAttrs);
        //$tmpFile = linkAudio($filepath, $audioAttrs);
-       $enclAttrs = array('type' =&gt; 'audio/mpeg',
-                                                        'length' =&gt; $streamAttrs['filesize'],
-                                                        //'url' =&gt; $config['tmpUrl'] . '/' . basename($tmpFile),
-                                                        'url' =&gt; $streamAttrs['url'],
-                                                        //'url' =&gt; $config['tmpUrl'] . '/' . 'au_011pr105_budh1204_24kbps_1chn_22050Hz.mp3',
-                                                        );
+       $enclAttrs = array('type' =&gt; $type,
+							'length' =&gt; $streamAttrs['filesize'],
+							//'url' =&gt; $config['tmpUrl'] . '/' . basename($tmpFile),
+							'url' =&gt; $streamAttrs['url']
+							//'url' =&gt; $config['tmpUrl'] . '/' . 'au_011pr105_budh1204_24kbps_1chn_22050Hz.mp3',
+							);
        writeTag($rss, &quot;streamurl&quot;, NULL, NULL, $enclAttrs);
+	   
   }
   $rss .= &quot;\n&lt;/item&gt;&quot;;
 }
@@ -314,7 +349,7 @@
   $queryText = implode(' ', $queryTexts);
   writeTag($rss, &quot;title&quot;, &quot;StreamOnTheFly query results&quot;);
   writeTag($rss, &quot;description&quot;, $queryText);
-  writeTag($rss, &quot;link&quot;, $config['rootUrl'] . &quot;advsearchresults.php?back=true&amp;SQLquerySerial=$query&quot;);
+  writeTag($rss, &quot;link&quot;, $config['rootUrl'] . &quot;/advsearchresults.php?back=true&amp;SQLquerySerial=$query&quot;); //added slash - martin schmidt
   //$properties[&quot;language&quot;]=&quot;en&quot;;
 	
   $rss .= &quot;\n&lt;image&gt;&quot;;

Modified: node/branches/video_test/www/search.php
===================================================================
--- node/branches/video_test/www/search.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/search.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -15,6 +15,10 @@
 $language = sotf_Utils::getSQLSafeParameter('language');
 $station = sotf_Utils::getSQLSafeParameter('station');
 
+//ADDED BY Martin Schmidt
+$audio = sotf_Utils::getParameter('audio');
+$video = sotf_Utils::getParameter('video');
+
 if($pattern) {
   //  debug(&quot;language&quot;, $language);
   //  if(strpos($pattern, '?') || strpos($pattern, '*') || strpos($pattern, '+')) {
@@ -26,7 +30,9 @@
 
   $advsearch = new sotf_AdvSearch();						//create new search object object with this array
 
-  $total = $advsearch-&gt;simpleSearch($pattern, $language, $station);
+  //$total = $advsearch-&gt;simpleSearch($pattern, $language, $station);
+  $total = $advsearch-&gt;simpleSearch($pattern, $language, $station, $audio, $video); //MOD by Martin Schmidt
+  
   $limit = $page-&gt;splitList($total, &quot;?pattern=&quot; . urlencode($pattern) . &quot;&amp;language=$language&quot;);
   $result = $advsearch-&gt;getSimpleSearchResults($limit[&quot;from&quot;] , $limit[&quot;to&quot;]);
 
@@ -38,7 +44,12 @@
   $smarty-&gt;assign('RESULTS', $result);
   $smarty-&gt;assign('PATTERN', $pattern);
   $smarty-&gt;assign('LANGUAGE', $language);
+  
+  //ADDED BY Martin Schmidt
+  $smarty-&gt;assign('VIDEO', $video);
+  $smarty-&gt;assign('AUDIO', $audio);
 }
+else $page-&gt;redirect(&quot;index.php&quot;); //ADDED BY Martin Schmidt
 
 $searchLangs = $config['languages'];
 array_unshift($searchLangs, &quot;any_language&quot;);

Modified: node/branches/video_test/www/static/main.css
===================================================================
--- node/branches/video_test/www/static/main.css	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/static/main.css	2006-05-04 14:34:58 UTC (rev 558)
@@ -82,6 +82,11 @@
   background: #EFF4FE;
 }
 
+/* ADDED BY Martin Schmidt */
+OBJECT.videoplayer{background-color: #EFF4FE;}
+EMBED.videoplayer{background-color: #EFF4FE;}
+/**************************/
+
 .prevnext {
   background: #A8C3F7; text-align: center; width: 20%;
 }

Added: node/branches/video_test/www/static/rss.gif
===================================================================
(Binary files differ)


Property changes on: node/branches/video_test/www/static/rss.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: node/branches/video_test/www/transcode.php
===================================================================
--- node/branches/video_test/www/transcode.php	2006-05-04 11:04:36 UTC (rev 557)
+++ node/branches/video_test/www/transcode.php	2006-05-04 14:34:58 UTC (rev 558)
@@ -0,0 +1,6 @@
+&lt;?php
+
+$output = shell_exec(&quot;ffmpeg -i /var/www/sotf/node_3/users/tm02103/mpg.mpg -r 16 -s qcif -ar 22050 -ab 48 -ac 1 /var/www/sotf/node_3/users/tm02103/mpg.flv&quot;);
+print $output;
+
+?&gt;
\ No newline at end of file

Added: node/branches/video_test/www/videoplayer.swf
===================================================================
(Binary files differ)


Property changes on: node/branches/video_test/www/videoplayer.swf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000180.html">[Sotf-general] r557 - node/branches
</A></li>
	<LI>Next message: <A HREF="000182.html">[Sotf-general] r558 - in node/branches/video_test: code      code/classes code/configs code/getid3-1.7.5 code/getid3-1.7.5/demos      code/getid3-1.7.5/getid3 code/getid3-1.7.5/helperapps code/share      code/templates www www/static
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#181">[ date ]</a>
              <a href="thread.html#181">[ thread ]</a>
              <a href="subject.html#181">[ subject ]</a>
              <a href="author.html#181">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/sotf-general">More information about the Sotf-general
mailing list</a><br>
</body></html>
